<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ART下一代壳通用解决方案 | xiaoeryu</title><meta name="author" content="xiaoeryu"><meta name="copyright" content="xiaoeryu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="虽然Dalvik的脱壳方案对现在的一些壳还有作用，不过它只能解决一些整体性加壳的加壳方案，所以接下来来了解一下ART下脱壳的原理 本章我们主要把从InMemoryDexClassLoader到DexClassLoader(进行dex2oat和直接加载dex)流程中涉及到的脱壳点过了一遍，并修改编译Android源码，测试了对一代壳的脱壳（未进行函数抽取）。">
<meta property="og:type" content="article">
<meta property="og:title" content="ART下一代壳通用解决方案">
<meta property="og:url" content="https://xiaoeeyu.github.io/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/index.html">
<meta property="og:site_name" content="xiaoeryu">
<meta property="og:description" content="虽然Dalvik的脱壳方案对现在的一些壳还有作用，不过它只能解决一些整体性加壳的加壳方案，所以接下来来了解一下ART下脱壳的原理 本章我们主要把从InMemoryDexClassLoader到DexClassLoader(进行dex2oat和直接加载dex)流程中涉及到的脱壳点过了一遍，并修改编译Android源码，测试了对一代壳的脱壳（未进行函数抽取）。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiaoeeyu.github.io/img/rabete.jpg">
<meta property="article:published_time" content="2023-09-13T16:09:38.000Z">
<meta property="article:modified_time" content="2023-09-23T10:15:38.811Z">
<meta property="article:author" content="xiaoeryu">
<meta property="article:tag" content="Android脱壳">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="Android源码分析">
<meta property="article:tag" content="ART脱壳">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiaoeeyu.github.io/img/rabete.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "ART下一代壳通用解决方案",
  "url": "https://xiaoeeyu.github.io/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",
  "image": "https://xiaoeeyu.github.io/img/rabete.jpg",
  "datePublished": "2023-09-13T16:09:38.000Z",
  "dateModified": "2023-09-23T10:15:38.811Z",
  "author": [
    {
      "@type": "Person",
      "name": "xiaoeryu",
      "url": "https://xiaoeeyu.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xiaoeeyu.github.io/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ART下一代壳通用解决方案',
  isHighlightShrink: true,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="web_bg" style="background-image: url(/images/abstract-lines.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/wallhaven-jxl31y.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">xiaoeryu</span></a><a class="nav-page-title" href="/"><span class="site-name">ART下一代壳通用解决方案</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav><div id="post-info"><h1 class="post-title">ART下一代壳通用解决方案</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-13T16:09:38.000Z" title="发表于 2023-09-14 00:09:38">2023-09-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-23T10:15:38.811Z" title="更新于 2023-09-23 18:15:38">2023-09-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android%E9%80%86%E5%90%91/">Android逆向</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>10分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>虽然Dalvik的脱壳方案对现在的一些壳还有作用，不过它只能解决一些整体性加壳的加壳方案，所以接下来来了解一下ART下脱壳的原理</p>
<p>本章我们主要把从InMemoryDexClassLoader到DexClassLoader(进行dex2oat和直接加载dex)流程中涉及到的脱壳点过了一遍，并修改编译Android源码，测试了对一代壳的脱壳（未进行函数抽取）。</p>
<span id="more"></span>

<h2 id="InMemoryDexClassLoader源码分析"><a href="#InMemoryDexClassLoader源码分析" class="headerlink" title="InMemoryDexClassLoader源码分析"></a>InMemoryDexClassLoader源码分析</h2><img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/90cdcec908d54bfd87192db00e958c31.png" class="" title="3e0209e82d4671484584240f43f7d582.png">

<p>先来分析InMemoryDexClassLoader的源码</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/15500a3fd1d8479e9d7b9201ebac36bf.png" class="" title="ae923e5a1854bfeb1d16715dfc2de1d6.png">

<p>从libcore中找到InMemoryDexClassLoader</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/f307d3cf398d44fab5bfba9c7f754d50.png" class="" title="c2bdc9c6c2baf1f3c297c5b3c5f5091b.png">

<ul>
<li><p>继承自InMemroyDexClassLoader，在函数体中调用了两次InMemoryDexClassLoader()，先跟进去看一下BaseDexClassLoader()</p>
</li>
<li><img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/3f1965aec8444cc5a0c3471e8029fc1b.png" class="" title="6a6df17d75bd9c2e4fa97ebc66d6d2b8.png">
</li>
<li><p>可以看到第一个参数传入的是ByteBuffer所以跟进这个方法</p>
</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/bfbd5c81b82a425b849dbc8959b4323f.png" class="" title="501890b458cd3424f8d8e98769b632d0.png">

<ul>
<li><p>进来之后先设置了一下父节点，然后new了一个DexPathList()，继续跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/18f5481a913c40c399bcc6b821fb1dd7.png" class="" title="8c301d921ef027410e8aa44dac09ffa9.png">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/49b8e606b07349a09806e71737537bb7.png" class="" title="2867390a4993eaa1d7bd8da451e0b991.png">
</li>
<li><p>进来之后忽略掉前面对参数的校验和对so库的一些操作，可以看到makeInMemoryDexElements()来处理了我们传入的dexFiles，继续跟进分析</p>
</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/a964c7a7e66a4d948b5cad864c7dda7d.png" class="" title="ba81f0172fa476ff1d689b060c190f55.png">

<ul>
<li><p>继续跟进DexFile()</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/38118ec4972940abba97d396e92f766f.png" class="" title="89c0e12305124c5cd76a4b5076ff8319.png">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/285e5e9a4af64cc18e854f689832bf9b.png" class="" title="e976e6c6acc3af13603acf6b8e2c9ad2.png">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/705af8ca444b4b829cead6552e9f32c8.png" class="" title="18b106d4982fde3cca3761aa8c06d842.png"></li>
<li><p>到了这里发现我们的<em>buf</em>传入了两个地方，它们调用完都进到native层了，接下来我们需要去<strong>native层</strong>继续跟踪</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ef0f5de37be249939aa7c58b8345351a.png" class="" title="73227684eea0697b4ca8f7574c7248fe.png">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/bae600a1e8854b7d8de2944598969d7b.png" class="" title="5737c5986c6749360b0f32a691e652fc.png">
</li>
<li><p>native层的代码我们在art里面查找可以直接检索到这两个函数，在<strong>图中237行</strong>的位置有memcpy()的动作，参数就有dex的起始地址和长度，所以我们在这个地方应该是可以将dex文件dump下来的。继续往下分析，可以看到我们找到的这两个函数在返回的时候都调用了*CreateSingleDexFileCookie()*参数传入了dex在内存中的地址，我们跟进去看一下</p>
</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/fb46b985d4e14caabb93487ab3a7ac2d.png" class="" title="f71e59c9ce1c7f676dcf5e8a29186fa2.png">

<ul>
<li><p>CreateSingleDexFileCookie()接收到传入的dex文件内存地址，dex地址给到了dex_file指针，之后进行操作调用ConvertDexFilesToJavaArray()将其转为java数组并返回。这里我们再跟一下CreateDexFile()看他对传入的dex文件是怎么操作的。</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/66388a6ace0d4f3285bf1e3eac0c717c.png" class="" title="e66015d333a966b5fcd86217582f0d76.png">

<ul>
<li><p>这边再跟进去看一下DexFile::Open()都进行了什么操作</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/767e749de7304539991a6cd5570778a2.png" class="" title="681b0d7a597cb734ebc2202e0c58bcdb.png">

<ul>
<li><p>这里又将参数传递给了OpenCommon()函数，再跟进去看一下</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/8d95260f03f148eca52b10ada0ec2def.png" class="" title="6afcdcb783831281fa9ed2271b12f4d0.png">
</li>
<li><p>可以看到这里创建DexFile对象的时候也传入了我们dex文件的起始地址和大小，再看一下</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/fd5d812cc0f94332aa1ee0fd20eabc8f.png" class="" title="26514b4500a0ebc7677556635a0e7392.png">
</li>
<li><p>通过对上面几个调用传参的分析，发现dex再加载的过程当中，有很多地方都涉及到了dex的起始地址和大小，我们也是可以获取这些信息来进行脱壳的，记录一下这些脱壳点api：</p>
<ol>
<li><p><code>static jobject CreateSingleDexFileCookie(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; data)</code></p>
</li>
<li><p><code>static const DexFile* CreateDexFile(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; dex_mem_map)</code></p>
</li>
<li><pre><code class="c++">std::unique_ptr&lt;const DexFile&gt; dex_file(DexFile::Open(location,
                                        0,
                                        std::move(dex_mem_map),
                                        /* verify */ true,
                                        /* verify_location */ true,
                                        &amp;error_message));
</code></pre>
</li>
<li><pre><code class="c++">std::unique_ptr&lt;DexFile&gt; dex_file = OpenCommon(map-&gt;Begin(),
                                         map-&gt;Size(),
                                         location,
                                         location_checksum,
                                         kNoOatDexFile,
                                         verify,
                                         verify_checksum,
                                         error_msg);
</code></pre>
</li>
<li><pre><code class="c++">DexFile::DexFile(const uint8_t* base,
                 size_t size,
                 const std::string&amp; location,
                 uint32_t location_checksum,
                 const OatDexFile* oat_dex_file)
</code></pre>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>不过InMemoryDexClassLoader()并没有对内存中的DEX信息进行编译生成OAT文件，这点和DexClassLoader()不同</p>
</li>
</ul>
<h2 id="DexClassLoader加载源码流程分析"><a href="#DexClassLoader加载源码流程分析" class="headerlink" title="DexClassLoader加载源码流程分析"></a>DexClassLoader加载源码流程分析</h2><p>DexClassLoader加载源码分析的流程会较为复杂一些，因为这当中需要涉及到dex to oat的编译过程。</p>
<p>虽然有很多的一代壳会禁掉Dex2Oat，但是我们先分析一下，把两种情况分开来分析。</p>
<p>这个前面的分析过程几乎跟再Dalvik下面的流程是一样的，简单再过一遍，熟悉的可以忽略。</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/602ad3058cd041f284ab93f15919f6b9.png" class="" title="81200831e39166f366eeada6a4266146.png">

<ul>
<li><p>跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/814cfc438b8742b289b5c09cba00f91a.png" class="" title="a86477b19dabd4bc5148bf33f802d324.png">
</li>
<li><p>跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/9137cbafb7ce43ac8e31c5b70b5d44db.png" class="" title="f2e17f5268d99d02fc239f3dd1249f1c.png">
</li>
<li><p>跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/279958ab9f574ce7bfa29a409a7c1152.png" class="" title="4f30489507233d5286afccd5e9a95885.png">
</li>
<li><p>继续跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/717abb01ef104175a1f982140846e1a4.png" class="" title="d252312ac29eb5a33697654812ae26fd.png">
</li>
<li><p>继续跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/68055090125040578491df01e7270006.png" class="" title="1f8d21dbce9bc2e997393a2a8b3c0603.png">
</li>
<li><p>跟进这个有五个参数的方法，因为我们传入的是五个参数</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/dca319d8eed2475891c5553aa0ccc7c1.png" class="" title="430bad6fd933cece7d48ca206aa598f9.png">
</li>
<li><p>继续跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/78af1ed4381d41c9a65627b7fb90451a.png" class="" title="45803d157fece5902462b9f4e74a0e3c.png">
</li>
<li><p>到这里接下来呢就要进入<strong>native层</strong>了</p>
</li>
</ul>
<h3 id="跟进native层"><a href="#跟进native层" class="headerlink" title="跟进native层"></a>跟进native层</h3><img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/f96f774610974615979d1da4028e8282.png" class="" title="5603828804b52494b9c055dc5c0861ed.png">

<ul>
<li>在art目录下找到openDexFileNative()的实现</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/685565d63eab45689917862f674c0877.png" class="" title="ff4eda24bf669d490b2f11f9e31a35ea.png">

<ul>
<li>这里我们就可以看到函数中定义了一个OatFile指针变量，后面执行了OpenDexFilesFromOat()来进行生成oat的流程，我们跟进去看一下</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/b91c408ab7d94eccabc74fd8c25e457a.png" class="" title="edc508483f810009812117434da6ba09.png">

<ul>
<li>这段代码里面初始化了一个oat的对象，然后对oat是否为空进行了检测，因为第一次调用的时候它里面肯定是空的，然后进入switch()里面执行了MakeUpToData()方法跟进去看一下</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/7ebe4507c02f4d22ac8c60cedb1512a6.png" class="" title="87af31d8d1089f4857f6571c6c47cae8.png">

<ul>
<li>这里返回值是来自于GenerateOatFileNoChecks()，继续跟进看一下</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/26640609f1824503812f067d69ee2618.png" class="" title="5ed8908a9bed208fa5295c1ab3a10207.png">

<ul>
<li>进入该函数，进行了一些校验之后在下面我们可以看到有一个Dex2Oat()，这个函数名的意思很明确我们跟进去看一下<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/739d8cdc2a0b459f83f0ec8ab742007f.png" class="" title="d07daa2a1fea9dc43f540e689ebb76b2.png"></li>
<li>进入这个函数我们可以看到它进行了一些编译oat之前的准备工作，之后调用Exec()执行编译，跟进看一下</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/c4163c2dc34e432c96c7242933013e7f.png" class="" title="aff6c9b13fa6d18a8f7ebf4d609e7f5c.png">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/e76a3f1a9e694adcb36b502c1bc38db2.png" class="" title="4e1c2058e543a27a12af1476ca3a47f3.png">

<ul>
<li>进来之后看到它执行了ExecAndReturnCode()，继续跟进看一下<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/4fc6a3f1260a40689379e96ecf593afc.png" class="" title="89b1b54df2ed18cdc871cac2ada04ee5.png"></li>
<li>进来这个函数之后，可以看到源码中创建新的进程来开始执行execve()来执行Dex2Oat的编译。<br><strong>到这里先暂停一下，接下来我们来分析如果这个壳不执行Dex2Oat它的编译流程</strong></li>
</ul>
<p><strong>在这整个流程当中如果我们把函数执行的流程进行了修改或者hook，就会导致Dex2Oat流程的结束。如果我们去强制结束这个Dex2Oat的流程是可以让DexClassLoader在第一次加载dex这个过程变得非常的快速，减省去执行Dex2Oat编译花费的时间。如果要实现ART下的函数抽取技术，我们也就需要阻断掉Dex2Oat的流程。这就是ART下的函数抽取实现方案和Dalvik下的区别，因为在Dalvik下不存在Dex2Oat的编译流程。</strong></p>
<p>如果我们阻断这个流程呢，oat文件就无法生成了，就会在前面判断的时候跳转到加载dex文件的分支</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/b39c3705ca0e4fd49814759c128364d0.png" class="" title="e7d449b26a5cb3cf37bb2949773f0837.png">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/31e56ded535d46f58f875c328a22be25.png" class="" title="4792f57c18a16f41c851dc9569a25a5d.png">

<ul>
<li>转而加载dex文件，在这里面我们跟进它调用的DexFile::Open()看一下<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/69a05ede94354e57ad646644ae40cc5a.png" class="" title="66aabfdc0c55694969262ec212349e6b.png"></li>
<li>这个文件里面Open()重载比较多，根据传入参数的类型找到这个Open()。在里面可以看到它调用了OpenAndReadMagic()</li>
</ul>
<p>这个函数是在devcon上来自Check Point的安全研究人员所使用的其中一个脱壳点<br><code>File fd = OpenAndReadMagic(filename, &amp;magic, error_msg);</code></p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/b395c12b8c394a03b3e960b8b22b8d6c.png" class="" title="5379554748e3c0ce442bd4ba9826e4f7.png">

<ul>
<li><p>不过这个脱壳点并不是很好，因为此时dex文件还没有加载到内存中，因为是dex文件所以接下来会执行到DexFile::OpenFile()中去，跟进去看一下</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/992ee61e4b454ba6a27a494650256912.png" class="" title="a6f4a285cc565b1a7bf9bc9c138ab25e.png">
</li>
<li><p>在这里我们可以看到将文件映射到了内存，之后又进入了OpenCommon()继续跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/718358cf7bd34210b037654507e26d85.png" class="" title="42be0a33f6dea978812cedf9e6ded676.png">
</li>
<li><p>OpenCommon()这里也有基址和大小，所以这个位置也可以作为一个脱壳点，</p>
<pre><code class="C++">std::unique_ptr&lt;DexFile&gt; DexFile::OpenCommon(const uint8_t* base,
                                             size_t size,
                                             const std::string&amp; location,
                                             uint32_t location_checksum,
                                             const OatDexFile* oat_dex_file,
                                             bool verify,
                                             bool verify_checksum,
                                             std::string* error_msg,
                                             VerifyResult* verify_result)
</code></pre>
</li>
<li><p>接下来的流程又进入了new DexFile()继续跟进</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2503e48477b340b88c222510ea31ba44.png" class="" title="6468067e203efe41edae9148dad4196d.png">
</li>
<li><p>这里也有基址和大小可以作为我们的一个脱壳点</p>
</li>
</ul>
<pre><code class="C++">DexFile::DexFile(const uint8_t* base,
                 size_t size,
                 const std::string&amp; location,
                 uint32_t location_checksum,
                 const OatDexFile* oat_dex_file)
</code></pre>
<ul>
<li><p>DexFile()对dex文件的对象进行了初始化，到这里我们就把从禁用Dex2Oat到加载dex文件的流程分析完了</p>
</li>
<li><p>在加载dex文件这个过程中我们找到了三个脱壳点</p>
<ol>
<li><p><code>File fd = OpenAndReadMagic(filename, &amp;magic, error_msg);</code></p>
</li>
<li><pre><code class="C++">std::unique_ptr&lt;DexFile&gt; DexFile::OpenCommon(const uint8_t* base,
                                             size_t size,
                                             const std::string&amp; location,
                                             uint32_t location_checksum,
                                             const OatDexFile* oat_dex_file,
                                             bool verify,
                                             bool verify_checksum,
                                             std::string* error_msg,
                                             VerifyResult* verify_result)
</code></pre>
</li>
<li><pre><code class="C++">DexFile::DexFile(const uint8_t* base,
                 size_t size,
                 const std::string&amp; location,
                 uint32_t location_checksum,
                 const OatDexFile* oat_dex_file)
</code></pre>
</li>
</ol>
</li>
<li><p>这里可以发现第2和第3个脱壳点和我们前面分析<em>InMemoryDexClassLoader</em>流程的时候的脱壳点是重合的，所以不管它使用哪一种ClassLoader去进行dex加载，在经过这两个脱壳点的时候都是可以dump下来的。接下来就实现一下这些脱壳点</p>
</li>
</ul>
<h3 id="修改源码脱壳"><a href="#修改源码脱壳" class="headerlink" title="修改源码脱壳"></a>修改源码脱壳</h3><p>在脱壳点获取内存中dex文件的基址和大小将其dump到文件中</p>
<pre><code class="C++">// 获取当前进程的ID  
int pid = getpid();  
  
// 创建一个字符数组，用于存储dex文件的路径  
char dexFilePath[100] = {0};  
  
// 使用sprintf函数将路径格式化为字符串，并存储在dexFilePath数组中  
// 路径为"/sdcard/"，后面跟着两个整数（size和pid），然后是dex文件的名称"OpenCommon.dex"  
sprintf(dexFilePath, "/sdcard/%d_%d_OpenCommon.dex", (int)size, pid);  
  
// 打开dex文件，使用O_CREAT|O_RDWR标志，文件权限为666（所有用户可读可写）  
int fd = open(dexFilePath, O_CREAT|O_RDWR, 666);  
  
// 如果文件打开成功（文件描述符大于0）  
if(fd &gt; 0){  
    // 向文件中写入数据，数据来源于base指针指向的内存，大小为size  
    int number = write(fd, base, size);  
  
    // 如果写入的字节数大于0，说明写入成功  
    if(number &gt; 0){}  
  
    // 关闭文件  
    close(fd);  
}
</code></pre>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230914162835544.png" class="" title="image-20230914162835544">



<p><strong>PS：注意编译Android源码要给虚拟机起码300MB以上的硬盘空间，因为单单只是源码就有一百多G</strong></p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/c352b1080cc14a9ca217dd89cb9a5f24.png" class="" title="ffa6aee3fc0ead0fb0b31e35c8472cad.png">

<p><strong>编译源码命令</strong></p>
<ul>
<li>进入源码目录下执行下面的命令</li>
</ul>
<pre><code>source build/envsetup.sh

lunch

21&lt;根据手机型号选择编译版本&gt;

time make -j4 &lt;线程多开几个编译速度会快点，虚拟机的内存给到16G以上&gt;
</code></pre>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230914155304069.png" class="" title="image-20230914155304069">

<center>编译完成</center>

<p>将编译好的img拷贝出来</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230914161213587.png" class="" title="image-20230914161213587">

<p>写个bat脚本自动刷机，也可以手动刷机。</p>
<pre><code class="bash">@echo off  
echo entering Fastboot model...  
adb reboot bootloader  
  
echo Locking device...  
fastboot oem unlock  
  
echo Flashing the system image...  
fastboot flash boot boot.img
fastboot flash vendor vendor.img
fastboot flash system_a system.img
fastboot flash system_b system_other.img
fastboot flash userdata userdata.img
  
echo Restarting the device...  
fastboot reboot  
  
echo Flashing is complete!  
pause
</code></pre>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/02ac72275c1c4dfc9aac6193ee5023de.png" class="" title="f1ca3dd4a77c3fe5691952d151ad1257.png">

<center>刷机完成</center>

<h3 id="测试脱壳效果"><a href="#测试脱壳效果" class="headerlink" title="测试脱壳效果"></a>测试脱壳效果</h3><p><strong>PS：测试之前可以先去把<em>sdcard</em>目录下安装系统时候产生的dex文件删除掉，有点多。</strong></p>
<p>先测试一下我们原来自己写的LoadDex，安装apk把dex放在<code>sdcard</code>路径下</p>
<p><code>adb install .\loadDex.apk</code></p>
<p><code>adb push 4.dex /sdcard/</code></p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230914155434953.png" class="" title="image-20230914155434953">

<ul>
<li><p>安装完成后在手机系统设置里给apk打开文件访问权限，才能脱壳写文件</p>
</li>
<li><p>设置完之后运行app，然后再*/sdcard/*目录下找到dump下来的dex文件</p>
</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/c2844eb50c5b4fc08553de56a58df482.png" class="" title="0781b10e10116d2149a2310aef57d5a9.png">

<p>然后，新建一个目录将这些文件都pull下来</p>
<ul>
<li><p>先把<em>sdcard</em>目录下的所有dex都放在一个文件夹里，然后把整个文件夹pull下来</p>
<p><code>mkdir /sdcard/dex</code></p>
<p><code>cp *.dex /sdcard/dex</code></p>
</li>
</ul>
<p>在电脑上准备好的目录下执行</p>
<p><code>adb pull /sdcard/dex</code></p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/29e34c1fa4c84ace9e38e0b43754b4a5.png" class="" title="73573295a1ed54ff9e75733069de0ef1.png">

<p>同时我们可以在<em>sdcard</em>目录下的<em>dex</em>文件中搜索TestActivity</p>
<p><code>grep -ril "TestActivity" ./*.dex</code></p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/1d1f3c5174b047bab0a248a1d950d9ea.png" class="" title="4fc1f38f66130ed89540bf68ecfe9cdc.png">

<p>然后用GDA打开这些文件查看一下</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/688afadad884485c87adf0c50cddba50.png" class="" title="3f19bacb4dd0713db2916d61ac1f1980.png">

<ul>
<li>完全正常</li>
</ul>
<p>因为这个apk和dex是我们自己写的使用<em>DexClassLoader</em>加载的，所以肯定是可以dump下来的。我们再拿其它的apk试试。</p>
<p>换了两个app，Express100和货拉拉司机版</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230914155735045.png" class="" title="image-20230914155735045">
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/8afea948022543abac1fdd8374ad207e.png" class="" title="6914aacc706ad63fcd7b7472a7407dad.png">

<center>Express100</center>

<ul>
<li>Express100这个dex脱壳正常所有的函数代码都能正常显示，下面试试货拉拉的。</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230914155936844.png" class="" title="image-20230914155936844">

<center>货拉拉司机版</center>

<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/a2a9c8573cd34b38bf921c16a88118f6.png" class="" title="0d4a5553d8d1f553254cdbf2a7d1a38b.png">

<ul>
<li>货拉拉dump下来的dex打开之后发现函数体都是空的，因为这个壳做了函数抽取的保护方案。这次我们使用的整体脱壳的方案不能应对函数抽取壳的脱壳，下一篇我们处理第二代壳函数抽取壳的问题。</li>
</ul>
<p><strong>小结一下：</strong></p>
<p>前面我们对InMemoryDexClassLOader和Dex2Oat被禁用掉这两个流程进行了脱壳点的总结，找到了它们的脱壳点（虽然大部分壳为了安全都不会这么做，因为执行to oat的时候dex文件时没有加密的），接下来我们再分析一下如果它执行了Dex2Oat怎么脱壳。</p>
<h3 id="进行Dex2Oat流程的脱壳分析"><a href="#进行Dex2Oat流程的脱壳分析" class="headerlink" title="进行Dex2Oat流程的脱壳分析"></a>进行Dex2Oat流程的脱壳分析</h3><p>在前面我们分析到了执行ExecAndReturnCode()的时候，执行到了execve()这个函数的时候就会去调用Dex2Oat()这种方式来加载dex文件</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/b2662afa121249cf88b24d45bf494288.png" class="" title="5194421095811fa941723658bce2ce9e.png">

<ul>
<li>如果这里正常执行过execve()之后，我们就进入到了Dex2Oat的流程当中了</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/e7ca73439a1744b7bb096661dc57e77a.png" class="" title="85ff5583eed7b76fe215941ef27d2bfb.png">

<ul>
<li>这个文件可以看到是一个带有main()的可执行程序，进入main()函数先执行了Dex2Oat()。我们跟进去看看</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/9098a19e7e524694a6568d75c17c6ff3.png" class="" title="4636e02cf9534c96cd7fce1b6a1cf6b7.png">

<ul>
<li>这个函数的前面是对传进来的命令行参数的解析、初始化ART内存映射、检查要编译的dex文件是否可以打开等操作，我们主要跟进dex2oat-&gt;Setup()看一下编译前的设置。</li>
</ul>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/acaf40b185c045fcaeee04c603e2333a.png" class="" title="64d13612569bd45a89941c76b846f8d7.png">

<ul>
<li><p>在Setup()的结尾处呢，会对当前所有的dex文件进行一个遍历确保存活然后注册，我们就可以在这个地方进行dex的脱壳<br>包括还有一些其它的地方也会有对dex内存地址的引用</p>
<img src="/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/4e3a19252a3547d19e10ae363f225748.png" class="" title="5b0a1858f7e5c741e488d00e183d1e89.png">
</li>
<li><p>我们需要的时候都可以在这些地方添加脱壳代码进行脱壳。在流程中有很多这种脱壳点，不一个一个找出来了。</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xiaoeeyu.github.io">xiaoeryu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xiaoeeyu.github.io/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">https://xiaoeeyu.github.io/2023/09/14/ART%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://xiaoeeyu.github.io" target="_blank">xiaoeryu</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android%E8%84%B1%E5%A3%B3/">Android脱壳</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android源码分析</a><a class="post-meta__tags" href="/tags/ART%E8%84%B1%E5%A3%B3/">ART脱壳</a></div><div class="post-share"><div class="social-share" data-image="/img/rabete.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="Dalvik下一代壳的通用解决方案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Dalvik下一代壳的通用解决方案</div></div><div class="info-2"><div class="info-item-1">本节主要分析在Dalvik时代怎么做到把壳脱下来的，通过Android...</div></div></div></a><a class="pagination-related" href="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/" title="ART下抽取壳实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">ART下抽取壳实现</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/09/22/ART%E4%B8%8B%E6%8A%BD%E5%8F%96%E5%A3%B3%E5%AE%9E%E7%8E%B0/" title="ART下抽取壳实现"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-22</div><div class="info-item-2">ART下抽取壳实现</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2023/09/04/Dalvik%E4%B8%8B%E4%B8%80%E4%BB%A3%E5%A3%B3%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="Dalvik下一代壳的通用解决方案"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-04</div><div class="info-item-2">Dalvik下一代壳的通用解决方案</div></div><div class="info-2"><div class="info-item-1">本节主要分析在Dalvik时代怎么做到把壳脱下来的，通过Android...</div></div></div></a><a class="pagination-related" href="/2023/08/19/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E5%92%8C%E8%84%B1%E5%A3%B3%E7%9A%84%E6%84%8F%E4%B9%89/" title="逆向分析和脱壳的意义"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-19</div><div class="info-item-2">逆向分析和脱壳的意义</div></div><div class="info-2"><div class="info-item-1">这里是脱壳的一些碎碎念和FART脱壳机的使用流程   查壳 app解压看文件也能看出来是否加壳 用Android...</div></div></div></a><a class="pagination-related" href="/2023/07/09/CTF004/" title="CTF004"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-09</div><div class="info-item-2">CTF004</div></div><div class="info-2"><div class="info-item-1">1. 脱壳用jadx打开之后发现有加壳那先脱壳再分析   看名字是一个_qihoo_的壳，这个呢我们使用反射大师去脱壳，反射大师需要运行在安卓7.1以下的系统上在root过的手机上安装一个_VMOS Pro_模拟一个安卓7.1的系统安装上反射大师和CTF004,注意：反射大师需要重启才能启用然后打开反射大师，选择我们的CTF004并打开   然后点击这个芒星点击 当前ACTIVITY   然后点击写出DEX-&gt;修复Magic-&gt;确定之后去提示的路径处将文件拷贝到物理机，再使用_adb pull_命令拉取下来对脱壳后的文件开始分析。   2. 开始分析分析代码逻辑  进来_MainActivity_之后发现_onCreate_函数都在native层去实现了，那再看看其它的类点进Flag类   进来之后发现这里面有些需要我们注意的点：   1. 有两个key   2....</div></div></div></a><a class="pagination-related" href="/2023/08/19/ClassLoader%E5%92%8C%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/" title="ClassLoader和动态加载"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-19</div><div class="info-item-2">ClassLoader和动态加载</div></div><div class="info-2"><div class="info-item-1">本章是加壳的一些前置原理，主要是基于Android8.0中ClassLoader的双亲委派模式原理和代码验证以及动态加载的代码验证   类加载器ClassLoaderAndroid的dalvik和art虚拟机都是继承于JVM的一种实现，是基于寄存器来实现的，这是和JVM不同的点  JVM的类加载器包括三种：每一个作用都是不一样的  Bootstrap ClassLoader（引导类加载器）：C/C++代码实现的加载器，用于加载指定的JDK的核心类库，比如java.lang、java.uti。等这些系统类。java虚拟机的启动就是通过Bootstrap，该ClassLoader在java里无法获取，负责加载*/lib*下的类，这些类在java中是没有办法获取到的。  Extensions ClassLoader（扩展类加载器）：Java中的实现类为ExtClassLoader，提供了除了系统类之外的额外功能，可以在java里获取，负责加载/lib/ext下的类。  Application...</div></div></div></a><a class="pagination-related" href="/2023/10/01/FART%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E6%B5%81%E7%A8%8B/" title="FART使用场景和流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-01</div><div class="info-item-2">FART使用场景和流程</div></div><div class="info-2"><div class="info-item-1">本章主要介绍一下什么是FART、为什么要使用FART，以及如何使用FART的问题 FART是一个支持在ART（Android...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/rabete.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">xiaoeryu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">113</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/xiaoeryu@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">同于道者，希言自然</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#InMemoryDexClassLoader%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">InMemoryDexClassLoader源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DexClassLoader%E5%8A%A0%E8%BD%BD%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">DexClassLoader加载源码流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%9F%E8%BF%9Bnative%E5%B1%82"><span class="toc-number">2.1.</span> <span class="toc-text">跟进native层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81%E8%84%B1%E5%A3%B3"><span class="toc-number">2.2.</span> <span class="toc-text">修改源码脱壳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%84%B1%E5%A3%B3%E6%95%88%E6%9E%9C"><span class="toc-number">2.3.</span> <span class="toc-text">测试脱壳效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8CDex2Oat%E6%B5%81%E7%A8%8B%E7%9A%84%E8%84%B1%E5%A3%B3%E5%88%86%E6%9E%90"><span class="toc-number">2.4.</span> <span class="toc-text">进行Dex2Oat流程的脱壳分析</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/" title="某麦购票Xposed脚本（一）">某麦购票Xposed脚本（一）</a><time datetime="2025-05-28T06:20:12.000Z" title="发表于 2025-05-28 14:20:12">2025-05-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/05/%E6%9F%90%E9%BA%A6APP%E8%B4%AD%E7%A5%A8%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90/" title="某麦APP购票接口分析">某麦APP购票接口分析</a><time datetime="2025-05-05T08:07:32.000Z" title="发表于 2025-05-05 16:07:32">2025-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/" title="微信小程序-某某牛仔城">微信小程序-某某牛仔城</a><time datetime="2024-09-16T14:14:02.000Z" title="发表于 2024-09-16 22:14:02">2024-09-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/10/%E7%BC%96%E8%AF%91Android13-AOSP/" title="编译Android13-AOSP">编译Android13-AOSP</a><time datetime="2024-08-10T01:40:30.000Z" title="发表于 2024-08-10 09:40:30">2024-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/" title="绕过爱奇艺libmsaoaidsec.so的Frida检测">绕过爱奇艺libmsaoaidsec.so的Frida检测</a><time datetime="2024-08-09T03:29:58.000Z" title="发表于 2024-08-09 11:29:58">2024-08-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By xiaoeryu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>