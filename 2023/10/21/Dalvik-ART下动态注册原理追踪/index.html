<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Dalvik/ART下JNI方法的动态注册原理与追踪 | xiaoeryu</title><meta name="author" content="xiaoeryu"><meta name="copyright" content="xiaoeryu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在之前的JNI代码中我们都是使用的静态注册，使用extern &quot;C&quot;来编译，这样的代码在编译之后的so文件中仍然会保留原函数名，对APK的安全性有一定影响。 接下来我们尝试一下将静态注册的JNI函数改为动态注册，比较一下和之前有何不同。 以及对于改为动态注册的函数我们应该如何去追踪。">
<meta property="og:type" content="article">
<meta property="og:title" content="Dalvik&#x2F;ART下JNI方法的动态注册原理与追踪">
<meta property="og:url" content="https://xiaoeeyu.github.io/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/index.html">
<meta property="og:site_name" content="xiaoeryu">
<meta property="og:description" content="在之前的JNI代码中我们都是使用的静态注册，使用extern &quot;C&quot;来编译，这样的代码在编译之后的so文件中仍然会保留原函数名，对APK的安全性有一定影响。 接下来我们尝试一下将静态注册的JNI函数改为动态注册，比较一下和之前有何不同。 以及对于改为动态注册的函数我们应该如何去追踪。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiaoeeyu.github.io/images/rabete.jpg">
<meta property="article:published_time" content="2023-10-21T14:04:43.000Z">
<meta property="article:modified_time" content="2023-11-04T03:58:51.630Z">
<meta property="article:author" content="xiaoeryu">
<meta property="article:tag" content="JNI函数注册原理与追踪">
<meta property="article:tag" content="源码修改">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiaoeeyu.github.io/images/rabete.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Dalvik/ART下JNI方法的动态注册原理与追踪",
  "url": "https://xiaoeeyu.github.io/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/",
  "image": "https://xiaoeeyu.github.io/images/rabete.jpg",
  "datePublished": "2023-10-21T14:04:43.000Z",
  "dateModified": "2023-11-04T03:58:51.630Z",
  "author": [
    {
      "@type": "Person",
      "name": "xiaoeryu",
      "url": "https://xiaoeeyu.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/images/rabete.ico"><link rel="canonical" href="https://xiaoeeyu.github.io/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Dalvik/ART下JNI方法的动态注册原理与追踪',
  isHighlightShrink: true,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body><div id="web_bg" style="background-image: url(/images/abstract-lines.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/wallhaven-jxl31y.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">xiaoeryu</span></a><a class="nav-page-title" href="/"><span class="site-name">Dalvik/ART下JNI方法的动态注册原理与追踪</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div></div></nav><div id="post-info"><h1 class="post-title">Dalvik/ART下JNI方法的动态注册原理与追踪</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-10-21T14:04:43.000Z" title="发表于 2023-10-21 22:04:43">2023-10-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-04T03:58:51.630Z" title="更新于 2023-11-04 11:58:51">2023-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NDK%E5%BC%80%E5%8F%91/">NDK开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>在之前的JNI代码中我们都是使用的静态注册，使用<code>extern "C"</code>来编译，这样的代码在编译之后的so文件中仍然会保留原函数名，对APK的安全性有一定影响。</p>
<p>接下来我们尝试一下将静态注册的JNI函数改为动态注册，比较一下和之前有何不同。</p>
<p>以及对于改为动态注册的函数我们应该如何去追踪。</p>
<span id="more"></span>

<h1 id="静态注册与动态注册"><a href="#静态注册与动态注册" class="headerlink" title="静态注册与动态注册"></a>静态注册与动态注册</h1><p>JNI函数被调用前，必须要完成Java与so的绑定：</p>
<ul>
<li>被动（静态）：由Dalvik/ART虚拟机在调用前查找并完成地址的绑定<ul>
<li>静态函数名规则：Java_包名_类名_方法名</li>
<li>优点：函数名简单明了</li>
<li>缺点：名字过长、查抓效率不高、安全性降低</li>
</ul>
</li>
<li>主动（动态）：由APP自己完成地址的绑定</li>
</ul>
<p>静态注册</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231019153051665.png" class="" title="image-20231019153051665">

<p><mark>反编译静态注册的so文件</mark></p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021221027648.png" class="" title="image-20231021221027648">

<ul>
<li>例如这个静态注册JNI代码编译后的so文件，用IDA反编译之后就能直接通过搜索函数名定义到函数位置。</li>
</ul>
<p>动态注册</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231019153303831.png" class="" title="image-20231019153303831">



<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231020014348852.png" class="" title="image-20231020014348852">

<blockquote>
<p>可以将原来的<code>extern "C"</code>给去掉，函数名无所谓可以随便写就是一个标识</p>
<p>在JNI_OnLoad中手动绑定</p>
<pre><code class="C++"> JNINativeMethod jniNativeMethod[] = {
         {"onCreate", "(Landroid/os/Bundle;)V", (void*)onCreate},
         {"newObject", "()V", (void*)newObject}
 };
 jclass MainActivityjclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/MainActivity");
 env-&gt;RegisterNatives(MainActivityjclass, jniNativeMethod, sizeof(jniNativeMethod)/sizeof(JNINativeMethod));
 jclass tmpjclass = env-&gt;FindClass("com/xiaoeryu/reflectiontest/Test");
 jclass testjclass = static_cast&lt;jclass&gt;(env-&gt;NewWeakGlobalRef(tmpjclass));
</code></pre>
<p>通过<code>RegisterNatives()</code>方法完成手动绑定</p>
</blockquote>
<p>在JNI函数前加上<code>__attribute__ ((visibility ("hidden"))) </code>来隐藏符号信息</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231020015132363.png" class="" title="image-20231020015132363">

<p>隐藏了之后就无法在IDA里面直接搜索到这个函数了</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231020221300327.png" class="" title="image-20231020221300327">

<h2 id="Dalvik下动态注册的原理"><a href="#Dalvik下动态注册的原理" class="headerlink" title="Dalvik下动态注册的原理"></a>Dalvik下动态注册的原理</h2><p>查看源码分析一下<code>RegisterNatives</code>的实现</p>
<blockquote>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231020223718539.png" class="" title="image-20231020223718539">

<ul>
<li><p>查看其在Android4.4中的实现</p>
<pre><code class="C++">2453/*
2454 * Register one or more native functions in one class.
2455 *
2456 * This can be called multiple times on the same method, allowing the
2457 * caller to redefine the method implementation at will.
2458 */
2459static jint RegisterNatives(JNIEnv* env, jclass jclazz,
2460    const JNINativeMethod* methods, jint nMethods)
2461{
2462    ScopedJniThreadState ts(env);
2463
2464    ClassObject* clazz = (ClassObject*) dvmDecodeIndirectRef(ts.self(), jclazz);
2465
2466    if (gDvm.verboseJni) {
2467        ALOGI("[Registering JNI native methods for class %s]",
2468            clazz-&gt;descriptor);
2469    }
2470
2471    for (int i = 0; i &lt; nMethods; i++) {
2472        if (!dvmRegisterJNIMethod(clazz, methods[i].name,
2473                methods[i].signature, methods[i].fnPtr))
2474        {
2475            return JNI_ERR;
2476        }
2477    }
2478    return JNI_OK;
2479}
</code></pre>
</li>
<li><p>函数参数：</p>
<ul>
<li><code>jclass jclazz</code>：表示要注册本地方法的Java类</li>
<li><code>const JNINativeMethod* methods</code>：是一个指向<code>JNINativeMethod</code>结构体数组的指针，该结构体包含了本地方法的名称、签名和函数指针</li>
<li><code>jint nMethods</code>：表示要注册的本地方法的数量</li>
</ul>
</li>
<li><p>这个函数的目的是将本地方法与Java类相关联，以便在Java代码中调用这些本地方法。</p>
</li>
<li><p>往下分析可以看到具体的实现在<code>dvmRegisterJNIMethod</code>函数中，跟进去看一下</p>
<pre><code class="C++">static bool dvmRegisterJNIMethod(ClassObject* clazz, const char* methodName,
                                 const char* signature, void* fnPtr)
{
    
    ...


    Method* method = dvmFindDirectMethodByDescriptor(clazz, methodName, signature);	// 这个method表示Java函数在Dalvik当中对应的结构体
        
    ...
        
    if (method-&gt;nativeFunc != dvmResolveNativeMethod) {
        /* this is allowed, but unusual */
        /* 这里表示允许这个JNI函数注册两次，不过不常见*/
        ALOGV("Note: %s.%s:%s was already registered", clazz-&gt;descriptor, methodName, signature);
    }
    method-&gt;fastJni = fastJni;
    dvmUseJNIBridge(method, fnPtr);
}
</code></pre>
<p>比如说在这里注册的时候可以让它注册两次，可以绑定不同的本地方法。（如果在动态调试APP的时候碰到有JNI函数在不同的时刻注册在了不同的地址，可能就是这种情况）<mark>暂时没发现有啥用</mark></p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231020232142297.png" class="" title="image-20231020232142297">
</li>
<li><p>继续往下分析，还可以看到有很多地方都使用到了<code>method</code>结构体，那分析这个有什么用呢？</p>
<ul>
<li>我们可以修改源码在调用method的地方添加log，重新编译，然后再运行APP的时候就可以将动态注册的结构体的注册信息打印出来。</li>
<li>暂时没有运行4.4的设备，而且Dalvik比较少用了就不去修改源码重新编译了，等下分析ART源码跟踪一下在ART中的动态注册的结构体。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="ART下动态注册的原理"><a href="#ART下动态注册的原理" class="headerlink" title="ART下动态注册的原理"></a>ART下动态注册的原理</h2><p>接下来分析Android8.0的ART源码，并修改源码在关键点加LOG获取动态注册的JNI函数地址。</p>
<h4 id="ART下动态注册分析"><a href="#ART下动态注册分析" class="headerlink" title="ART下动态注册分析"></a>ART下动态注册分析</h4><img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021094617207.png" class="" title="image-20231021094617207">

<p>跟进来之后可以看到函数的实现</p>
<pre><code class="C++">2148    static jint RegisterNatives(JNIEnv* env, jclass java_class, const JNINativeMethod* methods,
2149                                jint method_count) {
2150      return RegisterNativeMethods(env, java_class, methods, method_count, true);
2151    }
</code></pre>
<ul>
<li>跟进<code>RegisterNativeMethods</code></li>
</ul>
<pre><code class="C++">3054  void RegisterNativeMethods(JNIEnv* env, const char* jni_class_name, const JNINativeMethod* methods,
3055                             jint method_count) {
3056    ScopedLocalRef&lt;jclass&gt; c(env, env-&gt;FindClass(jni_class_name));
3057    if (c.get() == nullptr) {
3058      LOG(FATAL) &lt;&lt; "Couldn't find class: " &lt;&lt; jni_class_name;
3059    }
3060    JNI::RegisterNativeMethods(env, c.get(), methods, method_count, false);
3061  }
3062  
3063  }  // namespace art
</code></pre>
<ul>
<li>跟进<code>JNI::RegisterNativeMethods</code></li>
</ul>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021095331916.png" class="" title="image-20231021095331916">

<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021173436019.png" class="" title="image-20231021173436019">

<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021181032660.png" class="" title="image-20231021181032660">

<blockquote>
<ul>
<li>对于任意一个在Java类中定义的函数而言，它在调用前都会有一个准备的过程。这个过程中会调用LoadClassMembers完成被加载的过程：遍历当前类中的field和函数，将其准备好。</li>
</ul>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021180038425.png" class="" title="image-20231021180038425">

<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021180109175.png" class="" title="image-20231021180109175">

<ul>
<li>在这个遍历过程中会准备好每一个函数的ArtMethod对象</li>
<li>只有在准备好了之后才能被调用，不论这个函数是Java还是JNI实现</li>
</ul>
<p>接下来看一下ArtMethod的定义：</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021180753466.png" class="" title="image-20231021180753466">
</blockquote>
<p>继续之前的<code>JNI::RegisterNativeMethods</code></p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021181500327.png" class="" title="image-20231021181500327">

<ul>
<li>跟进<code>RegisterNative()</code></li>
</ul>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021181843637.png" class="" title="image-20231021181843637">

<ul>
<li><p>继续跟进SetEntryPointFromJni()，参数是函数地址</p>
</li>
<li><p>看这个名字我们就能发现他是对于JNI入口地址的绑定</p>
<blockquote>
<p>在<code>art_method.h</code>里面也有关于<code>EntryPointFromJni</code>的定义</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021182403408.png" class="" title="image-20231021182403408"></blockquote>
</li>
</ul>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021182530070.png" class="" title="image-20231021182530070">

<ul>
<li>到这里还可以继续往下分析，<code>SetEntryPointFromJniPtrSize</code>第一个参数是函数地址，第二个参数是运行系统位数</li>
</ul>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021223316896.png" class="" title="image-20231021223316896">

<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021223340230.png" class="" title="image-20231021223340230">

<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021223520552.png" class="" title="image-20231021223520552">

<blockquote>
<p><mark><strong>以上就是ART下一个函数的动态注册流程</strong></mark></p>
</blockquote>
<h3 id="修改源码HOOK"><a href="#修改源码HOOK" class="headerlink" title="修改源码HOOK"></a>修改源码HOOK</h3><p>接下来我们在这些流程中添加一些log信息，追踪动态注册的函数</p>
<blockquote>
<ol>
<li>RegisterNatives</li>
<li>RegisterNativeMethods</li>
<li>jint::RegisterNativeMethods</li>
<li>RegisterNative</li>
<li>SetEntryPointFromJni</li>
<li>。。。</li>
</ol>
</blockquote>
<p>通过在这些函数加LOG日志（<code>LOG(WARNING) &lt;&lt; xxx;</code>）的方法将函数的信息都打印出来</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021210427169.png" class="" title="image-20231021210427169">

<h6 id="修改完源码之后重新编译"><a href="#修改完源码之后重新编译" class="headerlink" title="修改完源码之后重新编译"></a>修改完源码之后重新编译</h6><blockquote>
<p><code>source build/envsetup.sh</code></p>
<p><code>lunch</code>执行后选择要编译的系统版本</p>
<p><code>time make -x</code>多给几个线程编译会快点</p>
</blockquote>
<h6 id="编译完成刷入手机"><a href="#编译完成刷入手机" class="headerlink" title="编译完成刷入手机"></a>编译完成刷入手机</h6><p>在编译的过程中，再来看一下art_method.h中JNI的注册</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021215743693.png" class="" title="image-20231021215743693">

<ul>
<li>通过注释我们就可以知道JNI函数最终是注册到了这里</li>
<li>不过这个地方在不同系统版本的实现会有所不同，这个我们在HOOK的时候要注意</li>
</ul>
<blockquote>
<p>例如：</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021215449812.png" class="" title="image-20231021215449812">

<center>android-6.0.1</center>

<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231021215608057.png" class="" title="image-20231021215608057">

<center>android-14.0.0_r2</center>
</blockquote>
<h6 id="运行我们的demo"><a href="#运行我们的demo" class="headerlink" title="运行我们的demo"></a>运行我们的demo</h6><img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022001832599.png" class="" title="image-20231022001832599">

<blockquote>
<ul>
<li><p>可以看到我们标记的第一部分所有绑定的函数都是同一个函数地址：所以这很可能是一个函数跳转表之类的东西</p>
</li>
<li><p>懒绑定：对于静态函数来说，第一次编译的时候都绑定在了跳转表的地址，第二次调用的时候才从跳转表查询要调用的函数并绑定，等再次调用的时候就不需要重复查询了。</p>
</li>
<li><p>这里面除了标红的onCreate、newObject之外都是静态函数</p>
</li>
<li><p>第二部分是我们动态绑定的函数，地址在我们插入LOG的几个位置都打印出来了，从地址长度可以看出来是运行在64位的设备上</p>
</li>
</ul>
</blockquote>
<h6 id="再拿一个加壳的APP跑一下试试"><a href="#再拿一个加壳的APP跑一下试试" class="headerlink" title="再拿一个加壳的APP跑一下试试"></a>再拿一个加壳的APP跑一下试试</h6><p>执行完过滤一下结果，可以看到加载的函数地址也都打印出来了</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022161955335.png" class="" title="image-20231022161955335">

<ul>
<li><strong>说明我们HOOK是成功的</strong></li>
<li>但是设备会特别卡，应该在哪里过滤一下会好点</li>
</ul>
<hr>
<h4 id="接下来了解一些so加载过程中，函数执行时机的问题"><a href="#接下来了解一些so加载过程中，函数执行时机的问题" class="headerlink" title="接下来了解一些so加载过程中，函数执行时机的问题"></a>接下来了解一些so加载过程中，函数执行时机的问题</h4><p>在Android里面有两个函数可以加载so文件：</p>
<ul>
<li><code>System.loadLibrary</code>，参数只需要传入文件名即可，它内部会自动拼接文件名</li>
<li><code>System.load</code>，参数需要传入绝对路径</li>
</ul>
<p>在项目中<code>JNI_OnLoad</code>函数是执行比较早的，要早于大部分JNI函数的执行时机</p>
<p>但是在它之前还有两类函数（INIT和INIT_ARRAY）要比它更早执行</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022183100163.png" class="" title="image-20231022183100163">

<blockquote>
<p><code>INIT_ARRAY</code>默认是按定义的顺序执行，也可以通过给<code>constructor</code>传入参数，手动设置它的执行顺序</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022185024397.png" class="" title="image-20231022185024397">
</blockquote>
<h6 id="分析编译后生成的apk文件"><a href="#分析编译后生成的apk文件" class="headerlink" title="分析编译后生成的apk文件"></a>分析编译后生成的apk文件</h6><blockquote>
<p>解压apk分析里面的so文件</p>
<p>用Ubuntu自带的readelf工具，可以解析so文件</p>
<pre><code>tom@ubuntu:~/Downloads$ readelf -d libreflectiontest.so 

Dynamic section at offset 0x4bb30 contains 31 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libandroid.so]
 0x0000000000000001 (NEEDED)             Shared library: [liblog.so]
 0x0000000000000001 (NEEDED)             Shared library: [libm.so]
 0x0000000000000001 (NEEDED)             Shared library: [libdl.so]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so]
 0x000000000000000e (SONAME)             Library soname: [libreflectiontest.so]
 0x000000000000001e (FLAGS)              BIND_NOW
 0x000000006ffffffb (FLAGS_1)            Flags: NOW
 0x0000000000000007 (RELA)               0xb880
 0x0000000000000008 (RELASZ)             34992 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000006ffffff9 (RELACOUNT)          992
 0x0000000000000017 (JMPREL)             0x14130
 0x0000000000000002 (PLTRELSZ)           3912 (bytes)
 0x0000000000000003 (PLTGOT)             0x4ce38
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000006 (SYMTAB)             0x2f8
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000005 (STRTAB)             0x6720
 0x000000000000000a (STRSZ)              20829 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x4408
 0x0000000000000004 (HASH)               0x5328
 0x0000000000000019 (INIT_ARRAY)         0x4cb10	// 这个是我们定义的INIT_ARRAY函数
 0x000000000000001b (INIT_ARRAYSZ)       32 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x4cb00
 0x000000000000001c (FINI_ARRAYSZ)       16 (bytes)
 0x000000000000000c (INIT)               0x2146c	// 在IDA里面直接可以搜索INIT函数的位置
 0x000000006ffffff0 (VERSYM)             0x3ec8
 0x000000006ffffffe (VERNEED)            0x43c4
 0x000000006fffffff (VERNEEDNUM)         2
 0x0000000000000000 (NULL)               0x0
</code></pre>
<p>在IDA里面按G搜索<code>0x2146c</code>这个地址就可以跳转到INIT函数处</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022191116590.png" class="" title="image-20231022191116590">

<p>再来搜索一下<code>INIT_ARRAY</code>函数</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022191938961.png" class="" title="image-20231022191938961">

<ul>
<li><p>这边的几个函数就是我们之前按顺序定义的initarray_3、initarray_2、initarray_1函数</p>
<img src="/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/image-20231022192112073.png" class="" title="image-20231022192112073"></li>
</ul>
</blockquote>
<p>以后我们如果要对一些加壳的SO文件进行分析的时候需要断在_INIT之前就可以用上面这种方法下断点，断下来之后开始动态调试</p>
<p><a target="_blank" rel="noopener" href="https://github.com/xiaoeeyu/JNI_method_track">代码地址</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://xiaoeeyu.github.io">xiaoeryu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://xiaoeeyu.github.io/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/">https://xiaoeeyu.github.io/2023/10/21/Dalvik-ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E8%BF%BD%E8%B8%AA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://xiaoeeyu.github.io" target="_blank">xiaoeryu</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JNI%E5%87%BD%E6%95%B0%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%BD%E8%B8%AA/">JNI函数注册原理与追踪</a><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81%E4%BF%AE%E6%94%B9/">源码修改</a></div><div class="post-share"><div class="social-share" data-image="/images/rabete.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/10/17/NDK%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%BC%95%E7%94%A8/" title="NDK内存管理-引用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">NDK内存管理-引用</div></div><div class="info-2"><div class="info-item-1">NDK中的内存管理：C/C++的new/malloc和delete/free以及JNI引用。   Java和C/C++内存管理的区别  三种引用的区别在JNI规范中定义了三种引用：  局部引用（LocalReference） 全局引用（Global Reference） 若全局引用（Weak Global Reference）     因生命周期限制，不能在外部定义一个全局变量接受局部引用，在其他函数使用     之前多线程的代码中使用过，例如： jobject appClassloader = env-&gt;NewGlobalRef(TestJclass); // 使用方式：用参数传递，或者定义一个全局变量接收也行     pthread_create(&amp;thread, nullptr, threadtest, appClassloader);  env-&gt;DeleteGlobalRef(appClassloader);      作用域和全局引用是相同的，但是如果内存紧张可能会被ART给释放掉     再JNI种局部引用的创建也是受局部引用表限制的 for...</div></div></div></a><a class="pagination-related" href="/2023/11/04/%E7%9C%8B%E9%9B%AA2W%E8%AF%BE-Frida%E5%BC%80%E5%8F%91%E5%92%8C%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" title="Frida开发和调试环境搭建"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Frida开发和调试环境搭建</div></div><div class="info-2"><div class="info-item-1">本章记录在kali上配置Frida开发和调试环境，这个环境配置真的相当麻烦，不同版本很容易碰到不兼容的问题需要多注意一下。 下面的安装流程仅限于kali 2023.3版本   安装kali虚拟机直接下载Get Kali | Kali Linux 的VMware压缩包省去安装流程 默认账号密码都是kali  打开之后先设置一下root密码、修改一下默认字体大小（kali默认的字体都太小了修改一下）, 安装的时候使用kali账户安装不要使用root账户 检查一下时间如果不对的话也修改一下sudo dpkg-reconfigure tzdata  安装配置clash这里选择安装桌面版 前两天clash删库了，回头可能还得换v2ray 下载解压到/opt/clash/目录下运行 ./cfw    有时候网络环境不好订阅地址下载失败的话，可以直接把主机的配置文件拷贝一份导入进去也行  浏览器科学上网配置：修改浏览器代理为手动    终端科学上网配置：这是临时的关闭终端就没有了 export http_proxy=http://127.0.0.1:7890 export...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/rabete.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">xiaoeryu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">113</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">93</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/xiaoeryu@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">同于道者，希言自然</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C"><span class="toc-number">1.</span> <span class="toc-text">静态注册与动态注册</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dalvik%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">Dalvik下动态注册的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">ART下动态注册的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ART%E4%B8%8B%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E5%88%86%E6%9E%90"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">ART下动态注册分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%BA%90%E7%A0%81HOOK"><span class="toc-number">1.2.1.</span> <span class="toc-text">修改源码HOOK</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AE%8C%E6%BA%90%E7%A0%81%E4%B9%8B%E5%90%8E%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91"><span class="toc-number">1.2.1.0.0.1.</span> <span class="toc-text">修改完源码之后重新编译</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%AE%8C%E6%88%90%E5%88%B7%E5%85%A5%E6%89%8B%E6%9C%BA"><span class="toc-number">1.2.1.0.0.2.</span> <span class="toc-text">编译完成刷入手机</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%88%91%E4%BB%AC%E7%9A%84demo"><span class="toc-number">1.2.1.0.0.3.</span> <span class="toc-text">运行我们的demo</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%8D%E6%8B%BF%E4%B8%80%E4%B8%AA%E5%8A%A0%E5%A3%B3%E7%9A%84APP%E8%B7%91%E4%B8%80%E4%B8%8B%E8%AF%95%E8%AF%95"><span class="toc-number">1.2.1.0.0.4.</span> <span class="toc-text">再拿一个加壳的APP跑一下试试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E4%BA%86%E8%A7%A3%E4%B8%80%E4%BA%9Bso%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">接下来了解一些so加载过程中，函数执行时机的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E7%BC%96%E8%AF%91%E5%90%8E%E7%94%9F%E6%88%90%E7%9A%84apk%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.1.1.0.1.</span> <span class="toc-text">分析编译后生成的apk文件</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/28/%E6%9F%90%E9%BA%A6%E8%B4%AD%E7%A5%A8Xposed%E8%84%9A%E6%9C%AC%EF%BC%88%E4%B8%80%EF%BC%89/" title="某麦购票Xposed脚本（一）">某麦购票Xposed脚本（一）</a><time datetime="2025-05-28T06:20:12.000Z" title="发表于 2025-05-28 14:20:12">2025-05-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/05/%E6%9F%90%E9%BA%A6APP%E8%B4%AD%E7%A5%A8%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90/" title="某麦APP购票接口分析">某麦APP购票接口分析</a><time datetime="2025-05-05T08:07:32.000Z" title="发表于 2025-05-05 16:07:32">2025-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/16/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E6%9F%90%E6%9F%90%E7%89%9B%E4%BB%94%E5%9F%8E/" title="微信小程序-某某牛仔城">微信小程序-某某牛仔城</a><time datetime="2024-09-16T14:14:02.000Z" title="发表于 2024-09-16 22:14:02">2024-09-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/10/%E7%BC%96%E8%AF%91Android13-AOSP/" title="编译Android13-AOSP">编译Android13-AOSP</a><time datetime="2024-08-10T01:40:30.000Z" title="发表于 2024-08-10 09:40:30">2024-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/09/%E7%BB%95%E8%BF%87%E7%88%B1%E5%A5%87%E8%89%BAlibmsaoaidsec-so%E7%9A%84Frida%E6%A3%80%E6%B5%8B/" title="绕过爱奇艺libmsaoaidsec.so的Frida检测">绕过爱奇艺libmsaoaidsec.so的Frida检测</a><time datetime="2024-08-09T03:29:58.000Z" title="发表于 2024-08-09 11:29:58">2024-08-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By xiaoeryu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 6.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"language":"zh-CN","perPage":10,"distractionFreeMode":false}

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23lid3JPIcqK0L34Na',
      clientSecret: '26b0132af5698c1565435293e034b78ef4cacc9e',
      repo: 'xiaoeryu-comments',
      owner: 'xiaoeeyu',
      admin: ['xiaoeeyu'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '7fd2283f45dcecbdc0285ee8806929de'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>